---
layout: post 
title: Docker - What is Docker?
subtitle: 촘촘히 배우기 위하여 Docker 공식 문서 번역해보기
categories: 학습
tags: 이직 학습 CS Docker CI CD Ops
thumb: /assets/images/posts/2025-09/2025-09-04-002.png
custom-excerpt: 촘촘히 배우기 위하여 Docker 공식 문서 번역해보기
banner:
  # video: https://vjs.zencdn.net/v/oceans.mp4
  video: /assets/images/posts/2025-09/2025-09-04-002.png
  loop: true
  volume: 0.8
  muted: true                 # For mobile device background music play 
  start_at: 8.5
  image: /assets/images/posts/2025-09/2025-09-04-002.png
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
---

## Docker란 무엇인가?

Docker는 애플리케이션을 개발, 배포, 실행하기 위한 개방형 플랫폼이다. Docker를 사용하면 애플리케이션을 인프라로부터 분리하여 소프트웨어를 신속하게 제공할 수 있다. Docker를 통해 인프라를 애플리케이션 관리와 동일한 방식으로 관리할 수 있다. Docker의 코드 배포, 테스트, 배포 방법론을 활용하면 코드 작성과 실제 운영 환경에서 실행 사이의 지연을 크게 줄일 수 있다.

-----

## Docker 플랫폼

Docker는 컨테이너라고 불리는 느슨하게 격리된 환경에 애플리케이션을 패키징하고 실행하는 기능을 제공한다. 격리 및 보안 기능을 통해 주어진 호스트에서 많은 컨테이너를 동시에 실행할 수 있다. 컨테이너는 가볍고 애플리케이션 실행에 필요한 모든 것을 포함하므로, 호스트에 설치된 것에 의존할 필요가 없다. 작업 중에 컨테이너를 공유할 수 있으며, 공유받는 모든 사람이 동일한 방식으로 작동하는 동일한 컨테이너를 얻게 됨을 확신할 수 있다.

Docker는 컨테이너의 라이프사이클을 관리하기 위한 도구와 플랫폼을 제공한다:

  * 컨테이너를 사용하여 애플리케이션과 그 지원 구성 요소를 개발한다.
  * 컨테이너는 애플리케이션을 배포하고 테스트하는 단위가 된다.
  * 준비가 되면, 애플리케이션을 컨테이너 또는 오케스트레이션된 서비스로서 프로덕션 환경에 배포한다. 이는 프로덕션 환경이 로컬 데이터 센터, 클라우드 제공업체 또는 이 둘의 하이브리드인지 여부와 관계없이 동일하게 작동한다.

-----

## Docker의 용도

### 빠르고 일관된 애플리케이션 제공

Docker는 개발자들이 애플리케이션과 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화된 환경에서 작업할 수 있게 함으로써 개발 라이프사이클을 간소화한다. 컨테이너는 지속적 통합(CI) 및 지속적 배포(CD) 워크플로우에 매우 유용하다.

다음 예시 시나리오를 고려해 볼 수 있다:

  * 개발자들은 로컬에서 코드를 작성하고 Docker 컨테이너를 사용하여 동료들과 작업을 공유한다.
  * 그들은 Docker를 사용하여 애플리케이션을 테스트 환경으로 푸시하고 자동화된 테스트와 수동 테스트를 실행한다.
  * 개발자들이 버그를 발견하면, 개발 환경에서 수정하고 테스트 및 검증을 위해 테스트 환경에 다시 배포할 수 있다.
  * 테스트가 완료되면, 수정 사항을 고객에게 전달하는 것은 업데이트된 이미지를 프로덕션 환경으로 푸시하는 것만큼 간단하다.

### 반응성 높은 배포 및 확장

Docker의 컨테이너 기반 플랫폼은 매우 이식성이 높은 워크로드를 가능하게 한다. Docker 컨테이너는 개발자의 로컬 노트북, 데이터 센터의 물리적 또는 가상 머신, 클라우드 제공업체 또는 혼합된 환경에서 실행될 수 있다.

Docker의 이식성과 가벼운 특성 덕분에 비즈니스 요구에 따라 거의 실시간으로 애플리케이션과 서비스를 확장하거나 축소하는 등 워크로드를 동적으로 쉽게 관리할 수 있다.

### 동일한 하드웨어에서 더 많은 워크로드 실행

Docker는 가볍고 빠르다. 이는 하이퍼바이저 기반 가상 머신에 대한 실행 가능하고 비용 효율적인 대안을 제공하므로, 서버 용량을 더 많이 활용하여 비즈니스 목표를 달성할 수 있다. Docker는 고밀도 환경과 더 적은 리소스로 더 많은 작업을 수행해야 하는 중소 규모 배포에 완벽하다.

-----

## Docker 아키텍처

Docker는 클라이언트-서버 아키텍처를 사용한다. Docker 클라이언트는 Docker 컨테이너의 빌드, 실행, 배포와 같은 힘든 작업을 수행하는 Docker 데몬과 통신한다. Docker 클라이언트와 데몬은 동일한 시스템에서 실행될 수도 있고, Docker 클라이언트를 원격 Docker 데몬에 연결할 수도 있다. Docker 클라이언트와 데몬은 REST API, UNIX 소켓 또는 네트워크 인터페이스를 통해 통신한다. 또 다른 Docker 클라이언트로는 Docker Compose가 있는데, 이는 여러 컨테이너로 구성된 애플리케이션 작업을 가능하게 한다.

![](https://docs.docker.com/get-started/images/docker-architecture.webp)

### Docker 데몬

Docker 데몬(`dockerd`)은 Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크, 볼륨과 같은 Docker 객체를 관리한다. 데몬은 다른 데몬과 통신하여 Docker 서비스를 관리할 수도 있다.

### Docker 클라이언트

Docker 클라이언트(`docker`)는 많은 Docker 사용자가 Docker와 상호 작용하는 주요 방법이다. `docker run`과 같은 명령을 사용하면 클라이언트는 이 명령들을 `dockerd`로 보내고, `dockerd`가 이를 실행한다. `docker` 명령어는 Docker API를 사용한다. Docker 클라이언트는 하나 이상의 데몬과 통신할 수 있다.

### Docker Desktop

Docker Desktop은 Mac, Windows 또는 Linux 환경에 쉽게 설치할 수 있는 애플리케이션으로, 컨테이너화된 애플리케이션과 마이크로서비스를 빌드하고 공유할 수 있게 해준다. Docker Desktop에는 Docker 데몬(`dockerd`), Docker 클라이언트(`docker`), Docker Compose, Docker Content Trust, Kubernetes 및 Credential Helper가 포함된다. 자세한 내용은 [Docker Desktop](https://www.google.com/search?q=/manuals/desktop/_index.md)을 참조하라.

### Docker 레지스트리

Docker 레지스트리는 Docker 이미지를 저장한다. Docker Hub는 누구나 사용할 수 있는 공개 레지스트리이며, Docker는 기본적으로 Docker Hub에서 이미지를 찾는다. 자신만의 비공개 레지스트리를 운영할 수도 있다.

`docker pull` 또는 `docker run` 명령을 사용하면 Docker는 구성된 레지스트리에서 필요한 이미지를 가져온다. `docker push` 명령을 사용하면 Docker는 이미지를 구성된 레지스트리로 푸시한다.

### Docker 객체

Docker를 사용할 때 이미지, 컨테이너, 네트워크, 볼륨, 플러그인 및 기타 객체를 생성하고 사용하게 된다. 이 섹션은 이러한 객체 중 일부에 대한 간략한 개요이다.

#### 이미지

이미지는 Docker 컨테이너를 생성하기 위한 지침이 담긴 읽기 전용 템플릿이다. 종종 이미지는 다른 이미지를 기반으로 하여 추가적인 사용자 정의를 더한 것이다. 예를 들어, `ubuntu` 이미지를 기반으로 하되 Apache 웹 서버와 당신의 애플리케이션을 설치하고, 애플리케이션 실행에 필요한 구성 세부 정보를 포함하는 이미지를 빌드할 수 있다.

자신만의 이미지를 생성하거나 다른 사람이 생성하여 레지스트리에 게시한 이미지만 사용할 수도 있다. 자신만의 이미지를 빌드하려면, 이미지를 생성하고 실행하는 데 필요한 단계를 정의하는 간단한 구문을 가진 Dockerfile을 생성한다. Dockerfile의 각 명령어는 이미지에 레이어를 생성한다. Dockerfile을 변경하고 이미지를 다시 빌드하면 변경된 레이어만 다시 빌드된다. 이것이 다른 가상화 기술에 비해 이미지가 매우 가볍고, 작고, 빠른 이유 중 하나이다.

#### 컨테이너

컨테이너는 이미지의 실행 가능한 인스턴스이다. Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있다. 컨테이너를 하나 이상의 네트워크에 연결하거나, 스토리지를 연결하거나, 심지어 현재 상태를 기반으로 새 이미지를 생성할 수도 있다.

기본적으로 컨테이너는 다른 컨테이너 및 호스트 머신과 비교적 잘 격리되어 있다. 컨테이너의 네트워크, 스토리지 또는 기타 기본 하위 시스템이 다른 컨테이너나 호스트 머신으로부터 얼마나 격리될지 제어할 수 있다.

컨테이너는 이미지와 함께 생성 또는 시작 시 제공하는 모든 구성 옵션에 의해 정의된다. 컨테이너가 제거되면 영구 스토리지에 저장되지 않은 상태 변경 사항은 모두 사라진다.

##### `docker run` 명령어 예시

다음 명령어는 `ubuntu` 컨테이너를 실행하고, 로컬 명령줄 세션에 대화형으로 연결한 다음, `/bin/bash`를 실행한다.

```console
$ docker run -i -t ubuntu /bin/bash
```

이 명령을 실행하면 (기본 레지스트리 구성을 사용한다고 가정할 때) 다음 과정이 발생한다:

1.  로컬에 `ubuntu` 이미지가 없다면, Docker는 마치 `docker pull ubuntu`를 수동으로 실행한 것처럼 구성된 레지스트리에서 이미지를 가져온다.
2.  Docker는 마치 `docker container create` 명령을 수동으로 실행한 것처럼 새 컨테이너를 생성한다.
3.  Docker는 컨테이너에 읽기-쓰기 파일 시스템을 최종 레이어로 할당한다. 이를 통해 실행 중인 컨테이너는 로컬 파일 시스템에서 파일 및 디렉터리를 생성하거나 수정할 수 있다.
4.  네트워킹 옵션을 지정하지 않았기 때문에 Docker는 컨테이너를 기본 네트워크에 연결하기 위한 네트워크 인터페이스를 생성한다. 여기에는 컨테이너에 IP 주소를 할당하는 것이 포함된다. 기본적으로 컨테이너는 호스트 머신의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있다.
5.  Docker는 컨테이너를 시작하고 `/bin/bash`를 실행한다. 컨테이너가 대화형으로 실행되고 터미널에 연결되어 있으므로(`-i` 및 `-t` 플래그 때문에), 키보드를 사용하여 입력을 제공할 수 있으며 Docker는 출력을 터미널에 기록한다.
6.  `/bin/bash` 명령을 종료하기 위해 `exit`를 실행하면 컨테이너는 중지되지만 제거되지는 않는다. 다시 시작하거나 제거할 수 있다.

-----

## 기반 기술

Docker는 [Go 프로그래밍 언어](https://golang.org/)로 작성되었으며, 기능을 제공하기 위해 Linux 커널의 여러 기능을 활용한다. Docker는 컨테이너라고 하는 격리된 작업 공간을 제공하기 위해 `namespaces`라는 기술을 사용한다. 컨테이너를 실행하면 Docker는 해당 컨테이너에 대한 네임스페이스 집합을 생성한다.

이러한 네임스페이스는 격리 계층을 제공한다. 컨테이너의 각 측면은 별도의 네임스페이스에서 실행되며 그 접근은 해당 네임스페이스로 제한된다.

-----

## 다음 단계

  * [Docker 설치](https://www.google.com/search?q=/get-started/get-docker.md)
  * [Docker 시작하기](https://www.google.com/search?q=/get-started/introduction/_index.md)