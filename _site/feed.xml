<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-07-29T01:07:37+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">AI Breakfast Ep 6 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/28/AI-trend-with-google-06.html" rel="alternate" type="text/html" title="AI Breakfast Ep 6 생각정리" /><published>2025-07-28T00:00:00+00:00</published><updated>2025-07-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/28/AI-trend-with-google-06</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/28/AI-trend-with-google-06.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://youtu.be/t3OuoheRiTU?si=KMR8Xvpq0Nma9XI7"><img src="https://i.ytimg.com/vi/t3OuoheRiTU/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>dd</p>

<h2 id="내-생각-정리">내 생각 정리</h2>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">AI Breakfast Ep 7 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/28/AI-trend-with-google-07.html" rel="alternate" type="text/html" title="AI Breakfast Ep 7 생각정리" /><published>2025-07-28T00:00:00+00:00</published><updated>2025-07-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/28/AI-trend-with-google-07</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/28/AI-trend-with-google-07.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=113tJcX0io8"><img src="https://i.ytimg.com/vi/113tJcX0io8/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>이번 최신화는 AI 시대의 업무와 삶의 혁신에 대한 논의를 다루고 있다.</p>

<ul>
  <li>
    <p><strong>Vertex AI 스튜디오</strong>: 구글 클라우드 내에 있는 서비스로, 기업 고객과 개발자들이 <strong>직접 AI 서비스를 만들 수 있는 도구</strong>이다. 이는 단순히 코드를 입력하는 개발 도구가 아니라, 노트북LM이나 제미나이 같은 다양한 AI 서비스를 접목하여 챗봇, 기업 맞춤형 제미나이, 비디오 및 음악 생성 등 새로운 서비스를 창의적으로 만들 수 있도록 돕는다. 또한, 고객이 직접 <strong>레고 조립하듯이 본인의 서비스를 만들 수 있는 도구</strong>로 비유되며, 이는 밀키트 판매보다는 음식 프랜차이즈를 기획하고 만드는 과정에 필요한 도구와 같다고 설명된다.</p>
  </li>
  <li><strong>구글 클라우드</strong>의 강점:
    <ul>
      <li><strong>확장성</strong>과 <strong>연결성</strong>이 매우 중요하며, 구글 클라우드는 AI 서비스의 가장 아래 단계인 모델(제미나이, 클라우드 소넷 등)부터 코드를 만들고 서비스를 제공하는 환경까지 <strong>전 포트폴리오</strong>를 제공하는 업계 유일의 서비스 제공자이다.</li>
      <li>구글 워크스페이스 같은 생산성 도구와 <strong>유기적인 데이터 교환 및 연동</strong>이 가능하여, 워크스페이스의 데이터를 Vertex AI 학습에 활용하거나 Vertex AI에서 생성된 데이터를 워크스페이스에서 참조할 수 있다. 이는 구글의 가장 큰 강점으로 꼽힌다.</li>
    </ul>
  </li>
  <li><strong>AI 도입 진입 장벽</strong>을 낮추기 위한 전략:
    <ul>
      <li>사용자가 AI를 <strong>자연스럽게 받아들이도록 유도</strong>하는 방향을 지향한다. 예를 들어, 구글링이나 이메일, 문서 작업 중 자연스럽게 AI 검색 결과나 제미나이 같은 기능이 등장하여 익숙해지도록 하는 방식이다.</li>
      <li>구글은 <strong>변화 관리 방법론</strong>을 가지고 있는데, 이는 사용자들이 A에서 B로 변화할 때 겪는 어려움을 최소화하고 마치 게임의 점진적인 업데이트처럼 사용자들이 눈치채지 못할 정도로 부드럽게 변화를 경험하도록 돕는다.</li>
      <li>이 방법론은 기업이 새로운 기술을 도입할 때 발생하는 <strong>기술 부채를 탕감</strong>해주는 역할을 한다. 기업의 현재 상황을 진단하고, 기존의 좋은 문화를 유지하면서 유연한 도구를 통해 개선할 수 있는 부분을 제안하며, <strong>작은 성공부터 맛보며 변화</strong>할 수 있도록 돕는다. 이는 “긁어 부스럼 만들지 말자”는 기업의 인식을 “변화를 눈치채지 못할 것”이라는 접근 방식으로 설득하는 데 사용된다.</li>
    </ul>
  </li>
  <li><strong>AI의 미래 발전 방향과 역할</strong>:
    <ul>
      <li>구글은 AI가 <strong>생산성 증강</strong>과 인간의 능력을 증강시켜 주는 방향으로 개발되고 있다고 밝힌다.</li>
      <li><strong>멀티모달리티</strong>를 추구하는 <strong>프로젝트 아스트라</strong>를 통해 렌즈, 음성, 소리를 통해 제미나이와 자연스러운 상호작용이 가능하며, 이는 시각 장애인 지원이나 학습 도구로 활용될 수 있다.</li>
      <li>AI가 발전할수록 우리 생활 속에 스며들어 마치 스마트폰처럼 <strong>본질은 같지만 접근 방식이 달라지는 도구</strong>가 될 것이며, 혁신적인 삶을 살아도 사용자들은 이를 당연하게 여기고 예전과 비슷하게 느낄 것이다.</li>
      <li>단기적으로는 <strong>개인 맞춤화</strong>된 AI가 발전할 것이며, 사용자의 업무 패턴이나 선호도를 기반으로 맞춤형 결과물을 제공할 것이다.</li>
      <li>더 나아가 <strong>자연스러운 인터랙션</strong>을 넘어, AI가 사용자의 모든 것을 지켜보다가 필요할 때 알아서 해주는 <strong>‘시키지도 않는 AI’</strong> 단계에 도달할 것이라는 예측도 있다. 이는 자동화와 자율 기능 부여 사이의 딜레마를 내포하고 있으며, 구글은 <strong>책임감 있는 AI</strong>를 만드는 것을 가장 중요한 가치로 삼고 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>AI의 핵심 가치</strong>는 <strong>시간 절약</strong>이다. AI는 개인이 업무에 소요되는 시간을 단축시켜 삶의 질을 높이는 데 기여한다.</p>
  </li>
  <li><strong>교육 현장</strong>에서의 AI:
    <ul>
      <li>AI는 학생들에게 양질의 정보를 쉽게 접하고 궁금증을 해결할 수 있는 새로운 채널을 제공한다.</li>
      <li>선생님들의 행정 업무 부담을 줄여주고, 아이들의 눈높이에 맞는 학습 자료나 과제 아이디어를 얻는 데 도움을 준다.</li>
      <li>AI는 <strong>숙제 개념 변화</strong>를 가져올 수 있으며, 미래 사회는 AI를 쓰는 능력이 필수가 될 것이기에 <strong>AI 숙련</strong>이 중요해진다.</li>
      <li>구글의 <strong>노트북LM</strong>은 학교 현장에서 <strong>할루시네이션</strong>(환각) 우려를 줄이고 <strong>데이터 소스 검증</strong> 능력을 키워주는 등 학생 학습과 교사 콘텐츠 준비에 높은 활용도를 제공한다.</li>
    </ul>
  </li>
  <li>학생들의 <strong>안전한 AI 사용</strong>:
    <ul>
      <li>어린 학생들의 경우, 판단 기준이 아직 확립되지 않았으므로 AI 도입은 <strong>점진적</strong>이어야 하며, 긍정적/부정적 변화를 평가할 시간이 필요하다. 정책적인 고려가 이루어지고 있다.</li>
      <li>AI가 아이들에게 칭찬을 많이 해줌으로써 학습 동기를 부여하는 등 긍정적인 학습 방법으로도 활용될 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>이제 슬슬 구글의 서비스들에 생각 이상으로 이해가 되는, 자체 구글 홍보(?) 같은 일을 내가 하고 있는가 싶다.</p>

<p>구글의 전략, 구글에 대한 이해도가 높아지고 있지만 그러는 한 편으로 AI 관련해서 구글의 전략에 대해서만 이해도가 높아져선 공평하지 않으니(?) 향후에 AWS, MS 등 웹프로바이져들을 중심으로 그 전략을, 그리고 특히나 Naver나 kakao, KT Cloud에 SKT까지는 알아봐야 하지 않을까 생각이 든다.</p>

<p>내용의 핵심인 요는 결국 ‘변화’의 바람에 떠밀듯이 회사도, 조직도, 학교도 적용될 것이지만, 문제는 그것을 어떻게 얼마나 플랫폼으로써 확장 될 수 있을까? 그리고 그 기반, 즉 공기나 물과 같은 위치를 구글의 서비스나 모델들이 확장될 수 있는가를 구글은 고민하고 있다는게 느껴진다.</p>

<p>변화는 좋은 것이지만, 그 결과가 명확하지 않을 때, 도전적인 이들도 있지만, 사실 생각해보면 대부분의 케이스 기존의 것들이 좋다는 관념적인 움직임이이 태반일 것이며 실제로도 그런 이들이 ‘어 바꿨나?’ 싶을 정도로 자연스럽게 녹아들고, 그 서비스에 락인(lock-in)될 때 그것이 진짜 플랫폼이 되는게 아닐까?</p>

<p>플랫폼 사업의 노하우, 그리고 그 앞을 바라보는 시선을 보면 왜 구글이 인터넷 춘추전국시대를 지나, 그 왕자를 분명 뺏을 만한 강자들이 있었음에도 그 강자들 사이에서 압도적일 수 있었는가에 대한 비전, 안목, 그리고 깊이감이 느껴지는 대담이 어제와 오늘자 내용이었다고 생각이 든다.</p>

<p>특히나 노트북LM, 이런 서비스에 대한 지속적인 노출이나, 교육 서비스, 워크 스페이스와의 연동 등은 어쩌면 그런 ‘가랑비에 옷 젖는’ 그리고 동시 ‘숨쉬듯’ 사용하기 위한 서비스이자, 특히나 ‘어떤 결과가 초래될지 모른다’라는 AI의 대중들의 거부감보다는 신뢰감, 효과성을 어필하려는 구글의 노력이 무엇인가를 새삼 느끼게 만드는 것 같다.</p>

<p>결국 내가 AI 와 관련되어 전문성을 얻어야 하는 지점은 어디일까?</p>

<p>어쩌면 일상의 생활에 얼마나 AI를 통해 자연스럽게 녹아들게 만들것인가. 그리고 그 과정을 단순히 백엔드의 절차적 사고를 통해서만 구현해내는 것이 아니라, 얼마나 통합된 구조를 만들 것인가?</p>

<p>궤도님의 발언처럼, 향후를 고려하여 미리 예측하여 결과를 만들어두는 것과 같이 전통적이지만 좀더 효율성이 있는 서비스로의 성장(물론, 지금 AI 산업의 구조나 하드웨어적 상황으론 거의 불가능할 것 같다만)에 도움이 되는 로직, 구조, 그리고 코드로 살려낼 수 있어야 한다는 생각, 그러려면 그런 서비스의 본질을 이해해야 한다는 생각이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">AI Breakfast Ep 5 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/25/AI-trend-with-google-05.html" rel="alternate" type="text/html" title="AI Breakfast Ep 5 생각정리" /><published>2025-07-25T00:00:00+00:00</published><updated>2025-07-25T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/25/AI-trend-with-google-05</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/25/AI-trend-with-google-05.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=Osk6h0ionM0"><img src="https://i.ytimg.com/vi/Osk6h0ionM0/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>이번 최신화는 에이전트 기술이 기업에 도입되는 현황과 미래에 대한 내용을 다루었다.</p>

<ul>
  <li><strong>기업들의 에이전트 도입 현황</strong>: 기업들은 이미 자체 서비스나 제품에 에이전트 개념을 많이 도입하였다. 예를 들어, LG유플러스의 콜 에이전트 서비스인 익시오나 카카오헬스케어의 혈당 관리 앱 파스타 등이 이에 해당한다. 그러나 자체 직원들을 위한 에이전트 도입은 아직 초기 단계에 있으며, 소수의 선구자들이 스스로 사용하고 만들어보는 단계이다.</li>
  <li><strong>업무 패러다임의 변화</strong>: 코로나19로 인한 재택근무와 온라인 협업의 시대에서 이제는 에이전트를 통해 개개인의 업무 생산성을 극대화하는 자동화의 시대로 전환되고 있다.</li>
  <li><strong>에이전트 스페이스</strong>: 구글은 이러한 변화에 대응하기 위해 ‘에이전트 스페이스’라는 제품을 출시 준비 중이다. 구글 직원들은 이미 6개월 전부터 에이전트 스페이스를 내부적으로 사용하여, 제품 출시 전 실제 사용 환경에서 문제점을 발견하고 피드백을 제공하는 ‘독푸딩(dogfooding)’ 개념으로 검증하고 있다. 구글 직원들은 에이전트 스페이스 없이는 일할 수 없을 정도의 높은 생산성을 경험하고 있다고 한다.</li>
  <li><strong>생산성 향상 경험</strong>: 과거에는 비효율적으로 일했지만 그 당시에는 인지하지 못했던 부분들이 에이전트를 사용하면서 명확해졌다. 한 번 에이전트를 사용하면 예전 방식으로 돌아가기 매우 어렵다는 점이 강조되었다. 예를 들어, ‘노트북LM’과 같은 에이전트 기술을 통해 방대한 데이터를 기반으로 자연어 대화 및 질의응답이 가능해지면서 자료를 찾아보는 시간을 대폭 절약할 수 있다.</li>
  <li><strong>에이전트가 그릴 미래</strong>: 에이전트가 많은 시간을 절약하고 업무를 대신하면서, 인간의 역할은 관리 감독, 결과 판단, 의사 결정 등으로 변화할 것이다. 인간은 에이전트의 역량을 자신의 역량으로 받아들여 더 많은 일을 할 수 있는 ‘강화형 인간’이 될 수 있다. 미래에는 단순 작업을 수행하는 에이전트를 넘어 에이전트를 관리하거나 다른 에이전트들의 상호 작용을 조율하고 학습하여 개선하는 ‘메타 에이전트’로 발전할 가능성이 있다. 궁극적으로 기업의 업무 생산성은 상상할 수 없는 수준으로 올라가 핵심 의사 결정이나 중요한 태스크에 시간을 집중할 수 있게 될 것이 예상된다.</li>
  <li><strong>에이전트 스페이스의 딥 리서치 기능</strong>: 에이전트 스페이스는 기업형 제품으로, 사용자가 가진 데이터 소스를 기반으로 딥 리서치를 수행한다. 예를 들어, 최근 AI 동향 조사를 요청하면 1분에서 10분 이내에 보고서를 생성할 수 있는데, 이는 사람이 며칠 또는 몇 주가 걸릴 일을 단축하는 것이다. 이를 통해 업무량은 늘어나더라도 더 어렵고 복잡한 일을 맡아 유능한 직원이 될 수 있다.</li>
  <li><strong>기업의 에이전트 도입 판단 기준</strong>: 에이전트 도입은 이미 많은 기업에서 생산성 도구로서 논의가 시작된 단계이며, ‘시기상조’인 기업은 거의 없다. 특히 인사, 재무, 백 오피스 지원 프로세스 등 명확한 ‘페인 포인트(Pain Point)’를 가진 기업은 에이전트 스페이스를 빠르게 테스트해보고 업무 효율성을 경험할 수 있다.</li>
  <li><strong>에이전트와 조직 변화</strong>: 에이전트 도입은 업무 프로세스를 자동화하여 위임하는 과정을 통해 이루어지며, 사람의 역할은 관리 감독과 판단 및 의사 결정으로 변화한다. 조직 관점에서는 중간 관리자의 취합 및 보고 업무가 자동화되어, 사람들은 관리보다는 실제 일하는 인력으로서 수평적인 역할을 하게 될 가능성이 있다. 또한, 마케팅, 영업, 크리에이팅 등을 혼자서도 할 수 있게 되어 1인 기업과 같은 새로운 기업 유형이 많이 생겨날 것으로 예상된다.</li>
  <li><strong>변화 관리의 중요성</strong>: 새로운 도구와 기술 도입에 있어 ‘변화 관리’가 가장 중요하다. 기업의 임원부터 실무자까지 모든 직무와 레벨에서 지원이 필요하며, 이를 위해 각 부서의 ‘챔피언’을 양성하여 에이전트의 성공 경험을 만들고 내부적으로 전파해야 한다.</li>
  <li><strong>에이전트 활용 분야</strong>: 에이전트는 반복적이고 정형화된 업무 프로세스를 가진 직무나 분야에 가장 먼저 도입될 수 있다. 일반적인 사무직 업무, 예를 들어 이메일 교환을 통한 가격 취합 및 계약서 작성 지원 등이 해당된다. 반면, 영업과 같이 다양한 감정 교류, 비언어적 의사소통, 눈치 싸움이 필요한 분야나 한 번의 잘못된 의사 결정이 큰 영향을 미치는 업무(예: 국가 지도자의 역할)에서는 에이전트가 완전히 대체하기 어렵다. 이러한 영역에서는 에이전트가 도움은 줄 수 있으나, 최종 의사 결정은 사람이 해야 한다.</li>
  <li><strong>에이전트 보안 및 신뢰성 확보</strong>: 구글은 에이전트 시스템의 보안을 다각도로 접근하고 있다. 인프라 측면에서는 모든 네트워크 통신과 데이터 사용이 암호화된 보안 채널을 통해 이루어진다. 또한, ‘IAM(Identity Access Management)’을 통해 누가 어떤 정보에 접근할 수 있는지를 세분화하여 관리하며, 에이전트 스페이스는 개개인의 접근 권한을 물고 들어와 각 직무나 팀에 따라 안전하게 정보를 검색하고 업무를 수행할 수 있는 엔터프라이즈 환경을 제공한다. 구글은 이러한 보안 측면에서 큰 사고가 발생한 적이 없다는 점을 강조한다.</li>
  <li><strong>에이전트 생태계의 미래</strong>: 에이전트가 할 수 있는 일은 지능과 툴 통합을 통해 계속 늘어날 것이다. 미래에는 사람들이 에이전트를 사용하는지조차 의식하지 못하고 공기처럼 자연스럽게 생활의 기반 기술처럼 사용하게 될 가능성이 크다. 직업 생태계는 에이전트와의 협업을 통해 변화하며, 에이전트가 마치 다른 부서처럼 여겨질 수도 있다. 멀티모달리티의 대세화로 AI와의 상호작용이 증가할 것이며, 스마트폰의 앱 생태계처럼 특정 태스크를 해결하는 다양한 에이전트들이 등장하는 ‘에이전트 생태계’가 열릴 것이다. 이 생태계에서는 책임감 있고 안정적인 에이전트 배포가 중요한 쟁점이 될 것으로 예상된다. 이러한 변화는 매우 빠르게 다가오고 있다고 예측된다.</li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>오늘 후반부의 내용은 정신이 번쩍 뜨이는 대목이었다.</p>

<p>첨단 기업의 ‘첨단’ 이란 말이 어떤 건지 새삼 깨달았다.</p>

<p>언론에서는 다양한 AI 관련된 소식을 빠르게 전한다고 하지만, 생각해보면 그러한 기술은 결국 엔드 유저의 관심을 사기 위한 것들이지, 실제 기업의 위치를 가르쳐주지는 않는 다는 내 나름의 오랜 깨달음을 알고 있었음에도 다시 한 번 뒤통수를 맞은 느낌이었다.</p>

<p>에이전트 플랫폼의 활성화, B2B 시장에만 열려 있는 Agent Space, 그리고 이를 준비하기 위한 ADK 와 노코드 툴.</p>

<p>세상의 AI의 등장과 흐름은 이미 시작된지 오래였고, 구글의 준비는 사실 언론이나, 커뮤니티의 정도를 이미 뛰어 넘었구나- 라는 생각을 했다.</p>

<p>백엔드 개발자이자, AI 개발자로 성장을 꿈꿔오고 있지만, 그런 것에 비하면 실제 비즈니스 시장과 구글과 같은 기업들이 어디까지 계획과 상황을 고려하고 있는지를 보면, 정말 침착하게, 대신 치열하게 준비해야 하는 것인지, 새삼 느낄 수 있었다.</p>

<p>이런 상황의 대처, 준비, 기업이 꿈꾸는 형태를 모르는데 어떻게 전문가가 될 수 있겠는가? 그리고 거기서도 핵심 기술로 보이는 ADK 와 같은 것들, 파이썬과 자바를 제대로 다시 공부하는게 필요하고, 그렇게 해서 ADK 적 방법론을 제대로 배워야 할 것이라 생각한다.</p>

<p>Human-in-the-loop 키워드를 비롯해서, adk, 플랫폼이 되는 언어 python 에 대한 키워드 등… 대응해야할 키워드가 보다 선명해지는 것이 느껴진다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">AI Breakfast Ep 4 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/23/AI-trend-with-google-04.html" rel="alternate" type="text/html" title="AI Breakfast Ep 4 생각정리" /><published>2025-07-23T00:00:00+00:00</published><updated>2025-07-23T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/23/AI-trend-with-google-04</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/23/AI-trend-with-google-04.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=bhNhy44jy5E"><img src="https://i.ytimg.com/vi/bhNhy44jy5E/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>유튜브 채널 "Google Cloud APAC"의 "AI Breakfast | Episode 4 - Agent로 일하는 시대가 이미 와버렸다 (Part 2)" 영상은 에이전트 기술의 발전과 구글의 관련 전략을 자세히 다루고 있다.</p>

<p><strong>에이전트의 정의와 역할</strong></p>
<ul>
  <li>에이전트는 자율적이고 통합된 대규모 언어 모델(LLM)을 의미한다. 단순히 똑똑한 것을 넘어 실제 업무를 수행하는 ‘일하는 존재’로 진화하고 있으며, 실제 직원의 모습과 유사하게 발전하고 있다.</li>
</ul>

<p><strong>에이전트 작동에 필요한 기술적 기반</strong>
에이전트가 제대로 기능하기 위해서는 다음과 같은 기술적 토대가 필요하다:</p>
<ul>
  <li><strong>두뇌, 즉 LLM:</strong> 가장 중요한 부분은 LLM이다. 제미니 2.5(Gemini 2.5)와 같은 강력한 기반 모델이 여기에 해당하며, 이들은 ‘생각하는’ 모델로서 답변을 생성하기 전에 추론 과정을 거쳐 스스로 답을 설명할 수 있는 능력을 갖추고 있다. 제미니 2.5는 에이전트 벤치마크 리더보드에서 오랜 기간 1위를 유지하고 있으며, 에이전트의 가장 근본적인 기반이자 오케스트레이터 모델로서 단단히 자리 잡아야 한다.</li>
  <li><strong>도구 사용 능력:</strong> 에이전트는 검색 기능이나 외부 예약 시스템 관리와 같은 도구를 활용할 수 있어야 한다. 다양한 사양과 접근 방식을 가진 시스템을 보다 보편적인 방식으로 다룰 수 있는 능력이 요구된다.</li>
  <li><strong>정보 탐색 능력 (Grounding):</strong> 정보를 잘 찾아내는 능력이 에이전트에게는 매우 중요하다. 구글은 ‘Grounding with Google Search’ 개념을 통해 제미니가 구글 검색의 방대한 정보를 활용하여 실시간 정보나 기업/개인이 보유하지 않은 정보까지 찾아 종합적인 답변을 제공하도록 한다. 나아가 ‘Grounding with Maps’를 통해 구글 지도의 방대한 실제 세계 정보(리뷰 데이터, 사진 데이터 등)를 활용하여 좋은 평점을 받은 식당을 추천하는 등의 판단도 가능하게 준비하고 있다.</li>
  <li><strong>다중 모드(Multimodality):</strong> 에이전트가 인간처럼 사고하고 판단하기 위해서는 세상을 인지할 수 있어야 하며, 이는 텍스트뿐만 아니라 시각, 청각 등 다양한 유형의 정보를 동시에 인지하고 처리하는 능력을 의미한다. 구글의 ‘프로젝트 아스트라(Project Astra)’는 정의된 LLM에 다중 모드와 구글 검색을 활용한 도구 사용 능력을 통합하여 시연한 사례이다.</li>
</ul>

<p><strong>최신 에이전트 트렌드</strong></p>
<ul>
  <li><strong>MCP (Model Card Protocol):</strong> 도구 사용과 관련하여 표준화가 시작되고 있다. MCP는 AI 애플리케이션과 외부 소스 및 도구 간의 연결을 표준화하는 공개 프로토콜이다. 이 프로토콜은 도구의 기능과 호출 규칙을 정의하여 LLM이 도구를 더 쉽게 이해하고 사용함으로써 오류 발생 가능성을 줄여준다. 앤트로픽(Anthropic)이 처음 제안했으며, 오픈AI(OpenAI)를 거쳐 구글 제미니도 MCP를 사용할 수 있다고 발표되었다.</li>
  <li><strong>A2A (Agent-to-Agent) 프로토콜:</strong> 멀티 에이전트 시대에 맞춰 구글이 발표한 기술로, 구글 클라우드 내의 에이전트뿐만 아니라 다른 벤더 플랫폼이나 프레임워크를 사용하는 에이전트 간에도 서로를 식별하고 직접 통신할 수 있도록 한다. 이는 하나의 에이전트가 할 수 있는 작업의 범위를 확장시켜주며, 나아가 사물 인터넷(IoT) 시대에는 가전제품들도 서로 연결되어 명령을 주고받을 수 있도록 할 예정이며, 이는 이미 일부 고객사와 논의 중이다.</li>
</ul>

<p><strong>구글 에이전트 전략의 핵심 플랫폼: Agent Space</strong></p>
<ul>
  <li><strong>Human-in-the-loop의 중요성:</strong> 에이전트의 자율성과 도구 사용 능력이 확장됨에 따라 인간의 감독과 관리가 매우 중요해진다. 에이전트가 특정 역할을 수행하기 전에 인간에게 선택지를 제시하고 허락을 구하는 <code class="language-plaintext highlighter-rouge">Human-in-the-loop</code> 개념이 안전장치로서 필수적이다.</li>
  <li><strong>Agent Space 출시:</strong> 기업 환경에서 에이전트 간의 상호 작용을 처리하고 에이전트 생태계를 효과적으로 활용할 수 있도록 구글이 출시한 플랫폼이다. 이는 구글이 수십 년 만에 처음으로 출시한 SaaS(Software as a Service) 제품이며, 에이전트와 함께 일하는 시대를 위한 엔터프라이즈 맞춤형 플랫폼이다.</li>
  <li><strong>목표:</strong> 기업들이 평균 9개 이상의 애플리케이션과 수많은 데이터 소스를 사용하는 복잡한 환경에서 발생하는 어려움을 해결하기 위해 만들어졌다. Agent Space는 이러한 분리된 데이터 소스들을 연결하고 에이전트 간의 통신을 통해 통합 검색과 인사이트를 제공하여 업무 효율성을 높이는 것을 목표로 한다.</li>
  <li><strong>주요 기능 및 특징:</strong>
    <ul>
      <li><strong>커넥터 제공:</strong> 다양한 데이터 소스를 연결하기 위한 약 150개의 커넥터가 이미 개발되어 있으며, 이를 통해 통합 검색과 자연어 질의응답이 가능하다.</li>
      <li><strong>행동 기반 자동화:</strong> 단순히 정보를 찾는 것을 넘어, 에이전트가 자동으로 이메일을 보내거나, 메시지를 전송하거나, 이벤트를 예약하는 등 실제 업무를 수행할 수 있도록 한다.</li>
      <li><strong>에이전트 갤러리 및 마켓플레이스:</strong> 구글이 미리 개발한 ‘Deep Research Agent’, ‘Data Science Agent’ 등 업무 기능별 에이전트들을 제공하며, 기업이 자체 에이전트를 구축하여 업로드하거나 마켓플레이스를 통해 다른 에이전트들을 찾아 사용할 수 있는 생태계를 조성한다.</li>
      <li><strong>에이전트 제작 용이성:</strong> 코딩 지식이 없는 사람도 에이전트 목표와 사용 도구를 자연어로 작성하면 에이전트로 등록하고 실행할 수 있는 ‘Agent Designer’ 기능(노코드)이 포함되어 있다. 개발자를 위해서는 더 세밀한 작업을 위한 ‘Agent Development Kit(ADK)’도 제공되며, 이는 제미니뿐만 아니라 타사 LLM, 랭체인(LangChain)이나 크루AI(CrewAI) 같은 다양한 프레임워크와도 호환되는 오픈소스 기반이다. ADK로 개발된 에이전트는 ‘Agent Engine’에 배포된 후 Agent Space에 등록된다.</li>
    </ul>
  </li>
  <li><strong>대상:</strong> 현재 Agent Space는 기업을 위한 B2B 솔루션으로만 제공된다.</li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>오늘 후반부의 내용은 정신이 번쩍 뜨이는 대목이었다.</p>

<p>첨단 기업의 ‘첨단’ 이란 말이 어떤 건지 새삼 깨달았다.</p>

<p>언론에서는 다양한 AI 관련된 소식을 빠르게 전한다고 하지만, 생각해보면 그러한 기술은 결국 엔드 유저의 관심을 사기 위한 것들이지, 실제 기업의 위치를 가르쳐주지는 않는 다는 내 나름의 오랜 깨달음을 알고 있었음에도 다시 한 번 뒤통수를 맞은 느낌이었다.</p>

<p>에이전트 플랫폼의 활성화, B2B 시장에만 열려 있는 Agent Space, 그리고 이를 준비하기 위한 ADK 와 노코드 툴.</p>

<p>세상의 AI의 등장과 흐름은 이미 시작된지 오래였고, 구글의 준비는 사실 언론이나, 커뮤니티의 정도를 이미 뛰어 넘었구나- 라는 생각을 했다.</p>

<p>백엔드 개발자이자, AI 개발자로 성장을 꿈꿔오고 있지만, 그런 것에 비하면 실제 비즈니스 시장과 구글과 같은 기업들이 어디까지 계획과 상황을 고려하고 있는지를 보면, 정말 침착하게, 대신 치열하게 준비해야 하는 것인지, 새삼 느낄 수 있었다.</p>

<p>이런 상황의 대처, 준비, 기업이 꿈꾸는 형태를 모르는데 어떻게 전문가가 될 수 있겠는가? 그리고 거기서도 핵심 기술로 보이는 ADK 와 같은 것들, 파이썬과 자바를 제대로 다시 공부하는게 필요하고, 그렇게 해서 ADK 적 방법론을 제대로 배워야 할 것이라 생각한다.</p>

<p>Human-in-the-loop 키워드를 비롯해서, adk, 플랫폼이 되는 언어 python 에 대한 키워드 등… 대응해야할 키워드가 보다 선명해지는 것이 느껴진다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">AI Breakfast Ep 3 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/22/AI-trend-with-google-03.html" rel="alternate" type="text/html" title="AI Breakfast Ep 3 생각정리" /><published>2025-07-22T00:00:00+00:00</published><updated>2025-07-22T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/22/AI-trend-with-google-03</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/22/AI-trend-with-google-03.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://youtu.be/pvbdNwysPBs?si=kcO1mQCCRE1_1t3H"><img src="https://i.ytimg.com/vi/pvbdNwysPBs/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>다음은 ‘AI Breakfast | Episode 3 - Agent로 일하는 시대가 이미 와버렸다 (Part 1)’ 영상 내용에 대한 요약이다.</p>

<hr />
<h3 id="ai-에이전트-시대의-도래와-구글의-접근-방식">AI 에이전트 시대의 도래와 구글의 접근 방식</h3>

<p>‘AI Breakfast’ 3화에서는 <strong>AI 에이전트로 일하는 시대가 이미 시작되었음</strong>을 강조하며, 에이전트의 정의, LLM과의 차이점, 그리고 에이전트의 발전 과정 및 구글의 관련 전략을 다루고 있다. 구글 클라우드 팀의 한지은 AI 비즈니스 담당자와 심대열 엔지니어가 에이전트 시대에 대한 구글의 시각을 설명한다. 한지은은 AI 고 투 마켓 전략 수립 및 엔터프라이즈 기업 지원을 담당하며, 심대열은 고객들이 아이디어를 빠르게 구현할 수 있도록 MVP 프로덕트 프로토타이핑을 지원한다.</p>

<p><strong>1. 에이전트의 정의와 특징</strong></p>
<ul>
  <li><strong>에이전트란</strong> 특정 목표 달성을 위해 스스로 판단하고 행동하는 똑똑한 비서이다. 예를 들어, 날씨 확인, 회의 일정 잡기, 관심 뉴스 제공 등 사용자를 대신하여 스스로 검색하고 학습하여 정보를 제공하는 역할을 한다.</li>
  <li>기술적으로는 <strong>툴을 활용</strong>하고, 검색 결과를 평가하여 필요시 다른 툴을 사용하는 등 복합적인 요소를 포함한다.</li>
  <li>에이전트는 <strong>자율성 수준</strong>에 따라 등급이 나뉘며, 완전 자동화된 에이전트부터 초보적인 에이전트까지 다양하다.</li>
  <li>구글은 에이전트를 <strong>어떤 목표를 달성하기 위해 세상을 관찰하고, 주어진 툴을 활용하여 액션을 취하는 시스템</strong>으로 정의한다. 이는 인간이 해오던 업무를 인공지능이 수행할 수 있게 되었음을 의미한다.</li>
</ul>

<p><strong>2. LLM과 에이전트의 차별점</strong></p>
<ul>
  <li><strong>기존 LLM의 사용성</strong>은 사용자의 질문에 LLM이 알고 있는 선에서 즉각적으로 답변하는 방식이다. 예를 들어, “세종대왕이 맥북을 던졌나”라는 질문에 LLM은 그럴듯한 시나리오를 제시할 수 있지만, 사실 여부 확인은 전적으로 사용자의 몫이었다. 이러한 한계는 “환각(hallucination)” 효과를 유발하기도 한다.</li>
  <li><strong>에이전트</strong>는 다르다. 하나의 목적을 받았을 때, <strong>스스로 검색</strong>을 수행하여 관련 정보를 찾고, LLM이 그 정보를 분석하여 중요 포인트를 파악한다. 필요한 경우 추가 질문을 생성하여 정보를 수집하고, 최종적으로 정확하고 심층적인 답변을 제공한다.</li>
  <li>에이전트는 단순히 답변을 찾는 것을 넘어, <strong>기억하고, 도구를 활용하며, 그 결과에 대해 스스로 자아성찰</strong>하여 올바른 방향으로 나아가는 과정을 포함한다.</li>
  <li>LLM은 에이전트의 <strong>두뇌 역할</strong>을 하지만, 에이전트는 LLM을 활용하여 특정 작업을 효과적으로 수행하고, 사고 과정을 거쳐 전문성을 발휘하는 시스템 자체를 의미한다.</li>
</ul>

<p><strong>3. 에이전트 개념의 발전 과정</strong></p>
<ul>
  <li>초기 LLM은 학습된 시점 이후의 정보를 알지 못하는 한계가 있었다 (예: 2021년 4월까지 학습된 모델은 그 이후 정보를 모름).</li>
  <li>이러한 한계를 극복하기 위해 <strong>RAG(검색 증강 생성)</strong> 기법이 등장했다. 이는 자동화된 툴이나 사람이 최신 정보를 검색하여 LLM에 제공함으로써 답변의 정확도를 높이는 방식이다.</li>
  <li>RAG의 유용성이 확인되면서, LLM의 한계를 돌파하기 위해 <strong>다양한 외부 툴(예: 인터넷 검색)</strong>을 활용하는 개념으로 확장되었다.</li>
  <li>이러한 툴 활용을 위한 <strong>워크플로우</strong>는 초기에는 사람이 직접 설정했지만, LLM의 <strong>추론 능력과 계획 수립 능력</strong>이 발전하면서, 특정 태스크 요청 시 최적의 답변을 생성하기 위해 스스로 추론하고 계획을 세워 도구를 활용(예: 검색 증강)하는 에이전트 역할이 가능해졌다.</li>
  <li>결과적으로 AI 자체가 LLM부터 시작하여 필요한 기능들을 계속 보완하고 발전하면서 <strong>‘에이전트’라고 부를 수 있는 단계</strong>에 이른 것이다.</li>
</ul>

<p><strong>4. 자율적 수행과 통합의 중요성</strong></p>
<ul>
  <li>에이전트에 <strong>‘자율적 수행(Autonomous Execution)’</strong>과 <strong>‘통합(Integration)’</strong>이라는 단어가 붙는 것은 LLM의 능력이 크게 향상되었기 때문이다.</li>
  <li><strong>자율적 수행</strong>은 LLM이 스스로 계획을 세우고 도구를 자율적으로 활용할 수 있게 되었음을 의미한다.</li>
  <li><strong>통합</strong>은 LLM이 도구를 활용하기 위해 해당 도구와 통합되어 있어야 하며, 다른 에이전트나 툴과의 협업을 통해서도 LLM의 능력이 대폭 향상될 수 있음을 나타낸다.</li>
  <li>이 두 가지 특성(자율적 수행과 통합)은 에이전트의 가장 큰 장점을 표현하는 핵심 개념으로, <strong>항상 함께 움직인다</strong>고 볼 수 있다.</li>
  <li>구글은 에이전트를 연결하는 <strong>‘오케스트레이션 모델’</strong> 또는 <strong>‘통합 에이전트’</strong> 개념을 제시하며, 이는 에이전트들이 사람처럼 다양한 업무를 통합적으로 수행할 수 있도록 돕는 역할을 한다.</li>
  <li><strong>멀티 에이전트 시스템</strong>은 하나의 에이전트가 모든 일을 처리하는 것이 아니라, HR 에이전트, 개발 에이전트, 리뷰 에이전트와 같이 <strong>특정 목적과 전문성으로 역할을 분리</strong>하여 구성한 다음, 이를 통합하거나 관리하는 방식이다. 이는 마치 신입사원이 어떤 부서에 배치되어도 전문가가 될 수 있는 잠재력을 가진 것과 유사하다.</li>
</ul>

<p><strong>5. 구글의 5가지 에이전트 범주와 Creative Agent</strong></p>
<ul>
  <li>구글은 이미 작년에 에이전트를 다섯 가지 범주로 정의한 바 있다:
    <ul>
      <li><strong>Employee Agent:</strong> 임직원 지원.</li>
      <li><strong>Customer Agent:</strong> 고객 인터랙션 지원.</li>
      <li><strong>Data Agent:</strong> 데이터 분석 지원.</li>
      <li><strong>Creative Agent:</strong> 미디어 생성 지원 (예: 비디오, 이미지, 오디오).</li>
      <li><strong>Security Agent:</strong> 보안 영역 지원.</li>
    </ul>
  </li>
</ul>

<p><strong>6. 저작권 및 안전성 문제에 대한 구글의 접근</strong></p>
<ul>
  <li>구글은 생성형 AI 모델 출시를 서두르지 않고, <strong>엔터프라이즈 기업들이 믿고 신뢰할 수 있도록</strong> 오랜 기간 정책을 준비했다.</li>
  <li>구글은 자사의 Gen AI 미디어 모델(Veo 2, Imagen 3, Lyria 등)을 통해 생성된 결과물에 대해 <strong>면책 조항(Indemnification)</strong>을 제공한다. 이는 사용자가 고의적으로 저작권을 침해하는 프롬프트를 입력하지 않는 한, 문제가 발생할 경우 구글이 책임지겠다는 약속이다.</li>
  <li>구글은 다양한 <strong>안전 필터(Safety Filter)</strong> 계층을 통해 문제가 될 수 있는 콘텐츠 생성을 최대한 막고 있다. 엔터프라이즈 고객의 특정 요구사항이 있을 경우, 구글의 <strong>7가지 AI 원칙</strong>에 따라 안전 필터를 완화하는 조치를 취하기도 한다.</li>
  <li>또한, AI가 생성한 콘텐츠에는 <strong>워터마크</strong>를 제공하여 AI 생성 여부를 확인할 수 있도록 하는 장치를 마련했다.</li>
  <li>구글은 <strong>‘책임감 있는 AI(Responsible AI)’</strong> 구축을 목표로 하며, 이는 AI 시대에 구글이 차별점을 가져갈 수 있는 중요한 부분으로 강조된다. 기존 창작자들의 거부감을 해소하고 AI 생태계를 건강하게 구축하는 것이 목표이다.</li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>나는 소비자와 기업이라는 관점에서 AI 의 고객을 생각했었다. 개발자니까, 그렇다면 거기서 필요한게 뭘까 하는 생각을 하기위해서였다. 하지만, 역시나 일까. 단순히 엔드 소비자와 기업이라는 관점만으론 부족했다는게 이번 내용에서 깨닫는 부분이다.</p>

<p>기업 내부에서도 결국 필요시 되는 건 결정권자들, 그리고 실무진이 다르며, 그들의 핵심이 어디서 어떤 것드을 제공해 주어야 하는지를 구글은 너무나 잘, 아주 함축적으로 파악하고 있다고 생각한다. 이게 역시 안목이라는 걸까.</p>

<p>에이전트 구축에 있어 어떤 방향성으로 좀더 명확해 져야 할지, 스스로 생각해 볼 수 있는 영역이었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">AI Breakfast Ep 1 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/21/AI-trend-with-google-01.html" rel="alternate" type="text/html" title="AI Breakfast Ep 1 생각정리" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/21/AI-trend-with-google-01</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/21/AI-trend-with-google-01.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=KlojGihJfMU"><img src="https://i.ytimg.com/vi/KlojGihJfMU/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>인공지능의 기본적인 개념, 대중화 과정, 사람처럼 대화하는 AI의 특성, 미래 트렌드, 그리고 구글의 AI 전략에 대한 내용들.</p>

<ul>
  <li><strong>인공지능의 정의</strong>: 구글의 관점에서 인공지능은 우리의 시간과 노력을 절감시켜주는 <strong>생산성 도구</strong>이며, 인류의 문제를 해결하고 개인, 조직, 공공 단체가 <strong>창의적인 결과</strong>를 얻도록 돕는 도구로 기대한다.</li>
  <li><strong>AI의 대중화 시점</strong>: 일반 대중이 AI를 처음 접하기 시작한 계기는 <strong>2016년 알파고(AlphaGo)</strong>가 이세돌과의 바둑 대국을 펼쳤을 때이며, 업계에서는 STT(음성을 텍스트로)와 TTS(텍스트를 음성으로) 기술의 발전, 그리고 <strong>거대 생성형 AI 모델</strong>들이 채팅 형태로 출시되면서 대중화가 확실히 각인되었다고 평가되고 있다.</li>
  <li><strong>AI가 사람처럼 대화하는 가장 큰 변화</strong>: 현재 AI 모델들은 사람의 행동 패턴과 방대한 텍스트 데이터를 학습하고 흉내 내는 것에 머무르고 있다. AI가 사람처럼 대화하는 것처럼 느껴지는 것은 <strong>패턴 분석과 학습을 통한 답변 구조</strong> 때문이다. AI는 아직 사람의 미세한 뉘앙스, 톤, 심리 상태와 같은 비텍스트 요소를 완벽하게 ‘이해’ 및 ‘판단’ 한 것은 아님</li>
  <li><strong>멀티모달리티(Multimodality)</strong>: <strong>구글의 제미나이(Gemini)는 처음 설계될 때부터 텍스트뿐만 아니라 소리, 음성, 영상, 이미지 등 인류가 만들어낸 다양한 미디어를 입력받아 해석할 수 있는 멀티모달리티를 지향</strong> 이는 궁극적으로 <strong>인공 일반 지능(AGI)</strong>에 도달하기 위해 필수적인 요소로 간주함.</li>
  <li><strong>미래 AI 트렌드 (10년 후)</strong>: 앞으로의 AI는 <strong>‘에이전트(Agent)’ 시대</strong>로 접어들 것으로 예상. 에이전트는 LLM을 적용하여 다양한 업무를 자동화하고 수행하며, 개인부터 기업까지 모든 사람이 활용하는 형태로 발전할 것이다. 딥마인드의 목표인 <strong>AGI는 10년 뒤쯤이면 인류의 난제를 해결하고 삶에 긍정적인 변화를 가져올 것</strong>으로 기대하고 있다. 이미 <strong>알파폴드(AlphaFold)</strong>와 같은 AI는 특정 문제 해결 능력에서 사람을 능가하는 ‘슈퍼 휴먼’ 수준에 도달했다.</li>
  <li><strong>AI 산업 주도 플레이어 및 전략</strong>: <strong>구글(Google), 오픈AI(OpenAI), 앤트로픽(Anthropic), 딥시크(DeepSeek), 메타(Meta)의 라마(Llama)</strong> 등이 주요 플레이어이자 AI 리더 플랫폼이다. 구글은 특히 <strong>‘책임감 있는 AI(Responsibility AI)’</strong>를 슬로건으로 삼아, 속도나 성능보다는 <strong>안전성</strong>을 최우선으로 여긴다. 이는 사용자에게 잘못된 정보를 주거나 혼란을 야기하지 않기 위함이다.</li>
  <li><strong>구글의 제미나이 생태계 확장 전략</strong>: 구글은 명확한 ‘AI 엔진’을 가지고 있다. 딥마인드와 같은 R&amp;D 조직에서 AI 모델을 연구하고 개발한 후, 유튜브, 구글 지도, 지메일 등 <strong>10억 명 이상의 사용자가 있는 자체 제품에 먼저 AI 모델을 적용하여 확장성과 사용자 피드백을 검증</strong>하고 있다. 이후 준비가 되면 오픈소스로 제공하고, 기업 고객을 위해 <strong>구글 클라우드(Google Cloud) 제품을 통해 기술을 제공</strong>하는 일련의 과정을 거친다.</li>
  <li><strong>AI가 생산성에 미치는 영향</strong>: AI는 업무 현장에서 없어서는 안 될 필수적인 도구가 되었으며, 구글 워크스페이스(Workspace)에 제미나이가 탑재되어 업무를 원활하게 수행할 수 있도록 돕는다. 특히 <strong>노트북LM(NotebookLM)</strong>은 학계에서 논문 요약 등 연구의 사전 단계를 단축시켜주는 데 크게 활용되고 있다</li>
  <li><strong>생성형 AI 활용 격차와 한계</strong>: AI 활용 격차는 주로 <strong>프롬프트 엔지니어링(Prompt Engineering)</strong>에서 비롯되지만, 더 중요한 것은 <strong>AI가 생성한 결과물을 사용자가 직접 필터링하고 검증할 수 있는 능력(배경지식)</strong>이다.</li>
  <li><strong>AI 환각 증상(Hallucination)</strong>: 환각은 AI의 <strong>패턴 분석 및 학습 과정에서 발생하는 자연스러운 현상</strong>으로, 뇌의 예측적 인지 과정과 유사. 특히 2017년 구글에서 발표한 <strong>트랜스포머(Transformer) 모델</strong> 기반의 LLM은 단어를 숫자로 변환하여 연관 관계를 파악하기 때문에, 언어를 직접 이해하는 것은 근본적으로 아니다. 이러한 태생적 한계로 인해 환각이 발생할 수밖에 없다.</li>
  <li><strong>환각 증상 극복 노력</strong>:
    <ul>
      <li><strong>더 많은 데이터 학습</strong>: 모델에 더 많은 데이터를 학습시켜 환각 발생 확률을 줄인다.</li>
      <li><strong>인간의 지도</strong>: 개발자가 거버넌스 모델을 통해 잘못된 답변을 방지하는 구조를 제공한다.</li>
      <li><strong>그라운딩(Grounding) 기술</strong>: 구글은 <strong>‘구글 검색(Google Search)을 통한 그라운딩’ 기술</strong>을 통해 제미나이가 실시간 정보를 활용하여 답변의 정확성을 높였다. 향후 구글 지도 및 유튜브 데이터까지 그라운딩에 활용될 예정이다. 답변에 <strong>출처(Citation)</strong>를 필수로 명시하여 사용자가 신뢰성을 판단할 수 있도록 돕는다.</li>
    </ul>
  </li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>요 최근의 AI 상황, 그 와중에서 아주 개론적인 내용들이 핵심이 된다고 보였다. 그리고 어디까지나 구글의 강점, 구글이 이번 2025 행사 이후에 상황에 대한 아주 간략한 정리라고 할까?</p>

<p>확실한 것은 구글이 말한 것 처럼, 2016년부터 준비하던 그들이기에, 이제는 속도는 빠르게 가야 하기에 달려가고 서두르겠지만, 동시에 기존부터 준비하던 든든한 하부가 드디어 결실을 맺는 단계가 되었다는 생각이 들었다.</p>

<p>제미나이만 보더라도 그렇다. 현재 사용하는 과정에서 얻은 제일 큰 핵심은 가성비, 그리고 AI 개발을 위한 하드웨어와 소프트웨어의 대응, 그리고 결정적으로 할루시네이션의 정도를 보면, 1편의 이야기처럼 구글은 다른 곳들에 비하면 월등한 플랫폼 AI 모델로서의 성능을 보여준다.</p>

<p>또한 계속 배우고 싶어했던 부분도 구글의 AI 관련 기능들, GCP와 통합된 서비스들이, 아직 불완정할지는 모르지만 다른 곳에 비하면 확실히 박차를 가하고 있음을, 느낄 수 있는 부분이기에 AI에 대해서는 AWS 보다 Google을 우선시 해야 할지도 모르겠다.</p>

<p>또한 대담 과정에서 나온 신뢰에 대한 지속적인 강조 표현들을 보면, 여러 이유가 있지 않을까 싶다. 우선 가장은 AI 의 특성을 이해하는 많은 이들에게, AI 활용을 한다고 할 때 결국 ChatGPT와 같은 각인된 선발주자들에 비해 신뢰성이 부족하다는 인상, 그리고 AI 사용하면서 알게된 이 환각증상이나, 여러 점들, 생각해보면 1.5까지만 해도 아쉬웠던 부분들에 대한 ‘편견’을 깨야 하는게 구글의 핵심이라고 생각한게 아닐까?</p>

<p>사실 LLM 자체에 대해 생각해본다면 대단히 상품성에서 ‘미묘한’ 본질을 갖고 있다. 성능은 말해서 뭐해 수준인 것은 맞으나, 결국 같은 값을 지불하고 동일한 성능을 낸다. 이 영역에 대한 한계는 아직 갖고 있기 때문에, 그런 점을 어필하는 구글은 결국 LLM 의 본질적 한계를 어떻게 극복하고, 극복 후에 어떻게 ‘팔아야할 까’ 에 집중한 전략이 아닐까 생각하게 된다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">AI Breakfast Ep 2 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/07/21/AI-trend-with-google-02.html" rel="alternate" type="text/html" title="AI Breakfast Ep 2 생각정리" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/07/21/AI-trend-with-google-02</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/07/21/AI-trend-with-google-02.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=GEUFX_OzceA"><img src="https://i.ytimg.com/vi/GEUFX_OzceA/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>"AI Breakfast | Episode 2"는 구글 AI의 차별점과 개발 원칙, AI의 미래 전망, 그리고 구글 클라우드 넥스트(Google Cloud Next) 행사의 주요 발표 내용을 다루고 있다.</p>

<ul>
  <li>
    <p><strong>구글 AI의 본질적 차별점은 ‘풀 스택(Full-Stack) 프로바이더’라는 점</strong>이다. 구글은 AI 특화 프로세서인 <strong>TPU와 같은 인프라를 직접 구축하고</strong>, 개발자들이 모델을 활용하고 에이전트를 구축할 수 있는 <strong>버텍스 AI(Vertex AI) 플랫폼을 제공하며</strong>, 워크스페이스(Workspace)와 같은 최종 사용자를 위한 <strong>SaaS 서비스까지 전체 스택을 모두 제공한다</strong>. 이는 AI의 근본부터 최종 서비스까지 모든 것을 직접 제공하는 독자적인 강점이다.</p>
  </li>
  <li><strong>구글 AI 개발의 세 가지 원칙은 2018년 구글 I/O에서 수립된 바 있다</strong>.
    <ol>
      <li><strong>대담한 혁신</strong>: 끊임없이 새로운 기술을 탐구하고 개발한다.</li>
      <li><strong>책임감 있는 개발 및 배포</strong>: 기술 개발 속도보다는 <strong>‘모두에게 도움이 될 것인가’를 우선시한다</strong>. 이를 위해 철저한 내부 테스트를 거치며, AI로 생성된 이미지나 영상에 <strong>신스아이디(SynthID)와 같은 워터마크를 넣어 AI 생성물임을 명확히 한다</strong>. 이는 투명성을 확보하고 사용자 혼란을 방지하기 위함이다.</li>
      <li><strong>협력적 발전</strong>: 개발된 AI 기술을 구글의 이익 추구에만 사용하지 않고, <strong>사회 공동의 선(善)과 이익을 위해 공유한다</strong>. 젬마(Gemma)와 같은 오픈소스 모델 배포, 산불 확산 예측 모델, 유방암 진단 보조 등 의료 및 공공 분야 기술 제공이 그 예이다.
<strong>구글은 2016년 ‘AI 퍼스트(AI First)’ 회사를 선언하며 ‘모두에게 유용한 AI를 만든다(AI for everyone)’는 사명을 가지고 있다</strong>.</li>
    </ol>
  </li>
  <li>
    <p><strong>구글은 AI의 감각 확장을 통해 물리적인 세계와 상호작용하는 것을 다음 단계로 바라본다</strong>. <strong>제미나이 로보틱스(Gemini Robotics)를 통해 제미나이 2.0 기반의 로봇 팔을 개발하여, 사람의 음성이나 키보드 명령을 수행하고 실시간으로 상황 변화를 인지하며 목표를 달성할 수 있도록 한다</strong>. 이는 VLA(Vision, Language, Action) 기술을 통해 AI가 인간의 동반자로서 진정으로 도움을 줄 수 있도록 하는 방향이다.</p>
  </li>
  <li><strong>구글 클라우드 넥스트(Google Cloud Next) 행사에서는 다음과 같은 주요 발표가 있었다</strong>.
    <ul>
      <li>라스베이거스의 스피어(The Sphere)에서 특별 행사를 진행했으며, <strong>Veo2(텍스트-투-비디오 AI)와 이매진(Imagen)을 활용하여 “오즈의 마법사”를 스피어의 360도 스크린에 상영할 수 있도록 업스케일링 및 영상 생성 프로젝트를 공개했다</strong>. 이는 구글의 방대한 연산 자원과 혁신적인 AI 기술력을 보여주는 사례이다.</li>
      <li><strong>7세대 TPU가 도입되었으며, 단일 연산 성능으로 42.5 엑사플롭스(exaFLOPS)를 달성했다</strong>. 이는 기존 슈퍼컴퓨터의 10배 이상 성능이며, 구글의 모든 AI 모델은 TPU 위에서 생성되고 서비스된다.</li>
      <li><strong>제미나이 2.5 프로(Gemini 2.5 Pro)는 100만 토큰의 이해력을 지원하여 장편 소설 여러 편에 해당하는 방대한 양의 정보를 한 번에 처리하고 깊이 있는 추론을 할 수 있다</strong>. 또한, <strong>플래시(Flash) 모델은 지연 시간을 극단적으로 줄여 빠른 응답을 요하는 서비스에 최적화되었다</strong>.</li>
      <li><strong>진화한 버텍스 AI(Vertex AI)는 기업이 구글 AI를 활용하는 올인원 솔루션이다</strong>. 모델 가든, 에이전트 빌더, 모델 빌더의 세 가지 핵심 구성 요소를 제공한다. 특히, <strong>유튜브 영상의 URL만으로 전체 영상을 분석하고 요약하는 기능이 추가되어, 특정 장면을 검색하는 것도 가능해졌다</strong>. 이는 구글의 유튜브 생태계를 활용한 강력한 기능이다.</li>
      <li><strong>구글은 기업 내 생산성 향상을 위한 ‘에이전틱 AI(Agentic AI)’에 집중하고 있다</strong>. <strong>A2A(Agent-to-Agent) 프로토콜을 통해 서로 다른 기술로 만든 에이전트 간의 교신을 가능하게 하며</strong>, 기업 내 누구나 에이전트를 활용할 수 있는 새로운 SaaS 제품인 <strong>‘에이전트 스페이스(Agent Space)’를 출시했다</strong>.</li>
    </ul>
  </li>
</ul>

<p>결론적으로 구글 클라우드 넥스트에서는 <strong>구글이 AI 인프라(7세대 TPU)부터 모델(제미나이 2.5), 에이전트, 기업형 플랫폼(버텍스 AI)까지 모든 것을 제공하는 ‘풀 스택’ 기업임을 명확히 보여주며, 기업들에게 ‘버텍스 AI만 쓰면 된다’는 메시지를 전달했다</strong>.</p>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>진짜 배울게 많다… 써보고 싶은 기능은 많은데 시간은 그걸 허락을 안하니… 이걸 어쩌면 좋으리… 
<del>복권을 사는 것 말곤 답이 없을 지도</del></p>

<p>확실히 AI 관련 인프라를 비롯해, API 로 활용하기 좋음, 성능을 고려하면 최고는 구글이라고 생각이 든다. 최대한 적용을 해볼 수 있어야 할텐데 싶다. 마음이 급해진다. 🤔</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">Tools - 유튜브 썸네일 추출기</title><link href="http://0.0.0.0:4000/tools/2025/07/21/tools-1st.html" rel="alternate" type="text/html" title="Tools - 유튜브 썸네일 추출기" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/tools/2025/07/21/tools-1st</id><content type="html" xml:base="http://0.0.0.0:4000/tools/2025/07/21/tools-1st.html"><![CDATA[<h2 id="들어가면서">들어가면서</h2>
<p>썸네일 찾기 귀찮을 때 유튜브 썸네일을 활용하고자 찾은 썸네일 추출기. 간단하게 만들었지만 유용해서 별 밖아둡니다…나중엔 내 블로그 내부에 구현해둘까 싶다.</p>

<p><a href="https://marshallku.com/dev/%ec%9c%a0%ed%8a%9c%eb%b8%8c-%ec%8d%b8%eb%84%a4%ec%9d%bc-%ec%b6%94%ec%b6%9c%ed%95%98%ea%b8%b0">유트브 썸네일 추출하기</a></p>]]></content><author><name>Paul2021-R</name></author><category term="tools" /><category term="tools" /><summary type="html"><![CDATA[들어가면서 썸네일 찾기 귀찮을 때 유튜브 썸네일을 활용하고자 찾은 썸네일 추출기. 간단하게 만들었지만 유용해서 별 밖아둡니다…나중엔 내 블로그 내부에 구현해둘까 싶다.]]></summary></entry><entry><title type="html">Jenkins 를 위한 Groovy 스크립트 언어 정리</title><link href="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/29/groovy-language-with-jenkins.html" rel="alternate" type="text/html" title="Jenkins 를 위한 Groovy 스크립트 언어 정리" /><published>2025-06-29T00:00:00+00:00</published><updated>2025-06-29T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/29/groovy-language-with-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/29/groovy-language-with-jenkins.html"><![CDATA[<h1 id="jenkinsfile-작성-튜토리얼">Jenkinsfile 작성 튜토리얼</h1>

<p>본 내용은 Jenkins 파이프라인 구축 전에 이해도를 위하여 언어에 대한 간단한 가이드를 정리한 내용이다.</p>

<h2 id="들어가기-전에-1-왜-gui가-아닌-스크립트-형태로-써야-하는가">들어가기 전에 1: 왜 GUI가 아닌 스크립트 형태로 써야 하는가?</h2>

<p>Jenkins 는 강력한 플랫폼이다. 다양한 대체제가 나왔음에도 여전히 인정받는 CI/CD 를 위한 툴이며, 그 플러그인과 커뮤니티, 레퍼런스들의 존재들은 여전히 영향력 있는 툴이라는 점을 보여준다.</p>

<p>GUI로 설정 대신 스크립트로 작성해야 하는 이유는 다음과 같다.</p>

<ol>
  <li>버전 관리 용이, 협업 용이성 : GUI 로 설정을 수행하는 것은 스크립트 형태로 내보낼 수 있으나, 그 스크립트 자체는 Git 과 같은 버전 관리 시스템 통합하기 까다롭다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 은 프로젝트 소스 코드와 함께 저장하여 관리하여, <strong>파이프라인 변경 이력</strong>을 Git 으로 완벽히 추적할 수 있고, 이는 긴급 상황이나, 개선이 필요시 쉽게 작업이 가능하다.</li>
  <li>재현성(Reproducibility)과 환경 일관성 : Jenkinsfile 은 파이프라인의 모든 단계를 코드로 정의 내리며, 새로운 Jenkins 인스턴스를 설정하거나 다른 팀에 동일한 파이프라인을 제공시, 스크립트만 복사하면 된다. 이러한 점에서 GUI 보다 효과적이고, <strong>환경의 일관성</strong>을 증대시킬 수 있다.</li>
  <li>복잡하고 동적인 로직 구현 : GUI 방식은 미리 정의된 블록, 제한된 옵션을 활용해야 한다. 그러나 Groovy 언어 기반으로 스크립트를 하게 되면, 매우 유연하고 복잡한 로직을 구현할 수 있다. 이는 다양한 서비스 환경에 맞춤화한 파이프라인 구성이 가능하다는 점에서 매우 중요하다.</li>
  <li>개발 친화적 : 개발팀이 직접 CI/CD 파이프라인을 개선, 유지보수를 할 수 있는데, 이는 DevOps 문화의 핵심 요소다.</li>
  <li>오류 사전 감지 : Jenkinsfile은 문법 오류나 논리 오류를 Git 에 커밋하기 전에 Linter 등을 통해 미리 확인해보는 것이 가능하다.</li>
</ol>

<p>물론, 반대의견으로 GUI 로 만들어 스크립트로 보관을 이야기 하기도 한다. 
Jenkins에는 <code class="language-plaintext highlighter-rouge">Pipeline Syntax</code> 라는 기능으로 GUI 로 설정한 내용을 기반으로 Groovy 코드로 생성 및 보관이 가능하다. 하지만 다음과 같은 이유로 추천하진 않는다.</p>

<ol>
  <li>GUI 에서 제공하는 기능만 사용 가능 : 복잡한 조건, 반복, 동적인 데이터 처리는 결국 손이 감</li>
  <li>복사-붙여넣기 오버헤드 : GUI 에서 설정을 불러와 이를 Jenkinsfile에 넣어야 하는 추가 과정이 발생</li>
  <li>버전관리의 완전한 통합 부족 : Jenkinsfile 이라는 파일로 관리 되어야 할텐데, 그렇지 못함.</li>
</ol>

<h2 id="들어가기-전에-2-jenkinsfile을-프로젝트-내부에-보관해야-하는-이유는">들어가기 전에 2: Jenkinsfile을 프로젝트 내부에 보관해야 하는 이유는?</h2>
<ol>
  <li>버전관리: Git 저장소에 함께 관리될 수 있으니 애플리케이션 코드와 함께 관리가 가능하여 Git 을 활용한 완벽한 추적이 가능.</li>
  <li>재현성 및 환경 일관성: 어떤 환경, 어떤 Jenkins 서버세서든 프로젝트 코드만 Git으로 클론하면 Jenkinsfile 이 함께 따라와서, 동일한 CI/CD 파이프라인을 재현할 수 있다.</li>
  <li>개발자 협업: CI/CD 파이프라인 설정이 코드베이스에 포함되어 개발자들도 파이프라인에 대한 변경 사항을 코드리뷰로 기여할 수 있고, 이는 DevOps 문화 개발, 협업을 강화하는데 기여.</li>
  <li>프로젝트 종속성: 파이프라인은 해당 프로젝트의 빌드, 테스트, 배포 단계를 정의하는데, 각 프로젝트 요구사항에 맞춰 Jenkinsfile 을 개별적으로 관리하는게 효율적.</li>
  <li>새로운 Jenkins 서버 설정의 용이성: 향후 Jenkins 서버를 새로 구축하거나 재설정 시 각 프로젝트에 존재하니, 다시 연결만 해주면 모든 파이프라인의 설정이 자동 복구됨.</li>
</ol>

<h2 id="groovy-언어">Groovy 언어</h2>

<p>Groovy 언어는 Java와 매우 유사하면서도 더 간결하고 유연한 문법을 제공하는 스크립트 언어다. Jenkinsfile에서는 주로 데이터 처리, 조건문, 반복문, 함수 호출 등에 사용된다.</p>

<h3 id="groovy-언어-기본-튜토리얼-jenkinsfile을-위한-핵심">Groovy 언어 기본 튜토리얼 (Jenkinsfile을 위한 핵심)</h3>

<p>여기서는 Jenkinsfile을 작성하는 데 필요한 Groovy의 <strong>핵심적인 문법과 개념</strong>을 위주로 설명한다.</p>

<h4 id="1-변수-선언과-데이터-타입">1. 변수 선언과 데이터 타입</h4>

<p>Groovy는 변수 선언 시 <code class="language-plaintext highlighter-rouge">def</code> 키워드를 사용하거나, 명시적인 데이터 타입을 지정할 수 있다. 대부분의 경우 <code class="language-plaintext highlighter-rouge">def</code>를 사용하면 Groovy가 타입을 자동으로 추론한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">"Jenkins"</span> <span class="c1">// 문자열 (String)</span>
<span class="kt">def</span> <span class="n">version</span> <span class="o">=</span> <span class="mf">2.452</span>   <span class="c1">// 숫자 (정수 또는 실수)</span>
<span class="kt">def</span> <span class="n">isRunning</span> <span class="o">=</span> <span class="kc">true</span>  <span class="c1">// 불리언 (Boolean)</span>
<span class="kt">def</span> <span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"apple"</span><span class="o">,</span> <span class="s2">"banana"</span><span class="o">,</span> <span class="s2">"cherry"</span><span class="o">]</span> <span class="c1">// 리스트 (List)</span>
<span class="kt">def</span> <span class="n">map</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"key1"</span><span class="o">:</span> <span class="s2">"value1"</span><span class="o">,</span> <span class="s2">"key2"</span><span class="o">:</span> <span class="mi">123</span><span class="o">]</span> <span class="c1">// 맵 (Map)</span>
</code></pre></div></div>

<h4 id="2-문자열-strings">2. 문자열 (Strings)</h4>

<p>Groovy는 문자열 처리는 자바보다 유연하게 설계 되어 있다.</p>

<ul>
  <li><strong>따옴표:</strong> 작은따옴표 (<code class="language-plaintext highlighter-rouge">'...'</code>)는 일반 문자열, 큰따옴표 (<code class="language-plaintext highlighter-rouge">"..."</code>)는 문자열 내 변수 삽입(GString)이 가능한 문자열을 나타낸다.</li>
  <li><strong>GString (변수 삽입):</strong> 큰따옴표 안에 <code class="language-plaintext highlighter-rouge">${변수명}</code> 또는 <code class="language-plaintext highlighter-rouge">$변수명</code> 형태로 변수를 직접 삽입할 수 있다.</li>
</ul>

<!-- end list -->

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">buildNumber</span> <span class="o">=</span> <span class="mi">10</span>
<span class="kt">def</span> <span class="n">jobName</span> <span class="o">=</span> <span class="s2">"MyProject"</span>

<span class="n">println</span> <span class="s2">"Build number is ${buildNumber}"</span> <span class="c1">// 결과: Build number is 10</span>
<span class="n">println</span> <span class="s2">"Job name is $jobName"</span>         <span class="c1">// 결과: Job name is MyProject</span>
<span class="n">println</span> <span class="s1">'This is a simple string.'</span>    <span class="c1">// 변수 삽입 안 됨</span>

<span class="c1">// 여러 줄 문자열: """ 또는 '''를 사용</span>
<span class="kt">def</span> <span class="n">multiLineString</span> <span class="o">=</span> <span class="s2">"""
Hello,
This is a multi-line string.
Build: ${buildNumber}
"""</span>
<span class="n">println</span> <span class="n">multiLineString</span>
</code></pre></div></div>

<h4 id="3-리스트-lists">3. 리스트 (Lists)</h4>

<p>iterable 한 데이터 컬렉션 기능. <code class="language-plaintext highlighter-rouge">[]</code> 대괄호를 사용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">fruits</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"apple"</span><span class="o">,</span> <span class="s2">"banana"</span><span class="o">,</span> <span class="s2">"orange"</span><span class="o">]</span>

<span class="n">println</span> <span class="n">fruits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>      <span class="c1">// 결과: apple (인덱스는 0부터 시작)</span>
<span class="n">println</span> <span class="n">fruits</span><span class="o">.</span><span class="na">size</span><span class="o">()</span>  <span class="c1">// 결과: 3 (리스트 크기)</span>
<span class="n">fruits</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s2">"grape"</span><span class="o">)</span>    <span class="c1">// 요소 추가</span>
<span class="n">println</span> <span class="n">fruits</span>         <span class="c1">// 결과: [apple, banana, orange, grape]</span>
</code></pre></div></div>

<h4 id="4-맵-maps">4. 맵 (Maps)</h4>

<p>키(key)와 값(value)의 쌍으로 이루어진 데이터 컬렉션이에요. <code class="language-plaintext highlighter-rouge">:</code> 또는 <code class="language-plaintext highlighter-rouge">=</code>를 사용하여 정의한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"Alice"</span><span class="o">,</span> <span class="s2">"age"</span><span class="o">:</span> <span class="mi">30</span><span class="o">,</span> <span class="s2">"city"</span><span class="o">:</span> <span class="s2">"Seoul"</span><span class="o">]</span>

<span class="n">println</span> <span class="n">userInfo</span><span class="o">[</span><span class="s2">"name"</span><span class="o">]</span>  <span class="c1">// 결과: Alice</span>
<span class="n">println</span> <span class="n">userInfo</span><span class="o">.</span><span class="na">age</span>      <span class="c1">// 결과: 30 (점(.) 표기법도 가능)</span>
<span class="n">userInfo</span><span class="o">.</span><span class="na">country</span> <span class="o">=</span> <span class="s2">"South Korea"</span> <span class="c1">// 새 키-값 쌍 추가</span>
<span class="n">println</span> <span class="n">userInfo</span>          <span class="c1">// 결과: [name:Alice, age:30, city:Seoul, country:South Korea]</span>
</code></pre></div></div>

<h4 id="5-조건문-ifelse">5. 조건문 (If/Else)</h4>

<p>Java와 동일하게 <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else</code>를 사용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">status</span> <span class="o">=</span> <span class="s2">"SUCCESS"</span>

<span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">==</span> <span class="s2">"SUCCESS"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"배포 성공!"</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">==</span> <span class="s2">"FAILURE"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"배포 실패!"</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"배포 상태 알 수 없음."</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="6-반복문-loops">6. 반복문 (Loops)</h4>

<p><code class="language-plaintext highlighter-rouge">for</code> 루프와 <code class="language-plaintext highlighter-rouge">each</code> 클로저(함수)를 주로 사용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">items</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"item1"</span><span class="o">,</span> <span class="s2">"item2"</span><span class="o">,</span> <span class="s2">"item3"</span><span class="o">]</span>

<span class="c1">// for 루프</span>
<span class="k">for</span> <span class="o">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"Processing: $item"</span>
<span class="o">}</span>

<span class="c1">// each 클로저 (더 Groovy스러운 방식)</span>
<span class="n">items</span><span class="o">.</span><span class="na">each</span> <span class="o">{</span> <span class="n">item</span> <span class="o">-&gt;</span>
    <span class="n">println</span> <span class="s2">"Processing with each: $item"</span>
<span class="o">}</span>

<span class="c1">// 인덱스와 함께 반복 (eachWithIndex)</span>
<span class="n">items</span><span class="o">.</span><span class="na">eachWithIndex</span> <span class="o">{</span> <span class="n">item</span><span class="o">,</span> <span class="n">index</span> <span class="o">-&gt;</span>
    <span class="n">println</span> <span class="s2">"Item ${index}: $item"</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="7-함수-methodsclosures">7. 함수 (Methods/Closures)</h4>

<p>Jenkinsfile에서는 주로 <code class="language-plaintext highlighter-rouge">script</code> 블록 내에서 Groovy 함수를 정의하거나, 클로저를 활용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일반적인 함수 정의</span>
<span class="kt">def</span> <span class="nf">greet</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s2">"Hello, ${name}!"</span>
<span class="o">}</span>

<span class="n">println</span> <span class="nf">greet</span><span class="o">(</span><span class="s2">"World"</span><span class="o">)</span> <span class="c1">// 결과: Hello, World!</span>

<span class="c1">// 클로저 (변수에 할당된 코드 블록)</span>
<span class="kt">def</span> <span class="n">sayHi</span> <span class="o">=</span> <span class="o">{</span> <span class="n">name</span> <span class="o">-&gt;</span>
    <span class="n">println</span> <span class="s2">"Hi, $name"</span>
<span class="o">}</span>

<span class="n">sayHi</span><span class="o">(</span><span class="s2">"Bob"</span><span class="o">)</span> <span class="c1">// 결과: Hi, Bob</span>
</code></pre></div></div>

<h4 id="8-try-catch-예외-처리">8. try-catch (예외 처리)</h4>

<p>스크립트 실행 중 발생하는 오류를 처리하여 파이프라인이 갑자기 중단되지 않도록 할 수 있음.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">def</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="s">/ 0 /</span><span class="o">/</span> <span class="mi">0</span><span class="err">으로</span> <span class="err">나누기</span> <span class="err">오류</span> <span class="err">발생</span>
    <span class="n">println</span> <span class="n">result</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"오류 발생: ${e.message}"</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"오류 발생 여부와 상관없이 항상 실행되는 부분."</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="9-외부-명령어-실행-shell-command">9. 외부 명령어 실행 (Shell Command)</h4>

<p>Jenkinsfile에서 가장 많이 사용하는 기능 중 하나로, <code class="language-plaintext highlighter-rouge">sh</code> (Shell) 명령어를 통해 리눅스/유닉스 쉘 명령어를 실행하는 것이 가능하다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sh</span> <span class="s1">'ls -al'</span> <span class="c1">// 파일 목록을 출력</span>
<span class="n">sh</span> <span class="s1">'echo "Hello from shell"'</span> <span class="c1">// 쉘에서 메시지 출력</span>

<span class="c1">// 여러 줄 명령</span>
<span class="n">sh</span> <span class="s2">"""
    echo "First line"
    echo "Second line"
"""</span>

<span class="c1">// 명령의 결과 받기</span>
<span class="kt">def</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sh</span><span class="o">(</span><span class="nl">script:</span> <span class="s1">'pwd'</span><span class="o">,</span> <span class="nl">returnStdout:</span> <span class="kc">true</span><span class="o">).</span><span class="na">trim</span><span class="o">()</span> <span class="c1">// 현재 작업 디렉토리 경로를 pwd 로 실행하고 받아서, trim 처리하여 작업 디렉토리를 저장한다.</span>
<span class="n">println</span> <span class="s2">"Current directory: $output"</span>

<span class="c1">// 명령의 성공/실패 여부만 확인</span>
<span class="kt">def</span> <span class="n">success</span> <span class="o">=</span> <span class="n">sh</span><span class="o">(</span><span class="nl">script:</span> <span class="s1">'exit 0'</span><span class="o">,</span> <span class="nl">returnStatus:</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// 성공하면 0 반환</span>
<span class="kt">def</span> <span class="n">failure</span> <span class="o">=</span> <span class="n">sh</span><span class="o">(</span><span class="nl">script:</span> <span class="s1">'exit 1'</span><span class="o">,</span> <span class="nl">returnStatus:</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// 실패하면 1 반환</span>
<span class="n">println</span> <span class="s2">"Success: $success, Failure: $failure"</span>
</code></pre></div></div>

<h4 id="10-jsonyaml-파싱">10. JSON/YAML 파싱</h4>

<p>AWS CLI 명령의 결과가 JSON 형태인 경우가 많다. 이를 Groovy에서 파싱하여 데이터에 접근하는 방법을 알아두면 유용하다. <code class="language-plaintext highlighter-rouge">readJSON</code>이나 <code class="language-plaintext highlighter-rouge">readYaml</code> 같은 Jenkins Pipeline Step이 이를 도와서 처리해준다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">jsonString</span> <span class="o">=</span> <span class="s1">'{"name": "test", "status": "success"}'</span> <span class="c1">// Json 을 읽어</span>
<span class="kt">def</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="n">readJSON</span><span class="o">(</span><span class="nl">text:</span> <span class="n">jsonString</span><span class="o">)</span> <span class="c1">//파싱 처리 =&gt; 객체화</span>

<span class="n">println</span> <span class="n">jsonData</span><span class="o">.</span><span class="na">name</span>   <span class="c1">// 결과: test</span>
<span class="n">println</span> <span class="n">jsonData</span><span class="o">.</span><span class="na">status</span> <span class="c1">// 결과: success</span>
</code></pre></div></div>

<hr />

<h2 id="groovy-학습-팁--알아두면-좋은-내용">Groovy 학습 팁 &amp; 알아두면 좋은 내용:</h2>

<ul>
  <li><strong>Jenkins Pipeline Syntax Snippet Generator:</strong> Jenkins 대시보드의 파이프라인 잡 설정 페이지에서 “Pipeline Syntax” 링크를 클릭하면 Snippet Generator를 사용할 수 있다. 여기서 원하는 Jenkins 스텝을 선택하고 설정을 채우면 해당 Groovy 코드를 자동으로 생성해 준다. 이것이 Groovy 문법을 익히는 데 가장 강력한 도구 중 하나다.</li>
  <li><strong>Java 지식 활용:</strong> Groovy는 Java와 매우 유사하므로, Java 경험이 있다면 빠르게 적응할 수 있다.</li>
  <li><strong>간결함 선호:</strong> Groovy는 Java보다 더 적은 코드로 동일한 작업을 수행할 수 있는 “Syntactic Sugar”가 많다. 간결한 표현을 선호하는 경향이 있다.</li>
  <li>Jenkins 를 위한 jenkins 파일의 구조를 이해하는 것이 실수를 줄이는데 중요하다.</li>
  <li>글로벌 변수의 경우 최초 설정을 하긴 하지만, 기본적으로 Secret 등에 대해 우선 가져오는 구조로 설정은 불가능하다. 각 단계별로만 되고, 이러한 경우 에러 핸들링은 Jenkins 가 알아서 해준다는 점 알아둘것.</li>
</ul>

<hr />

<h2 id="마치면서">마치면서</h2>

<p>젠킨스랑 같이 산지도 어언 7개월 차. Unity 클라이언트 프로젝트를 쓰는 바람에 익숙한 Github 방식을 버리게 되어 다소 아쉽지만, 뭐 어떤가, 대세 기술 하나 제대로 파는건 당연히 필요하고, 특히나 jenkins 는 최소 3년 ~ 5년차에게 요구되는 기술이라는데 제대로 배워둘 필요가 있다고 느꼈다(일단 재미도 있다)</p>

<p>엄두도 안 났었던 내용인데, Docker 를 비롯해 한 두달 바짝 DevOps를 위한 여러 기술들을 고심하고, API 서버에 도입을 하나씩 해 나가니 생각보다 별거 아니란 생각에, 역시 양파 까듯 생각했어야 하는 구나 란 생각을 다시 한 번 해보았다.(처음엔 뭐 그리 부담스럽게 생각했던 것인지…)</p>

<p>이제 한 발자국 남았다. Jenkins 배포를 위한 file 작업 중이니 조만간 마무리 지어야지….🤔</p>]]></content><author><name>Paul2021-R</name></author><category term="개발" /><category term="Backend" /><category term="DevOps" /><category term="Programming" /><category term="Groovy" /><category term="학습" /><summary type="html"><![CDATA[Jenkinsfile 작성 튜토리얼]]></summary></entry><entry><title type="html">서버 상태를 알려주는 서버리스 서버 만들기 v1</title><link href="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/28/EKS+LAMDA+CLOUDWATCH.html" rel="alternate" type="text/html" title="서버 상태를 알려주는 서버리스 서버 만들기 v1" /><published>2025-06-28T00:00:00+00:00</published><updated>2025-06-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/28/EKS+LAMDA+CLOUDWATCH</id><content type="html" xml:base="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/28/EKS+LAMDA+CLOUDWATCH.html"><![CDATA[<h2 id="0-introduciton">0. Introduciton</h2>

<p>신규 프로젝트를 진행하는 과정에서 backend 개발자로서 Legacy 코드들의 대대적인 개선, 코드 품질 향상, 그러면서도 향후를 고려한 다양한 DevOps 적인 요청이 들어왔다.</p>

<p>아무래도 클라이언트 처럼 직접적인 개발이 필요한 입장에선 타이트한 일정 상황에서 구현이나, 현재의 목표에 중시해야 했지만, 백엔드라는 특성 상 테크리더의 요청으로 백엔드는 보다 안전하고, 보다 관리 용이성을 높이는 것 역시 추가로 필요하다는 것이 리더의 설명이자, 계획이었다.</p>

<p>그렇기에 나 역시 개발의 핵심 방향성을 잡고 한달의 달리기를 위한 목표 설정을 했었다. 내용은 다음과 같다.</p>

<ol>
  <li>배포와 개발 환경을 최대한 독립화하자.
    <ul>
      <li>Docker 이미지화 + ECR 을 활용하기 + 시작 템플릿을 활용하여 1 딸깍이면 신규 이미지를 불러오돌 구현하자</li>
      <li>Jenkins 를 활용한 무중단 배포를 최대 목표로 잡자.</li>
    </ul>
  </li>
  <li>배포, 개발의 과정에서, 기계적으로 코드 품질을 유지할 장치를 마련하자.
    <ul>
      <li>Husky 의 도입을 통해 git 이벤트를 추적해 특정 품질 최적화 기능을 구동시킨다.</li>
      <li>lint, lint-staged, tsc 컴파일러의 typechecking 등을 내부에 추가하기</li>
    </ul>
  </li>
  <li>코드 외적으로 Ops 관점에서 최대한 안정성을 확보하자.
    <ul>
      <li><strong>Cloud Watch 서비스를 보다 고도로 파악하고 적용하자, 특히 각 서버의 특성(AI, API) 이에 최적화된 헬스 체킹의 기반을 준비하자.</strong></li>
      <li><strong>국내에선 당장 문자로 인스턴스 상태 알림을 수신 가능하게 만들자</strong></li>
    </ul>
  </li>
</ol>

<p>말이 길어졌다. 사실 해당 프로젝트에 대해서도 정리가 필요하긴 할 것으로 보이지만, 그것은 또 다음 시간에… 사실 너무 바빠서 그 중간의 내용에 진행했던 내용을 다 적었다간, 논문이 되어버릴지도 모른다. 😂</p>

<h2 id="1-sms-어떻게-보내볼까">1. SMS 어떻게 보내볼까</h2>

<p>사실 요즘은 딸깍- 이라는 키워드를 활용하듯 B2B 서비스나, AWS 에서도 돈을 더 내고 고급 서비스를 써도 된다. 심지어 글로벌이라면 SNS 서비스를 활용하면 그냥 그걸로 끝날지도 모른다. 하물며 lamda 와 SNS API 를 활용하면 아마 그걸로 충분히 구현 될 수도 있다.(그러니 사실 따라하라고 추천하고 싶진 않다… 이 글의 목적도 엄밀히 말하면 서버리스 서비스와 AWS 의 서비스를 보다 내 스타일로 써보면 어디까지 되나? 가 궁금해서 일을 크게 키운거기도 하다.) 어쨌든, 그리하여 여러 고민을 해보았다.</p>

<ol>
  <li>기존 쓸 수 있는 서비스를 최대한 활용하고 싶다.</li>
  <li>비용이나, 헬스 체킹에 너무 시간을 쏟기는 싫다.</li>
  <li>배포 관리하기 귀찮다!</li>
  <li>서버리스 서비스를 한번 써보고 싶다..!</li>
  <li>대신 종속성은 최소화 하자</li>
</ol>

<p>요정도를 고려해보았다.그리하여 나온 구조는 다음과 같은 구조이다.</p>

<p><img src="/assets/images/posts/2025-06/2025-06-28-0001.png" alt="" /></p>

<h3 id="1-1-event-추적--proccessor-로-송신">1-1. Event 추적 ~ Proccessor 로 송신</h3>

<p>CloudWatch 는 기본적으로 모니터링할 대상을 바라본다. 특히 여기서 핵심은 각 서버마다 이벤트를 지정 시 Health 의 지표가 될 만한 핵심을 파악해야 한다는 점이다. 연산장치인 CPUUtilization 을 보는 지표도 있겠지만, 자사의 경우 유저의 일정한 수준의 처리 성능을 중요시 했고, 따라서 네트워크 사용량에 대한 구체적인 정보 쪽이 훨씬 서버 관리에 중요하였다.</p>

<p>여기서 중요한 포인트라고 생각되는 것은, 사실 SNS 를 쓰지 않아도 된다는 사실이다. SimpleNotificationService 를 통해 주제를 설정하지 않더라도, CloudWatch 는 직접 Lambda 를 호출하는 게 가능하다. 하지만 그렇게 하게 되면 CloudWatch 의 알람마다 Lambda 설정을 건드려야 할 필요가 발생하고 만다. 따라서 1:N 의 관계가 필요하다면, 반드시 중간 매개체로 N이 1과 바로 연결되지 않는 구조가 필요하기 때문에 SNS 의 존재가 꼭 중요하다 볼 수 있다.</p>

<p>그 뒤 Lambda 는 SNS 를 통해 일원화 되어 들어오는 이벤트들에 대해 내가 지정한 위치의 URL 로 보내면 되는데, 이때 주요한 내용으로 알아두면 하는 것은, ‘파이썬’ 기반으로 사용한다고 하더라도, 순정 상태에선 외부 라이브러리를 쓰지 못한다는 점이다(괜히 이점 때문에 AI 바이브 코딩 했다 왜 안되나 한참 찾았다.) 다행히, 수동으로 넣어줘도 되고, 간단한 통신 정도만 수행한다면 제일 좋은 건 내장 통신 라이브러리로 전달만 하는 것이다.</p>

<h3 id="1-2-수신-및-프로세싱--sms">1-2. 수신 및 프로세싱 ~ SMS</h3>

<p>Processor 라고 이름을 지은 이 서버의 목적은 Naver의 SENS API 에 맞게 전달해주는 역할이다. NaverCloud 라니! 라고 생각할 수도 있다. 하지만 어떻게 하겠는가, 회사에선 이걸 쓰고 있는데(…) 이미 실서비스에 사용 중이기도 했고, API 가 익숙하다는 점을 생각하니, 이부분 만큼은 빠르게 가기로 했다.</p>

<p>그리하여 API ~ SMS 는 처리 했고, 그 다음의 포인트는 역시 수신 받는 곳의 구현이었다.</p>

<p>NestJS 를 사용해도 되긴 했다. 왜냐면 이미 NestJS 서버는, 우리 회사 상용 서버 역시 3.0.0에 해당하는 수준으로 판을 올려놓은 상태였고, 해당 템플릿을 사용한다면 충분히 할만하지 않을까? 싶었다.</p>

<p>그러나 이미 써본 기술, 동시에 장황하게 설정된 기능들이나 관리 코드들을 그대로 가져오기엔 용도에 맞지 않는 다는 점은 분명해 보였다. 이에 이왕 현재 자사 서비스를 위해 사용 중인 FastAPI 를 써보면 좋겠다는 생각을 했고, 이왕 하는 김에 의존성의 관리는 Poetry 를 사용해보기로 했다.</p>

<p>써본 후기로는… Poetry 는 가상환경 커맨드 안쳐도 된다! 편하다! 와, FastAPI 는 우와 자동 Swagger 쩐다…! 😯 라는 느낌을 받았다. Pydantic을 통한 자동 데이터 유효성 검사, 그리고 /docs 경로에 자동으로 생성되는 API 문서는 Postman 없이도 즉시 테스트가 가능한 환상적인 개발 경험을 제공했다.</p>

<p>여기서 핵심은 API 를 수신하고, 각 이벤트에 맞춰 지정된 대상에게 전달하는 구조를 작성하는 것이었고, 그 뒤엔 이를 배포하는 걸 조금이라도 ‘편하게’ 하는 방법을 구현하는 것이었다.</p>

<p>이에 ECR(Elastic Container Registry)에 tag 를 활용하여 가장 최신으로 관리되는 것, 그리고 EC2를 활용하여 인스턴스로 관리하는 것이 아니라, 알아서 필요시 사용되기 + 스케일러블 하게 대응이 가능하게 만드는 것으로 하였다.</p>

<p>특히나 이렇게 구현 하면서 ECS(Elastic Container Service) 를 처음 써보게 되었는데, Task 라는 개념으로 Fargate 방식을 제공하는 ECS 를 사용했고, 초기 사용은 복잡했지만, ELB 와 기타 조합을 통해 알아서 이미지로 갱신되도록 만들었다. Task Definition, Service, 그리고 ALB Target Group과 Security Group 간의 네트워킹 설정은 처음 접하는 입장에서 많은 시행착오를 요구했다. 코어 0.25개에 0.5GB 의 메모리 사용은, 인스턴스처럼 항상 준비된 하드웨어요금이 나가는 것보다 계산 시 훨씬 경제적이었다. (물론 함정은 다른데 있다)</p>

<h2 id="2-그래서-이-구조의-장점과-단점은-뭘까">2. 그래서 이 구조의 장점과 단점은 뭘까</h2>

<p>전체적으로 작업이 끝나고 SMS 를 받아보니, 확실히 이메일 받을 때 보단 상태를 확인도 가능하고, 설정에 따라 주기적으로 헬스 체크도 가능해진다는 점은 매우 편리하였다. 바이브 코딩 + 각종 기술 맛보기 + AWS 서비스 구성을 배워 본다는 점에선 매우 영양가 있던 시간(?) 이라고 밖에 할 말이 없을 것 같은데, 그럼에도 구조를 짜고 내용을 바라보면 다소 아쉬움도 남았다. 😎</p>

<h3 id="2-1-장점-pros">2-1. 장점 (Pros)</h3>
<p>우선, 완벽하게 모듈화된 설계 구성은 예를 들어 lambda 하나로만 한다거나 하는 것 보다 훨씬 직관적이었다. 각 역할(이벤트 수신, 처리, 발송)이 명확했고, 문제가 발생했을 때 어느 지점의 문제인지 파악하기 용이했으며, 특히 각 영역의 수정이나 배포 등에서 매끄럽다고 생각한다.</p>

<p>데이터 편집은 FastAPI 서버를 건드리면 되고, 알람은 CloudWatch 경보를 추가하거나 세밀하게 만들어 주면 될 문제였다. lambda는 필요할 때만 활성화 되니 필요하지 않을 땐 사실상 없는 것이나 마찬가지. Fargate의 경우에도 그냥 켜둔 다면 0원에 수렴하기 때문에 가장 작은 EC2 인스턴스를 쓴다고 해도, 이미 프리티어는 넘어버린 자사 입장에선 훨씬 양호했다.</p>

<p>개인적인 면에서도 서버리스 + ECR + 도커 이미지로의 빌드 + 태깅을 통한 최신 이미지 추적의 형태는 개발 이후 복잡할 수 있는 배포 과정을 deploy.sh 스크립트 하나로 매우 깔끔하게 만들어주었다. Fargate 라는 서비스는 생각 이상으로 편리하다는 점, 직접 프로비저닝이나 관리 안해도 되는 점은 확실히 좋았다. 응용할 수 있는 방법은 특히나 많았고, 서비스의 특성에 따라 경제적인 서버 운용에 키 역할을 해줄 수 있겠구나 하는 생각을 할 수 있었다.</p>

<p>람다의 경우, 생각 이상으로 너무 편하다는 생각은 확실히 들었다. 데이터의 중간 인터셉터 역할을 하기엔 확실히 편리했고, 그냥 코드를 짜고 deploy 만 하는 순간 끝난다는 점은 ‘서버로 만들긴 애매한’ 무언가를 위한 상당히 좋은 툴이었다는 경험이(?) 추가 되었다고 볼 수 있을 것 같다 😁</p>

<p>또한 먼 이야기겠지만, 이벤트가 늘어나면 조건만 추가하면 자연스럽게 스케일러블 한 설계가 가능하고, 민감한 정보는 모두 컨테이너화 되어 있으니(특히 전달 받는 분들의 연락처 등), 이러한 점에서 알림 서비스로서 향후를 고려한 꽤 괜찮은 구성이 아닐까 싶다.</p>

<h3 id="2-2-단점-cons">2-2. 단점 (Cons)</h3>
<p>AWS 는 바보가 아니다. 이렇게 편리한 서비스 옵션들, 모듈들을 무료로 푸는 데는 나름의 악랄한 부분이 있지 않으면 안된다(…) <del>등가교환 법칙…</del></p>

<p>우선 핵심은 모듈화 하는 과정에서 Fargate 의 구성 난이도가 오히려 무지하게 높다는(!) 생각을 할 수 있었다. 해당 서비스의 의도와 구성에 대한 이해도가 없지만 AI 를 활용해서 그나마 해결했지, 이걸 모르는 사람이 혼자 해본다? 과연 될까 싶은게 솔직한 감상이었다(…)</p>

<p>뿐만 아니라, SMS 로 알림을 보내는 게 핵심인데, 그걸 위해 하루 정도 소요되는 시간을 들여 만든다는 것은, 어떤 점에선 최악의 시간 낭비일 수도 있지 않나 싶다. 서버 상태의 알림은 주의-경보 이정도만 해도 되는데, 그걸 위해 이렇게까지 투자하는 것은 어쩌면 라이브 서비스에서도 어느정도 운영을 했다고 생각하니까지, 초기 팀이나, 초기 서비스에 이렇게 알림에 하루 쓴다는건 그게 맞나? 싶은 생각을 할 수 있었다.</p>

<p>모듈화가 장점이지만, 동시에 차라리 이렇게 안만들고 통짜로 만들어도 되는거 아닌가? 생각도 문뜩 들었다.</p>

<p>마지막으로 가장 최악은, 비용에 대한 부분이다. SMS 쓴다고 돈을 써야 하는 부분을 제외하면 이번 작업 과정 전체는 충분히 경제적이었다. 0.25 개의 코어 활용, 0.5GB 메모리, 일반 인스턴스론 불가능할 수준으로 작은 수준이다보니, 역할조차 작으니 말이 안되게 작은 스펙이지만 충분히 잘 돌아갔다.</p>

<p>하지만, Fargate, Lambda 등은 문제가 아닌데, 이를 통신하기 위해 연결해야 하고, 그렇게 되는 과정에서 ELB(Elastic Load Balancer)를 비롯한 각종 네트워킹 서비스들의 비용은 당연히 부과 되는 것이었고, 그냥 단순히 Fargate 의 컨테이너가 돌리기만 한다면 좋았겠지만 그렇지 못하다보니 계산 시 한달에 3만원 ~ 많게는 4.5 만원까지도 나올 수 있다는 계산을 다 만들고 했다(…)</p>

<p>아니, 인스턴스 24시간 켜놓고 3-4만원 나오는게 맞추면, 이것저것 다할 수 있는데? <del>전형적인 조삼모사</del></p>

<p>… 여하튼 할 말은 많지만 V1 버전은 그리하여 마무리하고 나니 아쉬운 점, 특히 투머치 한 점을 보완해야 한다는 점을 깨달을 수 있었다</p>

<h2 id="3-결론">3. 결론</h2>

<p>요즘 키워드 DevOps, GitOps 가 특히 중요하다는데, 확실히 재미있는 영역이다. 그리고 더불어 AWS 와 같은 서비스에 대해 개념의 이해도 착실히 늘어가고 있다는 점에서 자신감이 붙는 포인트가 아닐까 싶다.</p>

<p>특히나 서버리스는 말로만 서버리스라고 했지, 막상 테스트 삼아 만들어 본 적은 없었는데, 만들면서 왜 필요한지 확실히 체감을 할 수 있었다. 서버라는 어떤 스테레오 타입 구축을 위한 노력 없이, 기능적 최소화, 자원 사용의 최소화라는 관점에선 꽤나 멋진 기능이고, 활용도가 상당하다는 점에서 괜찮다는 생각이 들었다.</p>

<p>다만, 역시나. 이렇게 편하면 괜한게 아닌것 처럼(…) 그 서비스 자체는 괜찮지만, 사실상 반 필수로 써야 하는 다른 서비스들에 대해 요금설계가 확실히 되어 있다는 점에서, “이럴 거면 그냥 EC2 연결하지 왜…?” 라는 말이 튀어나오게 되는게 사실이다(개발자 입장에선).</p>

<p>그리하여 바로 V2 형태로 개선을 했었는데, 그 내용도 조만간 정리해야 겠다.</p>]]></content><author><name>Paul2021-R</name></author><category term="개발" /><category term="Backend" /><category term="DevOps" /><category term="AWS" /><category term="Python" /><category term="AI" /><category term="NaverCloud" /><summary type="html"><![CDATA[0. Introduciton]]></summary></entry></feed>