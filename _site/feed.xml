<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-05-25T08:37:16+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">백엔드 개발자, 2025년 트렌드 정리하기</title><link href="http://localhost:4000/backend/2025/05/25/backend-developper-issues.html" rel="alternate" type="text/html" title="백엔드 개발자, 2025년 트렌드 정리하기" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/25/backend-developper-issues</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/25/backend-developper-issues.html"><![CDATA[<h2 id="1-백엔드-왜-지금-이-변화를-주목하려고-하는가">1. 백엔드, 왜 지금 이 변화를 주목하려고 하는가?</h2>
<p>백엔드는 더 이상 단순히 데이터를 처리하고 저장하는 ‘뒷단’이 아니다. 서비스의 확장성, 안정성, 그리고 궁극적으로 사용자 경험의 질을 결정하는 핵심 두뇌이자 심장부이다. 기업들은 갈수록 더 빠르고, 더 유연하며, 더 비용 효율적인 시스템을 요구하고 있으며, 이러한 요구는 백엔드 아키텍처와 기술 스택의 끊임없는 진화를 촉진한다.</p>

<p>최신 트렌드를 이해하는 것은 단순히 유행을 쫓는 것이 아니라, 더 나은 아키텍처를 설계하고, 문제를 해결하며, 궁극적으로 더 가치 있는 서비스를 만들어내는 데 필수적이다. 더불어 점점 가속화되고 바이브 코딩이라는 말이 나올 정도로 개발의 사이클이 변화하고 있고, 이는 비즈니스적 문화와 가치 역시 바뀌고 있다는 것을 말하고 있으며, 이러한 상황은 인력시장의 개편 역시 당연한 말이지만 영향이 있다는 점을 새삼 느끼고 있다.</p>

<p>그렇기에 이러한 점들을 종합하여, AI의 성능, 능력을 봄과 함께 나의 백엔드 개발자로의 역량을 위하여 정리해본다.</p>

<h2 id="2-2025-백엔드-시장의-핵심-트랜드-5가지">2. 2025 백엔드 시장의 핵심 트랜드 5가지</h2>
<p>백엔드 시장의 변화를 주도하는 주요 기술 트렌드를 여러분의 시선으로 함께 살펴본다.</p>

<p><strong>2.1 클라우드 네이티브 &amp; 서버리스 아키텍처의 확산</strong>
서버리스 컴퓨팅은 인프라 비용 절감과 확장성 향상을 위해 기업들이 점차 더 많이 채택하고 있으며, AWS Lambda, Google Cloud Functions, Azure Functions와 같은 플랫폼이 이러한 추세를 주도한다. 서버리스 컴퓨팅 시장은 2024년부터 2029년까지 연평균 15.3% 성장하여 447억 달러에 이를 것으로 예상된다. 이러한 아키텍처의 핵심 이점은 서버 관리가 필요 없고, 수요에 따라 자동으로 확장되며, 사용량 기반 과금으로 비용 효율적이라는 점이다. 이러한 변화는 광범위한 디지털 전환 노력과 하이브리드 작업 환경의 증가에 의해 더욱 가속화된다.  </p>

<p>클라우드 네이티브 기술의 채택은 컨테이너화의 발전을 이끌고 있으며, 조직들은 마이크로서비스와 클라우드의 확장성 및 민첩성을 적극적으로 활용한다. Kubernetes는 컨테이너화된 애플리케이션의 배포, 관리, 확장을 자동화하여 클라우드 전환을 가속화하는 데 핵심적인 역할을 한다. 서버리스 및 클라우드 네이티브 아키텍처의 광범위한 도입은 백엔드 개발의 근본적인 변화를 의미하며, 인프라 관리에서 코드 및 서비스 관리로 초점이 이동한다. 서버리스 컴퓨팅의 주요 이점은 서버를 관리할 필요가 없다는 점이며 , Docker와 Kubernetes를 통한 컨테이너화 및 오케스트레이션은 배포, 관리, 확장을 자동화하고 , 인프라 계층을 추상화한다. 이러한 점진적인 추상화는 개발자들이 기저 하드웨어에 대한 걱정을 덜고 애플리케이션 로직, 서비스 계약, 분산 환경 내 서비스 상호작용에 더 집중하게 만든다. 이는 백엔드 개발에서 더 높은 수준의 관심사로의 전환을 의미하며, 운영 부담을 덜어줌으로써 개발자 생산성을 향상시킨다.  </p>

<p>그러나 이러한 광범위한 도입에도 불구하고, Kubernetes 구성의 내재된 복잡성은 여전히 중요한 과제로 남아있으며, 특히 보안 및 비용 최적화 측면에서 두드러진다. 57%의 조직이 컨테이너 권한 조정(rightsizing)을 효과적으로 관리하지만, 43%는 여전히 개선이 필요하며 이는 클라우드 비용에 직접적인 영향을 미친다. 또한, 이미지 취약점과 오래된 컨테이너 이미지는 증가하는 우려 사항이다. 이는 Kubernetes가 강력한 기능을 제공함에도 불구하고, 기본 보안 설정이 견고하지 않고 사용자 정의 가능성이 오작동으로 이어질 수 있음을 시사한다. 따라서 조직은 지속적인 모니터링, 권한 조정, 취약점 스캔을 위한 전문 기술과 자동화된 도구에 투자하여 컨테이너화의 이점을 완전히 실현하면서도 위험을 완화해야 한다.  </p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0002.png" alt="" /></p>

<blockquote>
  <p>클라우드 환경에서 서버리스 함수, 컨테이너, 그리고 Kubernetes 클러스터가 상호작용하는 모습을 보여주는 아키텍처 다이어그램.(출처 - <a href="https://www.researchgate.net/figure/In-the-test-platform-serverless-functions-are-deployed-in-a-Kubernetes-cluster-using-the_fig1_348914380">ResearchGate</a>)</p>
</blockquote>

<p><strong>2.2 AI 기반 개발의 가속화</strong>
인공지능(AI)은 백엔드 개발 효율성을 높이는 데 통합되고 있으며, GitHub Copilot, Cursor, ChaGPT Codex, Claude Code 와 같은 AI 코드 어시스턴트, OtterTune과 같은 AI 기반 데이터베이스 쿼리 최적화 도구, Postman AI와 같은 자동화된 API 문서화 도구가 활용된다. AI는 개발자를 대체하기보다는 반복적인 작업을 자동화하여 개발자의 업무를 용이하게 하는 데 기여한다. AI 알고리즘은 마이크로서비스의 확장성과 성능을 최적화하여 추가 하드웨어 및 인프라 비용을 절감할 수 있다. AI는 예측 분석 및 실시간 의사결정을 통해 애플리케이션 성능을 향상시키며, 서버리스 환경에서도 자동화와 결합되어 효율성을 증대시킨다. 2024년에는 콘텐츠 생성 및 통찰력 제공을 넘어 실제 행동을 수행할 수 있는 ‘Agentic AI’의 등장은 매우 핫하였고 2025년은 그러한 관심과 노력의 결실들이 대거 쏟아지고 있다.  </p>

<p>AI의 역할은 백엔드 개발에서 단순한 지원을 넘어 소프트웨어 전달 수명 주기 전반에 걸쳐 자동화 및 자율적 의사결정에 적극적으로 참여하는 방향으로 진화하고 있다. 초기에는 AI가 코드 지원 및 API 문서화와 같은 도구로 인식되었지만 , 이제는 마이크로서비스를 최적화하고 , 예측 알고리즘을 통해 애플리케이션 성능을 향상시키며 , 심지어 ‘Agentic AI’로서 행동을 수행하는 단계에 이르렀다. 이러한 발전은 AI가 백엔드 시스템 내에서 자율 최적화 및 운영이 가능한 내장된 능동적 구성 요소가 되고 있음을 시사한다. 따라서 <strong>백엔드 개발자들은 AI 에이전트와 통합되거나 잠재적으로 AI 에이전트에 의해 관리되는 시스템을 설계하는 방법을 이해해야 하며, 이는 AI 모델 통합 및 윤리적 AI 고려 사항에 대한 새로운 기술을 요구한다.</strong></p>

<p>AI가 백엔드 시스템 전반에 걸쳐 통합이 증가함에 따라, 효과적인 AI 활용을 위한 기본 요구 사항으로서 데이터 품질 및 통합 데이터 제어에 대한 더 큰 초점이 필요하다. AI는 “올바른 데이터가 없으면 지능형 애플리케이션으로서의 가치를 얻을 수 없다”고 명시하며 , 데이터에 대한 “통합 제어”의 필요성을 강조한다. 이는 백엔드 시스템에서 AI로부터 얻는 가치(예: 최적화, 지능형 애플리케이션)가 AI 모델에 공급되는 데이터의 품질, 접근성 및 거버넌스에 직접적으로 비례한다는 점을 강조한다. 따라서 백엔드 개발자와 데이터 아키텍트들은 강력한 데이터 파이프라인, 실시간 데이터 처리 능력 , 그리고 강력한 데이터 거버넌스를 우선시하여 AI 모델이 신뢰할 수 있고 잘 관리된 데이터로 작동하도록 해야 한다.  </p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0003.png" alt="" /></p>
<blockquote>
  <p>The AI Code Editor 를 표방하는 <strong>Cursor</strong>(출처 - <a href="https://www.cursor.com/">커서 공식 사이트</a>)</p>
</blockquote>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0004.png" alt="" /></p>
<blockquote>
  <p>백엔드 기술에 특화를 표방한 VSC 확장 프로그램 <strong>Workik</strong>(출처 - <a href="https://workik.com/">Workik. 공식 사이트</a>)</p>
</blockquote>

<p><strong>2.3 마이크로서비스 및 컨테이너화의 진화</strong>
마이크로서비스 아키텍처는 <code class="language-plaintext highlighter-rouge">DevOps</code> 엔지니어에게 복잡한 분산 시스템 관리를 용이하게 하여 확장 가능하고 효율적인 애플리케이션 구축에 집중할 수 있도록 돕는다. 이는 애자일 방법론과 결합하여 협업, 유연성, 배포 속도를 향상시키며, 각 팀이 독립적으로 작업할 수 있게 한다. 마이크로서비스가 증가함에 따라 서비스 메시는 서비스 간 통신, 관찰성, 보안, 트래픽 관리 등을 위한 전용 인프라 계층을 제공하여 복잡성을 완화한다. <code class="language-plaintext highlighter-rouge">GitOps</code>는 Git을 단일 진실 공급원(SSOT)으로 사용하여 인프라 및 애플리케이션을 선언적으로 관리함으로써 DevOps 관행을 혁신하고, 배포 프로세스를 투명하고 자동화하며 협업적으로 만든다.  </p>

<p>서비스 메시와 GitOps에 의해 지원되는 마이크로서비스의 진화는 분산 시스템 관리에서 추상화 및 자동화의 증가로 이어지고 있으며, 개발자의 초점을 저수준 오케스트레이션에서 비즈니스 로직 및 애플리케이션 설계와 같은 고수준 관심사로 이동시킨다. 서비스 메시는 “서비스 간 통신을 촉진하는 전용 인프라 계층을 제공하여 이러한 과제를 완화”하고 “서비스 검색, 장애 복구, 로드 밸런싱, 메트릭”을 처리하여  개발자들이 “핵심 비즈니스 생산성 향상에 집중”할 수 있도록 한다. GitOps는 “모든 배포를 자동화하고 기존 인프라를 효율적으로 관리”한다. 이는 마이크로서비스에 내재된 운영 복잡성이 전용 도구와 방법론에 의해 점차 관리되고 있음을 나타내며, 개발자들을 수동 구성 및 문제 해결에서 해방시킨다. 이는 “플랫폼 엔지니어링” 으로의 강력한 추진을 의미하며, 내부 플랫폼이 “황금 경로(golden paths)”와 개발자 친화적인 인터페이스를 제공하여 개발자 생산성을 더욱 향상시키고 시장 출시 시간을 단축한다. 결국 결론은 자동화와 단일화되고 보다 섬세하게 가속화된 것들이 개발의 속도를 더욱 가속화시킨다고 볼 수 있다. </p>

<p>그러나 모듈성과 확장성의 이점에도 불구하고, 분산 시스템의 내재된 복잡성, 특히 데이터 일관성 및 연쇄적 장애와 관련하여 여전히 중요한 아키텍처적 과제로 남아있으며, 개발자들이 적극적으로 해결해야 한다. 마이크로서비스 아키텍처에서 “복잡성은 개별 기능의 상호 연결로 이동”하며, “아키텍처적 과제에는 비동기 통신, 연쇄적 장애, 데이터 일관성 문제, 서비스 검색 및 인증 처리가 포함된다”고 명시되어 있다. <strong>서비스 메시가 통신 및 검색에 도움이 되지만, 독립적인 서비스 간 데이터 일관성을 보장하고 장애의 파급 효과(연쇄적 장애)를 관리하는 문제는 완전히 추상화되지 않는다.</strong> 이는 고급 도구가 있더라도 백엔드 개발자들은 특히 중요한 데이터를 다룰 때 탄력적이고 일관성 있으며 내결함성 있는 마이크로서비스를 설계하기 위해 분산 시스템 원리에 대한 깊은 이론적 이해가 필요하다는 것을 의미한다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0005.png" alt="" /></p>
<blockquote>
  <p>GitOps 프로세스 도식(출처 - <a href="https://saramin.github.io/2020-05-01-k8s-cicd/">사람인 기술 블로그</a>)</p>
</blockquote>

<p><strong>2.4 API 경제의 확장과 보안강화</strong>
API는 거의 모든 소프트웨어 개발의 핵심이며, 사용자 경험, 파트너 생태계, 내부 아키텍처를 지원한다. <code class="language-plaintext highlighter-rouge">RESTful API</code>가 여전히 지배적이지만, <code class="language-plaintext highlighter-rouge">GraphQL</code>은 유연한 데이터 페칭과 단일 요청으로 여러 API 호출을 줄이는 이점 때문에 복잡한 애플리케이션에서 대안으로 성장하고 있다. GraphQL은 필요한 데이터만 가져오고 여러 API 호출을 단일 요청으로 줄여 모바일 및 마이크로서비스에 적합하다. <code class="language-plaintext highlighter-rouge">gRPC</code>는 마이크로서비스 환경에서 고속 통신을 지원한다.  </p>

<p>사이버 위협이 정교해짐에 따라 <strong><a href="https://cloud.google.com/learn/what-is-zero-trust?hl=ko">Zero Trust 보안 모델</a></strong>이 백엔드 인증 및 API 보안에 필수적이다. 2024년에는 API에 대한 공격이 49% 급증했으며, 비효율적인 인증/인가가 주요 원인이다. API의 보편성과 증가하는 공격 표면은 반응적 보안 조치에서 개발 수명 주기 전반에 걸쳐 통합된 사전 예방적 “보안 설계” 원칙으로의 근본적인 전환을 요구한다. API는 “대부분의 소프트웨어 개발의 핵심”이며 , 2023년 1분기부터 2024년 1분기 사이에 애플리케이션 및 API에 대한 웹 공격이 49% 급증했으며, “비효율적인 API 인증 및 권한 부여”가 주요 원인이다. 이러한 직접적인 상관관계는 API가 더 이상 단순한 통합 지점이 아니라 중요한 보안 경계임을 의미한다. 따라서 “백엔드 개발에서 보안은 더 이상 부차적인 고려 사항이 아니라 핵심 요구 사항”이다. 개발자들은 Zero Trust 보안 모델 을 채택하고, CI/CD 파이프라인에 “자동화된 보안 테스트” 를 통합하며, 초기 설계 단계부터 강력한 인증/권한 부여 메커니즘 을 우선시해야 한다.  </p>

<p>이러한 흐름에서 API 프로토콜(REST, GraphQL, gRPC)의 다양화는 특정 사용 사례에 대한 최적화된 데이터 가져오기 및 고성능 통신 요구에 의해 주도되는 아키텍처 성숙도의 증가를 반영하지만, 각 설명이 이렇게 길어지는 만큼 당연히 실제 API 관리의 복잡성도 가중시킨다. 따라서 GraphQL은 “정확히 필요한 데이터”를 가져오고 “여러 API 호출을 줄여”  “마이크로서비스 및 모바일 애플리케이션에 더 적합”하다. gRPC는 “마이크로서비스 환경에서 고속 통신”을 지원한다. 이는 API 프로토콜 선택이 단순한 선호를 넘어 성능 및 데이터 유연성 요구 사항에 의해 주도되는 미묘한 결정이 되고 있음을 나타낸다. <strong>백엔드 개발자들은 여러 API 패러다임에 능숙하고 각 패러다임의 장단점을 이해하며, 멀티 클라우드 환경에서 다양한 프로토콜을 처리할 수 있는 “클라우드 중립적”이고 “범용 API 관리 솔루션” 을 설계할 수 있어야 한다.</strong></p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0006.png" alt="" /></p>
<blockquote>
  <p>각 통신 방식에 대한 요약 이미지(출처 - <a href="https://blog.stackademic.com/choosing-between-grpc-rest-and-graphql-for-designing-and-implementing-apis-25df124848dc/">Ian Kiprono</a>)</p>
</blockquote>

<p><strong>2.5 데이터 아키텍처의 현대화</strong>
2024년 데이터 아키텍처는 실시간 데이터 처리를 위한 인프라 현대화와 AI/ML 기능 활성화에 중점을 둔다. IoT 장치 및 소셜 미디어 피드와 같은 스트리밍 데이터 소스의 증가는 실시간 분석을 통한 효율적인 통찰력 확보를 요구한다. 분산 데이터 아키텍처는 실시간 데이터 처리, 데이터 접근 시간 단축, 중복성 제공, 유연성 증대 등의 이점을 제공한다. Oracle, SQL Server, IBM Db2와 같은 데이터베이스는 AI 기반 자동 인덱싱 및 지능형 워크로드 관리 기능을 포함하고 있다. AI는 데이터베이스 관리의 일상적인 작업을 자동화하고 데이터 분석 기능을 향상시킨다. 데이터 품질 문제가 기술 예산의 상당 부분을 차지하므로, 분산 아키텍처 구현 시 데이터 거버넌스에 신중한 접근이 필요하다.  </p>

<p>실시간 데이터 요구 사항과 AI 통합의 융합은 현대 데이터 아키텍처의 성공적인 구현과 실행 가능한 통찰력을 위해 강력한 데이터 품질과 책임 있는 데이터 거버넌스를 중요하게 만든다. 보고서들은 “운영 실시간 분석을 늘리고 AI 및 ML 기능을 활성화하기 위해 데이터 아키텍처를 현대화”할 필요성을 강조한다. AI는 “자율 데이터베이스 운영” 및 “향상된 데이터 분석”을 통해 데이터베이스 관리를 혁신하고 있다. 그러나 “데이터에 대한 신뢰가 없으면 어떤 분산 아키텍처도 ‘감탄하고 분석할 수는 있지만 실행할 수 없는’ 귀중한 보석에 불과할 것”이라는 경고가 반복된다. 이는 고급 분석 및 AI 기능이 낮은 데이터 품질에 의해 병목 현상을 겪는다는 중요한 의존성을 강조한다. 따라서 백엔드 개발자와 데이터 아키텍트들은 “책임 있는 데이터 거버넌스” 와 강력한 데이터 파이프라인을 우선시하여 이러한 고급 시스템에 공급되는 데이터가 신뢰할 수 있고 잘 관리되도록 해야 한다</p>

<p><strong>2.6 엣지 컴퓨팅 및 분산 시스템의 중요성 증대</strong>
5G 및 IoT의 부상으로 인해 엣지 컴퓨팅은 백엔드 서비스를 사용자에게 더 가깝게 실행하여 속도와 효율성을 향상시키는 데 필수적이다. Cloudflare, Akamai와 같은 CDN 제공업체는 엣지 컴퓨팅 기능을 확장하고 있으며, FaunaDB, Cloudflare D1과 같은 데이터베이스는 전역 분산 스토리지를 제공한다. 실시간 애플리케이션(게임, AR/VR, IoT)이 엣지 컴퓨팅의 가장 큰 이점을 얻는다. 분산 시스템 아키텍처 중 셀 기반 아키텍처는 복원력을 강조하고 “블래스트 반경”을 최소화하여 시스템의 한 부분이 실패하더라도 다른 부분에 미치는 영향을 제한한다.  </p>

<p>5G 및 IoT에 의해 촉진되는 초저지연 및 향상된 복원력에 대한 요구는 백엔드 서비스가 설계되고 배포되는 방식을 근본적으로 변화시키며, 컴퓨팅과 데이터를 사용자에게 더 가까운 엣지로 이동시킨다. 엣지 컴퓨팅은 백엔드 서비스를 “사용자에게 더 가깝게 실행하여 속도와 효율성을 향상”시키며 , 특히 “실시간 애플리케이션(게임, AR/VR, IoT)”에 중요하다. 이는 밀리초가 중요한 5G 및 IoT의 요구 사항에 대한 직접적인 응답이다. 동시에 “셀 기반 아키텍처는 복원력과 블래스트 반경 최소화를 강조하며 주목받고 있다”. 이는 중앙 집중식 모놀리식 배포에서 로컬 처리 및 데이터 저장이 핵심인 고도로 분산되고 내결함성 있는 시스템으로의 전략적 전환을 나타낸다. 따라서 백엔드 개발자들은 “엣지 환경을 위한 API 및 데이터 저장 방식”을 재고하고 , 네트워크 지연, 간헐적 연결, 로컬 의사결정을 고려하는 아키텍처 패턴을 수용해야 한다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0007.png" alt="" /></p>
<blockquote>
  <p>Edge Computing 구조도 (출처 - <a href="https://maddevs.io/blog/everything-you-need-to-know-about-edge-computing/">“Everything You Need to Know About Edge Computing” - Roman Panarin</a>)</p>
</blockquote>

<p><strong>2.7 새로운 프로그래밍 언어 및 프레임워크의 부상</strong>
Rust는 Node.js와 Go를 넘어 성능이 중요한 백엔드 시스템에서 선호되는 언어로 부상하고 있다. Rust는 메모리 안전성, Node.js 및 Go보다 빠른 성능, 보안성 등의 이점을 제공한다. Axum 및 Actix와 같은 Rust 백엔드 프레임워크의 성장이 예상된다. Python, JavaScript (Node.js), Java, PHP, Golang은 여전히 주요 백엔드 언어로 사용되고 있으며 , Django, Spring Boot, Laravel, Express.js 등 다양한 프레임워크가 개발 효율성, 보안, 확장성을 제공한다.  </p>

<p>기존 언어와 프레임워크가 백엔드 환경에서 여전히 지배적이지만, Rust의 인기가 높아지는 것은 특히 성능에 민감하고 안전한 인프라 구성 요소에 대해 고성능과 메모리 안전성을 모두 제공하는 언어에 대한 업계의 수요가 증가하고 있음을 의미한다. Python, Node.js, Java는 가독성, 광범위한 생태계 및 다용성으로 인해 주요 백엔드 언어로 나열되어 있다. 그러나 Rust는 “메모리 안전성”, “성능”, “보안” 덕분에 “성능에 민감한 백엔드 시스템을 위한 언어”로 빠르게 자리 잡고 있다. 이는 모든 것을 대체하는 추세라기보다는, 기존의 가비지 컬렉션 언어가 오버헤드를 유발할 수 있는 고성능, 보안 및 리소스 효율적인 시스템에 대한 특수화된 요구를 나타낸다. 따라서 조직은 단일 언어 스택을 고수하기보다는 특정 비기능적 요구 사항(예: 지연 시간, 보안, 리소스 사용량)에 따라 최적의 도구를 선택하는 다중 언어 프로그래밍(polyglot programming)으로 나아가고 있다. 이는 개발자들이 특수 작업을 위해 새로운 언어를 배우고 채택하는 데 개방적이어야 함을 의미한다.</p>

<p>물론 한국의 상황을 고려한다면, 이러한 가치가 중요시 되는 것이 국제적 트렌드는 되지만, 그렇지 않은 것도 사실이다. 하지만 과거 대비 Java 스타트 사업 및 글로벌 서비스가 확대되는 상황에서 이러한 대안의 등장은 비즈니스 특성에 따라 따라가거나 대비되어야 할 영역이리라 생각된다. 특히나 AI 서비스를 비롯하여 점차 서비스를 위한 대용량 처리가 더욱 강조되고, AI 확산에 따라 생겨나는 무수한 보안 공격을 비롯한 AI 기반의 크롤링 수법의 진화 등은 보다 안전하고, 보다 성능이 뛰어난 백엔드 인프라의 중요성을 더욱 부각시킨다고 볼 수 있다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0008.png" alt="" /></p>
<blockquote>
  <p>Rust Backend (출처 - <a href="https://www.youtube.com/watch?v=Rnw-x21kGaA">“How to Build A Rust Backend with Actix Web and SurrealDB (Full Tutorial)” - White Sponge</a>)</p>
</blockquote>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0009.png" alt="" /></p>
<blockquote>
  <p>2023년 stack overflow 조사로 84.66% 로 가장 인기 있는 언어로 나타났다.  (출처 - <a href="https://strapi.io/blog/rust-vs-other-programming-languages-what-sets-rust-apart">Munir Adavize Abdullahi</a>)</p>
</blockquote>

<h2 id="3-미래를-위한-백엔드-개발자의-핵심-역량">3. 미래를 위한 백엔드 개발자의 핵심 역량</h2>

<p>변화하는 백엔드 시장에서 개발자들이 경쟁력을 유지하고 성장하기 위해서는 다음과 같은 핵심 역량과 전략을 갖춰야 한다.</p>

<ul>
  <li><strong>아키텍처 및 설계 역량 강화</strong>: 수평적 확장성(stateless services, load balancers, sharding), 마이크로서비스(loosely coupled, message queues, API gateways), 이벤트 기반 아키텍처(asynchronous processing, event sourcing)에 대한 깊은 이해와 설계 능력이 필수적이다.  </li>
  <li><strong>클라우드 및 컨테이너 기술 숙달</strong>: AWS, Azure, GCP 등 주요 클라우드 플랫폼의 서비스와 Docker, Kubernetes와 같은 컨테이너 및 오케스트레이션 도구 활용 능력이 핵심이다. Terraform, CloudFormation, Pulumi와 같은 인프라 자동화 도구를 통해 환경을 코드로 정의하고 관리하는 능력이 요구된다.  </li>
  <li><strong>데이터 관리 및 최적화</strong>: SQL (MySQL, PostgreSQL) 및 NoSQL (MongoDB, DynamoDB) 데이터베이스에 대한 이해와 함께, 캐싱 (Redis, Memcached), 읽기 복제본, 데이터 샤딩을 통한 성능 최적화 능력이 중요하다. AI 기반 데이터베이스 관리 및 쿼리 최적화 도구의 활용도 고려해야 한다.  </li>
  <li><strong>보안 의식 및 실천</strong>: API 보안(RBAC, OAuth 2.0, TLS, JWT), 데이터 암호화(전송 및 저장), 취약점 관리(정기 감사 및 침투 테스트), Zero Trust 모델 구현이 필수적이다. 보안은 더 이상 부차적인 고려사항이 아니라 핵심 요구사항이며, 개발 초기 단계부터 보안을 통합하는 DevSecOps 접근 방식이 중요해진다.  </li>
  <li><strong>자동화 및 운영 효율성</strong>: CI/CD 파이프라인을 통한 테스트 및 배포 자동화, 인프라 자동화 (Infrastructure as Code), GitOps (Git 기반 인프라 관리)를 통한 운영 효율성 향상 능력이 요구된다. DevOps는 대규모 시스템 관리에 중요한 역할을 하며, 자동 스케일링 및 모니터링 시스템 구축이 포함된다.  </li>
  <li><strong>AI/ML 도구 활용 및 이해</strong>: AI 코드 어시스턴트, AI 기반 쿼리 최적화 도구 등 AI/ML 도구를 개발 워크플로우에 통합하고, AI 모델과의 API 연동 방식을 이해하는 것이 중요하다. AI는 개발자의 생산성을 높이고 반복 작업을 자동화하는 데 기여한다.  </li>
  <li><strong>지속적인 학습 및 적응</strong>: 빠르게 변화하는 기술 환경에 대한 유연한 대응과 지속적인 학습이 가장 중요하다. 새로운 언어, 프레임워크, 아키텍처 패턴, 보안 위협에 대한 최신 정보를 습득해야 한다. 기술 스택의 다양화와 복잡성 증가는 끊임없는 자기 계발을 요구한다.  </li>
</ul>

<h2 id="마무리하며--변화는-기회다">마무리하며 : 변화는 기회다</h2>
<p>지난 5월 13일 마이크로소프트는 인공지능의 적극적인 도입으로 엔지니어링 개발자, 회사 인력의 3%에 해당하는 6800명을 감원하였다. 이러한 모습들은 개발자의 ‘용도’와 ‘필요’가 이제 변화하고 있다는 사실을 이야기 한다. AI 를 통해 지능적으로 바뀌는 온갖 보안문제, 그에 비해 발생하는 엄청난 효율성과 자동화 영역에 대한 AI의 개발자 대체 가능성 등, 이 글에서 언급하지 않았지만 LLM 을 필두로 발생한 AI의 파동은 더욱 피부 속을 파고들 정도로 체감되기 시작했다.</p>

<p>그러한 상황에서 백엔드 개발자, 아울러 개발자라는 직군은 다른 포지셔닝이 필요하게 되었으며, 그러한 포지셔닝, 가치의 재정립은 이러한 트랜드를 이해하며, 숨쉬듯 AI 를 자신의 또 다른 뇌, 또 다른 자아처럼 다룰 수 있어야 함을 요구한다. 그런 상황에서 구체적인 역할이, 명료하게 자리 잡아야만 AI가 사람을 대체할 수 있어지는 이 시대에서의 개발자의 역할을 할 수 있으리라 보인다.</p>

<p>이러한 변화에 발맞춰 분산 시스템 설계, 클라우드 및 컨테이너 기술, 데이터 관리, 그리고 보안에 대한 깊은 이해를 갖춰야 한다. 또한, AI 도구를 적극적으로 활용하고 DevOps 및 GitOps 원칙을 내재화하여 효율성을 극대화해야 한다. 백엔드 시스템의 복잡성과 규모가 증가함에 따라 자동화는 선택이 아닌 필수 전략이 되고 있으며, 데이터 품질과 거버넌스는 AI 기반 시스템의 성공을 위한 필수적인 기반이 된다. 궁극적으로, 끊임없는 학습과 적응력은 이 역동적인 환경에서 성공적인 커리어를 위한 핵심 열쇠가 될 것이다. 이러한 것들을 의미는 무엇인가? <strong>결국 AI 를 진두지휘하는 커맨더적 개발자의 대두가 반드시 필요하며, 그러한 백엔드 개발자가 되지 못한다는 것은 더 빠른 시장에서의 퇴출 내지는 시장에서의 퇴보를 의미할 것이다.</strong></p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0010.png" alt="" /></p>
<blockquote>
  <p>이미지 프롬프팅 (출처 - 제미니 2.5 Flash)</p>
</blockquote>

<h2 id="진짜-마무리-이-글을-쓰기-위한-ai와-나의-노력">진짜 마무리, 이 글을 쓰기 위한 AI와 나의 노력</h2>
<p>구글 IO 2025 에서 사실 많은 사람들은 Flow 나 Whisk, veo3 등에 열광 했을지 모르겠다. 하지만 내가 가장 주목한 건 사실 다른 무엇보다 제미니 2.5 였다. 제미니는 2.0 부터 점차 두각을 드러내기 시작했다. 데이터의 양이나 플랫폼의 수준을 생각하면 사실 ChatGPT 나 Claude 가 사실 범접할 수준이 아니기에, 그 시작은 Google이 아닐지 모르지만, 그 끝은 Google 이 아닐까? 라는 생각을 했다.</p>

<p>그리고 그 결과, 나의 생각은 역시나 틀리지 않았다. 구글은 처음에는 후발 주자와 같은 미숙함이 보였지만, 데이터를 어떻게 다루면 되는지를 알며, 무엇보다 그러한 데이터의 정제를 위한 AI 적 사고가 어떻게 되면 되는지를 여실없이 보여주었다(….)</p>

<p>대충이라도 재어 본 결과, 위의 글의 살을 거의 완성시키는데 걸린 시간은 고작 10분이었고, 읽어보고 개선하고 하는데 걸린시간은 30분. 전체 글을 다 쓰는데 현재 3시간 남짓이 걸렸다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0011.png" alt="" /></p>
<blockquote>
  <p>최초 연구 요청</p>
</blockquote>

<p>물론, 첨삭이 필요하긴 했다. 하지만 나의 요청에 제미니는 말 그대로 연구의 목적과 이를 위한 사고를 보여주었고, 그 사고의 과정의 기법은 매우 체계적일 뿐 아니라 ‘자연어’ 스러웠다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0012.png" alt="" /></p>
<blockquote>
  <p>사과정의 기록이 보여주는 구글의 AI 철학은 인문학과 과학, 그 어딘가를 논하지 않을 수 없다고 생각이 든다.</p>
</blockquote>

<p>AI는 많이 두려운 존재인 것은 사실이다. 생각해보면 AI의 등장은 더 이상 ‘어중간한 존재’들이 필요없다는 식의 매우 냉랭한 말을 세상이 더더욱 말하고 있는 것이란 생각이 든다. No Code Low Code 라는 키워드가 흥할 때부터 이러한 낌새는 보였다. 점점 발전하고 감싸지면서 쉬워지는 프레임워크들, 그것을 1 나노초라도 더 빨리 구동하기 위해 구현되고 있는 하드웨어들, 이러한 상황 속에서 어중간한 실력과 어중간한 안목을 가진 개발자들, 아니 어쩌면 그러한 사람들의 소멸이나 사형선고가 아닐까 하는 무서운 상상도 든다.</p>

<p>하지만, 그런 과정 속에서도 나는 이런 생각을 하게 된다. 제미니의 이러한 수준은 사진에서도 다소 나오지만, 단순한 하드웨어나 데이터셋의 문제가 아니라는 점을 느끼게 만든다. CoT 프롬프팅, 지식 그래프 및 상징적 AI, 뇌신경-상징적 AI 패턴, 검색 증강 생성을 비롯한 고도의 인간의 고차원적 사고 패턴을 기계가 이용 가능하도록 형태를 변화 시킨것들의 접목된 결과가 이것이 아닐까?</p>

<p>인간만큼 뛰어나지는 것은 무엇 때문인가? 그것은 바로 인간의 고도화된 사고, 논리, 철학, 그러한 기준들의 존재가 있고 그것이 확률성과 붙었을 때, 비로소 LLM 이라는 형태로 인간의 확률성을 나타내는 것이 되고, AI라는 도구화 되어 확실한 두각을 내 비치는게 아닐까?</p>

<p>젠슨황의 말 처럼, 이젠 진짜 인문사회학과 과학, 그 사이 어딘가에서 창조적 가치, 그리고 인간만이 가능한 고등한 더 넓거나 더 고도의 사고체계를 구축하여, 물질세계에 구현해내는 작업들을 해낸다면 그것이 곧 AI의 성능 향상으로 끌어올리는게 아닐까 생각이 들고, 그러한 작업이 이제 인간의 업이 되는게 아닌가 조심스레 예상해본다. 그리고 그런 상황에서 개발자들은 단순하게 만든다의 의미에서 ‘가치’를 부여한다는 의미를 보다 되새길 수 있는 테크니션 리더가 되어야 하는게 아닌가 생각한다.</p>

<h2 id="참고-문헌">참고 문헌</h2>
<ol>
  <li>8 Trends In Backend Development You Can’t Ignore In 2025, <a href="https://arunangshudas.com/blog/8-trends-in-backend-development-you-cant-ignore-in-2025/">https://arunangshudas.com/blog/8-trends-in-backend-development-you-cant-ignore-in-2025/</a></li>
  <li>Serverless Computing Market Size &amp; Trends, Growth Analysis …, <a href="https://www.marketsandmarkets.com/Market-Reports/serverless-computing-market-217021547.html">https://www.marketsandmarkets.com/Market-Reports/serverless-computing-market-217021547.html</a></li>
  <li>Latest Microservices Architecture Trends in 2024 - Cloud Destinations, <a href="https://clouddestinations.com/blog/evolution-of-microservices-architecture.html">https://clouddestinations.com/blog/evolution-of-microservices-architecture.html</a></li>
  <li>How GitOps is Revolutionizing DevOps Practices in 2024 …, <a href="https://coffeebeans.io/blogs/how-gitops-is-revolutionizing-devops-practices-in-2024">https://coffeebeans.io/blogs/how-gitops-is-revolutionizing-devops-practices-in-2024</a></li>
  <li>Top K8s Workload Trends in the 2024 Kubernetes Benchmark …, <a href="https://cloudnativenow.com/features/top-k8s-workload-trends-in-the-2024-kubernetes-benchmark-report/">https://cloudnativenow.com/features/top-k8s-workload-trends-in-the-2024-kubernetes-benchmark-report/</a></li>
  <li>Docker and Containerization Trends in 2024 - Slashdev, <a href="https://slashdev.io/-docker-and-containerization-trends-in-2024">https://slashdev.io/-docker-and-containerization-trends-in-2024</a></li>
  <li>The Best Backend Frameworks for Speed, Scalability, and Power in 2025 - Fively, <a href="https://5ly.co/blog/best-backend-frameworks/">https://5ly.co/blog/best-backend-frameworks/</a></li>
  <li>Key Trends from 2024: Cell-Based Architecture, DORA &amp; SPACE …, <a href="https://www.infoq.com/podcasts/2024-year-review/">https://www.infoq.com/podcasts/2024-year-review/</a></li>
  <li>AI and event driven architecture – the perfect partnership to make …, <a href="https://vmblog.com/archive/2024/02/02/ai-and-event-driven-architecture-the-perfect-partnership-to-make-the-connected-enterprise-a-reality-2024.aspx">https://vmblog.com/archive/2024/02/02/ai-and-event-driven-architecture-the-perfect-partnership-to-make-the-connected-enterprise-a-reality-2024.aspx</a></li>
  <li>Data Architecture Trends in 2024 - DATAVERSITY, <a href="https://www.dataversity.net/data-architecture-trends-in-2024/">https://www.dataversity.net/data-architecture-trends-in-2024/</a></li>
  <li>A Stroll Through API Economy Trends - Nordic APIs, <a href="https://nordicapis.com/a-stroll-through-api-economy-trends/">https://nordicapis.com/a-stroll-through-api-economy-trends/</a></li>
  <li>Top API Trends that will Change the World Beyond 2025 - ImpactQA, <a href="https://www.impactqa.com/infographics/top-api-trends-that-will-change-the-world-beyond/">https://www.impactqa.com/infographics/top-api-trends-that-will-change-the-world-beyond/</a></li>
  <li>7 Best Practices for API Security in 2024 - GeeksforGeeks, <a href="https://www.geeksforgeeks.org/api-security-best-practices/">https://www.geeksforgeeks.org/api-security-best-practices/</a></li>
  <li>Database trends of 2025: Rankings, new technologies and changes in the industry, <a href="https://www.baremon.eu/database-trends-of-2025/">https://www.baremon.eu/database-trends-of-2025/</a></li>
  <li>Database Trends and Innovations: A Comprehensive Outlook for 2025 - Rapydo, <a href="https://www.rapydo.io/blog/database-trends-and-innovations-a-comprehensive-outlook-for-2025">https://www.rapydo.io/blog/database-trends-and-innovations-a-comprehensive-outlook-for-2025</a></li>
  <li>Top 11 Backend Programming Languages in 2025 - Webandcrafts, <a href="https://webandcrafts.com/blog/backend-languages">https://webandcrafts.com/blog/backend-languages</a></li>
  <li>Most Popular Backend Frameworks: Top 10 in 2025 - Netguru, <a href="https://www.netguru.com/blog/backend-frameworks">https://www.netguru.com/blog/backend-frameworks</a></li>
  <li>7 Essential Tips For Scalable Backend Architecture, <a href="https://blog.arunangshudas.com/7-essential-tips-for-scalable-backend-architecture/">https://blog.arunangshudas.com/7-essential-tips-for-scalable-backend-architecture/</a></li>
  <li>What Is Event-Driven Architecture? Comprehensive Guide 2024 …, <a href="https://estuary.dev/blog/event-driven-architecture/">https://estuary.dev/blog/event-driven-architecture/</a></li>
  <li>How to Become a Backend Developer in 2025 - GeeksforGeeks, <a href="https://www.geeksforgeeks.org/back-end-developer-roadmap/">https://www.geeksforgeeks.org/back-end-developer-roadmap/</a></li>
  <li>2024 Cloud Service Providers: Comparison &amp; Guide (Top Choices) - TechAhead, <a href="https://www.techaheadcorp.com/blog/2024-cloud-service-providers-comparison-guide-top-choices/">https://www.techaheadcorp.com/blog/2024-cloud-service-providers-comparison-guide-top-choices/</a></li>
  <li>Key Skills for Successful DevOps Engineers in 2024 - Creole Studios, <a href="https://www.creolestudios.com/key-skills-for-successful-devops-engineer-2024/">https://www.creolestudios.com/key-skills-for-successful-devops-engineer-2024/</a></li>
  <li>2024 Cloud Computing Spending Trends: AWS, Azure, GCP Insights - DEV Community, <a href="https://dev.to/ssojet/2024-cloud-computing-spending-trends-aws-azure-gcp-insights-5fg1">https://dev.to/ssojet/2024-cloud-computing-spending-trends-aws-azure-gcp-insights-5fg1</a></li>
  <li>Caching Best Practices: Boost Performance in 2024 - Eyer.ai, <a href="https://www.eyer.ai/blog/caching-best-practices-boost-performance-in-2024/">https://www.eyer.ai/blog/caching-best-practices-boost-performance-in-2024/</a></li>
  <li>Top 8 Skills Required in DevOps Engineer for 2024 - Softqube Technologies, <a href="https://www.softqubes.com/blog/top-8-skills-required-in-devops-engineer-for-2024/">https://www.softqubes.com/blog/top-8-skills-required-in-devops-engineer-for-2024/</a></li>
  <li>Best Certifications for Backend Developers in 2025 (Ranked) - Teal, <a href="https://www.tealhq.com/certifications/backend-developer">https://www.tealhq.com/certifications/backend-developer</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="Container" /><category term="Docker" /><summary type="html"><![CDATA[1. 백엔드, 왜 지금 이 변화를 주목하려고 하는가? 백엔드는 더 이상 단순히 데이터를 처리하고 저장하는 ‘뒷단’이 아니다. 서비스의 확장성, 안정성, 그리고 궁극적으로 사용자 경험의 질을 결정하는 핵심 두뇌이자 심장부이다. 기업들은 갈수록 더 빠르고, 더 유연하며, 더 비용 효율적인 시스템을 요구하고 있으며, 이러한 요구는 백엔드 아키텍처와 기술 스택의 끊임없는 진화를 촉진한다.]]></summary></entry><entry><title type="html">docker는 흔들리고 있을까?</title><link href="http://localhost:4000/backend/2025/05/06/alternative-for-docker.html" rel="alternate" type="text/html" title="docker는 흔들리고 있을까?" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/06/alternative-for-docker</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/06/alternative-for-docker.html"><![CDATA[<h2 id="도커-왕좌를-지키지-못하는-이유-컨테이너-생태계의-지각변동">도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동</h2>

<p><img src="/assets/images/posts/2025-05/docker-wallpaper.jpeg" alt="" /></p>

<p>수년간 <strong>컨테이너 생태계의 중심에는 도커가 있었다</strong>. 사실 도커는 ‘대명사’가 되긴 했지만 원래 그 기술의 근간은 ‘컨테이너’라는 기술이다.</p>

<p>리눅스 기반 OS 에서 제공하는 기술로 <strong>컨테이너</strong>는 시스템의 나머지 부분으로부터 격리된 하나 이상의 프로세스 집합을 의미한다.</p>

<p>이러한 프로세스를 실행하는 데 필요한 모든 파일과 필수 라이브러리, 종속성이 개별 이미지 내에 함께 패키징된다. 한 마디로 정리하면, Host 에 해당하는 영역에서 공통적인 걸 가져오고, 실제 독립적인 시스템 구현을 위해 필요한 부분은 ‘레이어’ 라는 이름으로 별도로 이미지 내부에 장착시켜서 호스트와는 별개의 시스템이 마치 구동되는 듯 보이게 만들어준다.</p>

<p>컨테이너는 가상 머신과 달리 <strong>가상 머신보다 적은 리소스를 사용</strong>하면서도 애플리케이션 격리를 유지할 수 있다. 또한, 표준 인터페이스를 갖추고 있어 대규모 애플리케이션(여러 컨테이너)의 일부로 더 쉽게 관리될 수 있으며, 여러 클라우드에 걸쳐 오케스트레이션될 수 있다. 궁극적으로 컨테이너는 <strong>애플리케이션 개발, 배포, 관리 방식에서 이식성과 일관성을 유지시키며 발전</strong>시킨 기술이라고 볼 수 있다. 그리고 이러한 컨테이너를 활용하여 시스테메틱한 관리체계를 정립한 도커는 컨테이너의 대명사처럼 여겨졌다.</p>

<p>하지만 이제는 도커만의 독주 무대가 아니게 되어감을 종종 느끼게 된다. 도커는 여전히 인기가 있지만, 점점 더 많은 기업과 개발자들이 다른 대안으로 눈을 돌리고 있다는 점은 고려해볼만한 논지가 아닐까 한다. 이는 도커가 선택지에서 제외되었다는 것이 아닌 성능, 보안, 유연성, 비용 등 주요 측면에서 도커가 뒤처지거나, 대안이 있다 혹은 대안을 찾아야 한다는 인식이 확산되고 있는 것이다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0001.png" alt="" /></p>

<h3 id="도커가-가지는-현안들">도커가 가지는 현안들</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0002.png" alt="" /></p>

<ol>
  <li>
    <p><strong>라이선스 및 비용 구조 변경</strong></p>

    <p>가장 중요한 전환점 중 하나는 <strong>도커 데스크톱의 라이선스와 비용 구조 변경</strong>이다. 도커는 일정 규모 이상의 조직에 유료 멤버십을 요구하기로 결정했으며, 이전까지 무료로 사용하던 도구에 대해 기업들이 갑자기 비용을 지불해야 하는 상황이 발생했다.</p>

    <p>이러한 부분은 비용에 민감한 팀들이 <strong>도커에 대한 의존도를 진지하게 재평가</strong>하도록 만들게 된다. 오픈 소스 도구로 전환하고자 하는 이들이 대안을 모색하는 계기가 되었다.</p>
  </li>
  <li>
    <p><strong>성능 문제</strong></p>

    <p>도커는 리눅스에서는 뛰어난 성능을 가집니다. 물론, 이는 컨테이너라는 기술 자체의 본질적으로 리눅스 시스템 구조와 밀접한 연관성을 갖고 있다.</p>

    <p>하지만 문제는 이러한 편리함을 윈도우나 Mac 에서 사용하고자 하면서 여러 이슈가 발생하게 된다. 도커는 기본적으로 Host로 사용할 영역을 각각 WSL2, HyperKit 을 활용하는데, 이를 기반으로 하는 도커 데스크톱은 리눅스 컨테이너를 에뮬레이트하기 위해 가상 머신을 사용하기 때문에, 이로 인한 불가피한 <strong>성능 저하, 과도한 메모리와 CPU 사용 등의 문제가 발생</strong>할 수 있다.</p>

    <p>고질적인 윈도우 WSL Vmmem 이슈, 파일 시스템의 비정상적인 느림, IO 성능 저하, CPU 오버헤드 문제 등등… 알려진 문제들, 불편함은 이미 충분히 지적되고 있고, 이에 대한 개선은 수년째 언급 되고 있는 실정이다.</p>

    <p>특히나 무거운 빌드나 복잡한 멀티 컨테이너 구성에서는 문제가 더욱 심각해진다. 수겹의 레이어를 만들어야 하고, 그걸 위한 이미지들은 기존보다 훨씬 많은 양의 가상화를 위한 리소스를 필요로 한다.</p>

    <p>반면, 핀치(Finch)에서 사용하는 리마(Lima) 같은 신기술은 맥 개발자를 위해 최적화된 가상화 환경을 제공하여 도커 데스크톱의 복잡성 없이 성능을 개선합니다. 맥 성능을 극대화하는 것이 대체 런타임을 고려하는 또 하나의 이유다.</p>
  </li>
  <li>
    <p><strong>보안 문제</strong></p>

    <p>도커의 아키텍처는 켜보면 바로 알 수 있는 특징이 있다. 내부의 구동에서 <strong>루트 권한으로 실행되는 데몬에 의존</strong>하고 있다는 점이다. 그러나 이러한 점이 바로 보안의 문제냐? 라고 하면 그렇지는 않다고 생각한다. 오히려 개발 친화적이고, Host 로의 입구 관문이 존재하는 데, 각 내부에 더 많고, 두꺼운 보안은 불필요한 요소일 수 있다.</p>

    <p>하지만 이로 인해 운영 환경에서 <strong>보안 위협 노출이 넓어질 수 있다</strong>. 이러한 점에서 도커는 보안 기능을 추가했지만, 보안을 중시하는 조직들은 애초부터 보안을 고려해 설계된 대안들을 선호하는 경우가 생길 수 밖에 없다.</p>
  </li>
  <li>
    <p><strong>모노리틱 접근 방식</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0003.png" alt="" /></p>

    <p>클러스터링을 위한 스웜(Swarm)과 이미지 레지스트리를 위한 도커 허브(Docker Hub)가 밀접하게 결합된 도커의 모노리틱 구조는 적응하고 난 사용자에게는 매우 편리하게 느껴질 수 있다. 모든 것이 물 흐르듯, 일사천리로 움직이게 되고 이러한 구조는 설정과 이식에서 우수한 성능을 보여준다.</p>

    <p>하지만 <strong>현대 클라우드 네이티브 환경에서는 오히려 제약</strong>으로 다가오게 될 수 있다. 오늘날의 트렌드는 <strong>특화되고 모듈화된 도구들로의 전환</strong>이다. 오케스트레이션은 쿠버네티스(Kubernetes)가 완전히 지배하고 있으며, 패키징은 헬름(Helm)이 담당하고, 컨테이너드(containerd)와 같은 전용 컨테이너 런타임은 컨테이너 관리에만 집중해준다. 즉, 각 역할에 맞는 수준의 관리를 하고 통제가 가능하다는 것은, 전체의 조율과 모듈화에 오히려 도움이 되지, 도커의 통합적 관리는, 오히려 <strong>복잡성을 증가</strong>시킬 수 있다.</p>
  </li>
  <li>
    <p><strong>밴더 종속성 우려</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0005.png" alt="" /></p>

    <p>개발자들은 도커의 특정 도구에 지나치게 의존하는 것에 신중해지고 있다. 도커 파일 문법은 널리 사용되지만, OCI 이미지 및 런타임 요구 사항처럼 공개 표준에 의해 관리되는 것이 아니다. 개발자들은 <strong>단일 툴체인에 묶이는 것을 피하고 싶어 하며</strong>, 특히 공개 표준이 더 큰 유연성과 장기적인 안정성을 보장해 줄 수 있다는 주장은 언제나 그렇지만 지속적으로 강조된다. <strong>다양한 도구와 플랫폼 간의 호환성 보장, 이식성, 밴더 중립성 확보가 더욱 중요</strong>해졌고 그렇지 못한 대상에 대해선 기피하는 것이 어느 기업이나, 개발자들의 공통된 영역이리라.</p>
  </li>
</ol>

<h3 id="도커의-대안들-새로운-플레이어들의-등장">도커의 대안들: 새로운 플레이어들의 등장</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0004.png" alt="" /></p>

<p>이러한 배경 속에서 여러 컨테이너 런타임들이 인기를 얻고 있으며, 이들은 현대적인 컨테이너 네이티브 환경의 핵심 가치인 모듈화, 성능, 개방성을 반영하고 있다. 주목할 만한 대안들은 다음과 같다.</p>

<ul>
  <li><strong>Podman</strong>: 레드햇(Red Hat)에서 개발한 포드만은 <strong>안전하고 데몬이 없는 대체재</strong>로 평가받는다. 도커와 달리 중앙 데몬에 의존하지 않으며, <strong>루트 권한 없이 컨테이너를 실행할 수 있는 루트리스 환경을 적극 지원</strong> 한다. 명령어 인터페이스도 도커와 매우 유사하여 보안을 중시하는 팀이 쉽게 전환할 수 있다.</li>
  <li><strong>containerd</strong>: 원래는 도커의 일부였지만 분리되어 현재는 CNCF가 관리하는 독립 프로젝트다. 특히 <strong>쿠버네티스 1.24에서 도커에 대한 직접 지원이 중단된 이후</strong>로, <strong>컨테이너드는 대부분의 쿠버네티스 배포판에서 기본 컨테이너 런타임으로 사용</strong>되고 있다. AWS, 구글 클라우드, 애저와 같은 주요 클라우드 제공 업체들도 자체 관리형 쿠버네티스 서비스에서 컨테이너드를 기반으로 사용한다. 컨테이너 관리에 단일 목적을 가지고 있어 <strong>경량화되고 확장 가능</strong>하다는 특징이 가장 크다.</li>
  <li><strong>CRI-O</strong>: CRI-O 역시 CNCF에서 관리하며, <strong>쿠버네티스를 위해 특별히 설계</strong>되었다. 컨테이너 런타임 인터페이스(CRI)를 엄격히 준수하며, 불필요한 요소를 제거한 간결하고 목적에 맞는 환경을 유지해준다. 오직 쿠버네티스 워크로드만을 지원하기 때문에 보안 측면에서도 이점을 제공한다. 레드햇 오픈 시프트의 기본 런타임이며, 최소주의와 규정 준수를 중시하는 팀들에게 선호된다.</li>
  <li><strong>Lima 및 Finch</strong>: 맥OS 성능 문제를 해결하기 위한 도구들이다. <strong>Lima는 맥OS에서 컨테이너 빌드를 위한 리눅스 가상 머신을 구성</strong>해 주는 도구로 성능에 최적화된 환경을 제공한다. <strong>Finch는 AWS가 후원하는 프로젝트</strong>로 리마와 컨테이너드/너드컨트롤(nerdctl)을 기반으로 하여 <strong>도커 데스크톱을 대체할 수 있는 고성능 도구를 제공</strong>한다. <strong>라이선스 제약 없이 사용할 수 있다는 점</strong>이 큰 장점이며, 맥OS 개발자들 사이에서 <strong>네이티브에 가까운 성능</strong>을 제공하는 대안으로 빠르게 선호되고 있다.</li>
</ul>

<h3 id="컨테이너-생태계의-미래">컨테이너 생태계의 미래</h3>

<p>컨테이너 생태계 전반의 분위기는 현재 지속적으로 <strong>모듈화와 전문화로의 전환</strong>을 반영하고 있다. 그러한 상황에서 도커의 아쉬운 부분을 이야기 해봤으나, 사실 지속적인 개선이 이루어지고 있다. 2025년 1월에 쓰여진 글로, <a href="https://www.paolomainardi.com/posts/docker-performance-macos-2025/">Docker on MacOS is still slow?</a>라는 이 글만 보더라도 2년 전 분석에 비하면 Docker 의 File Synchronization 기능으로 성능 저하는 최소화 가능하며, 아직 베타지만 Docker VMM 등 대안, 대첵 등도 거론된다는 점에서 MacOS 가상화 환경과 native linux 성능 간 격차 개선을 통해 컨테이너 생태계와 Docker가 여전히 개발자들의 선택을 받게 될 것이라는 점은 확실해 보인다.</p>

<p>도커는 사라지는 것이 아니라 변화하고 있는 것이다. 그러나 컨테이너라는 기술을 기반으로 하는 영역은 현재 <strong>개방형 표준, 경량화된 런타임, 클라우드 네이티브 원칙을 중심으로 빠르게 진화</strong>하고 있다. 도커가 이제는 컨테이너의 절대적인 중심은 아닐 수 있지만, 여전히 중요한 역할을 수행할 것이다. 우리가 목격하고 있는 것은 도커가 만들어낸 생태계의 성숙이며, 이를 통해 개발자들은 더 다양한 선택지를 갖게 되었다는 점이다.</p>

<p>미래는 <strong>모듈형 구조를 갖고 설계 단계부터 개방성을 지향하며, 기본적으로 안전하고 다양한 워크플로우에 유연하게 대응할 수 있는 도구들을 선호</strong>하는 것은 자연스러운 흐름일 것이고, 이 흐름을 읽고 대비하는 필요는 있어 보인다고 생각이 든다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="Container" /><category term="Docker" /><summary type="html"><![CDATA[도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동]]></summary></entry><entry><title type="html">@types/~ 의존성을 설치하면 얻는 것</title><link href="http://localhost:4000/backend/2025/05/03/Type-library.html" rel="alternate" type="text/html" title="@types/~ 의존성을 설치하면 얻는 것" /><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/03/Type-library</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/03/Type-library.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>요 최근 MSA 서버 구현 공부를 다시 하고 있다. 영어 강의고, 상당히 난감한 번역의 자막이라 열은 받지만… 그럼에도 구조적 설계를 배울 수 있어서 좋다.</p>

<p>그러는 와중에 여전히 모르는게 많은 응애 개발자 답게, 모르는 라이브러리의 설치에 대한 내용이 남아 이렇게 적어본다.</p>

<h2 id="typebcrypt-가-뭐시여">@type/bcrypt 가 뭐시여..?</h2>
<p>MSA auth 구현을 하던 도중, 강사가 개발환경에서 좋다고 하여 설치를 했고, 그러나 개발환경..? 굳이 구분이 필요한가 라고 생각을 했었는데… 그게 아니었다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">@types/</code> 라이브러리들은 TypeScript 개발 환경에서 매우 중요한 역할을 합니다. 이 라이브러리들은 주로 <code class="language-plaintext highlighter-rouge">-D</code> 플래그(또는 <code class="language-plaintext highlighter-rouge">--save-dev</code>)를 사용하여 개발 의존성으로 설치됩니다. <em>- Claude 3.7</em></p>
</blockquote>

<p>해당 패키지들이 괜히 구분된게 아니라고, 실질적으로 나름의 역할하는 거였구나. 새삼 깨닫게 되었다. 😅</p>

<h3 id="types-라이브러리의-역할은">@types/ 라이브러리의 역할은</h3>

<ol>
  <li>
    <p><strong>타입 정의 제공</strong>: JavaScript로 작성된 라이브러리에 대한 TypeScript 타입 정의를 제공한다. JavaScript는 원래 타입이 없는 언어이기 때문에, TypeScript에서 이러한 라이브러리를 사용할 때 타입 정보가 필요하고 없을 경우 당연히 TypeConflict 로 고생할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 시 코드 자동완성과 IntelliSense</strong>: 개발 도구(VS Code 등)에서 코드 자동완성, 파라미터 힌트, 메서드 시그니처 등의 도움말을 제공한다. 따라서 편의성 향상에 매우 도움이 된다.</p>
  </li>
  <li>
    <p><strong>타입 체크</strong>: TypeScript 컴파일러가 코드의 타입 오류를 찾아내는 데 사용된다. 이는 런타임 전에 많은 버그를 발견하는 데 도움이 되어 안정성에 도움이 된다.</p>
  </li>
  <li>
    <p><strong>문서화</strong>: 라이브러리의 API가 어떻게 사용되어야 하는지에 대한 문서 역할도 한다. 타입 정의를 통해 함수의 매개변수, 반환 값 등의 정보를 확인할 수 있다.</p>
  </li>
</ol>

<h3 id="예시">예시</h3>

<p>예를 들어, Express.js를 TypeScript 프로젝트에서 사용하려면:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>express          <span class="c"># 실제 라이브러리 설치</span>
npm <span class="nb">install</span> <span class="nt">-D</span> @types/express <span class="c"># TypeScript 타입 정의 설치</span>
</code></pre></div></div>

<p>이렇게 하면 다음과 같은 TypeScript 코드를 작성할 수 있습니다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">@types/express</code>는 <code class="language-plaintext highlighter-rouge">req</code>와 <code class="language-plaintext highlighter-rouge">res</code> 객체의 타입, 그리고 <code class="language-plaintext highlighter-rouge">express()</code> 함수의 반환 타입 등을 제공한다.</p>

<h2 id="알아둬야-하는-핵심-포인트">알아둬야 하는 핵심 포인트</h2>

<ol>
  <li>
    <p><strong>개발 의존성으로 설치할 것</strong>: <code class="language-plaintext highlighter-rouge">-D</code> 플래그를 사용하여 개발 의존성으로 설치하는 이유는 이 타입 정의가 런타임에 필요하지 않고 개발 및 컴파일 시에만 필요하기 때문.</p>
  </li>
  <li>
    <p><strong>라이브러리 버전 일치</strong>: <code class="language-plaintext highlighter-rouge">@types/</code> 패키지의 버전은 가능한 한 실제 라이브러리 버전과 일치해야 한다.</p>
  </li>
  <li>
    <p><strong>DefinitelyTyped</strong>: 대부분의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지는 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 프로젝트에서 관리됩니다. 이는 커뮤니티가 관리하는 타입 정의 저장소다.</p>
  </li>
  <li>
    <p><strong>내장 타입</strong>: 일부 라이브러리는 자체적으로 타입 정의를 포함하고 있어서 별도의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지가 필요하지 않기도 하다. 예를 들어, React 16.8 이후 버전은 자체 타입 정의를 포함하고 있다.</p>
  </li>
</ol>

<h2 id="yarn으로-types-패키지-설치하기">Yarn으로 @types/ 패키지 설치하기</h2>
<p>학습 시에는 pnpm 을 사용하였으나, 현재 회사의 의존성으로 yarn 을 사용 중이다. yarn 에선 다음과 같이 사용해서 type 을 다운받으면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 라이브러리 설치</span>
yarn add express

<span class="c"># 타입 정의를 개발 의존성으로 설치</span>
yarn add <span class="nt">--dev</span> @types/express
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 단축 </span>
yarn add <span class="nt">-D</span> @types/express
</code></pre></div></div>

<h2 id="yarn에서-packagejson-의존성-구분">Yarn에서 package.json 의존성 구분</h2>

<p>npm과 마찬가지로 Yarn도 <code class="language-plaintext highlighter-rouge">package.json</code> 파일에서 의존성을 다음과 같이 구분합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.1"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"devDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"@types/express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.13"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="타입-지원-여부-확인-방법">타입 지원 여부 확인 방법</h2>

<p>이렇듯 유용하기도 하고, 있는지 확인해 보면 좋은 <code class="language-plaintext highlighter-rouge">@type/~</code>는 각 라이브러리 마다 존재하는지 확인해서 필요시 설치하면 되고, 있는지 여부는 아래와 같은 방법을 활용하자.</p>

<ol>
  <li>패키지 설치 후 직접 확인</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 간단한 테스트 파일 작성</span>
<span class="k">import</span> <span class="o">*</span> <span class="kd">as </span><span class="kr">package</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">package-name</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>이 코드를 작성했을 때:</p>
<ul>
  <li>타입 오류가 없다면, 라이브러리가 이미 타입을 내장하고 있습니다.</li>
  <li>“Could not find a declaration file for module ‘package-name’” 오류가 발생한다면, 타입 정의가 없다고 보면 됨</li>
</ul>

<ol>
  <li>패키지 문서 확인</li>
</ol>

<p>대부분의 패키지는 README나 공식 문서에 TypeScript 지원 여부를 명시하니 확인 할 것</p>
<ul>
  <li>“Written in TypeScript” 또는 “TypeScript support included”와 같은 문구</li>
  <li>설치 안내에 <code class="language-plaintext highlighter-rouge">@types/package-name</code> 설치 지침이 포함되어 있는지 확인</li>
</ul>

<ol>
  <li>패키지 소스 확인</li>
</ol>

<p>패키지의 <code class="language-plaintext highlighter-rouge">package.json</code> 파일을 확인합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"package-name"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"types"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">       </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typings"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typescript"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"definition"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ol>
  <li>NPM 페이지 확인</li>
</ol>

<p>NPM 웹사이트에서 패키지 페이지를 확인하세요. 패키지 파일 목록에 <code class="language-plaintext highlighter-rouge">.d.ts</code> 파일이 있으면 타입을 제공한다.</p>

<ol>
  <li>DefinitelyTyped 검색</li>
</ol>

<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped GitHub 저장소</a> 또는 <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a>에서 <code class="language-plaintext highlighter-rouge">@types/package-name</code>이 있는지 확인한다.</p>

<ol>
  <li>자동화된 도구 사용</li>
</ol>

<h4 id="typescript-auto-importer-확장-프로그램">TypeScript-Auto-Importer 확장 프로그램</h4>

<p>VS Code의 <code class="language-plaintext highlighter-rouge">TypeScript-Auto-Importer</code>와 같은 확장 프로그램은 사용 가능한 타입 정의를 자동으로 감지한다.</p>

<h4 id="npx-typescript-check-esm-사용"><code class="language-plaintext highlighter-rouge">npx typescript-check-esm</code> 사용</h4>

<p>이 도구는 프로젝트 의존성의 TypeScript 호환성을 검사한다.</p>

<h4 id="typed-npm-registry-사용"><code class="language-plaintext highlighter-rouge">typed-npm-registry</code> 사용</h4>

<p>이 웹사이트에서 패키지 이름을 검색하여 타입 지원 여부를 확인 가능: https://www.typedregistry.com/</p>

<h3 id="실용적인-워크플로우">실용적인 워크플로우</h3>

<ol>
  <li>먼저 기본 패키지만 설치 함: <code class="language-plaintext highlighter-rouge">yarn add package-name</code></li>
  <li>코드에서 임포트해보고 오류가 발생하는지 확인</li>
  <li>오류가 발생하면 <code class="language-plaintext highlighter-rouge">@types</code> 패키지 존재 여부를 확인:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn info @types/package-name
<span class="c"># 또는</span>
npm view @types/package-name
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@types</code> 패키지가 존재하면 설치: <code class="language-plaintext highlighter-rouge">yarn add -D @types/package-name</code></li>
</ol>

<h2 id="마치며">마치며</h2>
<p>확실히 사용해보니, 없을 때 보다 공식 설명이 더 풍부한 경우가 많고, 객체, 타입에 대한 설명이 상세 해지는 걸 보니, 개발 시 무언가 추가 시 신경 써서 넣어두거나, 기본적으로 갖춰 둔 템플릿을 활용하면 좋을 것 같다.</p>

<p>이런 거 보면 아직 짬이 덜 찬 느낌이 든다. 🫥</p>

<p>개발의 길은 멀고, 아주 멀고, 아주 멀다. 😖</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="TypeScript" /><category term="Backend" /><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">클린 코드를 위한 룰</title><link href="http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming.html" rel="alternate" type="text/html" title="클린 코드를 위한 룰" /><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming</id><content type="html" xml:base="http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming.html"><![CDATA[<h2 id="-클린-코드-황금-6원칙-스터디-정리"><strong>🧠 클린 코드 황금 6원칙 스터디 정리</strong></h2>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0002.png" alt="" /></p>

<blockquote>
  <p>링크드인에서 개발과 관련한 이미지를 한 장봤다. 새롭게 개편한 블로그를 위한 글도 써야 하고, ‘오랜만에 정리 해 봐야겠구나’ 라는 생각이 들었다. 왜냐면 이제 개발을 시작한지 4년? 팀 개발을 해나가면 나갈 수록 더 중요한게 어디에 있는가에 대한 답변이 항상 거의 여기서 나오고 있다고 스스로도 느끼는데, 정작 정확하게 이해하고 있냐? 라고 하면 그렇지는 않다… 가 있기 때문이다. 🤔</p>
</blockquote>

<h3 id="1️⃣-soc-seperation-of-concerns--관심사는-분리해라">1️⃣ <strong>SOC (Seperation of Concerns) : 관심사는 분리해라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0003.png" alt="" />
어떤 비즈니스 로직을 구현 하는 과정에서, 다양한 것, 다양한 ‘관심’이 필요 시 된다. DTO로 들어오는 대상에 대해 무결성을 검증 해야 하고, 룰은 지켰으나 데이터는 온전한지도 확인 해야 하며,  그렇게 들어온 데이터는 비즈니스 로직이 정한 룰이나, 다양한 절차를 거쳐 결과적으로 요청을 한 클라이언트에게 전달되다.</p>

<p>따라서 다양한 요소들이나, 로직, 기능이 서로를 바라보게 될 수 밖에 없고, 보통 그런 구조가 설계되기 시작하면 거미줄처럼 얼키고 설켜 복잡한 형태를 이루게 된다.</p>

<p>문제는 그런 구조를 가지면 하나를 바꿔도 그 안에서 모든 것들이 영향을 미치게 되어 버린다는 점이다. 거기다 아무리 대단한 사람이 함께 참여하더라도 수천, 수만줄의 코드의 협업 속에서 그런 일이 일어난다면? 그걸 어떻게 발견하겠는가? 사소한 문제가 얼마나 커질 수 있는가를 여기서 알 수 있는 것이다. 물론, 이는 단적이고 극단적인 예시일 것이고 이 외에도 관심사의 혼재는 아주 큰 문제들을 많이 가진다.</p>

<p>따라서 많은 이들이 Seperation Of Concerns(관심사의 분리) 라는 가치를 이야기 하며, 이것이 필요한 이유를 크게 3가지 정도로 축약하여 이야기 한다.</p>

<ul>
  <li><strong>단일 책임 원칙을 지키기 위해</strong></li>
  <li><strong>유지 보수 과정에서 문제를 빠르게 좁혀야 한다.</strong></li>
  <li><strong>코드 재사용성을 극대화 하기 위해</strong></li>
</ul>

<p>예시를 그래도 간략하게 들어보자면… (feat. ChatGPT)</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Controller - 요청 처리만</span>
<span class="p">@</span><span class="nd">Post</span><span class="p">(</span><span class="dl">'</span><span class="s1">login</span><span class="dl">'</span><span class="p">)</span>
<span class="nf">login</span><span class="p">(@</span><span class="nd">Body</span><span class="p">()</span> <span class="nx">loginDto</span><span class="p">:</span> <span class="nx">LoginDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 여기서 무슨 일이 일어나든 </span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">login</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Service - 비즈니스 로직</span>
<span class="k">async</span> <span class="nf">login</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">:</span> <span class="nx">LoginDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">validateUser</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">);</span>
  <span class="c1">// 여기서 무슨 일이 일어나든 로직은 구분되어 있다 </span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">authService</span><span class="p">.</span><span class="nf">issueToken</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2️⃣-dyc-document-your-code--코드를-문서화하라">2️⃣ <strong>DYC (Document Your Code) : 코드를 문서화하라</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0004.png" alt="" /></p>

<p>팀 플레이를 진행하던, 혼자서 코드를 짜던 한 가지 중요한 지점은 사람은 ‘컴퓨터’ 가 아니라는 점이다. 컴퓨터도 데이터를 소실되니 마니 하는 마당에, 사람의 머리가 알 수 있고 기억할 수 있는 용량은 반드시 한계가 있다. 작업을 하던 과정이 급하고, 촉박하거나 하지 않더라도 개발을 하다보면 시간이 지나면서  ‘뇌 내 풍화(?)’를 겪게 된다.</p>

<p>그럴 때면 드디어 객관적으로 내 코드를 볼 수 있게 되고, 그 코드를 보며 자괴감도 분노도, 실망도 느끼게 되는게 마치 인생같다는(?) 이상한 소리를 할 수 있다. 왜 이렇게 했더라, 이 부분이 왜 필요했지 등등.. 그러다 보면 몇 달만에 다시 보고, 그 부분을 수정해야 할 때 그저 쉽게 코드 몇줄 추가 했음에도 에러가 생기는 일 등… 다양한 방해물이 생기고 나면, 그제야 우리는 깨닫게 된다.</p>

<p>‘아 메모 해 둘걸’</p>

<p>하고 말이다.</p>

<p>문서화가 중요한 것은 다음과 같은 이유라고 보면 된다.</p>

<ul>
  <li><strong>협업자가 코드를 빠르게 이해할 수 있으려면 필요하다.</strong></li>
  <li><strong>시간이 지난 뒤 ‘나’의 이해를 돕기 위해 필요하다.</strong></li>
</ul>

<p>뭐 예시는 필요하진 않을 것이다. 심지어 요즘은 LLM 을 활용하여 자동 문서화도 기가 막히게 잘 되고 있으니, 이 부분은 확실하게 도입하고 습관을 들이는 것이 좋아 보인다.</p>

<p>Cursor를 활용해도 좋을 것이고 Vsc 에 Continue 를 활용해도 좋다고 느껴진다.</p>

<h3 id="3️⃣-dry-dont-repeat-yourself--중복을-피하라">3️⃣ <strong>DRY (Don’t Repeat Yourself) : 중복을 피하라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0005.png" alt="" />
이번에는 좀 극단적인 예시를 들어 보면 좋을 것 같다.</p>

<blockquote>
  <p>결제 로직을 만들게 되었다고 치자. 전처리 과정에서 데이터들에 대한 정리, 특히나 암호화된 데이터를 decode 해서 실제 결제 이벤트를 받아내야 한다. 그 뒤 자세한 로직들이 나온다. 그런데 작업을 하다보니 이 decode 의 과정이 코드가 너무 길어, 블록으로 떼어 내서 다시 메서드화 시키기 너무 귀찮다..!</p>

  <p>결제 이벤트는 총 4개. 마음은 아팠지만, 기간이 얼마 남지 않았다는 생각에 어쩔 수 없이 결단을 내려 ctrl + c를 4회 진행하게 되는데…</p>

  <p>몇 달이 흘러, 결제 개선이 가능한 시점이 되었다. 결제 이벤트 하나만 추가로 개선하면 되는 것이었음에도, 무언가 이상하다. 무엇이 문제 였을까?</p>
</blockquote>

<p>같은 코드가 같은 내용임에도 불구하고 다양한 로직에 사용되는 경우는 은근히 흔하게 있다. 암호화와 복호화 과정이라는 대표적인 예시도 있지만, 그 밖에도 처리해야 하는 데이터의 가공 영역은 특히나 그런 경우가 많다.</p>

<p>하지만 문제는 예를 들어 이럴 수 있다. A 라는 로직이 있고 이것이 4번 쓰였는데, A를 고친다는 생각에 A’를 만들었지만, 막상 내가 그때 A를 4번 복붙 해야 한다는 걸 까먹을 수도 있고 실제로 그런 경우로 사고가 나는 경우가 정말 많다.</p>

<p>따라서 꼭 기억할 것은 같은 코드, 같은 규칙이라면 하나를 작성하고 그것을 통해 항상 정확하게 처리하는 것이 필요하다. 이를 통해 버그 발생 확률을 낮추고, 수정과 리펙토링 과정을 쉽고 정확하게 만들어주며, 오히려 이런 설계가 되었을 때 향후 코드 확장성이 높아지는 것은 당연히 덤이니까.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이런 단순한 코드라도 만들어두면, 재사용할 때 검색 한번으로 찾아서 쓸 수 있고, </span>
<span class="c1">// 향후 조건이 여러개로 늘어나도 1번의 수정이면 끝난다</span>
<span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="4️⃣-kiss-keep-it-simple-stupid--단순하게-유지하라">4️⃣ <strong>KISS (Keep It Simple, Stupid) : 단순하게 유지하라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0007.png" alt="" /></p>

<p>백엔드 개발자로 입문하게 되어, 첫 해 작업을 할 때 항상 생각했던 것은, 단단한 구조, 안정적인 성능, 이를 위한 수학적이거나 계산적인 로직으로 단단한 기능으로 구현하는게 좋지 않을까! 라는 호기로움이었다.</p>

<p>하지만 6개월 정도 했었을까? 그런 코드가 ‘잘 동작’은 하지만 ‘쓸모 없다’ 는 것은 너무나 빨리 알게 된 사실이었다.</p>

<p>개발의 과정은 완벽이 없다. 기능은 그대로지만 방향성은 달라지게되고, 사업의 형태, 비즈니스의 방향성의 고려로 기능은 수시로 바뀔 수 있다.</p>

<p>뿐만 아니라 새로운 사람이 들어오거나, 코드를 만드는 입장과 리뷰, 관리 하는 입장이 다른 경우도 있다. 무엇이 되었든 그런 상황이 되면 우리는 코드를 봐야하고, 그 코드를 이해하고 문제가 없는지를 확인하는 작업들이 필요 시 된다.</p>

<p>그런데 여기서 나만 아는, 혹은 나 혼자 이해할만한 로직을 활용한다는 것은 심각한 비효율성을 낳는다.</p>

<p>리펙토링을 이후에 할 때도 어려워지고, 누군가 읽고 해석해서 향후 관리를 해 나가는 것도 어렵다. 특히나 디버깅이나 테스트 과정 역시 어려울 수 밖에 없는 경우가 많다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">levels</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">90</span><span class="p">];</span>

  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">thresholds</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="nx">thresholds</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">idx</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">levels</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>둘은 동일한 결과를 만든다. 사실, 의도만 이해할 수 있다면 아래의 코드는 비교가 많아질 때 O(log n)의 복잡도로 이진탐색을 진행하기에, chatGPT 도 ‘압도적으로’ 성능이 좋다고 말할 정도로 성능면에선 좋다.</p>

<p>하지만 만약 구조가 바뀌거나 조건이 바뀐다고 할 때, 그리고 이 코드를 처음 보고 이해해야 하는 사람 입장이라면? 이런 부분들이 지속적으로 나온다면? 내 고집으로 만들어서 넣어 두고 충격적인 결말을 마주하게 될 지도 모를 것이다.</p>
<h3 id="5️⃣-tdd-test-driven-development--테스트-주도-개발">5️⃣ <strong>TDD (Test Driven Development) : 테스트 주도 개발</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0006.png" alt="" /></p>

<p>TDD는 일종의 로망(?) 처럼 느껴지고, 마치 판타지 처럼 여겨지는 경우가 좀 있다. 현실에 적용하기엔 어렵고, 번거롭고, 복잡하다는 것.</p>

<p>이러한 점이, 거를 타선이 없다는 것은 격하게 공감한다(?)</p>

<p>하지만 생각을 조금만 바꿔봐도 요즘은 훨씬 TDD 를 구현하고 준비하는 것이 어렵지 않은 시대가 되었다. 예를 들어 refernece 로 쓰이는 DTO 를 설정하고, AI 를 활용하여 예시가 되는 에러 케이스를 만들고, 그 경우의 수에 맞춰 만들어 달라고 해줄 수 있다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0001.png" alt="" /></p>

<p>실패를 먼저 고려하고, 그에 대한 대응을 정리해둔다면 로직에서 핸들링할 에러를 빼먹지 않을 수 있으며, 훨씬 명확한 협업, 클라이언트를 배려한 협업이 가능하다는 점에서 반드시 100% 완벽한 TDD 가 아니더라도 충분히 LLM 을 활용한 효율적인 방법이 적용 가능한 것이다.</p>

<p>특히나, 이렇게 준비되고, 이에 대한 Jest 테스트 같은 것들이 준비 된다면? 아마 말 하지 않아도 알 것이다. <code class="language-plaintext highlighter-rouge">버그는 잡히며</code>, <code class="language-plaintext highlighter-rouge">리펙토링을 해도 문제 없는지를 거의 즉각적으로 알 수 있고</code>, 결정적으로 성능 향상과 같이 <code class="language-plaintext highlighter-rouge">지표가 필요한 영역의 기능</code>이라면 손쉽게 테스트를 통해 리펙토링 포인트를 파악할 수 있다.</p>

<h3 id="6️⃣-yagni-you-arent-gonna-need-it--필요할-때만-만들기">6️⃣ <strong>YAGNI (You Aren’t Gonna Need It) : 필요할 때만 만들기</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0008.png" alt="" /></p>

<p>개발을 하는 것은 약간 장인정신(?)을 가지게 만든다. 내가 만드는 그것이 좀 더 멋지거나, 좀 더 성능이 좋거나, 뭐가 되었든 그 개발 분야가 뭐가 되었든 나름의 ‘미학’을 쫓는 것을 종종 보게 된다.</p>

<p>이것이 취미 일 땐 아름다울지 모른다.</p>

<p>취미 일 땐 입이 벌어지는 센스를 느낄 수 있는 것이 오히려 멋지고, 훌륭하며, 재미있다.</p>

<p>하지만 이것이 일이고, 비즈니스라면 말이 달라진다. 당장 필요한 기능, 시장이 원하는 기능, 괜찮은 아이디어를 빨리 구현하는 것이 이젠 너무 중요하고, 비즈니스에서 그 가치는 이미 십수년도 전, 아니 수백년 전부터 먼저 가져가는 사람이 임자였다.</p>

<p>개발 속도를 늦추는 오버 엔지니어링이 되어 버리게 된다면, 오히려 이후 유지 보수에도, 그리고 리소스의 낭비로 타이밍을 놓칠 수도 있다. 그리고 그것을 개발자도 경영자도, 상품을 소비할 소비자에게도 결코 좋을 리는 없다. 개발자는 회사 내지는 조직에서 함께 일하고 있고, 내가 맥을 쓰고, 커피를 마시면서, 일에 집중할 수 있게 해주는 건 내가 만든 그것을 쓰는 사람들의 돈으로 이루어진다는 사실을 잊고 살면, ‘잘 만들어도 욕을 먹는’ 케이스가 아주 드물지 않다는 것을 몸소 느낄 수 있을 것이다.</p>

<h2 id="-결론">📖 결론</h2>
<p>이 원치들에 대해 다양하게 적는건 시간 관계상 피하려고 한다. 이미 뭐 자료는 많으니… 😅</p>

<p>하지만 이 전체를 고민하고, 경험하고, 인정하게 되면 어느새 드는 하나의 생각은 다음처럼 정리 된다.</p>

<ul>
  <li>복잡한 시스템이 만들어지는 것을 막고</li>
  <li>코드를 읽기 쉽게 만들며</li>
  <li>유지 보수 가능하면서도</li>
  <li>팀 전체가 빠르게 개선할 수 있도록 하는 것.</li>
</ul>

<p>결국 이게 되면 그 어떤 소프트웨어도 유기적으로 살아 숨쉬듯 자기 복제와 자기 진화를 이루고, 목표 시 되는 프로덕트의 퀄리티를 맞추며, 인정받는 개인이자 팀이 될 수 있다.</p>

<p>오랜만에 링크드인에서 그저 짤로 본 것이지만, 정리를 하는 과정에서 CTO를 통해 얻어온 많은 경험들 그리고 백엔드 개발자로 1년 간 유지 보수, 코드를 짜오면서 얻은 많은 것들을 새삼 정리하는 감각을 느꼈다. 왜 실수가 많았고, 어디서 아쉬웠는지 새삼스럽게 느껴진 시간이었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="etc" /><category term="cleanCode" /><category term="prgramming" /><summary type="html"><![CDATA[🧠 클린 코드 황금 6원칙 스터디 정리]]></summary></entry><entry><title type="html">AI 로 어디까지 가능할까?</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game.html" rel="alternate" type="text/html" title="AI 로 어디까지 가능할까?" /><published>2025-04-12T00:00:00+00:00</published><updated>2025-04-12T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game.html"><![CDATA[<h2 id="ai-어디까지-가능할까-게임-만들-수-있을까">AI 어디까지 가능할까? 게임 만들 수 있을까?</h2>
<p>이런 영상을 보았다</p>

<p><a href="https://www.youtube.com/watch?v=NSXsTq6zg_s"><img src="https://img.youtube.com/vi/NSXsTq6zg_s/0.jpg" alt="5090사서..." /></a></p>

<p>엄밀히 말하면 5090을 가진 어마무시한 분의 이야기… 지금 살 수 있는 사람이 몇이나 될까하는 글카로 벤치에 AI까지 돌리는 내용인데.. 나에게는 다소 다르게 보였다.</p>

<h2 id="ai-로-어디까지-가능할까">AI 로 어디까지 가능할까?</h2>

<p>현재 stable diffusion 이나 Audacity + TortoiseTTS 등.. 오픈소스 AI 툴은 이미 성숙한 수준까지 올라온 상태이다.</p>

<p>뿐만 아니라 그러한 원초의 로우 툴에서 비롯되어, 웹 기반으로 서비스를 시작한 NovelAI, ComfyUI(이건 약간 중간 성격이긴 한데..), soundraw Ai 등… 이미 편리한 서비스들로 구체화 되었고, 좀더 알아보니 네이버나, 기타 굉장한 AI 스타트업들의 개발. 이제는 진짜 아무리 생각해도 AI가 핵심이고, 극강의 효율성이 필요하다는 점을 느낄 수 있었다. 이러한 점을 생각하니 이런 생각에 귀결 되었다.</p>

<blockquote>
  <p>이 정도면 혼자 게임도 만들 수 있지 않을까?</p>
</blockquote>

<p>게임, 게임성을 갖추는 것은 대단히 어렵고, 인간의 창조 영역에서도 특히나 혼자선 어려운 분야이다. 특히나 종합적인 컨텐츠로 연출, 그래픽스, 모션, 세부 분야로 파고 들면 생각보다 고려할 것들이 너무 많은 영역일 것이다.</p>

<p>하지만 생각해보면 꼭 종합적이어서 재밌거나 한건 아니다.</p>

<p>사람은 스토리를 먹고 사는 동물이다.</p>

<p>또한 사람은 본질적으로 <code class="language-plaintext highlighter-rouge">부족</code>할 때 비로소 <code class="language-plaintext highlighter-rouge">동기</code>를 얻는다.</p>

<p>그런 점이 가장 극대화 되는 장르들이 보통 퍼즐이나 비주얼 노벨류. 그리고 놀랍게도 현재 모바일 시장에서 여전히 흥행 강세이고, 수명이 유지되는 게임들도 결국 그런 부분에서 받춰져서 팬덤이 형성된 류가 꽤나 있다는 것을 알 수 있다.</p>

<p><img src="https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/2396980/capsule_616x353.jpg?t=1726036301" alt="" />
페이트 스테이 나이트는 내 시절 최고의 판타지 물이었고</p>

<p><img src="https://i.namu.wiki/i/ES0zVAPjU7o89_R-0Hywfus4caJ9LYFpF2zqLHQ0YTUuakUNw5LRY-MFHKKZmxoMiMdzor32OJc3moeQkySnCA.webp" alt="" />
그에 이어 나온 페이트 그랜드 오더는 소니를 먹여살리는 일등 공신 중 하나로 현재 수년째 그 인기를 이어가고 있는 프랜차이즈가 되었으며,</p>

<p><img src="https://i.namu.wiki/i/pvrIEFOSpzhHxbnEqMMSViO9_BnBoaHZs9hMbO32P27hV7hOv14nEQbJpPr3wpYelqgFxqk78z7C2dyPa2NeBg.webp" alt="" />
국내 성공작으로 게임성에선 뭐라고 욕을 먹어도 스토리에서 성공적인 블루 아카이브,</p>

<p><img src="https://cdn.getnews.co.kr/news/photo/202405/676535_395705_4552.png" alt="" />
빵댕이 게임이라고 하지만, 팬들에겐 그 이상이라는 평을 받는 니케</p>

<p>이런 류들이 런칭 이후 지속적인 사랑을 받고, 그 지속적인 사랑으로 얻은 캐시카우가 새로운 능력이나 도전을 이뤄내는 것을 생각해본다면… 과연 AI 를 활용하고, 핵심이 되는 부분 비주얼과 스토리에 대해서만 얼마나 좋은 스토리, 좋은 내용을 양질로 끌고 오냐만 결정 난다면 이건 굉장한 One Man Army 로 뭔가를 할 수 있는 게 아닐까?</p>

<h2 id="필요한-도구들은-뭐가-있을까">필요한 도구들은 뭐가 있을까?</h2>
<p>지금까지 확인 해보았을 때, 필요한 영역은 다음과 같다.</p>

<h3 id="게임의-툴-">게임의 툴 :</h3>
<p>게임의 툴로는 렌파이, Game Maker, Unity 를 생각해볼 수 있다. 툴의 난이도는 Unity 쪽이 가장 어렵지만, 활용성이나 장기적으론 Unity 가 가장 우수하다. 하지만 렌파이나 Game Maker는 쉽고, 오픈소스라는 가장 큰 장점을 갖고 있다.</p>

<p>비용의 처리나, 복잡성, 간단함을 승부로 할 것이라면 개인적으론 GameMaker 가 가장 현실적인 중간 답안이 아닐까? 다른 엔진도 여럿 추천 받았지만, 결국 2D 게임을 만든다고 할 때, 가장 적절한 수준은 어디인가에서 다플랫폼을 지원하고, 커뮤니티 수준등을 보면 결국 GameMaker로 갈 수 밖에 없을 것 같다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0003.png" alt="" /></p>

<p>거기다 이젠 영어만 있는 것들이 못 쓸 정도가 아니라는 점을 너무나 잘 알고 있다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0004.png" alt="" /></p>

<p>노트북LM 을 활용하여, 영어로 된 튜토리얼을 넣고, 학습 시켜 배워야할 영역만 체크하고, 영상도 볼 필요 없이 튜토리얼 대로 만든다… 진짜 지금 내가 사는 시대는 아무리 생각해도 말이 안된다(…)</p>

<h3 id="그림-">그림 :</h3>
<p>위에서도 언급한 Raw 한 툴을 활용하는 것도 가능하고, 거기서 좀더 개선된 것들이나 플러그인 등도 있다. 만약 쓰게 된다면 Stable Diffusion 을 사용할 것 같은데, 이는 오픈소스로 개방된 모델들을 활용할 수 있고, 무엇보다 오픈소스라는 점이 가장 중요하기 때문이다. 현재 끌리는 건 미드저니, NovelAI 와 같이 이미 좀더 편리하게 쓰도록 구성된 것들이 있는 것은 사실이지만, 혼자서 할 수 있는가? 로컬에서 이용 가능한가? 라는 점에서 테스트먼트를 한다면 stable diffusion을 우선 써보는게 낫다는 생각이 든다.</p>

<p>다만, 이걸 위해서 필요한 것은 역시 무드, 그리고 캐릭터를 별도로 가져갈 수 있냐는 점. 이 부분은 stable diffusion을 제대로 설치하여 사용해봐야 알 수 있을 것으로 보인다. 아직 아무것도 안하고 써보는 것이다보니(도커에 설치만 해봄 ㅋㅋ..) 뭐라고 이렇다 말하긴 애매하다.</p>

<p>한가지 현재 상황에서 대단히 중요한 부분은 과연 상용으로 쓸 수 있는가? 에 대한 부분이리라 생각된다. 상용 라이센스를 가지는 것들로만 구성을 해야 하므로, 이에 대한 고민 연구가 필요하며 법적인 부분에 대한 조언은 받아봄직 하긴 하다.</p>

<p>어쨌든, 이러라고 산 4080super 가 제 역할을 다해주길 기대한다…(<del>3년 내에 2천은 벌어야 한다…</del>)</p>

<h3 id="bgm--효과음-">BGM / 효과음 :</h3>
<p>사실 AI 가 거의 필요없다고 생각한다. 이런건 무료 에셋으로 가보자.</p>

<h3 id="음성-">음성 :</h3>
<p>이게 가장 큰 문제일 수 있을 것 같다. 비주얼 노벨에서 성우는 생각보다 중요하고, 현재 리메이크된 유명 게임들도 인게임 보이스를 넣어서 리메이크 하는 걸 보면, 확실하 예전 감성으로만 접근할 수 없긴 하다. 그래서 찾아보니…</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0001.png" alt="" /></p>

<p>세상에… AI 는 이미 여기도 이미 해결이 되어 있었다.</p>

<p>그 와중에 개인적으로 사용해본 결과 굉장히 독보적인 곳을 발견했는데, 그곳이 바로 이곳</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0002.png" alt="" /></p>

<p>SUPERTONE 이라는 곳으로, 목소리 수준이나, 비용, 어떤 면에서도 로컬보단 월등히 낫다는 생각이 들었다. 특히 한국어 성우 학습이 정말 괜찮다.</p>

<h2 id="일단-해보자">일단 해보자</h2>
<p><img src="https://i.namu.wiki/i/H0zMZ4htL9ypyfJ0LXQrcTcC6f7dZBBh1KedrpMXNnEiXaAIzyBTAOgFReXNwgw6JWjtlr4Agc6_kEMckjFUeLQpFzEJiCxurXkxzaA3azZbR_6oMHND5511MI4fQyhP9BcG1zVgKX7GrKgka6uT1A.webp" alt="" /></p>

<p>AI 를 공부하고, 개발자로 뭔가 해보려고 하였다. 개발을 배우는 것도 중요하고 그래서 현재 회사에서 나름데로 정말 노력에 노력을 더하고 있지만, 취미로 무언가 만들기 위해선 역시 재미가 필요하다. 그리고 필요한 건 ‘가볍지만 제대로’ 할 수 있는 도구 들.</p>

<p>어차피 배워 나가고 살아 나가다보니 친구도 없고, 시간은 많다.</p>

<p>내가 좋아하는 건 판타지와 SF, 그리고 씹덕.</p>

<p>개발자로 이것저것 배운 것들이 접목될 수 있는데, 심지어 팀이 아니어도 할 수 있다? 지금 나에게 필요한건 어쩌면 이런 도전을 해보는게 아닐까 싶다.</p>

<p>가즈아.</p>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><category term="게임" /><summary type="html"><![CDATA[AI 어디까지 가능할까? 게임 만들 수 있을까? 이런 영상을 보았다]]></summary></entry><entry><title type="html">기술 블로그를 다시 시작하면서</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start.html" rel="alternate" type="text/html" title="기술 블로그를 다시 시작하면서" /><published>2025-04-07T00:00:00+00:00</published><updated>2025-04-07T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start.html"><![CDATA[<h2 id="기술-블로그를-개편하면서">기술 블로그를 개편하면서</h2>
<p>기존의 개발자가 되기 전의 블로그를 써보겠다고 나름 노력했습니다. 
아카이브란 이름을 걸고, 기술 블로그를 만드는데 이것 저것 노력해봤던 그 흔적들.</p>

<p>하지만 취업을 하고나서 보니 부족한 것도 많고, 아쉬운 점도 많았습니다.
원래는 원대한 계획을 세우고, 직접 만들어보겠다! 이런 마인드도 있었지만…</p>

<p>일은 정신 없고, 내가 배우고 즐거워하는 것들을 씹어 삼키는 것만으로도 바쁘다 보니,
개인적인 일까지 겹치며서 시간을 확보하기는 커녕 하루 살아 하루 회복하는 일상…. 😫</p>

<p>하지만 조금 천천히 갈 순 있어도 멈추기는 싫었기에, 쇠뿔도 당긴 김에 빼라는 말 처럼 전체를 정리하고 다시 시작할 공간으로 정리를 단행했습니다.
(<del>정리라는 이름의 강제 초기화</del>)</p>

<p>기존의 글들도 다시 정리하여 마이그레이션을 할 것이고, 새롭게 배우던 것들도 좀더 깔끔하게, 좀더 쉽게 정리하는게 핵심입니다. 
그리고 이렇게 글로 내 생각을, 내 삶을 남겨, 나라는 존재의 능력치도, 동시에 내 가치도 함께 성장시키는 것이 이 공간에서 시작하려 합니다.</p>

<h2 id="앞으로">앞으로</h2>
<p>AI의 발전은 하루 걸러 하루 달라지고, 새로워지고, 진보합니다. 
백엔드적 경험은 무언가 하나 만들 때마다 성장을 하는 듯 하지만, 부족함을 놓치는 것들이 끊임없이 나오고 그것들을 못 챙겼다는 것은 상당한 아쉬움으로 남습니다.</p>

<p>그렇기에 목표는 명확합니다.</p>

<p>AI 는 아직 ‘따라잡을’ 수는 없어도, 따라가려고 노력은 할 것이며,</p>

<p>배운 것들 중 괜찮은 것들을 정리하여 이곳에 적고, 특히나 그것이 남들이 읽기 좋은 글의 형태로 남기려고 합니다.</p>

<p>이유는 간단합니다. 
쉬운 글로 남기려고 노력할 때, 비로소 어려운 것을 나 스스로도 이해하고, 동시에 누군가에게도 도움이 될 수도 있기 때문입니다. 
생각해보면 그 주제가 결국 개발이라는 점에서 차이가 있는 것은 아닌가- 라는 것도 한 편으로 생각해볼 지점이겠지만… 😂</p>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><summary type="html"><![CDATA[기술 블로그를 개편하면서 기존의 개발자가 되기 전의 블로그를 써보겠다고 나름 노력했습니다. 아카이브란 이름을 걸고, 기술 블로그를 만드는데 이것 저것 노력해봤던 그 흔적들.]]></summary></entry></feed>