<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-08-18T05:04:00+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">AI Breakfast S2 Ep 3 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/08/18/00-AI-trend-with-google-s2-03.html" rel="alternate" type="text/html" title="AI Breakfast S2 Ep 3 생각정리" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/18/00-AI-trend-with-google-s2-03</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/18/00-AI-trend-with-google-s2-03.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=WTea4oBLPLQ"><img src="https://i.ytimg.com/vi/WTea4oBLPLQ/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>AI 에이전트 시대가 도래하고 있으며, 구글 클라우드의 AI 전문 고객 엔지니어와 제너러티브 AI 필드 솔루션 아키텍트 사이의 에이전트 개발의 실제적인 측면을 논하고 있다. 구글은 제미나이 2.0과 2.5를 통해 에이전트 시대를 준비하고 있으며, 에이전트 개발을 지원하는 방향으로 나아가고 있음을 보여주는 영상이었다.</p>

<p><strong>ADK (Agent Development Kit)의 필요성 및 특징</strong></p>

<ul>
  <li>에이전트 개발은 LM 기술 활용을 넘어 소프트웨어 엔지니어링 지식과 LM 관련 지식이 모두 필요하여 시작이 어렵다.</li>
  <li>시중에는 랭그래프(LangGraph)나 크루AI(CrewAI)와 같은 다양한 에이전트 개발 프레임워크가 있지만, 구글은 <strong>ADK를 개발</strong>하였다.</li>
  <li><strong>ADK의 목적</strong>은 에이전트 개발을 <strong>더 쉽게</strong> 만들고, 개발된 에이전트를 <strong>쉽게 프로덕션에 배포</strong>할 수 있도록 이밸류에이션, 세션 관리, 다른 서비스와의 연결 등 필요한 부분을 신경 써서 만드는 것이다.</li>
  <li><strong>기존 프레임워크와의 차이점</strong>으로, ADK는 <strong>사용 편의성</strong>이 높고, <strong>구글의 다른 서비스들과의 통합</strong>이 매우 쉽다. 또한 실제 <strong>프로덕션 환경을 위한 배포, CI/CD, 이밸류에이션 등</strong>의 고려가 잘 되어 있다.</li>
  <li>ADK는 고객의 요구사항을 셀즈포스에 반영하는 CRM 에이전트나 고객에게 제품을 추천하는 에이전트 등 <strong>다양하고 복합적인 전문 에이전트들을 이미 잘 만들어 놓은 예시</strong>를 제공하며, 이를 활용하여 개발을 시작할 수 있다. 튜토리얼을 통해 기존 기술로는 오래 걸렸을 작업을 매우 심플하게 구현하는 경험을 할 수 있다.</li>
  <li>ADK는 <strong>개발 시간을 획기적으로 단축</strong>시킨다. 예를 들어, RAG(Retrieval Augmented Generation) 기법을 활용한 프로젝트는 과거 몇 달이 걸렸으나, ADK를 사용하면 1~2주 만에 기존에 몇 달 걸렸을 만한 완성도로 개발이 가능하다. 문서 처리 프로젝트 또한 LLM과 에이전트를 결합하여 몇 개월, 심지어 1년 이상 걸리던 작업을 매우 빠르게 완성할 수 있다.</li>
  <li>ADK의 <strong>주요 기능</strong>은 다음과 같다:
    <ul>
      <li><strong>인스트럭션 기반의 작업 위임</strong>: 프롬프트만 입력하면 에이전트가 필요에 따라 서브 에이전트에게 작업을 위임하거나 특정 툴을 호출한다.</li>
      <li><strong>쉬운 검색 연동</strong>: 구글의 Vertex AI Search나 Vertex AI의 RAG 엔진을 쉽게 붙일 수 있어 검색 부분 구현이 매우 용이하다.</li>
      <li><strong>LLM 에이전트</strong>: 동적 추론을 통해 요청에 따라 전문화된 서브 에이전트에게 작업을 넘기는 것이 가능하다 (예: 수학 계산 에이전트가 소수점 계산은 더 똑똑한 에이전트에게 위임).</li>
      <li><strong>워크플로우 에이전트</strong>: 비즈니스 로직 처리를 위해 순차적, 병렬적, 루프 기반의 프로세스를 정의할 수 있다. 이는 LLM의 동적 추론만으로는 부족한 부분을 보완하여 에이전트의 안정적인 동작을 보장한다. 프로젝트에서는 LLM 에이전트와 워크플로우 에이전트를 혼합하여 설계하고 구현하는 경우가 많다.</li>
    </ul>
  </li>
</ul>

<p><strong>에이전트 개발의 평가 및 안정성</strong></p>

<ul>
  <li>에이전트 개발에서 <strong>평가는 가장 중요한 부분</strong> 중 하나이다.</li>
  <li>ADK는 <strong>세션 관리, 장기 기억(Long-term Memory), 이밸류에이션(Evaluation)</strong>과 같은 기능을 기본적으로 제공하여 개발자가 직접 구현해야 할 노력을 줄여준다.</li>
  <li><strong>에이전트 평가</strong>는 단순히 정답을 맞추는 것을 넘어, <strong>설계 의도대로 플로우를 따랐는지, 정확한 도구를 호출했는지</strong> 등을 확인하는 것이 중요하다.</li>
  <li>ADK는 특정 쿼리에 대해 에이전트가 따라야 할 경로(트랙토리)를 정해 놓고 이를 따르는지 평가하는 <strong>경로 트랙토리 평가</strong>를 지원한다.</li>
  <li>자연어 아웃풋 평가 시에는 로그 매트릭(Log Metric)이나 <strong>LLM을 심판(Judge)으로 활용하는 방식(LLM as a Judge)</strong>을 사용한다. LLM을 심판으로 활용하면 사람이 평가하는 것과 거의 차이 없는 정확도를 보이며, 특히 개발 단계에서 매우 유용하다.</li>
  <li>ADK Dev UI는 <strong>시각적인 디버깅</strong>을 제공한다. 요청 시 어떤 에이전트에게 위임되었는지, 어떤 툴을 사용했는지 등을 그래프 형태로 시각적으로 확인할 수 있으며, 트레이싱 정보도 제공하여 디버깅을 편리하게 한다. 또한 멀티모달(이미지, 비디오 처리) 및 스트리밍 처리도 지원한다.</li>
</ul>

<p><strong>에이전트 간 통신 표준: A2A (Agent-to-Agent)</strong></p>

<ul>
  <li>에이전트가 많아지면 <strong>서로 다른 에이전트 간의 인터페이스 문제</strong>가 발생할 수 있다.</li>
  <li>앤트로픽(Anthropic)이 발표한 <strong>MCP(Model Context Protocol)</strong>는 LLM의 한계를 보완하기 위해 외부 툴 사용을 쉽게 하는 개방형 프로토콜로 빠르게 확산되었다. 이는 기존 OpenAI의 펑션 콜링(Function Calling)이 GPT 생태계 내에서 폐쇄적으로 이루어진 것과 달리, 서버-클라이언트 개념을 차용하여 개발자에게 익숙하고 개방적이라는 점에서 큰 주목을 받았다.</li>
  <li>구글은 MCP의 부상 당시 외부의 우려에도 불구하고, MCP를 포괄하는 <strong>더 큰 생태계를 만드는 청사진</strong>을 가지고 <strong>A2A라는 개방형 프로토콜</strong>을 개발하고 있었다.</li>
  <li>A2A는 에이전트 간 소통을 위한 <strong>개방형 프로토콜</strong>로, 구글 독점 기술이 아니라 여러 회사와 협력하여 발표되었다. 이는 A2A가 MCP처럼 널리 퍼질 수 있는 가능성을 시사한다.</li>
</ul>

<p>결론적으로, ADK는 에이전트 개발을 쉽고 빠르며 프로덕션 수준으로 안정적으로 만들 수 있도록 지원하며, A2A는 에이전트 시대에 필수적인 에이전트 간 통신 표준이 될 것으로 기대된다.</p>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>말 그대로다.</p>

<p>AI 를 이제 슬슬 제대로 공부해야 하고, 배경지식에서 넘어서서 필요한 기술 스택을 배우고, 특히나 내가 중점적으로 생각하는 영역을 학습해야 할 때가 왔다고 생각한다.</p>

<p>그리고 그런 것들을 가능케 하는 도구들, 그 중에도 구글의 입장을 대변하는 것이 오늘 팟캐스트를 통해 들은 내용이다.</p>

<p>이러한 플랫폼으로 어떻게 고객을 먼저 잡는가, 그리고 거기서 개발이 얼마나 편리하게 될 수 있고, 개발 과정이 ‘예측 가능한가’의 강점을 어필할 수 있냐는 항상 AI 라는 혁신의 수면 아래에 잠잠하게 숨겨진 근본적인 한계치 였다.</p>

<p>ADK와 그 내부의 평가 절차, gui 화를 통해 조금이라도 쉽고, 명료하게 개발하며,  A2A 등의 존재를 통해 AI 를 적극 제어한다… 등 특히나 확률적인 답변이 정말 의도대로 동작하는가 라는 차원의 문제를 해결하기 위한 구글의 나름대로의 해결책이며, 특히나 모델이 제대로 이해했는가를 평가하기 위해선, 결국 ‘해야할 일을 수행할만한 수준의 AI’에다가, 그 AI의 상황 업무를 판단, AI가 적절했는가를 평가하는 것이 필요하다는, 현재의 구조의 최대의 맹점을 보여주고, 인정하며, 해결하는 구글의 나름의 방식을 제시한 것 같다.</p>

<p>ChatGPT 5 가 처음 나왓을 때, 샘 알트만은 라우팅 처리가 자연스러워서, 필요한 순간 적절한 사이즈의 모델로 답을 해주겠다. 모델을 고를 필요는 없다- 라고 말했었다. 이것이 OpenAI 식의 LLM 이 가지는 근본적인 문제의 대답이었다.</p>

<p>하지만 ChatGPT 는 여전히 그 통제가 사람들이 원하는 수준이 안되었고, 그 결과 사람들에게 내리는 답변의 질, 그리고양 어느 면에서도 납득을 시키지 못해, 결국 슬그머니 다시 기존의 방식으로 돌아갔었다.(아마도 언젠간 다시 라우팅을 시도하지 않을까?)</p>

<p>그만큼 이 일은 매우 까다롭고 어려운데, 결국 이러한 한계를 개선하려면 정확하고, 적절한 평가 체계가 준비되어 있어야 하며, 무엇보다 그 평가체계가 CICD 과정에 통합되어야 개발은 쉬워진다.</p>

<p>그리고 결정적으로 구글이나, OpenAI, 다른 경쟁자들의 이러한 플랫폼 경쟁, 개발 친화 경쟁은 뭘 의미할까?</p>

<p>궁극적으로 신뢰성 + 비용 개선 이 두가지가 핵심이 아닐까 생각해본다.</p>

<p>LLM은 훌륭한건 사실이다. 인프라도 점점 싸질거다. 하지만 여전히 비싸고, 여전히 그 한계와, 사용성 대비 ‘비즈니스’로 취급하기엔 다른 기업들 입장에서 쉽지는 않다는 게 현실이다. 성능면에서나, 자원면에서 적절하게 리소스 분배- 라는 차원으로 사람의 통제하에 있지 못한 면도 여전히 존재한다. 그러한 점에서 통제력을 키우고, 개발자의 의도대로 움직이며, 오히려 더 기계적이게 정확한 인풋에 대해 정확한 답을 내리기, 그리고 그 과정에서 리소스는 최소화하기 - AGI 를 지향하고 가면서도, 소버린 AI 와 같이 안보 차원에서도 적극적인 것에 함께 더불어서 기업이란 관점에서 본다면 ‘최적화’ 와 ‘비용개선’이라는 표면화 하기 어려운 영역에 대해 개선하고 싶은게 아닐까?</p>

<p>그렇기에 생각하건데, 필요한 건 DevOps 관점의 기술과, AI 기술 두가지의 융복합은 필수라고 생각한다.</p>

<p>AI 개발자들의 티오를 보더라도, 1티어를 제외한 나머지 AI 개발자는 사실상 갈 곳이 없다. 그렇다고 백엔드 개발만 해서도 요즘의 시장에서 먹히지 않는 것을 볼 수 있었다.</p>

<p>그런데 또 대담을 하다보면 AI 개발자가 백엔드지식을 이해하고 접근하시는 분도 분명 있지만, 그렇지 않은 분도 월등히 많다는 사실 또한 알 수 있었다.</p>

<p>AI 를 통해 내가 기본적으로 해야할 백엔드 역량을 매우 빠르고, 정확하게 접근할 수 있게 되었으니, 나의 능력을 어디에 쏟아야 할까? 결국 구글이 제시하듯, LLM 의 리소스를 잘 분배하거나, 평가를 통해 요구되는 사항에 최적화된 기능을 제공하고, 궁극적으로 비용 절감이나, 비용 만큼의 신뢰있는 서비스화 할 수 있는가? 그게 내가 생각하는 다음 내 인계점(Inflection Point)이 아닐까 생각한다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">memo - blog utterance setting 차이 정리</title><link href="http://0.0.0.0:4000/tools/2025/08/18/01-utterance-setting-issue.html" rel="alternate" type="text/html" title="memo - blog utterance setting 차이 정리" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/tools/2025/08/18/01-utterance-setting-issue</id><content type="html" xml:base="http://0.0.0.0:4000/tools/2025/08/18/01-utterance-setting-issue.html"><![CDATA[<h2 id="댓글-이상하다-뭐지">댓글 이상하다… 뭐지?</h2>

<p>댓글이 달렸다. 기술 블로그 운영할 때 정말 가뭄에 콩나듯, 아직 댓글이 많지는 않지만, 와주시는 것만으로도 감사한데…</p>

<p>문제는 이상하다..</p>

<p>알고보니 모든 댓글이 모든 글에 보인다..!</p>

<p>이상하여 분석하고 정리한 내용이다.</p>

<hr />

<h2 id="utterances-댓글-통합-문제-해결">Utterances 댓글 통합 문제 해결</h2>

<h3 id="원인-분석">원인 분석</h3>

<p>원인은 Jekyll 설정 파일(<code class="language-plaintext highlighter-rouge">_config.yml</code>)의 Utterances <code class="language-plaintext highlighter-rouge">issue_term</code> 설정에 있었다.</p>

<p>기존 설정은 <code class="language-plaintext highlighter-rouge">issue_term: "blog-comment:"</code>로 되어 있었는데, 이는 모든 페이지가 ‘blog-comment:’라는 단 하나의 GitHub Issue를 공유하도록 만든다. 따라서 어떤 글에서 댓글을 달아도 모두 같은 Issue에 저장되어 모든 글에 동일하게 표시되는 것이고 이렇게 되면 어느 글에 댓글을 단 건지 확실히 알기 어렵다 ㅠ..</p>

<p><img src="/assets/images/posts/2025-08/2025-08-18-002.png" alt="" /></p>
<blockquote>
  <p>설마 다른 글로 공유가 될 줄은 몰랐다.</p>
</blockquote>

<h3 id="해결-방안">해결 방안</h3>

<p>이 문제를 해결하기 위해 알아본 결과… gemini 왈 + 검색 결과, 해당 설정의 <code class="language-plaintext highlighter-rouge">issue_term</code> 값을 각 페이지의 고유한 URL 경로를 사용하도록 변경해야 한다.</p>

<ul>
  <li><strong>기존 설정:</strong> <code class="language-plaintext highlighter-rouge">issue_term: "blog-comment:"</code></li>
  <li><strong>변경할 설정:</strong> <code class="language-plaintext highlighter-rouge">issue_term: "pathname"</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">pathname</code>으로 설정하면, Utterances는 각 게시물의 고유 URL 경로(예: <code class="language-plaintext highlighter-rouge">/2025/08/18/post-A.html</code>)를 제목으로 하는 별도의 GitHub Issue를 생성하고 연결한다.</p>

<p><img src="/assets/images/posts/2025-08/2025-08-18-003.png" alt="" /></p>
<blockquote>
  <p>깔끔하게 해결 완료</p>
</blockquote>

<h3 id="나름-블로그-jekyll-공부-하고-했다는건데">나름 블로그 jekyll 공부 하고 했다는건데..</h3>

<p>아직 부족한게 넘 많다… 화려한 스펙이라고 할만하려면 더 능통해야하는데, 막상 다른 사람들 사이에서 보면 뭐 이리 모르는게 많은지! 🤣</p>]]></content><author><name>Paul2021-R</name></author><category term="tools" /><category term="생각정리" /><category term="학습" /><category term="blog" /><summary type="html"><![CDATA[댓글 이상하다… 뭐지?]]></summary></entry><entry><title type="html">나의 설명서를 정리는 했던가?</title><link href="http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/08/12/00-what-is-my-introduction.html" rel="alternate" type="text/html" title="나의 설명서를 정리는 했던가?" /><published>2025-08-12T00:00:00+00:00</published><updated>2025-08-12T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/08/12/00-what-is-my-introduction</id><content type="html" xml:base="http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/08/12/00-what-is-my-introduction.html"><![CDATA[<h2 id="나는-내-설명서를-갖고-있는가">나는 내 설명서를 갖고 있는가?</h2>

<p><a href="https://www.youtube.com/watch?v=d07JauBUt5g"><img src="https://i.ytimg.com/vi/d07JauBUt5g/hq720.jpg" alt="비디오 제목" /></a></p>

<p>김경일 교수님은 해당 유튜브 영상에서 다양한 심리적 문제와 대처 방안에 대해 통찰력 있는 내용의 강의를 자기 개발 차원에서, 숨 고르기 용으로 보았다. 그런데 생각보다 정말 괜찮은 내용들이 많았고, 그 생각들을 정리해두는게 나에게 정말 필요하겠구나 싶어 이렇게 정리해본 글이다.</p>

<h2 id="내-생각들">내 생각들</h2>

<h3 id="철학이-없는-사람이-무섭다">철학이 없는 사람이 무섭다</h3>

<p>확실히 나도 느낀 적이 있다. 자기 가치가 명확하지 않거나, 이익 추구형인 사람들을 종종 보게 되면, 그들의 입에서 나오는 이야기가 대단히 위험한 케이스. 내지는 소위 ‘가스라이팅’이 얼마나 심한지.</p>

<p>그리고 그런 이들의 이야기를 믿으면 안된다는 생각을 정말 심하게 했던, 내가 당했던 때들. 참 신기한게 그런 수단과 방법을 가리지 않는 이들의 이야기가 꼭 순간순간 솔깃 하게 들릴 때가 있던 건, 어쩌면 그때의 나는 여전히 가치 기준이 미흡하고, 관점의 흐릿함이 함께 있던게 아닌가, 그렇게 생각해본다.</p>

<p>특히나 나의 마음이 어떻게 안정을 찾아야 할지 모르던 청년, 20대의 시기, 그 시기는 결국 내가 어디가 부족한지를 이제 다시 한 번 보여준다 생각이 든다. 근거 없는 무서움, 근거 없는 불안감 속에서 나는 잘못된 이야기들, 잘못된 종교관, 특히나 마치 ‘이렇게만 하면 된다’ 라는 말이 얼마나 말이 안되는지를 깨닫게 되었을 때, 그때가 이런 내용에 드디어 공감할 수 있었던 게 아닌가 싶다.</p>

<h3 id="나르시즘-감정-배설-가스라이팅">나르시즘, 감정 배설, 가스라이팅</h3>

<p>교수님의 이야기 속에서도 특히나 안타까운 부분, 즉, ‘이용 당하는데’ 라는 제 3자의 시각을 인정하지 못하고, 그들의 이용을 다른 감정이나, 다른 표현으로 만들어 이해하려는 사람들. 그들에 대한 이야기를 할 때면 몇몇 스쳐지나가는 것을 느낄 수 있었다.</p>

<p>사랑이란 이름으로, 우정이란 이름으로, 동정이나 공감이란 이름으로, 사람에게 자신의 욕구에 맞춰 사람을 활용하는 행위는 그게 얼마나 지독한지, 얼마나 상대에게 나중에 후유증으로 남는지를 알 필요는 있지만… 문제는 역시 그걸 당하는 이들이 거기에 대해 참 신기하게도 저항하는 사람이 아니라, 이용 당하기 좋은 케이스의 사람이 또 그런 기묘한 관계가 된다는 것이, 참 안타까운 대목이 아닐까 싶다.</p>

<p>과거에 기독교 공동체에 있을 때도 그런 분이있었다. 상대를 웃기기 위해 자기 ‘밑’이라고 생각하는 이에 대해 무조건적인 광대 역할을 요구했고, 장난을 치면서 웃고 떠들게, 사람들 전체의 웃음을 유도하는 것 자체가 악의는 아니었지만, 그걸 당한 이들 중에 상처가 심한 이들도 발생했던 걸 떠올려 본다면, 여러 생각을 들게 하는 대목이었고, 요즘도 심심치 않게 보인다는 점에서 그런 행동이 얼마나 좋지 않은지 - 새삼 느끼게 되는 것이 있다.</p>

<h3 id="그러는-와중에-느끼는-바-진짜-성장-진짜-학습을-시킨다는-의미는">그러는 와중에 느끼는 바, 진짜 성장, 진짜 학습을 시킨다는 의미는</h3>

<p>그런 점에서 ‘나의 성장’ 동시에 누군가를 ‘성장시킨다’ 라는 의미에 대해, 특히 자녀 교육에 대하여서는 요즘 특히나 고민을 하게 만드는 영역인데, 정말 쉽지 않구나, 준비를 잘 해야하는 구나 라는 생각을 했다.</p>

<p>나의 어린 시절을 떠올리더라도, 가치가 성립 되기 전, 한 마디 한 마디, 감정 표현을 가능하게 만드냐 아니냐를 몰랐기에 했던 오해들을 생각해본다면… 진짜 잘 준비하고 많은 고민 속에서 이루어지는게 필요하지 않나 생각이 든다.</p>

<p>진짜 존중이 뭘까? 사람들과 만나고, 그들과 제대로 선한 영향력을 행사하고, 그러면서도 사회에서 내가, 조직이, 체계가 처한 현실에서 제대로 존중하고 존중 받는 것, 그게 행복할 텐데라고 고민하지만, 막상 그걸 위한 나만의 확고한 태도가 있냐? 하다못해 내 자식들, 내 가족을 나는 존중하나? 라는 생각에서 교수님의 이야기는 반드시 체화할 영역이라고 생각한다.</p>

<h3 id="결국-자신을-제어하는-방법은">결국 자신을 제어하는 방법은</h3>

<p>언제부터 나는 나의 관리를 잘했나?</p>

<p>사실 이 질문에 대해 이제는 좀 희미해진 기억을 갖고 있다. 공부, 역할, 임무, 나의 성장 과정에서 나는 생각해보면 그렇게 잘한다고 불리게 된 것이 썩 처음부터는 아니었다.</p>

<p>중학교 2학년 끝날 때 즈음, 조금 씩이었고, 대학교 때도 생각해보면 ‘완벽’은 아니었다.</p>

<p>그럼에도 한 가지 이야기 할 수있는 사실은, 대학생 때 이후, 나의 감정을 이해하고 나의 감정을 어떻게 조절할지 그것을 체득한 이래로 나의 학습도, 작업도, 그리고 무엇보다 계획을 실행하는 능력에서는 나름 자신감이 생긴 것을 느낄 수 있었다.</p>

<p>그런데 그럴 때 느꼈던, 그리고 내 스스로의 방법이 뭐냐! 라고 할 때 생각했던 문구가 바로 ‘자신 설명서’ 라는 것이었다. 호불호, 내가 효과적일 시간을 활용한다, 계획해서 수행한다, 그리고 거기서 그렇게 생각할 수 있는 이유는 ‘싫다’와 ‘좋다’를 확실하게 말하면서 결정하게 된 것. 그것이 내가 일을 판단하는 것이 남들보다 명확해졌던 이유이자, 결론에 따라 행동을 확실하게 하게 된 계기였다.</p>

<p>그리고 오늘 교수님의 이야기는 그런 나의 생각에 상당히 부합하면서도, 좀더 들어가야 함을 깨달았다. 작업 시작의 부담을 줄이는 방법을 사용하고, 가장 나의 최적 시간을 판단하고 고민한 뒤 그것에 기반해서 해야 한다.</p>

<p>그러려면 나에 대한 메타인지가 있어야 하는데, 이는 결국 시간표를 계획해보고, 계획 과정에서 ‘나란 놈’을 인지해서 어떻게 하면 ‘할 수 있는지’에 맞춰 나를 설계한다. 결국 말은 쉽지만 객관성이란 잣대 부터 위험한 잣대기도 하고, 그렇게 얻은 생체 데이터가 맞는지, 오히려 훈련이 필요한 부분도 있지 않을까? 그렇게 생각하면 머리가 아파오지만… 그럼에도 확실히 그것이 필요함은 느껴졌다.</p>

<p><img src="/assets/images/posts/2025-08/2025-08-12-002.png" alt="" /></p>
<blockquote>
  <p>ChatGPT 5 괜찮긴 하다..</p>
</blockquote>

<p>Gemini 는 시간 데이터로 판단이 불가능하다고 하여 요최근 다시 쓰기 시작한 ChatGPT 를 기준으로 대화 내역으로 나의 활동 상황, 특히나 내 대화를 기반으로 어떤 지적 활동을 몇시에 하는지 분석해보았다.</p>

<p>아주 단편적인 정보라 절대 ‘결과’나 ‘통찰’로 취급하면 안되지만 ChatGPT 왈,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) 오전에는 라이트한 일, 계획에 대한 결정 등을 주로 수행하고
2) 3시부터 개발이나 복잡한 실무적 이야기를 특히 많이 하는데, 그 때도 4시가 가장 피크를 이루며(지적 활동 극대화)
3) 오후에는 10시가 되면 희안하게 중대한 결정, 고민 등을 결정한다(결정활동 위주로 수행)
</code></pre></div></div>

<p>라고 이야기 했다.</p>

<p>결국 업무의 배치, 생산성, 미래에 목표를 이루기 위해선 이런 나의 특성을 이해한 계획, 이해한 목표와 실천의 연속이 결과를 낼 수 있으리라, 그렇게 생각하니 확실히 나의 계획이나 일정 진행 과정을 잘 기록하고 메타데이터화 하는게 필요하다는 사실에 확신을 얻을 수 있었다.</p>

<h3 id="인사이트-그리고-성장">인사이트 그리고 성장</h3>

<p>지식 인사이드라는 채널에서, 소통과 성장에 대해 이야기를 들을 때면 ‘똑똑해진 것 같은 기분’을 느껴, 이것도 중독인가 싶어 불안하긴 하지만(ㅋㅋㅋ)</p>

<p>그럼에도 영상을 곱씹어 보는 이유. 결국 다음 성장, AI 와 함께 하는 ‘인간’으로 어떤 것들을 갖춰야 나는 전문가가 될 수 있을까, 그것에 대한 답을 오늘 다소 얻은 것 같다.</p>

<p>나의 몸, 나의 마음을 제어하는 것, 그리고 그 중간에는 나의 정체성이 명확한게 핵심이며, 그렇게 되면 자신에 대한 제어도, 거짓말이나, ‘개소리’에 대한 판단도 할 수 있으며, 결론적으로 진짜 결정, 목표, 그리고 나아가서 삶에서 ‘일’을 성공적으로 해나갈 수 있으리라 생각해본다.</p>

<p>아직 감정도, 해야할 일들도 다 이해한 건 아니지만… 이런 시간과 기회, 고민할 상황을 얻어낸 것에 대단한 감사를 느낀다.</p>

<p>몸 아픈것도 해결 되었으니… 이젠 다이어트와 함께 AI + 그리고 백엔드 기술 연마에 힘써야겠다.</p>

<h2 id="영상-요약-내용">영상 요약 내용</h2>
<ul>
  <li><strong>성품의 변화와 얼굴의 드러남</strong>:
    <ul>
      <li>젊은 시절과 현재의 얼굴을 비교하면 사람의 성품을 상당 부분 파악할 수 있다고 본다. 이는 타고난 성격이 아니라 다듬어지는 성품과 관련이 있다. 40세가 넘으면 자신의 얼굴에 책임을 져야 한다는 말도 일리가 있다고 보았다. 특히 SNS 발달로 과장되거나 연출된 모습이 오히려 성품의 문제를 드러내는 함정이 될 수 있다고 경고했다.</li>
    </ul>
  </li>
  <li><strong>타인 파악 방법</strong>:
    <ul>
      <li>대화를 통해서는 상대방의 거짓을 알아내기 어렵다. 대화 시에는 목적이 있어 다른 가능성을 열어두지 않기 때문이다. 대신 <strong>목적 의식 없는 관찰</strong>이 사람을 파악하는 데 훨씬 유리하다고 강조했다. 말콤 글래드웰의 주장을 인용하며, 사업 파트너를 파악할 때 사업과 무관한 제3자를 데려가 관찰하게 하는 것이 도움이 된다고 설명했다.</li>
    </ul>
  </li>
  <li><strong>‘개소리(Bullshit)’의 심리</strong>:
    <ul>
      <li>진실이 아닌 것을 알면서 하는 거짓말보다, <strong>진심으로 헛소리(개소리)를 하는 사람에게 대응하는 것이 더 어렵다</strong>고 말한다. 거짓말은 팩트 체크에 무너지지만, 개소리는 진실에 관심이 없기 때문이다. 이는 사이비 종교를 믿는 것과 같은 심리적 방식이며, “내 마음이 중요한 거야”라고 주장하는 교주의 심리와 유사하다고 설명한다. 누구나 마음이 상하면 개소리를 할 수 있으며, 자신의 상한 마음이 중요하다는 점을 스스로 알아차리지 못할 때 이러한 현상이 발생한다고 보았다.</li>
    </ul>
  </li>
  <li><strong>개소리에 대한 저항 능력</strong>:
    <ul>
      <li>개소리를 하는 사람에게 직접 “헛소리”라고 바로잡아주면 오히려 화를 내기 때문에 통하지 않는다고 한다. 개소리에 흔들리지 않기 위해서는 어떤 사안이나 현상에 대한 <strong>자기 정의(self-definition)를 명확히 하는 것이 중요</strong>하다고 강조했다. 자기 정의가 없는 사람들은 ‘존재론적 착각’에 빠져 표피적인 특성에 쉽게 현혹되며, 이는 교육 수준이나 소득 수준과 무관하게 발생할 수 있다고 경고했다. 자신의 삶의 중요한 부분(돈, 집, 가족, 사랑, 성공 등)에 대해 끊임없이 정의를 내리고, 이를 타인과 공유하며 정교화하는 과정이 필요하다고 제안했다.</li>
    </ul>
  </li>
  <li><strong>나르시시스트 대처법</strong>:
    <ul>
      <li>나르시시즘은 자신이 잘난 것보다 <strong>남이 못나야 더 중요하다고 생각하는 특징</strong>을 가진다. 나르시시스트는 가까이하지 않는 것이 좋지만, 피할 수 없는 관계라면 다음과 같이 대처할 것을 조언한다:
        <ul>
          <li><strong>자신이 그 사람과 친하지 않음을 명시</strong>하여 악의적인 소문이 정당성을 얻지 못하게 해야 한다.</li>
          <li>리더의 경우, 나르시시스트를 <strong>절대 독대하지 말아야 하며</strong>, 실적이나 공을 칭찬할 때는 <strong>여러 사람 앞에서 칭찬</strong>해야 한다.</li>
          <li>조직의 상은 <strong>리더의 이름을 빼고 조직의 이름으로 수여</strong>해야 나르시시스트적 욕구를 자극하지 않고 상의 신뢰도와 생명력을 높일 수 있다고 설명한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>고민 상담을 빙자한 감정 배설자 대처</strong>:
    <ul>
      <li>필요에 의해 가해하고, 반대로 그걸 다시 자신을 위해 상대의 요청에 거절하지 못한다.
        <ul>
          <li><strong>전략적으로 타인을 옴짝달싹 못 하게 하려는 경우</strong>: 거의 소시오패스에 가까우므로 피해야 한다.</li>
          <li><strong>상담자를 대안으로 삼는 경우</strong>: 상대방의 이야기를 끊지 않고 들어주되, “<strong>아 그러니까 네 말은 이런 거구나</strong>“와 같이 <strong>요약 질문을 반복</strong>하여 상대방이 불편함을 느끼게 함으로써 이야기를 줄이도록 유도할 수 있다.</li>
          <li><strong>감정 배설의 도구로 삼는 경우</strong>: 불안형에 해당하며, 자신을 부정하고 타인을 긍정하는 경향이 있다. 이 경우, <strong>가벼운 욕설 사용</strong>이나 <strong>거리두기</strong>를 통해 자신이 함부로 배설할 대상이 아님을 알리고, 공유 면적을 줄여나가는 것이 중요하다고 보았다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>‘어른 아이(Adult Child)’ 대처법</strong>:
    <ul>
      <li>어른 아이는 성인이 되어서도 감정 조절이 어려운 사람들이다. 이는 성장 과정에서 부모가 아이의 감정을 대신 느끼거나 감정 표현을 아예 막았기 때문에 발생한다고 보았다. 부모는 아이가 자기 감정을 먼저 드러내게 하고, <strong>감정을 표현할 기회를 주되 적절한 감정의 크기를 가르쳐야 한다</strong>고 조언했다.</li>
      <li>어른 아이를 대처하는 방법으로는 <strong>물리적으로 떨어져서 이야기하기</strong>, <strong>말을 느리게 하여 화를 누그러뜨리기</strong>, 상대방의 격한 말을 “<strong>아, 그러니까 선생님 말씀은 그 거지 같은 놈들이 선생님한테 찾아와서 개 같은 짓을 하셨다는 얘기죠?</strong>“와 같이 <strong>거울처럼 따라 해 객관화</strong>시키는 방법을 추천한다.</li>
    </ul>
  </li>
  <li><strong>실패 수용과 ‘사후 확증 편향’ 극복</strong>:
    <ul>
      <li>작은 실수를 ‘인생 망했다’고 받아들이는 것은 과거의 상처가 한꺼번에 터지는 경우라고 본다. 타인의 실패에 대해 “내 그럴 줄 알았어”라고 말하는 것은 <strong>‘사후 확증 편향(hindsight bias)’</strong>을 유발하여 학습과 개선을 방해하고 회피하게 만든다고 경고했다. 성장을 위해서는 사소한 실수라도 흔쾌히 인정하고 솔직히 고백하는 문화가 필요하며, 이를 위해 <strong>자신만의 시그니처 행위나 멘트를 만들어 유쾌하게 실수를 인정하는 것</strong>이 도움이 된다고 제안했다.</li>
    </ul>
  </li>
  <li><strong>게으름에 대한 재해석 및 생산성 향상</strong>:
    <ul>
      <li>게으름은 천성이라기보다는 <strong>상황적 요인</strong>과 <strong>‘트리거(trigger)’ 부재</strong>로 인해 발생하는 경우가 많다고 보았다. 한국인의 뇌는 본래 근면 성실하므로, 자신을 게으르다고 생각한다면 상황 단서를 찾지 못하고 있을 가능성이 크다고 설명한다.
        <ul>
          <li><strong>생산성 높은 사람들의 특징</strong>: 자신이 <strong>언제, 무엇을, 어디서 잘하는지</strong>에 대한 상황 단서 데이터를 기록하고 활용한다.</li>
          <li><strong>작업 시작의 부담 극복</strong>: 큰 작업을 통째로 시작하려 하지 말고, <strong>가장 쉬운 첫 단계(예: “책만 펴자”, “연필만 올려놓자”)만 설정</strong>하여 부담을 줄이고 자연스럽게 다음 단계로 나아가게 유도해야 한다.</li>
          <li><strong>‘게임화’ 전략</strong>: 세밀하게 나눈 계획(예: 페이지 단위, 분 단위)을 통해 <strong>진도감</strong>을 느끼고 <strong>성취감</strong>을 얻는 것이 몰입에 도움이 된다고 설명한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>아침형/저녁형 인간과 업무 배치</strong>:
    <ul>
      <li>심리학적으로 아침형 인간과 저녁형 인간이 분명히 존재하며, 각자 <strong>지적인 능력이 최고조에 달하는 시간대가 다르다</strong>고 한다. 한국 사회는 이른 등교 및 출근 문화로 인해 저녁형 인간에게 불리한 면이 있다고 지적했다.
        <ul>
          <li><strong>자신의 최적 시간대 파악</strong>: 매일 밤 잠들기 전 자신의 말, 행동, 기분에 점수를 매기고 어제 몇 시에 자서 몇 시간 잤는지 6개월 정도 기록하면 자신에게 <strong>가장 활발한 ‘아침’이 언제인지</strong> 알 수 있다고 조언한다.</li>
          <li><strong>효율적인 하루 시간표</strong>:
            <ul>
              <li><strong>오전(뇌가 가장 각성된 시간)</strong>: 깊은 생각, 결정, 새로운 정보 처리 등 높은 집중력이 필요한 일을 배치해야 한다. 루틴한 일은 낭비라고 보았다.</li>
              <li><strong>오후(뇌가 지쳐 있는 시간)</strong>: 익숙하고 반복적이며 루틴한 일을 배치하는 것이 효율적이다. 지쳐 있을 때 자동화된 일을 잘하기 때문이다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>미래 목표 설정 및 직업 선택</strong>:
    <ul>
      <li>청년들이 지나치게 구체적인 미래 목표(예: “35세에 35평 아파트”)를 설정하여 좌절하는 경우가 많다고 보았다.
        <ul>
          <li><strong>동사형 목표 설정</strong>: 먼 미래의 목표일수록 <strong>명사나 숫자가 아닌 동사형(예: “나는 40살에 내가 원하는 곳에서 중심적인 위치가 될 거야”)으로 설정</strong>하여 유연성과 대안을 확보해야 한다고 강조했다.</li>
          <li><strong>적성은 ‘행위’에 있다</strong>: 직업이나 분야가 아닌 ‘어떤 행위’에 재능이 있는지를 찾아야 한다고 한다. 예를 들어, 김경일 교수님은 새로운 정보를 알려주는 것보다 과거의 성공과 실패 이유를 일깨워주는 ‘행위’에 특화되어 있다고 설명했다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>직업 만족도와 기업 문화</strong>:
    <ul>
      <li>많은 사람들이 자신이 회사에서 무엇을 왜 하는지 모르고 일에 재미를 느끼지 못하는 현실을 지적하며, <strong>기업 문화를 중요하게 봐야 한다</strong>고 강조한다.
        <ul>
          <li>기업은 돈이나 서열이 아닌 <strong>‘이런 문화가 있다’는 것을 정확하게 알려야 하며</strong>, ‘녹서(Green Paper)’와 같은 형태로 회사 내에서 주고받는 질문들을 공유하여 지원자가 문화를 짐작할 수 있도록 해야 한다고 제안했다.</li>
          <li>사람들이 직장이나 배우자를 선택할 때 <strong>감정을 약속하기보다 행동을 약속해야 한다</strong>고 니체의 말을 인용하며 강조한다. 감정은 변하면 수정 불가능하지만, 행동은 수정, 용서, 만회가 가능하기 때문이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>일에서 즐거움 찾기 (게임화)</strong>:
    <ul>
      <li>일, 공부, 훈련은 본래 뇌에서 즐겁게 인식하지 않는 ‘노동’이지만, <strong>‘게임’처럼 만들어 ‘몰입’하면 즐겁다고 착각</strong>할 수 있다고 말한다. 몰입을 통해 <strong>‘성장감’</strong>을 느끼는 것이 중요하며, 일이 재미없게 느껴지는 것은 전문가가 되어 더 이상 실력이 급격히 늘지 않는 정체기일 가능성이 크다고 보았다. 이럴 때에는 <strong>‘직무 변경’</strong>을 통해 새로운 성장을 도모하고 업무를 확장하는 것이 안전하고 효과적인 방법이라고 추천한다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="생각정리" /><category term="자기개발" /><category term="심리" /><summary type="html"><![CDATA[나는 내 설명서를 갖고 있는가?]]></summary></entry><entry><title type="html">AI Breakfast S2 Ep 2 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/08/11/00-AI-trend-with-google-s2-02.html" rel="alternate" type="text/html" title="AI Breakfast S2 Ep 2 생각정리" /><published>2025-08-11T00:00:00+00:00</published><updated>2025-08-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/11/00-AI-trend-with-google-s2-02</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/11/00-AI-trend-with-google-s2-02.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=1ZO6C8itatI"><img src="https://i.ytimg.com/vi/1ZO6C8itatI/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<ul>
  <li><strong>생성형 AI 모델의 발전</strong>: 미디어를 생성하는 모델인 <strong>Veo (베오)가 어드밴스드 모델로 출시되어 동영상 품질을 크게 향상시켰다</strong>. 이전에는 텍스트로만 동영상을 제어하기 어려웠으나, 이제는 <strong>이미지를 기반으로 동영상을 제작하여 등장인물의 일관성을 유지할 수 있게 되었다</strong>. 또한, 이미지를 생성하는 <strong>Imagen (이마젠)</strong>이나 음악을 생성하는 <strong>Lyra (리라)</strong>와 같은 모델들은 몇 번의 프롬프트 엔지니어링만으로도 손쉽게 콘텐츠를 생산하여 <strong>기업의 생산성 향상 및 비용 절감에 기여한다</strong>.</li>
  <li><strong>AI의 일관성 및 신뢰도</strong>: AI 기술에서 <strong>일관성</strong>은 답변의 신뢰성을 보장하는 중요한 허들이다. 이는 <strong>할루시네이션(환각 현상)과도 연관</strong>되며, 텍스트 기반 모델(LLM)에 시드(seed) 정보를 넣어 <strong>동일한 질문에 유사하고 일관된 답변이 나오도록 모델 개발에 중점을 두고 있다</strong>.</li>
  <li><strong>개발 생산성 향상</strong>: <strong>Gemini Code Assistant (제미나이 코드 어시스턴트)</strong> 2.5 버전이 출시되어 개발자들의 생산성을 높이는 데 기여한다. 이 도구는 <strong>문서 작업을 대신 생성</strong>하고, <strong>에러를 잡는</strong> 데 유용하며, <strong>멀티턴 대화</strong>를 통해 질문에 대한 추가 질문을 할 수 있어 효율적이다. 궁극적으로 개발자들이 반복적인 코딩 작업보다는 <strong>소프트웨어 아키텍처 설계와 디자인에 집중</strong>할 수 있도록 돕는 것이 주된 목적이다.</li>
  <li><strong>AI의 역할 변화</strong>: AI는 인간을 대체하는 것이 아니라 <strong>어시스턴트로서 활용되어야 한다</strong>는 관점을 제시한다. 과거에는 AI가 불가능하다고 여겨졌던 <strong>그림 그리기, 사진 만들기, 코딩과 같은 창의적인 영역에 AI가 먼저 도전하고 있다</strong>.</li>
  <li><strong>워크스페이스 기능 강화</strong>: Google Workspace (구글 워크스페이스)에도 다양한 AI 기능이 추가되었다. 대표적으로 <strong>라이브 통역(Live Interpreter) 기능</strong>이 꿈같은 기능으로 언급되었으며, 이메일 작성, 문서 요약, 파일 위치 확인 등 <strong>사용자의 생산성을 향상시키는 디폴트 기능들이 대거 도입될 예정</strong>이다.</li>
  <li><strong>에이전트 시대의 도래</strong>: 2024년은 <strong>‘에이전트 시대(Agentic Year)’</strong>로 불린다. 초기 AI가 대고객 서비스에 주로 활용되려 했으나 AI 자체의 완벽하지 않음으로 인해 어려움이 있었으며, 현재는 <strong>기업 내부의 어시스턴트로서 에이전트 환경을 구축하는 데 집중</strong>하고 있다.</li>
  <li><strong>구글의 에이전트 생태계 구축 전략</strong>: 구글은 에이전트 생태계를 확장하기 위해 <strong>ADK (Agent Development Kit)</strong>와 <strong>A2A (Agent-to-Agent)</strong>를 <strong>오픈소스</strong>로 릴리즈하고 있다. 이는 구글이 TPU/GPU부터 소프트웨어까지 모든 것을 다루는 <strong>풀스택(Full-stack) 회사</strong>임에도 불구하고, 더 큰 생태계를 구축하기 위해 <strong>다양한 파트너와 협력하여 기술 표준화를 주도</strong>하려는 전략이다.
    <ul>
      <li><strong>ADK</strong>: 에이전트를 쉽게 만들고 실행할 수 있는 개발 도구이다. 에이전트가 무엇을 해야 할지에 대한 <strong>명령(프롬프트)에 따라 실행하며, 필요할 경우 툴을 활용</strong>한다.</li>
      <li><strong>A2A</strong>: <strong>에이전트 간의 통신 규약(프로토콜)을 표준화</strong>하는 기술로, 서로 다른 에이전트들이 원활하게 커뮤니케이션할 수 있도록 돕는다.</li>
    </ul>
  </li>
  <li><strong>MCP (Model-Component-Protocol)</strong>: MCP는 <strong>에이전트와 툴 간의 표준화된 통신 규약</strong>이다. 에이전트가 어떤 작업을 수행할 때 필요한 툴(예: 구글 서치)을 효율적으로 사용하고 관리할 수 있도록 지원하며, 이는 에이전트 생태계를 확장하고 표준화하는 데 중요한 역할을 한다.</li>
  <li><strong>Firebase Studio (파이어베이스 스튜디오)</strong>: 백엔드 개발 프레임워크인 파이어베이스의 새로운 기능으로, 일반 언어 프롬프트만으로 <strong>프로토타이핑을 빠르고 쉽게 생성</strong>할 수 있게 한다. 이는 개발 과정에서 <strong>커뮤니케이션을 가속화하고, 사전 문제점을 빠르게 파악하여 생산성을 높이는 데 매우 중요한 도구</strong>이다.</li>
  <li><strong>구글의 미래 비전</strong>: 구글은 현재를 “구글의 시간이 왔다”고 표현하며, 미래에는 <strong>AGI (일반 인공지능) 레벨에 가까운 AI 기술이 등장할 것</strong>으로 예측하고 있다. 이는 더욱 깊어진 추론 능력과 강화된 멀티모달리티, 그리고 더욱 강력해진 답변 일관성을 특징으로 할 것이다. 궁극적으로 다양한 비즈니스에 활용될 수 있는 AI 기술의 발전을 기대하고 있다.</li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>해당 팟캐스트를 통해 알 수 있는 사항, 사실 1편에서도 이야기 된 내용들이었긴 하지만… 
그럼에도 대단한 것들에 대해 다시 강조하는 내용, 보여주는 내용들은 확실히 훌륭하다고 생각했다.</p>

<p>ChatGPT 5가 발표 되었지만, 논란, 호불호가 있는 것에 비하면, 
Google 의 서비스는 일반 대중에게는 그다지 큰 놀라움이 아니고, 심지어 개발자들 조차 빠르게 인지하는 사람들은 AI에 진심인, 정말 얼마 안된다는 생각이 들긴 한다.</p>

<p>하지만 막상 써보고 느낀 감상은, 오히려 ChatGPT 보다 Google의 그것들이 정말 놀랄 만큼 미친 수준이고, 또 여전히 아쉬움이 있지만(특히 Google Code Assistance) 여전히 그 포텐셜이나 어떤 서비스를 구축하려고 하는가를 곰곰히 생각해보면 확실하게 ‘효과적’인 것들이며 플랫폼으로의 영향력을 얼마나 치밀하게 고민했는가를 느낄수 있었다. (실력도 실력이고)</p>

<p>이부분이 중요하다고 생각하는 것은 다음과 같은 일들 때문이다.</p>

<p><a href="https://zdnet.co.kr/view/?no=20250801175507">오픈 AI, 1년 매출 120 달러 속 적자 여전…</a></p>
<blockquote>
  <p>이건 사실 뭐 어쩔 수 없다고 본다</p>
</blockquote>

<p><a href="https://www.digitaltoday.co.kr/news/articleView.html?idxno=584197">AI 코딩 스타트업, 매출 급성장에도 수익성은 여전히 ‘글쎄’</a></p>
<blockquote>
  <p>오늘자 기사다</p>
</blockquote>

<p>물론 부정적인 이야기를 본다고 뭔가 결론이 나진 않을 것이다.
그리고 여전히 투자 열기나, 새로운 기대감, 그리고 변화하는 진폭의 크기가 너무 커서, 객관적 평가가 되긴 할까? 하는 의구심은 든다.</p>

<p>하지만 한가지 확실하게 알 수 있는 것은 AI는 과거의 다른 IT 트랜드 보다는 확실히 혁신적이지만, 그것이 시장의 성장과 기업의 성과, 그리고 매출이 시장의 반응성에서 정말 혁신으로 자리잡을 까, 세상의 판도를 뒤집는가, 기업이 여기에 모든 걸 투자할 이유가 되는가? 에 대한 답이 아직 아님을 보여준다.</p>

<p>그러다 보니 기업들은 생존을 위한 현실적 BM 이 필요해지고, 이런 점에서 개발자들의 역할과 역량, AI에 대한 어떤 생각을 갖고 있어야 할지는 생각해볼만한 영역이라고 고민이 된다.</p>

<p>과거 메타버스로 정부 투자 열심히 받아서, 결과적으로 살아있는 회사가 몇 군데인가? 를 바라본다면, 이러한 흐름 속에서 살아가는 한 사람으로서 보다 진중하게 이 상황을 적절하게 활용할 태도가 필요하다는 생각은 확고하게 든다.</p>

<p>특히나 이런 점은 그냥 단순하게 AI 자체를 잘 다루는 기술의 시대에서, AI를 얼마나 효과적이게 시스템에 녹여내고, 비용 절감, 수익 창출로 이끌어낼 것인가- 라는 차원에서 바라볼 이유이자, 이런 점을 무시한 투자와 고민은 튤립에 투자를 하던 때나, 메타버스에 투자하던 때와 유사한 결론이라는 사실을 다시 한 번 상기 시켜준다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">1년 간의 활동을 정리 하면서</title><link href="http://0.0.0.0:4000/backend/2025/08/11/01-Final-Report-For-My-task.html" rel="alternate" type="text/html" title="1년 간의 활동을 정리 하면서" /><published>2025-08-11T00:00:00+00:00</published><updated>2025-08-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/08/11/01-Final-Report-For-My-task</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/08/11/01-Final-Report-For-My-task.html"><![CDATA[<h2 id="api-서버-개발-1년-회고-안정성과-확장성을-향한-여정">API 서버 개발 1년 회고: 안정성과 확장성을 향한 여정</h2>

<p>지난 1년간 <code class="language-plaintext highlighter-rouge">A-api(가칭)</code> 프로젝트를 개발하고 개선하며 경험했던 여정을 회고하는 글을 드디어 작성한다. 더 빨리 적었어야 했겠지만… 아무래도 네이버 부스트 캠프라던가, 그 외에 정리 라던가, 사실 8월 쉬지도 못하고 작업 하고 있는 상황이라 ㅋㅋㅋ.. 약간의 변명 섞어 가지만, 이제는 좀 정리 해봐야 겠다 싶어 이렇게 남겨 본다.</p>

<p>이 글을 통해 1년 간의 메인 서버로 API 서버가 어떻게 구축되었고, 어떤 기능들이 추가되었으며, 안정성과 효율성을 위해 어떤 노력들이 있었는지 스스로 정리를 위한 글을 남겨보려고 한다. (기업 사용 명칭들은 모두 가칭으로 대체 된다.)</p>

<h3 id="1-프로젝트-개요-및-핵심-기술-스택">1. 프로젝트 개요 및 핵심 기술 스택</h3>

<p><code class="language-plaintext highlighter-rouge">A-api(가칭)</code> 프로젝트는 아동의 재활 및 치료 과정을 돕는 게임형 콘텐츠의 핵심 비즈니스 로직과 이에 관련된 데이터를 관리하고, 사용자 및 아동 정보를 처리하며, 결제(구독), 알림, 스케줄링 등 다양한 부가 기능을 제공하는 백엔드 애플리케이션이다.</p>

<p>주요 기술 스택은 다음과 같다:</p>
<ul>
  <li><strong>프레임워크</strong>: NestJS (TypeScript 기반)</li>
  <li><strong>데이터베이스</strong>: MongoDB (Prisma ORM 활용)</li>
  <li><strong>캐시/메시지 큐</strong>: Redis (캐싱 및 세션 관리), BullMQ (비동기 작업 큐)</li>
  <li><strong>인증</strong>: JWT 기반 인증</li>
  <li><strong>로깅</strong>: Winston (파일 및 DB 로깅), 자체 구현 로거</li>
  <li><strong>API 문서화</strong>: Swagger</li>
  <li><strong>배포/운영</strong>: Docker, Jenkins, Nginx, (GitHub Actions - 현재 버전에선 삭제)</li>
  <li><strong>기타</strong>: <code class="language-plaintext highlighter-rouge">axios</code>, <code class="language-plaintext highlighter-rouge">agenda</code>, <code class="language-plaintext highlighter-rouge">mixpanel</code>, <code class="language-plaintext highlighter-rouge">notionhq/client</code>, 인앱 결제 라이브러리 등</li>
</ul>

<p>최초 설계 시에는 MVC 구조를 기반으로 고려한 전형적인 모놀리스 식 서버 애플리케이션이었으며, 이후 3.0.0 이후 NestJS 공식 권장하는 모듈 기반 아키텍처를 적극적으로 활용하여 기능별로 책임과 관심사를 명확하게 분리한 견고한 구조로 최종 구현되었다.</p>

<h3 id="2-주요-기능-개발-및-개선-내역">2. 주요 기능 개발 및 개선 내역</h3>

<p>지난 1년간 A-api 서버의 핵심 기능들을 개발하고 개선하는 데 집중하였다. 게임의 기본 구현이 클라이언트에서 진행되다보니, 최대한 유저의 행적, 운동, 운동 스케쥴링 등에서 로그를 남기는 쪽이 핵심이 되었다.</p>

<ul>
  <li><strong>사용자 및 인증 시스템</strong>:
    <ul>
      <li>로컬(이메일/비밀번호) 및 소셜(Google, Apple) 로그인/회원가입 기본 골자를 기반으로 개선 작업을 수행했다.</li>
      <li>JWT 기반의 인증 시스템을 구축하여 API 접근을 안전하게 제어하고, 사용자 정보 및 탈퇴 처리 로직을 관리하였다.</li>
      <li>임상 시험이 이루어져(2024년 ~ 2025년), 이에 대응하고자 <code class="language-plaintext highlighter-rouge">UserAttribute</code> 모델을 통해 임상시험 참여자와 같은 특정 사용자에게 특별 권한이나 속성을 부여하는 기능을 추가하였다.</li>
      <li>이후 <code class="language-plaintext highlighter-rouge">UserAttribute</code>를 기반으로 사용자의 클라이언트 디바이스에 맞춰 최적 설정으로 게임 플레이 가능하도록 대응하였다.</li>
    </ul>
  </li>
  <li><strong>아동 및 치료 관리</strong>:
    <ul>
      <li>보호자 계정에 여러 자녀를 등록하고 관리할 수 있는 기능을 개발하였다.</li>
      <li>자녀의 재활 치료 게임 플레이 기록(<code class="language-plaintext highlighter-rouge">PlayRecord</code>), 치료 결과(<code class="language-plaintext highlighter-rouge">TherapyResult</code>), 일일 활동 로그(<code class="language-plaintext highlighter-rouge">DailyActivityLog</code>)를 상세히 저장하는 시스템을 구축하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">TherapySchedule</code>을 통해 개인별 맞춤 치료 스케줄을 관리하고, 특히나 <code class="language-plaintext highlighter-rouge">Agenda</code>를 활용하여 스케줄링된 작업을 처리하도록 하여 최대한 분산 처리 가능하도록 구축하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">TherapyHand</code>, <code class="language-plaintext highlighter-rouge">HandClassLabel</code> 등 재활 치료에 특화된 상세한 데이터 타입을 <code class="language-plaintext highlighter-rouge">Prisma</code> 스키마에 정의하여 전문적인 데이터 관리가 가능하도록 하였다.</li>
    </ul>
  </li>
  <li><strong>게임 콘텐츠 및 설정 관리</strong>:
    <ul>
      <li>치료에 사용되는 손동작(<code class="language-plaintext highlighter-rouge">Motion</code>) 데이터(가이드 영상, 설명 등)를 관리하는 기능을 구현하였다.</li>
      <li>메인 치료 게임 외에 미니게임(<code class="language-plaintext highlighter-rouge">MiniGameResult</code>)의 결과도 기록하고, <code class="language-plaintext highlighter-rouge">GameSettings</code> 모델을 통해 게임의 난이도, 패치노트 등 다양한 설정을 동적으로 관리할 수 있도록 하였다.</li>
      <li>미니 게임의 경우, 모듈 구조를 적극 활용하여 클라이언트가 미니 게임에 저장할 데이터를 직접 설정도 가능하고 최대한 백엔드 어플리케이션와 클라이언트 사이의 의존성이 필요시를 제외하면 최대한 의존성을 분리하도록 구조화하였다.</li>
    </ul>
  </li>
  <li><strong>결제 시스템 및 비즈니스 로직</strong>:
    <ul>
      <li>Apple App Store 및 Google Play Store 인앱 결제(구독)를 처리하고, 구독 상태를 관리하는 시스템을 구축하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">PaymentResult</code>, <code class="language-plaintext highlighter-rouge">PaymentHistory</code>, <code class="language-plaintext highlighter-rouge">Subscription</code> 모델을 통해 결제 및 구독 이력을 추적하고, 프로모션 코드(<code class="language-plaintext highlighter-rouge">Promotion</code>) 발급 및 관리 기능을 추가하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">TherapyTicket</code>을 통해 게임의 보상이 적절하게 제공될 수 있는 내부 시스템을 구현하였다.</li>
      <li>Google 의 <code class="language-plaintext highlighter-rouge">Pub/Sub</code> 과 Apple 의 <code class="language-plaintext highlighter-rouge">ServerNotification V2</code> 를 분석하여 이벤트들에 대응, 결제 사이클에 따라 서버에서 구독 상태의 완전한 관리가 가능하도록 구축하였다.</li>
    </ul>
  </li>
  <li><strong>알림 및 외부 연동</strong>:
    <ul>
      <li>NCP SENS를 통해 알림톡(회원가입, 치료 목표 달성 등)을 발송하는 기능을 구현하였다.</li>
      <li>Discord 웹훅을 이용하여 서버의 주요 이벤트(서버 시작, 에러 등)를 개발팀에 실시간으로 알리도록 하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">Mixpanel</code>을 사용하여 사용자 행동 데이터를 수집 및 분석하고, <code class="language-plaintext highlighter-rouge">Notion</code> API를 연동하여 내부 데이터를 동기화하거나 리포트를 생성하는 기능을 개발하였다.</li>
      <li>외부 연동 기능에서 외부 서비스의 상황과 조건에 따라, <code class="language-plaintext highlighter-rouge">Agenda</code>와 <code class="language-plaintext highlighter-rouge">BullMq</code>를 활용하여 로깅에 실패하지 않는 구조룰 구축해 냄.</li>
    </ul>
  </li>
  <li><strong>서버 안정성 및 성능 테스트</strong>:
    <ul>
      <li>파일 로깅, 표준 출력 로깅을 포함하여 Winston 을 라이브러리를 최적화하여, 월별 로깅 저장, 자동 로깅 압축 등 실 서비스에 최적화된 로깅을 구현하였다.</li>
      <li>더불어 비즈니스 로직에서 발생한 로깅 사항이나 외부 접속 시의 Req/Res 의 로깅 저장의 필요성 대두에 <code class="language-plaintext highlighter-rouge">Interceptor</code> 개념을 활용한 미들웨어를 구축하였으며, 인메모리 큐 기반으로 하여 로그 데이터 쌓기로 인해 발생 가능한 서버 부담을 최소화 하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">그레이스풀 셧다운</code> 을 도입, 리눅스 시스템의 긴급한 정지나 강제 종료 등 상황에서 시스템 콜에 의한 강제 서버 종료를 막을 수 있게 했다. 이를 통해 로그의 소실 없이 해야할 작업들을 온전히 마무리 되었을 때 종료 될 수 있는 형태로 구축하여 로그 소실을 최소화 시켰다.</li>
      <li>k6 를 도입 AWS 의 현재 서버 자원 상태에서 최대 얼마나 처리 가능한지, 필요한 응답을 얼마 안에 받을 수 있는지 등을 테스트하여 체계화 하였다.</li>
    </ul>
  </li>
</ul>

<h3 id="3-devops-및-인프라-개선">3. DevOps 및 인프라 개선</h3>

<p>안정적이고 효율적인 개발 및 배포 환경을 구축하기 위해 DevOps 프로세스 개선에 많은 노력을 기울였다.</p>

<ul>
  <li><strong>Jenkins CI/CD 파이프라인용 배포 스크립트 통합 및 개선</strong>:
    <ul>
      <li>최초에는 AWS App Runner 서비스를 활용한 완전 관리형 서비스를 통해 배포 및 실행됨.</li>
      <li>기존 방식의 문제점들로 인해 일반적인 EC2 인스턴스로 서버를 이전 ELB 를 활용한 간단한 로드벨런싱 서버 형태에서 점진적으로 개선하여 ASG(Auth Scaling Group) 기반의 이미지 푸시 및 배포 기능으로 구현 하였다.</li>
      <li>이후 무중단 배포 및 개발환경 개선을 위해 전 서버 구성목록을 컨테이너화하였다.</li>
      <li>무중단 배포를 위하여 개별 서비스 배포 스크립트(<code class="language-plaintext highlighter-rouge">tag_and_push_nestjs.sh</code>, <code class="language-plaintext highlighter-rouge">tag_and_push_nginx.sh</code>)를 구축, ECR 서비스를 활용하여 <code class="language-plaintext highlighter-rouge">target</code> 태깅을 통해 이미지를 자동 추적 및 배포 가능한 서버 형태로 구현하여 기존 형태에서 비용, 자동 배포, 무중단성 등 이점들을 극대화한 운영하도록 개선됨.</li>
      <li>모든 사용자 입력을 제거하고, 환경, 서비스별 버전, Target 태그 여부를 명령행 인자로 받아 처리하도록 설계하여 자동화에 적합하도록 변경하였다.</li>
      <li>스크립트들은 반복되는 이미지 푸시 로직을 <code class="language-plaintext highlighter-rouge">push_image</code> 함수로 모듈화하여 코드 재사용성과 가독성을 높였다.</li>
      <li>NestJS 버전은 설정 파일에서 동적으로 읽어오거나 직접 명시할 수 있도록 유연성을 추가하였고, 특정 서비스의 배포를 건너뛸 수 있는 <code class="language-plaintext highlighter-rouge">skip</code> 옵션을 추가하여 파이프라인의 선택적 실행을 가능하게 하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">aws ecr put-image</code>를 사용하여 <code class="language-plaintext highlighter-rouge">target</code> 태그를 갱신하는 방식으로 기존 로직을 개선하여 효율적이고 원자적인 태그 관리가 가능하도록 하였다.</li>
      <li>package.json 을 적극 활용하여 패키지 매니징을 통한 빌드, 이미지 관리, 배포 등을 명령어로 가능케 만들었고, 이를 통해 서버 개발 및 배포 시간의 효율을 극대화 하였다.</li>
      <li>Husky 와 Lint 의 추가적인 도입 및 CodeRabbit AI 와 같은 서비스 도입을 통해 코드 품질을 끌어올려, 에러가 실 서비스로 최대한 넘어가지 안 도록 관리하였다.</li>
    </ul>
  </li>
</ul>

<p>이 외에도 Docker를 활용한 컨테이너화, Jenkins를 통한 CI/CD 파이프라인 구축, Nginx를 통한 정적 파일 서빙 및 리버스 프록시 역할 수행 등 전반적인 DevOps 환경을 개선하였다.</p>

<h3 id="5-버전별-주요-업데이트-내역">5. 버전별 주요 업데이트 내역</h3>

<p>지난 1년간 진행된 주요 기능 추가 및 개선 내역은 다음과 같다.</p>

<ul>
  <li><strong>API 2.2.1</strong>:
    <ul>
      <li><strong>성능 개선 (Throttler)</strong>: 인증 컨트롤러에 Rate Limiting을 적용하여 성능, 부정 요청을 제한하는 것으로 개선하였다.</li>
      <li><strong>테스트 계정 관리 API</strong>: 유저 계정에 다중 테스트 계정 삽입 및 삭제 API를 개발하였다.</li>
      <li><strong>사용자 및 자녀 컨트롤러/서비스 리팩토링</strong>: 자녀 삭제 로직을 개선하고, 유저 생성 과정 로직을 리팩토링하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.2.2</strong>:
    <ul>
      <li><strong>데이터 처리 개선</strong>: 데이터가 없는 경우 API에서 빈 배열을 전달하고, DTO를 <code class="language-plaintext highlighter-rouge">Partial</code>로 래핑하여 유연성을 높였다.</li>
      <li><strong>일일 로그 Public API 핫픽스 및 개선</strong>: 일일 로그 치료 결과 Public API 버그를 수정하고, Prisma <code class="language-plaintext highlighter-rouge">find</code> 메서드 및 MongoDB <code class="language-plaintext highlighter-rouge">relation</code> 활용을 개선하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.2.3</strong>:
    <ul>
      <li><strong>로깅 점검 및 개선</strong>: 스케줄링 모듈의 로거를 점검하고, 로깅 누락 문제에 대응하기 위해 로깅을 추가하고 에러 핸들링을 강화하였다.</li>
      <li><strong>자녀 등급 추가</strong>: <code class="language-plaintext highlighter-rouge">Child</code> 모델에 <code class="language-plaintext highlighter-rouge">grade</code> 필드를 추가하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.3.0</strong>:
    <ul>
      <li><strong>로깅 통합 및 리팩토링</strong>: 로깅 통합 작업을 완료하고, 파일 로거 및 Winston 설정을 개선하였다.</li>
      <li><strong>오늘 치료 결과 전송 기능 수정</strong>: 오늘 치료 결과를 확인할 수 있도록 기능을 수정하였다. <code class="language-plaintext highlighter-rouge">Agenda</code> 라이브러리를 도입하여 치료 기록의 수집과 서버 성능 최적화를 감안하여 개발함.</li>
      <li><strong>사용자 속성 및 임상 시험 기능 구현</strong>: 사용자 속성 및 임상 시험 관련 기능을 구현하였다. 임상 대상자에 맞춰 손 동작 등을 변경될 수 있는 기능을 Decorator 와 Interceptor 를 활용하여 개발하였다. 이를 통해 기존 비즈니스 로직을 그대로 사용 가능하도록 개발함.</li>
    </ul>
  </li>
  <li><strong>API 2.4.0</strong>:
    <ul>
      <li><strong>미니게임 관리 모듈</strong>: 미니게임 관리 시스템, 모듈형으로 구현하여 다양한 미니게임 추가를 코드 개발 없이 가능하도록 구현함.</li>
      <li><strong>게임 설정 분리</strong>: 게임 설정을 독립적인 모듈로 분리하였다. 미니게임과 연동되는 게임 설정 기능.</li>
    </ul>
  </li>
  <li><strong>API 2.5.0</strong>:
    <ul>
      <li><strong>아산 임상 시험 개정</strong>: 아산 임상 시험 관련 기능들의 개정 요청에 따라 작업을 진행하고, Prisma 모델링 및 치료 캘린더 컨트롤러 API를 업데이트하였다. 요청 사항에 따라 전체 기능 리 팩토링 완료 하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.6.0</strong>:
    <ul>
      <li><strong>자녀 진단 기록 추가</strong>: 새로운 진단 기록 기능 및 기본 관리 API 명세 작성을 완료하였다.</li>
      <li><strong>관리자 추가 보안 기능 구현</strong>: 관리자의 유저 비밀번호 초기화 등의 어드민 기능 구현을 완료 하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.7.0</strong>:
    <ul>
      <li><strong>일일 로깅 및 로그인 프로세스 리팩토링</strong>: 일일 로깅 및 로그인 프로세스 리팩토링을 진행하였다.</li>
      <li><strong>코드 컨벤션 통합</strong>: 코드 컨벤션 통합 작업을 진행하였다. 기존 레거시 코드들에 대한 컨벤션과 맞지 않은 개발 사항들 전체를 분석 및 정리하였다.</li>
      <li><strong>CI/CD 개선</strong>: <code class="language-plaintext highlighter-rouge">deploy-to-dev.yaml</code> 및 <code class="language-plaintext highlighter-rouge">gemgem-hosted-test.yaml</code> 파일을 만들어서 AWS App Runner 에서 GitHub Action의 방식으로 CI/CD를 개선하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.8.0</strong>:
    <ul>
      <li><strong>미국 SMS 인증</strong>: 외부 서비스를 활용하여 미국 SMS 인증 기능 개발을 진행하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.9.0</strong>:
    <ul>
      <li><strong>구독 시스템 구현</strong>: 구독 구글 및 애플의 스토어 및 결제 시스템 구현을 진행하였다. 전체 라이프 사이클 중 4개</li>
      <li><strong>로컬 회원가입 개선</strong>: 로컬 회원가입 시 이미 가입된 메일이면 가입 수단을 리턴하도록 변경하였다.</li>
      <li><strong>에러 핸들링 개선</strong>: 에러 핸들링 응답 바디 복구 및 iOS 취소 조건 추가를 진행하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.10.0</strong>:
    <ul>
      <li><strong>미니게임 결과 제한/잠금 리팩토링</strong>: 미니게임 결과 제한 및 잠금 관련 리팩토링을 진행하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.11.0</strong>:
    <ul>
      <li><strong>Notion CRM 기능 구현</strong>: Notion API를 활용하여 고객들의 정보를 비개발 구성원이 보기 좋게 동기화 기능 구현하였다.</li>
      <li><strong>새로운 미니게임 설정</strong>: 새로운 미니게임 설정 관련 작업을 진행하였다.</li>
      <li><strong>일반 사용자 손 스케줄링</strong>: 일반 사용자 손 스케줄링 기능을 추가하였다.</li>
      <li><strong>새로운 회원가입 로직</strong>: 새로운 회원가입 로직을 추가하였다.</li>
      <li><strong>외부 API 모듈화</strong>: 모든 외부 API 부분을 수정하고 모듈화하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.12.0</strong>:
    <ul>
      <li><strong>치료 캘린더 수정</strong>: 치료 캘린더 관련 버그를 수정하였다.</li>
      <li><strong>출석 기능 업데이트</strong>: 출석 기능 관련 새로운 업데이트를 진행하였다.</li>
      <li><strong>회원 탈퇴 로직 리팩토링</strong>: 회원 탈퇴 로직 리팩토링을 진행하였다.</li>
      <li><strong>DI 구조 개선</strong>: DI(Dependency Injection) 구조 개선을 진행하였다.</li>
      <li><strong>Discord 개선</strong>: Discord 관련 개선을 진행하였다. 기존 디스코드 로깅의 간단한 시스템으로 인해 Rate Limitting 문제를 발견. 이에 따라 테스트 후 얼마나 로깅 소실 되는지 판단하고, 개선을 위한 구조 리펙토링 수행. 워커 스레드와 큐 기능을 활용, 지수 백오프 로직 등을 통해 99% 유지 상태로 구현 완료.</li>
      <li><strong>컴파일러 빌드 구조 수정</strong>: 컴파일러 빌드 구조를 SWC와 babel 컴파일러 사이에서 필요 상황에 따라 컴파일 방식을 선택하고, 빌드 속도 등을 개선함.</li>
    </ul>
  </li>
  <li><strong>API 3.0.0</strong>:
    <ul>
      <li><strong>주요 변경 및 버전 업그레이드 이유</strong>: API 3.0.0은 단순히 기존 기능의 개선을 넘어, <strong>레거시 코드에 대한 대대적 리펙토링 및 모듈 구성 변경, 새로운 결제 시스템(구독 인상 대응, 스토어 이벤트 핸들링)의 대대적인 도입, 새로운 게임 콘텐츠(미니게임, VideoPinkfong)의 추가, 그리고 핵심 사용자 기능(운동 리포트)의 구현</strong> 등 서비스의 핵심 비즈니스 로직과 사용자 경험에 큰 영향을 미치는 대규모 기능들이 통합된 버전이다. 또한, 이러한 대규모 변경 사항들을 안정적으로 서비스하기 위한 CI/CD 개선 및 여러 중요한 버그 수정이 동반되었다. 이러한 변화의 폭이 컸기 때문에 메이저 버전 업그레이드(2.x.x -&gt; 3.0.0)가 이루어졌다.</li>
      <li><strong>서버 구조 개선</strong>: 공통 모듈의 라이브러리화 이전에, <code class="language-plaintext highlighter-rouge">common</code> 모듈로 분리하여 DI 적절 구조로 리펙토링, <code class="language-plaintext highlighter-rouge">feature</code> 에 해당하는 기능들만 분리하고 순환의존성 문제 대거 개선.</li>
      <li><strong>새로운 스토어 이벤트 핸들링 및 구독 인상 대응</strong>: 구독 인상에 대한 핸들링 구현 및 새로운 스토어 이벤트 핸들링 기능이 완료되었다.</li>
      <li><strong>미니게임 추가 및 기존 게임 구조 변경</strong>: 미니게임(<code class="language-plaintext highlighter-rouge">brushing</code>, <code class="language-plaintext highlighter-rouge">cooking</code>), 영상 재생 게임이 추가되었고, UpStairs 복잡한 구조를 리펙토링하였다.</li>
      <li><strong>운동 리포트 기능 추가</strong>: 메인 화면 운동 리포트를 위한 기능이 추가되었다.</li>
      <li><strong>CI/CD 및 개발 환경 개편</strong>: Husky 와 같은 린팅 후킹을 통해 개발 시 놓치기 쉬운 영역, 코드 포멧팅을 휴먼 에러 케이스를 없도록 개선, 개발 환경의 Container 화 스크립트를 전체 구축하여 local, Dev, Staging, Prod 환경을 로컬에서 테스트 및 빌드 가능하도록 구축함. AWS 설정을 개선하여 무중단 배포가 가능하도록 구축 이후 Jenkins 를 기반으로한 CICD 파이프라이닝 구축.</li>
      <li><strong>린트 설정 동기화</strong>: 린트 설정 동기화 및 포맷팅 작업을 진행하였다.</li>
      <li><strong>Google 구독 취소 API</strong>: Google 구독을 업체에서 갱신 취소를 신청하는 API 기능을 탑재하였다.</li>
    </ul>
  </li>
</ul>

<h3 id="6-1년의-여정-그리고-아쉬운-점과-향후-학습개선-사항">6. 1년의 여정, 그리고 아쉬운 점과 향후 학습/개선 사항</h3>

<p>나의 1년간의 작업은 NestJS 기반의 백엔드 시스템을 안정적이고 확장 가능하게 구축하는 데 매우 큰 기여를 하였다. 특히, 체계적인 모듈화, 상세한 데이터 모델링, 그리고 DevOps 자동화에 대한 노력은 내가 무얼 해야 하고 Backend 개발이란게 무엇인지를 이해하는, 치열한 시간이었다고 평가한다.</p>

<p>하지만, AI의 비약적 발전 덕에, 그리고 그렇게 점점 더 업무 효율이 올라가면서, AI가 이 서버를 분석하면 어떤 부분에서 아쉬운 점과 향후 학습 및 개선을 통해 더욱 발전할 수 있는 영역이 있는지를 분석하였고, 이를 기반으로 다음 개발의 역량의 지표로 삼으려고 한다.</p>

<ul>
  <li><strong>문서 관리 프로세스 개선</strong>: 문서의 최신성을 유지하고 협업 과정에서 발생할 수 있는 문제를 방지하기 위한 명확한 문서 관리 프로세스(예: 문서 변경에 대한 코드 리뷰 강화, 자동화된 병합 도구 활용, 문서 버전 관리 전략 수립)의 필요성을 느꼈었다. 물론 테크 리더께서 온전히 나를 신뢰해주시고 덕분에 개발 요청 상황과 현 서버들의 상태를 기반으로 개선작업들을 할 수 있었지만, 결과적으로 다른 사람들과 함께 개발한 것이 아니라는 점, 이런 프로세스가 미리미리 준비되지 않았기 때문에 아쉽다고 느꼈다.</li>
  <li><strong>DB 로깅의 안정성 강화 및 로깅 시스템 강화</strong>: <code class="language-plaintext highlighter-rouge">LoggerMiddleware</code>가 기존의 로깅 방식이고, 새롭게 만든 <code class="language-plaintext highlighter-rouge">HttpLoggingInterceptor</code> 간의 역할 중복이 있었다. 특히나 프로덕션 수준에서 볼 때 로깅으로 서버에 시스템 부하를 최소화 시켜야 할 것이며, 에러 상황을 판단하기 위해서 파일 로그가 반드시 어딘가에 저장되도록 만들어야 할 텐데, ASG 로 인스턴스가 최신화가 되는 구조는 파일을 날려버리는 형태가 되다보니, 이를 고려하지 않은 설계는 대단히 초보적인 실수라고 보였다.(하다 못해 EC2 볼륨 설정을 바꿔도 충분하리라…)</li>
  <li><strong>민감 정보 마스킹 활성화</strong>: 보안 강화를 위해 로그에 민감한 정보가 기록되지 않도록 <code class="language-plaintext highlighter-rouge">maskSensitiveInfo()</code> 함수를 구현했었다. 하지만 로그들 전체를 분석하거나, 체계화 하는 과정을 거치지 못해, 활성화 시키지 못했다. 민감 정보를 잘 처리해내고, 로깅은 확실히 남기는 두 가지를 잘 다 이루었다면 좋았으리라 생각이 된다.</li>
  <li><strong>Nginx 역할 확장 고려</strong>: Nginx가 현재 정적 파일 서빙 및 로깅 역할을 한다고 명시되어 있는데, 향후 API Gateway 역할(인증, 라우팅, 속도 제한 등)을 확장하여 백엔드 서비스의 부하를 줄이고 보안을 강화하는 방안을 학습하고 적용하는 것을 고려할 수 있다.</li>
  <li><strong>보다 진보된 파이프라이닝</strong>: CICD 의 구현은 가능했으나, 다양한 기능으로 적절히 서버로 서빙되지 못한다는 점, 유저 활성화가 아쉬워 보다 넓은 스케일링에 도전해보지 못했다는 점은 다소 아쉬운 부분이다.</li>
  <li><strong>어드민 기능 구현의 부재</strong>: 백엔드 개발만이 전부가 아니라, 데이터의 취득, 데이터 가공, 데이터 사용 대상이 보다 쉽게 접근 가능한 구조화가 필요했으나, 그러한 개발은 시간상 하지 못했었다. 이러한 점은 이후 운영이란 차원에서 매우 아쉬움으로 남았다.</li>
</ul>

<h3 id="7-결론">7. 결론</h3>

<p>지난 1년간 A-api 서버 프로젝트를 개발하며 NestJS 기반의 견고한 백엔드 시스템을 구축하고, 다양한 핵심 기능들을 구현하였다. 특히 DevOps 프로세스 개선을 통해 개발 생산성과 배포 안정성을 높이는 데 기여하였으며, 로깅 시스템 분석 및 잠재적 오류 분석을 통해 시스템의 안정성과 품질을 향상시키기 위한 노력을 지속하였다. 그 결과들은 3.0 버전을 구현할 수 있었고, 테크 리더님에게도 상당한 호평을 받은 대단히 체계화된 구조라는 칭찬을 받았고, 이는 다음 단계로 가야하는 구나, 갈 수 있겠구나 하는 자긍심, 자부심도 될 수 잇었다고 생각한다.</p>

<p>여러 상황이 겹쳐 이제는 해당 업체를 나와 AI 라는 키워드 DevOps 라는 키워드를 더 집중하기 위해 노력하려고 하는데, 이러한 나의 노력이 다음 곳에서 다시 또 무언가로 나타내질 수 있기를 기원한다.</p>

<p>나란 존재 빠이팅…</p>

<p><img src="/assets/images/posts/2025-08/2025-08-11-003.png" alt="" />
<img src="/assets/images/posts/2025-08/2025-08-11-004.png" alt="" />
<img src="/assets/images/posts/2025-08/2025-08-11-005.png" alt="" /></p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="생각정리" /><category term="Backend" /><category term="NestJS" /><category term="TypeScript" /><summary type="html"><![CDATA[API 서버 개발 1년 회고: 안정성과 확장성을 향한 여정]]></summary></entry><entry><title type="html">Docker Build, 90초에서 2초로</title><link href="http://0.0.0.0:4000/backend/2025/08/11/02-From-90-To-2s.html" rel="alternate" type="text/html" title="Docker Build, 90초에서 2초로" /><published>2025-08-11T00:00:00+00:00</published><updated>2025-08-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/08/11/02-From-90-To-2s</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/08/11/02-From-90-To-2s.html"><![CDATA[<h2 id="90초에서-2초로-나의-docker-빌드-속도-최적화-분투기">90초에서 2초로: 나의 Docker 빌드 속도 최적화 분투기</h2>

<p>전체 서버 API 프로그램에 대해 정리를 하고, 작업했던걸 테스트 해보려고 Docker Compose로 프로젝트를 빌드하다 흥미로운 메시지를 발견했다.</p>

<blockquote>
  <p>Compose can now delegate builds to bake for better performance. To do so, set COMPOSE_BAKE=true.</p>
</blockquote>

<p>성능 개선이라는 말에 <code class="language-plaintext highlighter-rouge">COMPOSE_BAKE=true</code> 옵션을 바로 적용했다. 이는 약 2만 줄 규모의 NestJS API 서버의 빌드 시간은 항상 90초를 훌쩍 넘기며 어우 너무 길다고 느꼈었다. 그러니 기대도 해봤지만…  결과는 생각보다 실망스러웠다. 아주 약간의 개선은 있었지만, 기대했던 드라마틱한 변화는 없었다.</p>

<p>이 글은 그 실망스러운 결과에서 시작하여, 근본적인 원인을 파헤치고 마침내 빌드 시간을 2초 내외로 단축하기까지의 과정을 정리한 글이다.</p>

<h3 id="1-첫-시도와-실망-10의-미미한-개선">1. 첫 시도와 실망: 10%의 미미한 개선</h3>

<p><code class="language-plaintext highlighter-rouge">COMPOSE_BAKE=true</code> 옵션을 적용한 첫 빌드 시간은 약 88초였다. 기존 98초에 비하면 <strong>약 10% 빨라진 셈</strong>이니 효과가 없지는 않았다. 
이 옵션의 경우 새로운 빌드 기능인데, 빌드 시 이미지를 만드는 과정에서 병렬 처리를 통해 성능이 아주 좋아질 거라고 그렇게 이야기 했었다. 실제로 사용하는 현재 개발 기기는 M4 맥북 프로, 램도 24기가바이트 이니 분명 넉넉하고도 남을 상황이었고, 그러면 못해도 3-40 % 개선이 있을 수 있다고 예상했던 것인데…</p>

<p>무언가 더 근본적인 문제가 내 빌드 과정에 숨어있음을 직감했다.</p>

<p><code class="language-plaintext highlighter-rouge">Bake</code>라는 도구는 죄가 없었다. 문제는 내부에 있었다.</p>

<h3 id="2-근본-원인-추적-왜-내-빌드는-항상-느렸을까">2. 근본 원인 추적: 왜 내 빌드는 항상 느렸을까?</h3>

<p>결론적으로, 내 빌드 속도를 저해하던 범인은 세 가지였다.</p>

<ol>
  <li>
    <p><strong>잘못된 습관: ‘안전’을 맹신한 캐시 삭제</strong>
가장 큰 문제였다. 3.0.0 을 구성하면서 나는 빌드 시 클린 빌드가 되는 것이 가장 중요하다고 생각했다. ‘혹시 모를 충돌’이나 ‘깨끗한 빌드’를 명분으로, 매번 빌드 전에 <code class="language-plaintext highlighter-rouge">docker rmi</code> 명령어로 이전 이미지를 삭제하는 것을 package.json에서 수행하도록 자동화 했었다. 이것은 Docker의 가장 강력한 무기인 <strong>캐시(Cache)를 스스로 내다 버리는 행위</strong>였다.</p>
  </li>
  <li>
    <p><strong>비효율적인 Dockerfile: 잘못된 <code class="language-plaintext highlighter-rouge">COPY</code> 순서</strong>
두 번째 문제는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 내부에 있었다. 나는 습관적으로 소스 코드 전체를 복사(<code class="language-plaintext highlighter-rouge">COPY . .</code>)한 뒤에 의존성을 설치(<code class="language-plaintext highlighter-rouge">RUN yarn install</code>)했다. 이로 인해 소스 코드 단 하나만 수정해도 <code class="language-plaintext highlighter-rouge">yarn install</code> 캐시가 무효화되어 매번 수 분이 걸리는 의존성 설치를 반복하고 있었다.</p>
  </li>
  <li>
    <p><strong>나의 무지: <code class="language-plaintext highlighter-rouge">COMPOSE_BAKE</code>의 본질</strong>
<code class="language-plaintext highlighter-rouge">Bake</code>는 여러 빌드 작업을 <strong>병렬로 처리</strong>해주는 도구이지, 단일 작업 자체를 마법처럼 빠르게 만들어주는 도구가 아니었다. 내 빌드 시간의 대부분은 <code class="language-plaintext highlighter-rouge">yarn install</code>이라는 단일 네트워크 작업이 차지하고 있었으므로, <code class="language-plaintext highlighter-rouge">Bake</code>가 활약할 무대 자체가 없었던 것이다.</p>
  </li>
</ol>

<h3 id="3-전환점-문제-해결과-최적화-적용">3. 전환점: 문제 해결과 최적화 적용</h3>

<p>원인을 알았으니 해결은 명확했다. 각 문제를 해결하기 위해 적용한 구체적인 코드 변경 사항은 다음과 같다.</p>

<h4 id="해결-1-dockerfile-캐시-구조-최적화"><strong>해결 1: <code class="language-plaintext highlighter-rouge">Dockerfile</code> 캐시 구조 최적화</strong></h4>

<p><code class="language-plaintext highlighter-rouge">Dockerfile</code>의 빌더 스테이지에서 <code class="language-plaintext highlighter-rouge">COPY</code> 명령어의 순서를 조정하여 캐시 효율을 극대화했다.</p>

<ul>
  <li>
    <p><strong>수정 전:</strong></p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ❌ 문제 지점: 소스 코드를 의존성 설치 전에 복사</span>
<span class="k">COPY</span><span class="s"> src ./src/</span>
<span class="k">RUN </span>yarn <span class="nb">install</span> <span class="c"># 캐시가 거의 항상 무효화됨</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>수정 후:</strong></p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ✅ 개선 지점: 의존성 설치를 먼저 실행하여 캐시 레이어 생성</span>
<span class="k">RUN </span>yarn <span class="nb">install</span>
<span class="c"># ✅ 개선 지점: 자주 변경되는 소스 코드를 나중에 복사</span>
<span class="k">COPY</span><span class="s"> src ./src/</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="해결-2-파괴적인-빌드-스크립트-수정"><strong>해결 2: 파괴적인 빌드 스크립트 수정</strong></h4>

<p><code class="language-plaintext highlighter-rouge">unset</code> 명령어를 빌드 과정에서 완전히 분리하고, 캐시 사용 여부에 따라 스크립트 역할을 명확히 나누었다.</p>

<ul>
  <li>
    <p><strong>수정 전:</strong></p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w"> </span><span class="nl">"build:dev"</span><span class="p">:</span><span class="w"> </span><span class="s2">"yarn unset:dev &amp;&amp; docker compose ... build"</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>수정 후:</strong></p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"build:dev"</span><span class="p">:</span><span class="w"> </span><span class="s2">"docker compose ... build"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"build:dev:no-cache"</span><span class="p">:</span><span class="w"> </span><span class="s2">"docker compose ... build --no-cache"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="4-결과-98의-시간-단축-개발-경험의-혁명">4. 결과: 98%의 시간 단축, 개발 경험의 혁명</h3>

<p>모든 최적화를 적용한 결과는 역시나 훌륭했다.</p>

<ul>
  <li><strong>최적화 이전 (캐시 X, 비효율 구조):</strong> <strong>약 98초</strong></li>
  <li><strong>최적화 이후 (캐시 X, 효율 구조):</strong> <strong>약 88초</strong> (기존 대비 <strong>10%</strong> 향상)</li>
  <li><strong>최적화 이후 (캐시 O, 효율 구조):</strong> <strong>약 2초</strong> (최초 대비 <strong>98%</strong> 시간 단축)</li>
</ul>

<h4 id="지표로-만들어보면"><strong>지표로 만들어보면?</strong></h4>

<p>이 시간 기록을 기반으로, 평균 프로젝트에서 개발 과정에서 빌드 하는 횟수를 평균 낸 적이 있는데, 이를 기준으로 단축이 실제로 얼마나 큰 차이를 만드는지 프로젝트 규모에 따라 예상해보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능 규모</th>
      <th style="text-align: left">예상 빌드 횟수</th>
      <th style="text-align: left">최적화 전 누적 시간</th>
      <th style="text-align: left">최적화 후 누적 시간</th>
      <th style="text-align: left">**절약된 시간**</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**소형**</td>
      <td style="text-align: left">약 10회</td>
      <td style="text-align: left">약 16분</td>
      <td style="text-align: left">**약 20초**</td>
      <td style="text-align: left">**약 15분**</td>
    </tr>
    <tr>
      <td style="text-align: left">**중형**</td>
      <td style="text-align: left">약 100회</td>
      <td style="text-align: left">약 2시간 40분</td>
      <td style="text-align: left">**약 3분 20초**</td>
      <td style="text-align: left">**약 2시간 36분**</td>
    </tr>
    <tr>
      <td style="text-align: left">**대형**</td>
      <td style="text-align: left">약 250회</td>
      <td style="text-align: left">약 6시간 45분</td>
      <td style="text-align: left">**약 8분 20초**</td>
      <td style="text-align: left">**약 6시간 37분 (거의 하루)**</td>
    </tr>
  </tbody>
</table>

<p>결과적으로, <strong>대형 기능 하나를 개발할 때마다 거의 하루에 가까운 근무 시간을 절약</strong>할수 있게되었다. 이것은 단순한 시간 단축을 넘어, 잦은 빌드 대기로 인해 끊기던 개발의 리듬과 흐름(Flow)을 온전히 유지할 수 있게 만들었다.</p>

<h3 id="5-결론-내가-얻은-교훈들">5. 결론: 내가 얻은 교훈들</h3>

<p>이번 최적화 과정을 통해 몇 가지 중요한 교훈을 얻었다.</p>

<ol>
  <li><strong>도구를 의심하기 전에 나를 의심하라.</strong> <code class="language-plaintext highlighter-rouge">Bake</code>는 훌륭한 도구였지만, 내가 그 성능을 발휘할 환경을 만들어주지 못했다.</li>
  <li><strong>Docker의 기본, 캐시를 믿고 활용하라.</strong> <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 명령어 순서는 단순한 순서가 아닌, 캐시 전략 그 자체이다.</li>
  <li><strong>의도에 맞는 정확한 명령어를 사용하라.</strong> <code class="language-plaintext highlighter-rouge">docker rmi</code>와 <code class="language-plaintext highlighter-rouge">build --no-cache</code>는 비슷해 보이지만, 그 역할과 결과는 완전히 다르다.</li>
</ol>

<p>깨끗한 구조가 꼭 완벽한 개발 상황을 유지해주는 것은 아니었다. 안정성을 최우선으로 생각했지만, 반대로 그렇게 됨으로서 얼마나 많은 손해를 본건지… 다음번 CI/CD 를 수행한다면, 그때엔 이러한 점들의 고려가 필수라고 생각되고, 이러한 점에서 AI 나 동료들과의 검증 절차를 반드시 넣고 만들어보리라 생각을 할 수 있었다.</p>

<p>흠 재밌는 정리였다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="생각정리" /><category term="Backend" /><category term="NestJS" /><category term="TypeScript" /><summary type="html"><![CDATA[90초에서 2초로: 나의 Docker 빌드 속도 최적화 분투기]]></summary></entry><entry><title type="html">GPT v5 공개…! 현재 상태 좀 볼까?</title><link href="http://0.0.0.0:4000/ai/2025/08/07/00-chat-gpt-v5-introduction.html" rel="alternate" type="text/html" title="GPT v5 공개…! 현재 상태 좀 볼까?" /><published>2025-08-07T00:00:00+00:00</published><updated>2025-08-07T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/07/00-chat-gpt-v5-introduction</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/07/00-chat-gpt-v5-introduction.html"><![CDATA[<p><img src="/assets/images/posts/2025-08/2025-08-07-002.png" alt="" /></p>

<h2 id="gpt-5를-뜯어보자">GPT-5를 뜯어보자!</h2>
<p>OpenAI의 GPT-5가 드디어 공개되었다. 이번 출시는 GPT-4 라는 모델의 충격 때문일까, 확실히 여기저기, 특히나 유튜브에서 관심을 다들 가지는 느낌이 들었다. 그러니 그 변화에 탑승해서(?) GPT-5라는 새로운 버전에 대해 제대로 파악하고자 먼저, 기업이란 거시적인 관점의 조망해보고, 그 후 구체적인 기능을 살펴보면서, 씹고 뜯고 맛보고 즐겨보자(?).</p>

<h3 id="gpt-5를-통해-볼-수-있는-openai">GPT-5를 통해 볼 수 있는 OpenAI</h3>
<p>GPT-5의 등장은 몇 가지 핵심적인 전략적 전환을 의미한다. 이는 기술의 방향성과 AI 산업의 미래를 암시하는 거대한 흐름이다.</p>

<ul>
  <li>
    <p>GPT-5는 개별 도구의 집합에서 단일 통합 지능 시스템으로의 패러다임 전환이다.
과거 사용자는 GPT-4, GPT-4o 등 복잡한 ‘모델 선택기(model picker)’ 앞에서 어떤 모델이 자신의 작업에 최적인지 직접 고민해야 했다. GPT-5는 이 불편함을 완전히 해소한다. 사용자의 질문 의도를 실시간으로 분석해 가장 적합한 추론 능력을 자동으로 할당하는 지능형 라우터를 탑재한 통일된 플랫폼으로 진화했다. 이는 AI를 마치 하나의 운영체제(OS)처럼 만들어, 경쟁자들이 쉽게 넘볼 수 없는 기술적 ‘해자(moat)’를 구축하려는 OpenAI의 핵심 전략이다.</p>

    <p>개발자들이나, 파워 유저의 경우 특정 룰을 가지고 에이전틱한 사용성을 보장해주는 것을 필요로 한다 말하지만, 일반 사용자가 AI 를 사용할 때는, 그러한 영역들이 상당한 장애물이 될 수 있다. 그런 점을 볼 때 엔드 유저를 생각할 때의 핵심은 ‘알잘딱’하게 알아 맞추는 것이며, 이것이 곧 락인(lock-In) 효과의 핵심이라고 판단한 것으로 보인다.(사실 개발자라도, 쉽고 빠르게 쓰고 싶다는 점에선, 이 점은 여전히 중요하리라 본다.)</p>
  </li>
  <li>
    <p>이번 출시는 점진적 개선을 넘어 ‘박사급 전문가’ 수준의 질적 도약을 의미한다.
샘 알트먼 CEO는 GPT-3를 “고등학생”, GPT-4를 “대학생”에 비유하며, GPT-5와의 대화는 “어떤 분야에서든 합법적인 박사급 전문가와 이야기하는 느낌”이라고 표현했다. 이는 단순 정보 검색을 넘어, 복잡한 문제 해결을 위한 심층적인 사고 파트너로서의 역할을 목표로 함을 의미한다. AI의 지능 수준이 이전 세대와는 근본적으로 다른 차원에 도달했음을 시사하는 대목이다. 이는 기존의 gemini 2.5 Pro를 포함하여 지속적으로 나오는 다른 서비스들의 심층 추론이를 보다 명시적이고 전문성이 있다고 강조한 걸로 보인다.</p>
  </li>
  <li>
    <p>기술의 최전선에서 신뢰성과 안전성을 최우선으로 하여 엔터프라이즈 시장을 정조준한다.
기업이 AI 도입을 주저했던 가장 큰 이유는 ‘환각(Hallucination)’ 현상, 즉 AI가 그럴듯한 거짓말을 하는 문제였다. GPT-5는 이 문제를 정면으로 겨냥해, 사실 기반 벤치마크에서 이전 모델보다 오류를 최대 80%까지 줄였다. 이러한 신뢰성 향상은 금융 분석, 법률 실사, 헬스케어와 같이 정확성이 생명인 고위험 분야에서 AI를 실용적인 비즈니스 도구로 도입하기 위한 필수적인 기반이다. 이미 SAP, Relativity 같은 기업들은 GPT-5를 활용해 비즈니스 혁신을 가속하고 있다.</p>

    <p>이러한 지점은 기존 다른 업체들의 모델들이 자기 나름의 방법으로 할루시네이션을 극복하고, 특히나 비즈니스에서 사용시 이러한 문제를 해결하지 못하면 안된다라는 아주 구조적 킬포인트를, 그들도 이미 공감하고 최우선으로 생각했다는 공감의 표시라고 생각된다. Gemini 2.5 pro의 경우에도 구글 서치 그라운딩고 같이, 정확한 정보인가 아닌가? 를 검증한다는 점을 강하게 어필했고, 지금껏 AI 관련된 공식 팟캐스트에서도 구글 측의 입장은 한결같이 ‘기업이 신뢰할만한가?’ 라는 명제에 최대한 답을 하려고 했단 점은 GPT 역시 동일한 결론이라는 걸 보여준다.</p>
  </li>
</ul>

<h3 id="요약해본-gpt-5의-핵심-업데이트-내용">요약해본 GPT-5의 핵심 업데이트 내용</h3>
<p>OpenAI 의 전략, 상황, 그리고 AI 트랜드의 편린을 보았으니, GPT 5의 개선 사항들을 정리해보자. GPT-5의 강력한 성능은 다음과 같은 핵심 기능들의 비약적인 발전에 기반한다.</p>

<ul>
  <li><strong>통합 아키텍처는 실시간 라우터를 통해 질문에 따라 최적의 모델을 자동 할당</strong></li>
</ul>

<p>내부적으로 GPT-5는 빠른 응답을 위한 효율적인 모델과, 복잡한 문제 해결을 위한 심층 “사고(Thinking)” 모델로 나뉘어 있다. 사용자가 “이 문제에 대해 깊이 생각해봐”라고 명시하거나 질문이 복잡하다고 판단되면, 시스템의 중추인 ‘실시간 라우터’가 즉시 ‘사고’ 모델을 활성화한다. 덕분에 사용자는 속도와 깊이를 모두 자연스럽고 빠르게 경험할 수 있다.</p>

<ul>
  <li><strong>‘주문형 소프트웨어(Software-on-Demand)’ 개념을 현실화하는 강력한 코딩 능력</strong></li>
</ul>

<p>코딩 지식이 없는 사용자도 “프랑스어 학습 앱을 만들어줘. 단어 퀴즈랑 플래시카드 기능도 넣어줘”와 같은 자연어 설명만으로 몇 분 만에 실제 작동하는 앱을 만들 수 있다고 전했다. 전문 개발자에게는 더욱 강력한 도구가 된다. SWE-bench와 Aider Polyglot 같은 주요 코딩 벤치마크에서 각각 74.9%, 88%라는 압도적인 점수를 기록했으며, 이는 대규모 코드베이스를 이해하고 복잡한 버그를 수정하는 능력이 탁월함을 증명했고, 데모를 제공해준다.</p>

<ul>
  <li><strong>환각(Hallucination) 현상이 이전 모델 대비 최대 80%까지 감소하여 답변의 신뢰성이 비약적으로 향상</strong></li>
</ul>

<p>GPT-5의 전체적인 환각 발생률은 이전 모델의 20% 이상에서 4.8%로 크게 줄었다. 특히 민감한 의료 관련 질문에서는 오류율이 1.6%까지 떨어졌으며, 모르는 내용에 대해 억지로 꾸며내는 ‘기만적 행동’은 이전 모델의 86.7%에서 단 9%로 대폭 감소했다. 존재하지 않는 이미지에 대해 질문했을 때 GPT-4 세대가 86.7%의 확률로 자신있게 거짓말을 했던 반면, GPT-5는 단 9%만이 그런 반응을 보여, 모르는 것에 대해 솔직하게 인정하도록 훈련되었음을 보여준다.</p>

<ul>
  <li><strong>이미지와 텍스트를 동시에 이해하는 멀티모달 능력과 최대 40만 토큰의 컨텍스트 처리 능력</strong></li>
</ul>

<p>최대 40만 토큰의 컨텍스트 창은 책 한 권 전체나 몇 주간의 대화 기록을 하나의 대화 안에서 일관성 있게 처리할 수 있음을 의미한다. 또한, 사용자의 구글 캘린더나 Gmail과 연동하여 “지난주에 놓친 중요한 이메일 요약해줘”와 같은 개인화된 작업도 수행할 수 있다. 아직 구글의 그것이 정말 말이 안될 사이즈로 제공해주긴 하지만, 이 역시 훌륭한 컨텍스트 양이라고 볼 수 있을 것이다.</p>

<ul>
  <li><strong>‘취향’이 개선된 작문 능력과 ‘성격(Personalities)’ 기능으로 더 인간적인 상호작용이 가능</strong></li>
</ul>

<p>“문학적 깊이와 리듬”을 갖춘 설득력 있는 글을 생성하며, 사용자의 비위를 맞추려는 ‘아첨(sycophancy)’ 경향은 14.5%에서 6% 미만으로 줄었다. 또한 ‘냉소주의자(Cynic)’, ‘로봇(Robot)’, ‘너드(Nerd)’ 등 네 가지 사전 설정된 ‘성격’으로 AI의 응답 톤을 간편하게 조절할 수 있다. Gemini 2.5 Pro 에 대한 사용자 평가에서 이부분의 필요성이 대두되었는데, 이점은 보다 ‘객관성’과 ‘신뢰성’ 확보를 위해 필요하다고 생각되는 강조점이라고 볼 수 있겠다.</p>

<ul>
  <li><strong>‘안전한 완료(Safe Completions)’라는 새로운 안전 철학을 도입</strong></li>
</ul>

<p>민감한 질문에 대해 무조건 답변을 거부하는 ‘강경한 거절’ 방식에서 벗어나, 유해할 수 있는 내용을 제거하면서도 최대한 유용한 정보를 제공하려 노력한다. 예를 들어 위험 물질에 대한 질문에 제조법을 알려주는 대신, 그것의 위험성과 안전한 취급 방법에 대한 정보를 제공하는 식이다.</p>

<ul>
  <li><strong>자율적으로 다단계 작업을 수행하는 ‘에이전트(Agentic)’ 능력이 강화</strong></li>
</ul>

<p>단순 응답을 넘어, “레스토랑 웹사이트를 만들어줘”라는 요청에 스스로 전체 프로젝트 계획을 세우고, 필요한 도구(브라우저, 코드 실행기 등)를 연속적으로 호출하여 과업을 완수하는, 마치 프로젝트 매니저와 같은 역할을 수행한다.</p>

<ul>
  <li><strong>개발자를 위해 API 기능이 세분화되고 가격 경쟁력을 갖추었다.</strong></li>
</ul>

<p>용도에 맞게 최고 성능의 <code class="language-plaintext highlighter-rouge">gpt-5</code>부터 비용 효율적인 <code class="language-plaintext highlighter-rouge">gpt-5-mini</code>, 초저지연에 특화된 <code class="language-plaintext highlighter-rouge">gpt-5-nano</code> 모델까지 선택할 수 있다. 가격 또한 GPT-4o 대비 입력 비용이 절반으로 줄어든 100만 토큰당 1.25달러로 책정되었으며, 반복 호출 시 비용을 90% 절감해주는 캐싱 할인도 제공된다. 이러한 부분은 가격 경쟁력 부분이 필요하다는 수요를 나름 인지한 것으로 보인다.</p>

<ul>
  <li><strong>모두를 위한 사용자 경험(UX) 개선과 생태계 통합:</strong></li>
</ul>

<p>이제 무료 사용자를 포함한 모든 유저가 개선된 음성 모드를 사용할 수 있으며, 여러 아이디어를 시각적으로 펼쳐놓고 작업하는 ‘캔버스(Canvas)’ 기능도 추가되었다. 또한, GPT-5 출시와 함께 GPT-4o 등 모든 구형 모델이 플랫폼에서 제거되어, 모든 사용자와 개발자가 GPT-5라는 단일 생태계로 통합된다.</p>

<ul>
  <li><strong>주요 외부 도구와의 통합 심화:</strong></li>
</ul>

<p>GPT-5는 Microsoft 365 Copilot에 깊숙이 통합되어 사용자의 이메일, 문서 등 개인 업무 데이터를 기반으로 매우 맥락에 맞는 분석을 제공하며, GitHub Copilot과 Visual Studio Code에도 직접 통합되어 개발자들이 코드를 작성하고 디버깅하는 전 과정을 실시간으로 돕는다.</p>

<h3 id="gpt-5-그리고-그-다음은-써보니">GPT 5 그리고 그 다음은…? 써보니..</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">모델</th>
      <th style="text-align: left">강점 포인트</th>
      <th style="text-align: left">주요 스펙</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">GPT‑5 (OpenAI)</td>
      <td style="text-align: left">“박사급 전문가” 수준의 추론• 매우 적은 환각률, 안전한 응답• 뛰어난 도구 연동 및 에이전트 작업• SWE‑bench 74.9%, Aider Polyglot 88% 성능</td>
      <td style="text-align: left">컨텍스트 윈도우 최대 256k 토큰- variants: standard, mini, nano / Pro, Plus 등- verbosity, reasoning_effort API 옵션 제공</td>
    </tr>
    <tr>
      <td style="text-align: left">Gemini 2.5 Pro (Google)</td>
      <td style="text-align: left">“생각하는 라우팅” 탑재, 추론 기반 응답• WebDev Arena 등 코딩 벤치마크에서 탁월• 영상→코드, UI 자동 생성에 강점• 멀티모달 + 긴 문맥 + 노이즈 인식</td>
      <td style="text-align: left">컨텍스트 최대 1백만 토큰- Deep Think 모드 제공- 기능: 멀티모달, 오디오, 도구 연동, 스타일 제어</td>
    </tr>
    <tr>
      <td style="text-align: left">Claude (Anthropic) 최신 모델 (Opus 4.1, Sonnet 4)</td>
      <td style="text-align: left">고급 추론·코딩 능력• 긴 문맥 처리 (200k 토큰)• 확장 추론 모드와 멀티모달 지원</td>
      <td style="text-align: left">Opus 4.1: 최고 성능 모델, 복잡한 논리/코딩에 강함- Sonnet 4: 효율적이고 반응 빠름- 둘 다 텍스트+이미지 입력 가능, 200k 컨텍스트 윈도우</td>
    </tr>
  </tbody>
</table>

<p>GPT 5 의 변화 내용을 여러 시사점, 특히 다른 플랫폼들에 대해 경쟁 지점에 대한 나름의 전략들이 녹아든 개선점이 보이는 것 같아, 그만큼 괜찮은데? 싶었다. 일반 유저들 입장에선 일단 무조건 chatGPT 쓰고 본다- 의 효과를 어떻게든 더 유지하기 위함이 나름 느껴지는 개선포인트가 아니었나 생각한다. 특히나 몇 차례 5를 활용한 심층 분석 시 무엇을 위해 어떤 대상, 어떤 도구, 어떤 범위 등 자신이 해야할 일들을 단순히 ‘판단’ 하고 확신하지 않고, 한번더 물어 본 뒤 작업을 하는 것, 이후 딱 요청한 것들을 정확히 알려준다는 점은 생각 이상으로 4 버전보다 확실히 나아졌다. 오히려 기계스럽게 일을 잘한다는 느낌을 받을 수 있었다.</p>

<p>AWS Bedrock 이 현재 기업 시장에서 나름 인지도를 쌓아간다고 하고, Gemini 와 다양한 모델들, 압도적인 가성비로 Google 역시 기업시장에서 계속 입지를 다져가는 상황, 개발자들은 Claude 의 메모리 성능과 문맥 이해력, Claude Code 의 안정적인 성능 등, 어쩌면 선구자로 입지가 위태위태 하지만, 그럼에도 여전히 GPT 가 살아 있음을 호소한다는 느낌을 강하게 들었다.</p>

<p>다만 결과에 대하여 내가 쓴 경우를 제외하더라도, 다른 분들의 평가나 분석한 내용을 볼 때, 모든게 1등이냐? 라는 차원에서는 여전히 한계는 있어 보였다.</p>

<p>연속적인 이해나, 대화 내용에 대한 안정적인 이해도는 여전히 Claude 가 앞서가고 있고, Gemini 2.5 는 다소 떨어지는 부분은 있지만, 할루시네이션을 구글 검색 그라운딩과 합쳐 놓아 충분히 완성도 있게 해주었다. 토큰 허용치는 정말 타의 추종을 불허한다는 엄청난 장점을 갖고 있다. 또한 코딩 실력 역시 결과적으로 요즘 모델들이 너무 잘 만들어주는 것은 사실이지만, 결국 과거 문맥을 이해하고, 실수가 없는가! 라는 차원의 비교에선 Claude Code가 보다 안정적이었다는, 실무적 결과들을 볼 때, 가닥을 잘 따라 완성도 있게 나온 것은 사실이지만 GPT 5가 엔드 유저가 아닌 다른 유저들에게 얼마나 어필 될까? 는 고민해볼 여지가 있는 영역이라고 보인다. (물론, 링크드인의 다양한 평가들 중에선, ‘전문성’의 키워드에 대한 해결 능력은 뛰어나다는 이야기도 있었다. 즉, 복잡하고 어려운 건 오히려 잘 해낸다고 볼 수도 있을것 같다. 개발 실무 보단, 진짜 연구 개발에 가까운 영역은 호평인듯)</p>

<p>오히려 조사 과정에서 Gemini CLI + Claude Code 라는 미친 조합으로 정보 분석 + 정보 요약은 Gemini에게 시키고, 실 결과물은 Claude 를 쓰게 만드는 끔찍한 혼종을 만들어 쓰는 분들의 결과물을 봤을 때, AI 의 전쟁은 진짜 더욱 더 치열해진다는 점을 새삼 느낄 수 있었다.</p>

<h3 id="참고-문헌">참고 문헌</h3>
<ul>
  <li><a href="https://openai.com/index/introducing-gpt-5/">https://openai.com/index/introducing-gpt-5/</a></li>
  <li><a href="https://openai.com/index/introducing-gpt-5-for-developers/">https://openai.com/index/introducing-gpt-5-for-developers/</a></li>
  <li><a href="https://azure.microsoft.com/en-us/blog/gpt-5-in-azure-ai-foundry-the-future-of-ai-apps-and-agents-starts-here/">https://azure.microsoft.com/en-us/blog/gpt-5-in-azure-ai-foundry-the-future-of-ai-apps-and-agents-starts-here/</a></li>
  <li><a href="https://www.microsoft.com/en-us/microsoft-365/blog/2025/08/07/available-today-gpt-5-in-microsoft-365-copilot/">https://www.microsoft.com/en-us/microsoft-365/blog/2025/08/07/available-today-gpt-5-in-microsoft-365-copilot/</a></li>
  <li><a href="https://news.microsoft.com/source/features/ai/openai-gpt-5/">https://news.microsoft.com/source/features/ai/openai-gpt-5/</a></li>
  <li><a href="https://simonwillison.net/2025/Aug/7/gpt-5/">https://simonwillison.net/2025/Aug/7/gpt-5/</a></li>
  <li><a href="https://the-decoder.com/openai-claims-gpt-5-offers-its-best-coding-performance-yet-for-complex-programming-tasks/">https://the-decoder.com/openai-claims-gpt-5-offers-its-best-coding-performance-yet-for-complex-programming-tasks/</a></li>
  <li><a href="https://apnews.com/article/gpt5-openai-chatgpt-artificial-intelligence-d12cd2d6310a2515042067b5d3965aa1">https://apnews.com/article/gpt5-openai-chatgpt-artificial-intelligence-d12cd2d6310a2515042067b5d3965aa1</a></li>
  <li><a href="https://mashable.com/article/best-new-gpt-5-ai-features">https://mashable.com/article/best-new-gpt-5-ai-features</a></li>
  <li><a href="https://mashable.com/article/chatgpt-5-coolest-feature-vibe-coding">https://mashable.com/article/chatgpt-5-coolest-feature-vibe-coding</a></li>
  <li><a href="https://www.techradar.com/news/live/openai-chatgpt5-launch">https://www.techradar.com/news/live/openai-chatgpt5-launch</a></li>
  <li><a href="https://www.pcmag.com/news/with-gpt-5-openai-promises-access-to-phd-level-ai-expertise">https://www.pcmag.com/news/with-gpt-5-openai-promises-access-to-phd-level-ai-expertise</a></li>
  <li><a href="https://economictimes.indiatimes.com/magazines/panache/openai-introduces-chatgpt-5-features-performance-access-pricing-heres-all-you-need-to-know/articleshow/123174283.cms">https://economictimes.indiatimes.com/magazines/panache/openai-introduces-chatgpt-5-features-performance-access-pricing-heres-all-you-need-to-know/articleshow/123174283.cms</a></li>
  <li><a href="https://timesofindia.indiatimes.com/technology/tech-news/what-have-we-done-sam-altman-says-i-feel-useless-compares-chatgpt-5s-power-to-the-manhattan-project/articleshow/123112813.cms">https://timesofindia.indiatimes.com/technology/tech-news/what-have-we-done-sam-altman-says-i-feel-useless-compares-chatgpt-5s-power-to-the-manhattan-project/articleshow/123112813.cms</a></li>
  <li><a href="https://wandb.ai/byyoung3/ml-news/reports/GPT-5-Benchmark-Scores---VmlldzoxMzkwMTYyMg">https://wandb.ai/byyoung3/ml-news/reports/GPT-5-Benchmark-Scores—VmlldzoxMzkwMTYyMg</a></li>
  <li><a href="https://www.vellum.ai/blog/gpt-5-benchmarks">https://www.vellum.ai/blog/gpt-5-benchmarks</a></li>
  <li><a href="https://metr.github.io/autonomy-evals-guide/gpt-5-report/">https://metr.github.io/autonomy-evals-guide/gpt-5-report/</a></li>
  <li><a href="https://www.youtube.com/watch?v=0Uu_VJeVVfo">https://www.youtube.com/watch?v=0Uu_VJeVVfo</a></li>
  <li><a href="https://www.youtube.com/watch?v=tqPQB5sleHY">https://www.youtube.com/watch?v=tqPQB5sleHY</a></li>
  <li><a href="https://www.youtube.com/watch?v=2jqS7JD0hrY">https://www.youtube.com/watch?v=2jqS7JD0hrY</a></li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="학습" /><category term="ChatGPT" /><category term="OpenAI" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">AI Breakfast S2 Ep 1 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/08/06/00-AI-trend-with-google-s2-01.html" rel="alternate" type="text/html" title="AI Breakfast S2 Ep 1 생각정리" /><published>2025-08-06T00:00:00+00:00</published><updated>2025-08-06T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/06/00-AI-trend-with-google-s2-01</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/06/00-AI-trend-with-google-s2-01.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://youtu.be/Dm1V-ODwb1Q?si=aoeugkXlpHokwMNd"><img src="https://i.ytimg.com/vi/Dm1V-ODwb1Q/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>구글 I/O 2025 행사는 <strong>구글이 인공지능(AI) 분야의 주도권을 확실히 잡고 나아간다는 분위기</strong>였다.</p>

<p>이번 구글 I/O에서 가장 인상 깊었던 핵심 기술 및 발표 내용은 다음과 같다:</p>

<ul>
  <li><strong>Gemini 2.5 모델</strong>이 발표되었다. 이 모델은 <strong>Thinking 모델 기반에서 멀티모달리티를 강화한 모델</strong>이다. 기업에서 Gemini 모델을 사용할 때 더욱 정확하고 복잡한 문제를 풀 수 있을 것으로 기대된다. Gemini 2.5는 Deep research의 근간을 이루고 있으며, 복잡한 문제들을 쉽게 풀 수 있는 AI 모델이다.</li>
  <li><strong>Thinking 모델</strong>은 기존의 Instruction 모델과 달리, 한 번 더 단계적으로 추론하고 생각을 깊게 할 수 있도록 사전 학습된 모델이다. 이는 모델 훈련 과정에서 Thinking 과정을 추가하여 요청이 들어왔을 때 그 프로세스를 거치면서 답을 내도록 트레이닝된 것이다. 이를 통해 AI가 더 깊은 추론 능력을 갖게 되었다고 한다. Gemini 2.5 Pro는 LM Arena와 같은 공신력 있는 웹사이트에서 모든 영역에서 1위를 차지하며, Deep research 영역에서도 계속 상위에 올라와 있다고 언급된다.</li>
  <li><strong>Project Astra</strong>는 구글이 AI의 미래를 어떻게 이끌어갈 것인가에 대한 프로토타입 프로젝트이다. 이는 <strong>구글이 꿈꾸는 미래 AI의 모습, 즉 AGI(Artificial General Intelligence) 수준의 AI 비서</strong>를 보여준다. 사람처럼 커뮤니케이션할 수 있는 멀티모달리티 기능이 탑재되어 있다. Project Astra는 <strong>Live API</strong>를 기반으로 만들어지고 있다.</li>
  <li><strong>멀티모달리티(Multimodality)</strong>는 사람이 일반적으로 커뮤니케이션하는 방법과 동일하게 다양한 감각이나 유형의 정보를 컴퓨터가 학습하여 사고할 수 있게 만든 AI이다. 보이스, 시각(눈으로 보는 것), 텍스트, 문서 읽기 등 사람이 할 수 있는 일들을 AI가 할 수 있게 된 것이다. Gemini 2.5부터 Thinking 모델과 함께 멀티모달리티 기능이 매우 강화되었다.</li>
  <li><strong>생성형 미디어 모델들</strong>이 다양해졌다. 특히 <strong>Veo 3</strong>가 포함된 비디오 생성 모델과 Imagen을 통한 이미지 생성, 음악 생성 기능 등이 소개되었다. 이러한 미디어 제품들은 미디어 산업과 광고 분야에서 많이 활용될 것이라고 예상된다.</li>
  <li><strong>Code Assistance</strong>는 Gemini 2.5 버전을 기반으로 6월 12일에 출시되었으며, 개발자들의 반복적인 코드 작업을 해소하고 아키텍처 및 설계에 더 많은 시간을 할애할 수 있도록 도울 것이다.</li>
  <li><strong>Workspace</strong>에 다양한 AI 기술들이 도입되었다. Gmail에서 기존 메일 스레드를 참조하여 메일을 대신 작성해 주는 개인 맞춤형(personalization) 기능이 그 예시이다. 이는 AI가 어시스턴트 역할을 하는 방향으로 발전하고 있음을 보여준다.</li>
  <li><strong>ADK(AI Agent Development Kit)</strong>는 구글 넥스트 행사에서 처음 소개된 오픈 소스 프레임워크로, AI Agent 생태계를 키우고 기업들이 쉽게 Agent를 만들 수 있도록 지원하는 것을 목적으로 한다.</li>
  <li><strong>Firebase Studio</strong>는 개발자를 위한 프로토타이핑 툴로, 기존에 일주일에서 열흘 걸리던 프로토타이핑 작업을 몇 분 만에 가능하게 하여 개발자와 현업 간의 커뮤니케이션 및 생산성을 크게 향상시킬 것이다.</li>
  <li><strong>Live API</strong>는 짧은 지연 시간으로 양방향 음성 및 동영상 상호작용을 지원하며, 파운데이션 모델(예: Gemini)에 실시간 음성 및 동영상 스트리밍이 다이렉트하게 들어갈 수 있는 기술이다. 이는 사용자가 음성 명령이나 카메라를 통해 모델에 직접 정보를 전달하고 응답을 받을 수 있게 한다. Project Astra가 이 Live API를 기반으로 개발되고 있으며, 이는 미래의 일이 아니라 조만간 상용화될 것이라고 언급된다.</li>
</ul>

<p>AI의 발전 방향은 강화된 추론 능력 및 기획 능력, 멀티모달리티 및 라이브 커뮤니케이션의 진화, 그리고 온디바이스 및 오픈 소스 모델 쪽으로 진행되고 있다. 또한 AI는 헬스케어와 같은 분야에서도 데이터 분석 및 질병 패턴 파악에 큰 도움이 될 수 있으며, 개인 정보 보호(프라이버시), 컴플라이언스, 규제 등 윤리적인 측면도 매우 중요하게 다루고 있다고 한다.</p>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>WA!</p>

<p>사실 엄청난 뒷북일 수 있다. 하지만 2.5 Pro 를 아주 잘 활용하고 있고, 조만간 Gemini CLI 사용 한 것에 대한 후기도 남길 생각이지만, 2025년의 구글은 확실히 뭐가 달라도 다르다는 느낌이다.</p>

<p>TPU 사용이 가능하게 AI 를 구성하고, 플랫폼 모델을 기반으로 얼마나 다양한 프로젝트를 준비중인지, 결정적으로 API 비용이 싸다는 점을 포함하면 OpenAI가 ChatGPT 로 충격을 준 이래로 이만큼 괜찮은 업데이트가 있을까? 하는 생각이 들 정도의 충격이었다.</p>

<p>특히나 AI에 대한 노하우가 있기에 가능한 다양한 특화 서비스들은 당장 찾아보지 않았음에도, 일부 테스트만으로도 그 수준이 얼마나 괜찮은지 새삼 느꼈고, 단순히 웹 클라우드 프로바이저로 끝이 아닌, AI 를 위한 진짜 플랫폼이 되려는 의지가 확고하다는 것은 거를 타선이 없는 영역이리라 생각된다.</p>

<p>이번 내용을 기반으로 테스트 간단하게 해본 것들 중, 가장 흥미로웠던 것 두 가지를 뽑자면 다음과 같다.</p>

<ol>
  <li>AI Studio 를 활용한 Project Astra 데모 시연</li>
  <li>Firebase Studio를 활용한 진정한 딸깍(?)의 프로토타이핑</li>
</ol>

<p><img src="/assets/images/posts/2025-08/2025-08-06-001.png" alt="" /></p>
<blockquote>
  <p>캬…</p>
</blockquote>

<p>우선 AI 스튜디오에서 Stream Realtime 을 활용하면 Project Astra의 정말 기능적 데모를 써볼 수 있다. 보면 알 수 있듯 웹캠을 활용한 것인데, 확실한건 2.5 기반으로 데모시 정말 아주 빠른 반응속도로 상황을 해석하고, 표정도 읽어준다.</p>

<p>특히나 2.5 기반의 모델들은 구글의 워크스페이스, 일정이나 다양한 서비스 연동이 되는데, 이미 에이전트로 해야할 매우 큰 서비스들이 다 연결이 된다는 점에서 Project Astra 안경이 나온다면 정말 엄청난 일이 벌어지지 않을까? 솔직히 XR 보단 안경이 얼마이든 구매를 하고 싶단 생각이다(…)</p>

<p>두번째로 Firebase Studio, 요 친구도 아주 물건인데. 설명처럼 프로토 타이핑용으로 아주 제격인 서비스이다. 
서비스 자체는 대화형이라는 차원은 동일하고, 문서를 찾아보니 Project IDX 라는 구글의 웹기반 IDE 서비스 관련하던 것이 통합된 것으로 전에는 크게 신경을 쓰지 않았었는데, 이번 내용은 생각 이상이었다.</p>

<p><img src="/assets/images/posts/2025-08/2025-08-06-002.png" alt="" /></p>
<blockquote>
  <p>메인 화면</p>
</blockquote>

<p><img src="/assets/images/posts/2025-08/2025-08-06-003.png" alt="" /></p>
<blockquote>
  <p>슬쩍 프롬프트 넣어주고</p>
</blockquote>

<p><img src="/assets/images/posts/2025-08/2025-08-06-004.png" alt="" /></p>
<blockquote>
  <p>에러가 나오면 확인하고 처리를 하거나 하면 된다. API 키가 없어서 에러가 났다. 하지만 요청만 하면…</p>
</blockquote>

<p><img src="/assets/images/posts/2025-08/2025-08-06-005.png" alt="" /></p>
<blockquote>
  <p>적당히 수정해서, 기다리면 찰떡같이 알아 먹곤 프로토 웹 데모를 보여준다.</p>
</blockquote>

<p>5분 걸렸을까? 기초적인 기능 구현에서 이정도면 충분하게 동작하고, 무엇보다 대중적인 기술로 쉽게 구현 + 바로바로 에러 핸들링, 수정 결과까지 이정도 생산성의 증대는 과연 누가 생각이나 했을까? 기존의 IDX 프로젝트 때는 실질적으로 IDE 를 굳이 바꿔야 하나? 클라우드로 불편하게? 라는 의구심이 들었다면, 이정도라면 프로토타입을 만들기 위해 구태여 내가 AI 를 쓸 이유가 있을까?</p>

<p>물론 gemini-cli 를 활용한다는 건 로컬 환경에서 굉장히 효과적인 사용이 가능한 것은 맞다. 하지만 불편함이 없냐? 하면 사실 충분히 있다. MCP 의 연결이나, 세팅 등, 여러 면에서 번거롭게 일을 수행할 이유 보단 철저하게 ‘딸깍’을 하고 나온 내용을 스스로 분석하고 해석하는게 빠르지 않을까?</p>

<p><img src="/assets/images/posts/2025-08/2025-08-06-006.png" alt="" /></p>
<blockquote>
  <p>기존에 써보게 되었든 ‘스티치 AI’ 디자인용 AI 다</p>
</blockquote>

<p>기존 스티치 AI 라는 웹 퍼블리싱, 웹 디자인을 위한 툴이 있었는데 이것만으로도 훌륭했지만, 이젠 정말 에이전트의 개념이 충분히 녹아든 서비스가 나오며, 그걸 활용할 줄 아냐 모르느냐의 차이는 명백한 생산성, 무엇보다 기본 실력과 경험의 차이를 이끌 수 있겠다.</p>

<p>내가 필요한 서비스를 만들거나, 내가 필요한 기능을 구체화 한다. 거기서 핵심은 ‘내가 필요한’ 것이 아닌 것들을 AI에게 맡긴다면, 나는 내가 원하는 수준의 내 도메인을 위한 필요에 따른 스킵, 빠른 진행을 가능케 만들 수 있다는 것이다…. 진짜 멈춰 있을 틈이 없을 것 같다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">python AI 개발환경 설정(가상환경) + Jupyter lab (colab)</title><link href="http://0.0.0.0:4000/ai/2025/08/06/01-setting-python-for-ai-study.html" rel="alternate" type="text/html" title="python AI 개발환경 설정(가상환경) + Jupyter lab (colab)" /><published>2025-08-06T00:00:00+00:00</published><updated>2025-08-06T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/06/01-setting-python-for-ai-study</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/06/01-setting-python-for-ai-study.html"><![CDATA[<h2 id="python-ai-개발-환경-구축-로컬uv-vs-클라우드colab">Python AI 개발 환경 구축: 로컬(uv) vs. 클라우드(Colab)</h2>

<h3 id="1-개요">1. 개요</h3>

<p>이 문서는 파이썬 AI 개발을 위한 두 가지 주요 환경 구축 방법을 정리한 것이다. 첫 번째는 <code class="language-plaintext highlighter-rouge">uv</code>를 활용해 개인 PC에 구축하는 <strong>로컬(Local) 환경</strong>의 핵심 도구인 <strong>JupyterLab</strong>이고, 두 번째는 별도 설치가 필요 없는 <strong>클라우드(Cloud) 환경</strong>인 <strong>Google Colab</strong>이다. 각 환경의 개념과 특징을 이해하여 상황에 맞는 최적의 도구를 선택하고 활용하는 것을 목표로 한다.</p>

<hr />

<h3 id="2--로컬-개발-환경-uv--jupyterlab">2. 🚀 로컬 개발 환경 (<code class="language-plaintext highlighter-rouge">uv</code> + JupyterLab)</h3>

<h4 id="가-jupyterlab-이란">가. JupyterLab 이란?</h4>

<p><strong>JupyterLab</strong>은 웹 브라우저에서 실행되는 **통합 개발 환경(IDE)**이다. 단순히 코드를 작성하고 실행하는 노트북(<code class="language-plaintext highlighter-rouge">ipynb</code>) 기능을 넘어, 파일 탐색기, 터미널, 텍스트 편집기 등 데이터 과학 작업에 필요한 여러 도구를 하나의 작업 공간에 통합하여 제공한다.</p>

<blockquote>
  <p><strong>쉽게 비유하자면,</strong> JupyterLab은 데이터 과학자를 위한 **‘디지털 작업실’**과 같다. 작업실 안에서 코드가 담긴 노트북, 각종 데이터 파일, 명령어 창을 한눈에 펼쳐놓고 유기적으로 오가며 전체 프로젝트를 관리할 수 있는 유연한 공간이다.</p>
</blockquote>

<h4 id="나-로컬-환경-도구로-uv를-선택한-이유">나. 로컬 환경 도구로 <code class="language-plaintext highlighter-rouge">uv</code>를 선택한 이유</h4>

<p>전통적인 <code class="language-plaintext highlighter-rouge">conda</code>나 <code class="language-plaintext highlighter-rouge">pip</code>+<code class="language-plaintext highlighter-rouge">venv</code> 조합 대신 <code class="language-plaintext highlighter-rouge">uv</code>를 선택한 이유는 <strong>속도와 간결함</strong>을 통해 현대적이고 효율적인 개발 환경을 구성하기 위함이다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">uv</code>의 핵심 장점</strong>:
    <ol>
      <li><strong>압도적인 속도</strong>: <code class="language-plaintext highlighter-rouge">uv</code>는 Rust로 작성되어 기존 <code class="language-plaintext highlighter-rouge">pip</code>이나 <code class="language-plaintext highlighter-rouge">conda</code> 대비 수십 배에서 수백 배 빠른 패키지 설치 및 의존성 해결 속도를 보여준다. 기다리는 시간을 극적으로 줄여준다.</li>
      <li><strong>통합된 도구</strong>: 가상 환경 생성(<code class="language-plaintext highlighter-rouge">venv</code>)과 패키지 설치(<code class="language-plaintext highlighter-rouge">pip</code>) 기능을 <code class="language-plaintext highlighter-rouge">uv</code> 명령어 하나로 통합하여 관리의 복잡성을 낮춘다.</li>
      <li><strong>간결함과 표준</strong>: 파이썬 표준 패키지 인덱스(PyPI)를 사용하면서도 미니멀하고 빠른 환경 구축을 가능하게 한다.</li>
    </ol>
  </li>
</ul>

<h4 id="다-환경-구축-절차-uv-활용">다. 환경 구축 절차 (<code class="language-plaintext highlighter-rouge">uv</code> 활용)</h4>

<ol>
  <li><strong>Python 3.9 설치 (사전 조건)</strong>
Homebrew를 통해 특정 버전의 파이썬을 설치한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>python@3.9
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">uv</code> 가상 환경 설정</strong>
프로젝트 폴더를 생성 후, <code class="language-plaintext highlighter-rouge">uv</code>로 Python 3.9 기반의 가상 환경(<code class="language-plaintext highlighter-rouge">.venv</code>)을 만든다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>my-local-project <span class="o">&amp;&amp;</span> <span class="nb">cd </span>my-local-project
uv venv <span class="nt">--python</span> 3.9
<span class="nb">source</span> .venv/bin/activate
</code></pre></div>    </div>
  </li>
  <li><strong>JupyterLab 설치 및 실행</strong>
활성화된 가상 환경 내에서 <code class="language-plaintext highlighter-rouge">uv pip</code>으로 JupyterLab을 설치하고 실행한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uv pip <span class="nb">install </span>jupyterlab
jupyter lab
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="라-주요-단축키">라. 주요 단축키</h4>

<p>Jupyter의 작업 효율은 <strong>명령 모드</strong>와 <strong>입력 모드</strong>의 이해에서 시작된다.</p>

<ul>
  <li><strong>명령 모드 (Command Mode)</strong>: 셀 테두리가 <strong>파란색</strong>. 셀 자체를 하나의 블록 단위로 다룬다. (<code class="language-plaintext highlighter-rouge">Esc</code>로 진입)</li>
  <li><strong>입력 모드 (Edit Mode)</strong>: 셀 테두리가 <strong>초록색</strong>. 셀 내부에 코드를 입력하고 수정한다. (<code class="language-plaintext highlighter-rouge">Enter</code>로 진입)</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">단축키 (Win/Linux: Ctrl)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**(필수) 셀 실행**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Shift + Enter</code></td>
      <td style="text-align: left">현재 셀 실행 후, 아래 셀로 이동한다.</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + Enter</code></td>
      <td style="text-align: left">현재 셀 실행 후, 커서는 그대로 유지된다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**셀 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">A</code> (명령 모드)</td>
      <td style="text-align: left">현재 셀 **위에** 새 셀을 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">B</code> (명령 모드)</td>
      <td style="text-align: left">현재 셀 **아래에** 새 셀을 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**셀 관리**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">D, D</code> (명령 모드)</td>
      <td style="text-align: left">현재 셀을 삭제한다. (D를 두 번 누름)</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">X</code> / <code class="language-plaintext highlighter-rouge">C</code> / <code class="language-plaintext highlighter-rouge">V</code> (명령 모드)</td>
      <td style="text-align: left">셀을 잘라내기 / 복사 / 붙여넣기 한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**셀 타입 변경**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">M</code> (명령 모드)</td>
      <td style="text-align: left">셀을 마크다운 타입으로 변경한다.</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Y</code> (명령 모드)</td>
      <td style="text-align: left">셀을 코드 타입으로 변경한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**코드 편집**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + /</code> (입력 모드)</td>
      <td style="text-align: left">선택한 코드 라인을 주석 처리/해제한다.</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Shift + Tab</code> (입력 모드)</td>
      <td style="text-align: left">함수 괄호 안에서 함수의 설명(Docstring)을 본다.</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="3-️-클라우드-개발-환경-google-colaboratory">3. ☁️ 클라우드 개발 환경 (Google Colaboratory)</h3>

<h4 id="가-google-colab-이란">가. Google Colab 이란?</h4>

<p>**Google Colaboratory(Colab)**는 구글이 제공하는 <strong>클라우드 기반의 무료 Jupyter Notebook 환경</strong>이다. 모든 연산이 구글의 서버에서 이루어지므로 별도의 설치 과정 없이 웹 브라우저만으로 강력한 개발 환경을 이용할 수 있다.</p>

<blockquote>
  <p><strong>쉽게 비유하자면,</strong> Colab은 **‘구글이 제공하는 고사양 컴퓨터를 인터넷을 통해 무료로 빌려 쓰는 것’**과 같다. 내 컴퓨터 사양과 무관하게 딥러닝 모델을 학습시킬 수 있는 것이 최대 장점이다.</p>
</blockquote>

<ul>
  <li><strong>핵심 장점</strong>:
    <ul>
      <li><strong>설치 불필요 (Zero Setup)</strong>: 웹 브라우저와 구글 계정만 있으면 즉시 사용 가능하다.</li>
      <li><strong>무료 GPU/TPU 제공</strong>: 딥러닝 등 고사양 연산에 필수적인 하드웨어를 무료로 제공한다.</li>
      <li><strong>쉬운 공유와 협업</strong>: 링크 하나로 노트북을 공유하고 실시간으로 함께 편집할 수 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="나-주요-단축키">나. 주요 단축키</h4>

<p>Colab은 Jupyter와 많은 단축키를 공유하지만, <code class="language-plaintext highlighter-rouge">Ctrl + M</code> (macOS: <code class="language-plaintext highlighter-rouge">Cmd + M</code>) 조합을 사용하는 고유한 단축키가 많다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">단축키 (Win: Ctrl, Mac: Cmd)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**(필수) 셀 실행**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Shift + Enter</code> / <code class="language-plaintext highlighter-rouge">Cmd + Enter</code></td>
      <td style="text-align: left">Jupyter와 동일하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**셀 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + M, A</code></td>
      <td style="text-align: left">현재 셀 **위에** 새 셀을 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + M, B</code></td>
      <td style="text-align: left">현재 셀 **아래에** 새 셀을 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**셀 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + M, D</code></td>
      <td style="text-align: left">현재 셀을 삭제한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**셀 타입 변경**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + M, M</code></td>
      <td style="text-align: left">셀을 텍스트(마크다운) 타입으로 변경한다.</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + M, Y</code></td>
      <td style="text-align: left">셀을 코드 타입으로 변경한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**명령어 팔레트**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Cmd + Shift + P</code></td>
      <td style="text-align: left">모든 기능을 검색하고 실행할 수 있는 창을 연다.</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="4--로컬-vs-클라우드-언제-무엇을-쓸까">4. 💡 로컬 vs. 클라우드: 언제 무엇을 쓸까?</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: left">**로컬 환경 (<code class="language-plaintext highlighter-rouge">uv</code> + JupyterLab)**</th>
      <th style="text-align: left">**클라우드 환경 (Google Colab)**</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**초기 설정**</td>
      <td style="text-align: left">**필요** (Python, uv, 라이브러리 설치)</td>
      <td style="text-align: left">**불필요** (웹 브라우저로 접속하면 끝)</td>
    </tr>
    <tr>
      <td style="text-align: left">**성능**</td>
      <td style="text-align: left">내 PC 사양에 의존</td>
      <td style="text-align: left">**무료 GPU/TPU 제공** (고성능)</td>
    </tr>
    <tr>
      <td style="text-align: left">**인터넷 연결**</td>
      <td style="text-align: left">오프라인 작업 가능</td>
      <td style="text-align: left">**필수**</td>
    </tr>
    <tr>
      <td style="text-align: left">**파일 관리**</td>
      <td style="text-align: left">자유롭고 빠름 (로컬 파일 시스템)</td>
      <td style="text-align: left">구글 드라이브 연동 또는 업로드/다운로드 필요</td>
    </tr>
    <tr>
      <td style="text-align: left">**적합한 작업**</td>
      <td style="text-align: left">- 인터넷이 없는 환경에서의 작업&lt;br&gt;- 맞춤형 환경 구축&lt;br&gt;- 가벼운 데이터 분석 및 스크립팅</td>
      <td style="text-align: left">- **딥러닝 모델 학습**&lt;br&gt;- 빠른 프로토타이핑&lt;br&gt;- 팀원과의 코드 공유 및 협업</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="학습" /><category term="Python" /><category term="Jupyter-lab" /><category term="colab" /><category term="google" /><category term="UV" /><summary type="html"><![CDATA[Python AI 개발 환경 구축: 로컬(uv) vs. 클라우드(Colab)]]></summary></entry><entry><title type="html">AI Breakfast Ep 11 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/08/05/00-AI-trend-with-google-11.html" rel="alternate" type="text/html" title="AI Breakfast Ep 11 생각정리" /><published>2025-08-05T00:00:00+00:00</published><updated>2025-08-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/05/00-AI-trend-with-google-11</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/05/00-AI-trend-with-google-11.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=P7TzvAJ6n_w"><img src="https://i.ytimg.com/vi/P7TzvAJ6n_w/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>이번 내용은 AI와 대규모 언어 모델(LLM)이 코딩 및 개발자 역할에 미치는 영향, 그리고 현재의 한계와 미래 전망에 대한 논의이다.</p>

<ul>
  <li><strong>대규모 언어 모델(LLM)과 코딩의 미래</strong>:
    <ul>
      <li>LLM은 기존 자연어 처리(NLP) 솔루션과 달리 <strong>단일 모델로 다양한 NLP 작업을 수행할 수 있으며</strong>, 수 테라바이트의 레이블 없는 데이터로 학습된 <strong>기초 모델</strong>이다.</li>
      <li>현재의 구조화된 프로그래밍 언어는 LLM에 비적합하며, 미래에는 <strong>자동 회귀(auto-regressive) 방식으로 한 줄씩 진화하는 새로운 프로그래밍 언어가 등장할 수 있다</strong>고 예상된다. 이는 토큰 사용량을 대폭 줄일 것이다. =&gt; 이 인사이트는 염두해 둬야 하는, 어쩌면 개선해야할 AI 영역일 것임.</li>
      <li>LLM은 언어를 ‘이해’하는 것이 아니라 학습된 패턴을 기반으로 <strong>다음에 올 가장 확률 높은 토큰을 예측하는 정교한 수학적 함수</strong>이며, 트랜스포머 아키텍처와 어텐션 메커니즘을 사용한다.</li>
    </ul>
  </li>
  <li><strong>개발자의 역할 변화와 비즈니스 영향</strong>:
    <ul>
      <li>먼 미래에는 개발자 직업이 사라질 수 있다는 예측에 동의하며, 5년 이내에도 개발 인력이 크게 줄어들 수 있다고 보았다.</li>
      <li>LLM은 개발자의 <strong>생산성을 10배 이상 향상</strong>시켜, 개발자가 기획보다 빠르게 결과물을 내놓는 시대로 전환시키고 있다.</li>
      <li>코딩은 상품화를 위한 중간 과정이며, <strong>AI를 통해 대체 가능한 부분</strong>으로 여겨진다.</li>
      <li>앞으로는 큰 도메인 지식을 갖춘 <strong>‘빅픽처 전문가’ 또는 ‘프로덕트 엔지니어’가 중요</strong>해질 것이며, AI에게 명확한 요구사항을 전달하는 능력이 핵심이다.</li>
      <li>비개발자들도 코딩에 참여하는 <strong>개발의 ‘민주화’ 현상</strong>이 나타나고 있다.</li>
      <li><strong>인간과 기술은 공존해야 하며</strong>, AI를 받아들이고 경험하는 정도가 개인의 대체 여부를 결정하는 중요한 요소이다.</li>
    </ul>
  </li>
  <li><strong>바이브 코딩의 실제 적용과 한계</strong>:
    <ul>
      <li>바이브 코딩은 <strong>빠르게 데모를 만들고 결과물을 검증하는 데 효과적</strong>이다.</li>
      <li>그러나 <strong>보안이 매우 취약할 수 있어</strong> 금융 등 중요한 분야에서는 도입에 거부감이 크다.</li>
      <li>큰 범위의 프로젝트에는 아직 적용하기 어렵다.</li>
      <li>AI가 생성한 코드는 방대하여 인간이 리뷰하기 어렵고, <strong>AI 생성 코드에 대한 신뢰도가 아직 높지 않다</strong>.</li>
      <li>LLM의 한계로 인해 복잡한 문제 해결 시에는 <strong>인간이 직접 고치는 것이 더 빠르다</strong>.</li>
      <li>LLM은 학습된 지식 내에서만 작동하며 <strong>메타인지 능력이 부족하여 새로운 지식에 대한 업데이트나 함수 생성에 어려움</strong>이 있다.</li>
      <li>정확한 결과물을 얻기 위해서는 <strong>요구사항을 아주 세분화하여 명확하게 설계하고, 테스트를 잘 작성하는 능력</strong>이 중요해졌다.</li>
      <li>생성된 코드를 다시 설계 문서 등으로 <strong>‘리버스 엔지니어링’하여 저장하고 관리하는 방식</strong>이 활용될 수 있다.</li>
      <li>사용자는 <strong>‘프롬프트 문해력’을 길러야</strong> 하며, 생성된 결과를 올바르게 이해하고 검증해야 한다. =&gt; 결국 프롬프트 문해력이란것이 무엇인가? 프롬프트를 잘 작성한다는 게 무엇인가? 를 이해해야 한다.</li>
    </ul>
  </li>
  <li><strong>결론 및 시사점</strong>:
    <ul>
      <li>LLM 시대에는 <strong>인간의 도메인 지식과 노하우, 그리고 비판적 사고가 더욱 중요</strong>해지며, LLM의 명확한 한계를 인지하고 이를 보완하는 것이 필요하다.</li>
      <li>개개인은 <strong>‘언어의 경계가 곧 세계의 경계’라는 철학자의 말처럼</strong>, 어떤 언어(프롬프트)를 구사하느냐에 따라 자신의 가능성이 달라지므로, <strong>무한히 도전해 볼 것</strong>이 권장된다.</li>
    </ul>
  </li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>Gemini 의 성능을 약간 보여주는 화 같아서(물론 그래도 잘 만들긴 하더라 ㅋㅋ), 핵심적인 내용들, 개발자로 가져야 하는 태도에 대해 다시 한번 생각해본 시간이었다.</p>

<p>여전히 한계로 지적되는 부분, 즉 구조적으로 현 AI 는 코딩을 하기에 효율적인 도구가 아니고, ‘효율적인 척’ 하면서 GPU 를 녹이고 있다는 사실을 다시 한 번 강조했다.</p>

<p>생각해보면 그정도로 자기 회귀적으로 진행되는 구조로 가는 건 어쩌면 모든 점에서 더 나을 건데, 과연 그런 형태의 예측이나, 알고리즘 개선이 되는지는 잘 모르겠다는 생각이 든다. (수알못이라…)</p>

<p>어쨌든 모델의 개선도 지속적으로 이루어지고 있으니, 어쩌면 그러한 부분까지 언젠가는 개선이 되지 않을까 하는 생각은 해본다. 메타가 거의 백억단위 연봉을 주며 개발자를 데려가고 AGI 그 이상의 초 인공지능을 만들겠다고 하니, 결국 AI 는 양과 질의 향상이 계속 될 것은 맞고, 그런걸 실현 가능한 사람이 되는게 1티어 급 인사가 되는 길이 아닐까?</p>

<p>어쨌든, 일단 현 개발자라는 차원에서 본다면 사용 방법에 대해, 내 방법이 틀린게 아니었구나 ~ 하는 생각이 들었다.</p>

<p>무조건 맡기는 식으론 매우 위험하고, MVP 그 이상으로 빠르게 구현이 되지만 보안의 문제는 확실하게 존재한다. 더불어 회사가 그걸 용인해주는 곳인가? 여러 면에서 편리함, 효용성에 +로 고려할 것을 미리미리 고려하는 것은 매우 중요한 부분이라고 생각된다.</p>

<p>어쩌면 나만의 검증 절차를 AI 로 체계화 하는 것, 그리고 그걸 내 작업 루틴에 넣는 것이 포함되면 좋지 않을까? 하는 생각을 하게 된다. 그리고 그걸 종합해서 적절하게 코드 리포트 형태로 만든다거나 하는 것도 괜찮지 않을까?</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry></feed>