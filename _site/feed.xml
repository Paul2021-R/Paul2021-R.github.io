<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-09-15T06:28:43+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">CS 학습 - 9월 3주차</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03.html" rel="alternate" type="text/html" title="CS 학습 - 9월 3주차" /><published>2025-09-15T00:00:00+00:00</published><updated>2025-09-15T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03.html"><![CDATA[<h2 id="알고리즘">알고리즘</h2>

<h3 id="sort">Sort</h3>
<h4 id="1-삽입-정렬-insertion-sort">1. 삽입 정렬 (Insertion Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757913162355_f8k6df.png" alt="" /></p>

<h5 id="1-1-개념">1-1. 개념</h5>

<p>삽입 정렬은 <strong>처리되지 않은 데이터를 이미 정렬된 부분의 적절한 위치에 삽입</strong>해 나가는 방식으로 동작한다. 손안의 카드를 정렬할 때, 새로운 카드를 이미 정렬된 카드 뭉치의 올바른 자리에 꽂는 과정과 유사하다.</p>

<p>2번째 원소부터 시작하여 그 앞(왼쪽)의 데이터들과 비교하여 삽입할 위치를 지정하고, 데이터를 뒤로 옮긴 후 해당 자리에 삽입한다.</p>

<h5 id="1-2-시간-복잡도">1-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n)$ - 이미 데이터가 모두 정렬되어 있는 경우, 외부 루프만 한 번 순회한다.</li>
  <li><strong>평균(Average):</strong> $O(n^2)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 데이터가 역순으로 정렬되어 있는 경우, 모든 요소를 비교하고 이동시켜야 한다.</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
삽입 정렬은 데이터셋의 크기가 작거나, 데이터가 거의 정렬된 상태일 때 매우 효율적으로 동작한다. 이런 특성 때문에 다른 복잡한 정렬 알고리즘(예: 팀 정렬)의 <strong>일부</strong>로 사용되기도 한다.</p>
</blockquote>

<h5 id="1-3-python-구현-코드">1-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># 배열의 2번째 요소(인덱스 1)부터 시작
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 정렬할 대상이 되는 요소
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>     <span class="c1"># 비교 대상이 되는 정렬된 부분의 마지막 인덱스
</span>        
        <span class="c1"># key를 정렬된 부분의 올바른 위치에 삽입
</span>        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># 요소를 한 칸씩 오른쪽으로 이동
</span>            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="c1"># 찾은 위치에 key를 삽입
</span>    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">삽입 정렬 결과: </span><span class="si">{</span><span class="nf">insertion_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="2-버블-정렬-bubble-sort">2. 버블 정렬 (Bubble Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916208845_6sxbw2.png" alt="" /></p>

<h5 id="2-1-개념">2-1. 개념</h5>

<p>버블 정렬은 <strong>인접한 두 개의 원소를 비교하며 자리를 교환</strong>하는 방식으로 동작한다. 배열의 처음부터 끝까지 순회하면서, 왼쪽 값이 오른쪽 값보다 크면 두 값의 위치를 바꾼다. 이</p>

<p>러한 한 번의 순회(Pass)가 끝나면 가장 큰 원소가 배열의 맨 끝으로 이동하게 된다. 이 과정을 배열의 크기만큼 반복한다. 마치 물속의 거품(Bubble)이 위로 올라오는 모습과 같아 버블 정렬이라는 이름이 붙었다.</p>

<h5 id="2-2-시간-복잡도">2-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n)$ - 이미 데이터가 정렬된 상태에서, 한 번의 순회 중 교환(swap)이 발생하지 않으면 정렬을 종료하는 로직을 추가했을 경우이다.</li>
  <li><strong>평균(Average):</strong> $O(n^2)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 데이터가 역순으로 정렬되어 있는 경우이다.</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
버블 정렬은 구현이 매우 간단하여 정렬 알고리즘의 기본 원리를 학습하는 데는 좋지만, 성능이 좋지 않아 실제 현업에서 사용되는 경우는 거의 없다.</p>
</blockquote>

<h5 id="2-3-python-구현-코드">2-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># 배열의 크기만큼 외부 루프를 반복
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># 이미 정렬된 마지막 요소들을 제외하고 내부 루프를 반복
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 왼쪽 요소가 오른쪽 요소보다 크면 교환
</span>            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">swapped</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># 한 번의 순회 동안 교환이 일어나지 않았다면, 이미 정렬된 상태
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">버블 정렬 결과: </span><span class="si">{</span><span class="nf">bubble_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-병합-정렬-merge-sort">3. 병합 정렬 (Merge Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916435555_h2m3yt.png" alt="" /></p>
<h5 id="3-1-개념">3-1. 개념</h5>

<p>병합 정렬은 <strong>분할 정복(Divide and Conquer)</strong> 패러다임을 사용하는 대표적인 정렬 알고리즘이다.</p>

<ol>
  <li><strong>분할(Divide):</strong> 배열의 크기가 1이 될 때까지 재귀적으로 계속해서 반으로 나눈다.</li>
  <li><strong>정복(Conquer):</strong> 나누어진 작은 배열들을 2개씩 쌍을 이루어 정렬하면서 병합(Merge)한다. 이 과정을 모든 배열이 다시 하나로 합쳐질 때까지 반복한다.</li>
</ol>

<h5 id="3-2-시간-복잡도">3-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n \log n)$</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
병합 정렬은 데이터의 분포와 상관없이 항상 $O(n \log n)$의 시간 복잡도를 보장하여 안정적(Stable)이다. 하지만 정렬 과정에서 임시 배열을 위한 추가적인 <strong>메모리 공간($O(n)$)</strong> 이 필요하다는 단점이 있다.</p>
</blockquote>

<h5 id="3-3-python-구현-코드">3-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="c1"># 1. 분할 (Divide)
</span>    <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left_half</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">right_half</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
    
    <span class="c1"># 2. 정복 및 병합 (Conquer and Merge)
</span>    <span class="n">merged_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l_idx</span><span class="p">,</span> <span class="n">r_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">l_idx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">left_half</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r_idx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">right_half</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">]:</span>
            <span class="n">merged_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">])</span>
            <span class="n">l_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">])</span>
            <span class="n">r_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="c1"># 남은 요소들을 추가
</span>    <span class="n">merged_arr</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">:])</span>
    <span class="n">merged_arr</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">:])</span>
    
    <span class="k">return</span> <span class="n">merged_arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">병합 정렬 결과: </span><span class="si">{</span><span class="nf">merge_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="4-힙-정렬-heap-sort">4. 힙 정렬 (Heap Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916561788_se2vpw.png" alt="" /></p>

<h5 id="4-1-개념">4-1. 개념</h5>

<p>힙 정렬은 <strong>힙(Heap) 자료구조</strong>를 이용하여 정렬하는 알고리즘이다. 힙은 ‘완전 이진 트리’의 한 종류로, 부모 노드의 값이 항상 자식 노드의 값보다 크거나 같은(최대 힙) 또는 작거나 같은(최소 힙) 속성을 만족한다.</p>

<ol>
  <li>주어진 데이터를 최대 힙(Max Heap) 구조로 만든다.</li>
  <li>힙에서 가장 큰 값은 루트(root) 노드에 위치한다. 이 루트 노드를 배열의 가장 마지막 요소와 바꾼다.</li>
  <li>힙의 크기를 하나 줄이고, 다시 힙 속성을 만족하도록 구조를 재조정(heapify)한다.</li>
  <li>힙의 크기가 1이 될 때까지 2~3번 과정을 반복한다.</li>
</ol>

<h5 id="4-2-시간-복잡도">4-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n \log n)$</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
힙 정렬은 병합 정렬과 달리 추가적인 <strong>메모리 공간을 거의 사용하지 않는($O(1)$)</strong> 장점이 있으며, 항상 $O(n \log n)$의 성능을 보장한다. <strong>우선순위 큐</strong>를 구현할 때 매우 유용하다.</p>
</blockquote>

<h5 id="4-3-python-구현-코드">4-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># 현재 서브트리의 루트
</span>    <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
    
    <span class="c1"># 왼쪽 자식이 루트보다 크면 largest를 업데이트
</span>    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
        
    <span class="c1"># 오른쪽 자식이 largest보다 크면 largest를 업데이트
</span>    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
        
    <span class="c1"># largest가 변경되었다면, 루트와 교환하고 재귀적으로 heapify 호출
</span>    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="c1"># 1. 최대 힙(Max Heap) 구성
</span>    <span class="c1"># 마지막 비단말 노드부터 시작하여 루트까지 heapify 수행
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
    <span class="c1"># 2. 힙에서 요소를 하나씩 추출하여 정렬
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 루트(최댓값)를 배열의 끝으로 이동
</span>        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># 크기가 줄어든 힙에 대해 heapify 수행
</span>        
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">힙 정렬 결과: </span><span class="si">{</span><span class="nf">heap_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="4-4-heapq-모듈-사용-예시-및-장단점">4-4. heapq 모듈 사용 예시 및 장단점</h5>

<p>Python의 내장 라이브러리인 <code class="language-plaintext highlighter-rouge">heapq</code>를 사용하면 힙 자료구조를 간단하게 활용할 수 있다. 다음은 <code class="language-plaintext highlighter-rouge">heapq</code>를 이용해 리스트를 정렬하는 예시 코드이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="k">def</span> <span class="nf">heapq_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 모든 원소를 힙에 차례대로 삽입
</span>    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    
    <span class="c1"># 힙에서 모든 원소를 차례대로 꺼내 정렬된 리스트 생성
</span>    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">sorted_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">sorted_arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">heapq를 이용한 정렬 결과: </span><span class="si">{</span><span class="nf">heapq_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># 더 간결한 방법: heapify 사용
</span><span class="k">def</span> <span class="nf">heapq_sort_concise</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># 리스트를 한 번에 힙으로 변환 (O(n))
</span>    <span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">sorted_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">sorted_arr</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># 최대 힙으로 사용할 리스트
</span><span class="n">max_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="c1"># 1. 최대 힙에 원소 추가 (부호를 바꿔서 heappush)
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">--- 최대 힙에 원소 추가 ---</span><span class="sh">"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s"> 추가 후 힙 상태: </span><span class="si">{</span><span class="n">max_heap</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">최종 최대 힙 (내부 표현):</span><span class="sh">"</span><span class="p">,</span> <span class="n">max_heap</span><span class="p">)</span> <span class="c1"># 내부적으로는 음수 값을 가진 최소 힙
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">가장 큰 값(루트): </span><span class="si">{</span><span class="o">-</span><span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">--- 최대 힙에서 원소 추출 ---</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># 2. 최대 힙에서 원소 추출 (heappop 후 부호를 다시 변경)
</span><span class="k">while</span> <span class="n">max_heap</span><span class="p">:</span>
    <span class="c1"># 가장 작은 음수(원래는 가장 큰 양수)를 꺼내서 부호를 복원
</span>    <span class="n">max_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">추출된 최댓값: </span><span class="si">{</span><span class="n">max_val</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
기존 리스트를 제자리에서 힙으로 변환하는 heapq.heapify(list) 함수를 사용하면 $O(n)$의 시간 복잡도로 힙을 구성할 수 있어, 모든 원소를 하나씩 heappush 하는 것보다 효율적이다.</p>
</blockquote>

<ul>
  <li><strong>구현 대비 장점</strong>
    <ul>
      <li><strong>간결성:</strong> 복잡한 <code class="language-plaintext highlighter-rouge">heapify</code> 로직을 직접 구현할 필요 없이, 몇 줄의 코드로 힙 기능을 사용할 수 있어 매우 편리하다.</li>
      <li><strong>성능:</strong> 내장 모듈은 C언어로 구현되어 있어 일반적으로 직접 Python으로 구현한 코드보다 실행 속도가 빠르다.</li>
      <li><strong>안정성:</strong> 이미 충분히 검증된 라이브러리이므로 직접 구현 시 발생할 수 있는 실수를 방지하고 코드의 안정성을 높일 수 있다.</li>
    </ul>
  </li>
  <li><strong>구현 대비 단점</strong>
    <ul>
      <li><strong>추상화:</strong> 내부 동작 원리가 감춰져 있어 힙 정렬의 학습 목적으로는 적합하지 않다.</li>
      <li><strong>추가 메모리 사용:</strong> 위 예시처럼 정렬된 결과를 담을 새로운 리스트가 필요하므로, 제자리 정렬(in-place sort)이 아니며 $O(n)$의 추가 공간이 필요하다.</li>
      <li><strong>최소 힙 고정:</strong> <code class="language-plaintext highlighter-rouge">heapq</code>는 최소 힙(Min Heap)만 지원하므로 최대 힙(Max Heap)이 필요할 경우, 값의 부호를 변경하는 등의 추가적인 처리가 필요하다.</li>
    </ul>
  </li>
</ul>

<p>— 2025년 9월 15일 학습</p>

<h4 id="5-퀵-정렬-quick-sort"><strong>5. 퀵 정렬 (Quick Sort)</strong></h4>

<h5 id="5-1-개념"><strong>5-1. 개념</strong></h5>

<p>퀵 정렬 또한 <strong>분할 정복</strong> 패러다임을 사용하며, 평균적으로 매우 빠른 성능을 자랑한다.</p>

<ol>
  <li>배열 내에서 임의의 기준점, **피벗(Pivot)**을 선택한다.</li>
  <li>피벗을 기준으로 피벗보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 분할(Partition)한다.</li>
  <li>분할된 양쪽의 부분 배열에 대해 재귀적으로 퀵 정렬을 수행한다.</li>
  <li>부분 배열의 크기가 1 이하가 되면 정렬을 멈춘다.</li>
</ol>

<h5 id="5-2-시간-복잡도"><strong>5-2. 시간 복잡도</strong></h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$ - 피벗이 항상 배열을 절반으로 분할할 때이다.</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 피벗이 항상 가장 작거나 가장 큰 값으로 선택되어 배열이 한쪽으로 치우치게 분할될 때이다 (예: 이미 정렬된 배열에서 항상 첫 요소를 피벗으로 선택).</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
퀵 정렬은 평균적인 성능이 매우 뛰어나 ‘퀵’이라는 이름이 붙었으며, 많은 프로그래밍 언어의 표준 정렬 라이브러리에서 기본 알고리즘으로 채택되곤 한다. 최악의 경우를 피하기 위해 피벗을 랜덤하게 선택하거나, 세 값의 중앙값(Median-of-three)을 선택하는 등의 기법이 사용된다.</p>
</blockquote>

<h5 id="5-3-python-구현-코드"><strong>5-3. Python 구현 코드</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># 중앙값을 피벗으로 설정
</span>    <span class="n">lesser_arr</span><span class="p">,</span> <span class="n">equal_arr</span><span class="p">,</span> <span class="n">greater_arr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">lesser_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">greater_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">equal_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">lesser_arr</span><span class="p">)</span> <span class="o">+</span> <span class="n">equal_arr</span> <span class="o">+</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">greater_arr</span><span class="p">)</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">퀵 정렬 결과: </span><span class="si">{</span><span class="nf">quick_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h4 id="6-각-정렬-알고리즘-시간-복잡도-비교"><strong>6. 각 정렬 알고리즘 시간 복잡도 비교</strong></h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘 (Algorithm)</th>
      <th style="text-align: center">최선 (Best)</th>
      <th style="text-align: center">평균 (Average)</th>
      <th style="text-align: center">최악 (Worst)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**삽입 정렬**</td>
      <td style="text-align: center">$O(n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**버블 정렬**</td>
      <td style="text-align: center">$O(n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**병합 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**힙 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**퀵 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="7-번외-그-외에-개발-시-사용하면-좋을-정렬-기법"><strong>7. (번외) 그 외에 개발 시 사용하면 좋을 정렬 기법</strong></h4>

<p>이론적인 학습을 넘어 실제 개발 환경에서는 언어 차원에서 제공하는 내장 정렬 함수를 사용하는 것이 일반적이다. 이 함수들은 대부분의 상황에 최적화된 고성능 알고리즘을 사용한다.</p>

<ul>
  <li>
    <p><strong>팀 정렬 (Timsort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 병합 정렬과 삽입 정렬을 결합한 하이브리드 안정 정렬(Stable Sort) 알고리즘이다.</li>
      <li><strong>특징:</strong> 실제 데이터는 완전히 무작위가 아니라 어느 정도 정렬된 연속적인 부분(run)을 포함하는 경우가 많다는 점에서 착안되었다. 이런 ‘run’들을 찾아서 삽입 정렬로 처리하고, 이 run들을 효율적으로 병합해 나간다. 적응형(Adaptive) 알고리즘으로, 데이터의 상태에 따라 최적의 성능을 낸다.</li>
      <li><strong>용도:</strong> <strong>Python</strong>의 내장 정렬 함수(<code class="language-plaintext highlighter-rouge">sorted()</code>, <code class="language-plaintext highlighter-rouge">list.sort()</code>)와 Java의 <code class="language-plaintext highlighter-rouge">Arrays.sort()</code> (객체 배열용)에서 표준 알고리즘으로 사용된다.</li>
    </ul>
  </li>
  <li>
    <p><strong>기수 정렬 (Radix Sort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 비교 기반 정렬이 아니다. 데이터의 자릿수(radix)를 이용하여 낮은 자릿수부터 정렬해 나가는 방식이다. 예를 들어, 10진수 정수를 정렬한다면 1의 자리, 10의 자리, 100의 자리 순으로 정렬을 수행한다.</li>
      <li><strong>특징:</strong> 시간 복잡도는 $O(d(n+k))$ (d: 자릿수, n: 데이터 개수, k: 기수)로, 데이터의 길이가 짧고 개수가 많을 때 비교 기반 정렬인 $O(n \log n)$보다 빠를 수 있다.</li>
      <li><strong>용도:</strong> 정수나 문자열 등 자릿수 구분이 명확한 데이터들을 정렬할 때 효과적이다. (예: 대규모 숫자 데이터 정렬, 사전순 문자열 정렬)</li>
    </ul>
  </li>
  <li>
    <p><strong>계수 정렬 (Counting Sort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 비교 기반 정렬이 아니다. 각 숫자가 몇 번 등장했는지 개수를 센 다음, 누적합을 이용하여 각 숫자의 정렬된 위치를 계산하는 방식이다.</li>
      <li><strong>특징:</strong> 데이터 값의 범위(range)가 데이터의 개수(n)에 비해 작을 때 매우 빠른 성능을 보인다. 시간 복잡도는 $O(n+k)$ (k: 데이터의 최댓값)이다.</li>
      <li><strong>용도:</strong> 정수 데이터, 특히 양수이고 값의 범위가 한정적일 때 사용하기 좋다. (예: 0~100점 사이의 시험 점수 정렬)</li>
    </ul>
  </li>
</ul>

<h3 id="동적-프로그래밍dynamic-programming">동적 프로그래밍(Dynamic Programming)</h3>

<h3 id="재귀-알고리즘">재귀 알고리즘</h3>

<h3 id="알고리즘---고급">알고리즘 - 고급</h3>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[알고리즘]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차 (2)" /><published>2025-09-09T00:00:00+00:00</published><updated>2025-09-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02.html"><![CDATA[<h2 id="자료구조와-알고리즘-feat-ts와-python-을-얹은">자료구조와 알고리즘 (feat, TS와 Python 을 얹은)</h2>

<h3 id="typescript-vs-python-배열array-사용법-비교">TypeScript vs. Python: 배열(Array) 사용법 비교</h3>

<p><strong>TypeScript는 정적 타입을 지원하여 코드의 안정성을 높이는 반면, Python은 동적 타이핑으로 유연하고 간결한 코드 작성을 지원한다.</strong></p>
<h4 id="1-배열의-선언과-초기화">1. 배열의 선언과 초기화</h4>

<p>가장 큰 차이점은 <strong>타입 명시 여부</strong>이다. TypeScript는 변수 선언 시 타입을 지정하여 예측 가능하고 안정적인 코드를 작성하도록 유도하는 반면, Python은 타입을 명시하지 않아도 되어 간결하다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 배열이 담을 요소의 타입을 명시적으로 지정해야 한다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">let list: number[] = [1, 2, 3];</code></li>
      <li><code class="language-plaintext highlighter-rouge">let list: Array&lt;number&gt; = [1, 2, 3];</code></li>
      <li>다양한 타입을 허용하려면 유니온 타입(<code class="language-plaintext highlighter-rouge">(string | number)[]</code>)을 사용할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Python</strong>: 파이썬의 리스트는 기본적으로 모든 데이터 타입을 담을 수 있는 동적 배열이다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">my_list = [1, "hello", True]</code></li>
      <li>타입을 강제하고 싶다면 <code class="language-plaintext highlighter-rouge">array</code> 모듈을 사용하거나, 타입 힌트(Type Hint)를 활용할 수 있으나, 이는 강제 사항이 아니다.</li>
      <li><code class="language-plaintext highlighter-rouge">from array import array</code></li>
      <li><code class="language-plaintext highlighter-rouge">arr = array('i', [1, 2, 3])</code></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-요소-접근-추가-및-삭제">2. 요소 접근, 추가 및 삭제</h4>

<p>배열의 요소를 다루는 기본적인 방법은 유사하지만, 사용하는 메서드의 이름과 기능에서 차이가 나타난다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">TypeScript</th>
      <th style="text-align: left">Python (List)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**요소 접근**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr[0]</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list[0]</code>, <code class="language-plaintext highlighter-rouge">my_list[-1]</code></td>
      <td style="text-align: left">TypeScript와 Python 모두 인덱스로 요소에 접근한다. Python은 음수 인덱스를 지원하여 뒤에서부터 접근이 가능하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 뒤에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.push(4)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.append(4)</code></td>
      <td style="text-align: left">가장 일반적인 요소 추가 방식이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 앞에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.unshift(0)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.insert(0, 0)</code></td>
      <td style="text-align: left">TypeScript에는 <code class="language-plaintext highlighter-rouge">unshift</code>라는 명확한 메서드가 있다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 인덱스에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.splice(1, 0, 1.5)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.insert(1, 1.5)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">splice</code>는 추가, 삭제, 교체가 모두 가능하여 더 강력하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 뒤 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.pop()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop()</code></td>
      <td style="text-align: left">두 언어 모두 동일한 이름의 메서드를 사용한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 앞 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.shift()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop(0)</code> 또는 <code class="language-plaintext highlighter-rouge">del my_list[0]</code></td>
      <td style="text-align: left">TypeScript는 <code class="language-plaintext highlighter-rouge">shift</code> 메서드를 제공한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 인덱스 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.splice(1, 1)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop(1)</code> 또는 <code class="language-plaintext highlighter-rouge">del my_list[1]</code></td>
      <td style="text-align: left">특정 위치의 요소를 삭제하는 기능이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 값으로 요소 삭제**</td>
      <td style="text-align: left">(직접 구현 필요)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.remove(3)</code></td>
      <td style="text-align: left">Python은 값으로 요소를 찾아 삭제하는 <code class="language-plaintext highlighter-rouge">remove</code> 메서드를 기본 제공한다.</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="3-배열-순회-반복">3. 배열 순회 (반복)</h4>

<p>배열의 모든 요소를 순차적으로 접근하여 작업을 수행하는 반복문에서도 약간의 차이가 존재한다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">for...of</code>, <code class="language-plaintext highlighter-rouge">forEach</code>, 그리고 전통적인 <code class="language-plaintext highlighter-rouge">for</code> 루프를 주로 사용한다.</p>

    <ul>
      <li><strong>for…of</strong>: 배열의 ‘값(value)’을 순차적으로 가져온다. (가장 권장되는 방식 중 하나)
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>
<span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong>forEach</strong>: 각 요소에 대해 콜백 함수를 실행한다.
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">list</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Index </span><span class="p">${</span><span class="nx">index</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">for...in</code> 구문을 사용하는 것이 가장 일반적이고 파이썬다운(Pythonic) 방법이다.</p>

    <ul>
      <li><strong>for…in</strong>: 배열의 ‘값(value)’을 순차적으로 가져온다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li><strong>enumerate</strong>: 인덱스와 값을 함께 가져와야 할 때 유용하게 사용된다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="typescript-vs-python-배열-순회-및-변형-심화">TypeScript vs. Python: 배열 순회 및 변형 심화</h3>
<p><strong>TypeScript는 메서드 체이닝(Method Chaining)을 통해 가독성을 높이는 반면, Python은 리스트 컴프리헨션이라는 독특하고 간결한 구문을 통해 강력한 기능을 제공한다.</strong></p>

<h4 id="1-배열의-각-요소를-변형하기-mapping">1. 배열의 각 요소를 변형하기 (Mapping)</h4>

<p><code class="language-plaintext highlighter-rouge">map</code>은 배열의 모든 요소를 순회하며 주어진 함수를 적용하여 <strong>새로운 배열을 생성</strong>하는 기능이다. 원본 배열은 변경되지 않는다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">map()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">squared</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">);</span>
<span class="c1">// squared: [1, 4, 9, 16]</span>
</code></pre></div>    </div>

    <p>각 요소에 함수를 순차적으로 적용하고 그 결과값을 모아 새로운 배열로 반환하는 직관적인 방식이다.</p>
  </li>
  <li>
    <p><strong>Python</strong>: 리스트 컴프리헨션(List Comprehension)이 가장 일반적이고 효율적인 방법이다. <code class="language-plaintext highlighter-rouge">map()</code> 함수도 존재한다.</p>

    <ul>
      <li><strong>리스트 컴프리헨션</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squared</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
<span class="c1"># squared: [1, 4, 9, 16]
</span></code></pre></div>        </div>
        <p>대괄호 안에 <code class="language-plaintext highlighter-rouge">for</code> 루프를 포함하는 형태로, 매우 간결하고 가독성이 높다고 평가받는다.</p>
      </li>
      <li><strong>map() 함수</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1"># map 객체를 반환하므로 list로 변환 필요
</span><span class="n">squared</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span> 
<span class="c1"># squared: [1, 4, 9, 16]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-조건에-맞는-요소만-걸러내기-filtering">2. 조건에 맞는 요소만 걸러내기 (Filtering)</h4>

<p><code class="language-plaintext highlighter-rouge">filter</code>는 배열의 모든 요소를 순회하며, 주어진 함수의 결과값이 <code class="language-plaintext highlighter-rouge">true</code>인 요소들만 모아 <strong>새로운 배열을 생성</strong>하는 기능이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">filter()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">evens</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// evens: [2, 4]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: 여기서도 리스트 컴프리헨션이 널리 쓰인다.</p>

    <ul>
      <li><strong>리스트 컴프리헨션</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># evens: [2, 4]
</span></code></pre></div>        </div>
        <p><code class="language-plaintext highlighter-rouge">for</code> 루프 뒤에 <code class="language-plaintext highlighter-rouge">if</code> 조건을 추가하여 필터링 기능을 구현한다.</p>
      </li>
      <li><strong>filter() 함수</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1"># filter 객체를 반환하므로 list로 변환 필요
</span><span class="n">evens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">num</span><span class="p">:</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span>
<span class="c1"># evens: [2, 4]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="3-배열을-하나의-값으로-통합하기-reducing">3. 배열을 하나의 값으로 통합하기 (Reducing)</h4>

<p><code class="language-plaintext highlighter-rouge">reduce</code>는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하여 <strong>하나의 결과값</strong>을 반환한다. 누적 계산에 주로 사용된다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">reduce()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">sum</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">accumulator</span><span class="p">,</span> <span class="nx">currentValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">accumulator</span> <span class="o">+</span> <span class="nx">currentValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// sum: 15</span>
<span class="c1">// 0은 accumulator의 초기값이다.</span>
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">accumulator</code>는 이전 콜백의 반환값이 누적되는 변수이고, <code class="language-plaintext highlighter-rouge">currentValue</code>는 현재 처리 중인 요소이다.</p>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">functools</code> 모듈의 <code class="language-plaintext highlighter-rouge">reduce()</code> 함수를 사용해야 한다. (Python 3.x부터 내장 함수에서 모듈로 이동했다)</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">sum_value</span> <span class="o">=</span> <span class="nf">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">current_value</span><span class="p">:</span> <span class="n">accumulator</span> <span class="o">+</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># sum_value: 15
# 0은 초기값(initializer)이다.
</span></code></pre></div>    </div>

    <p>물론, 합계를 구하는 경우 파이썬의 내장 함수 <code class="language-plaintext highlighter-rouge">sum()</code>을 쓰는 것이 훨씬 간단하고 효율적이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sum_value</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># 결과: 15
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="typescript-vs-python-연결-리스트linked-list-구현-및-사용법">TypeScript vs. Python: 연결 리스트(Linked List) 구현 및 사용법</h3>
<p>TypeScript와 Python 모두 <strong>연결 리스트(Linked List)를 직접 구현해야 한다는 점은 동일하다.</strong> 두 언어 모두 배열(리스트)과 달리 내장된 연결 리스트 자료 구조를 제공하지 않기 때문. 하지만 <strong>TypeScript는 타입 시스템을 활용해 노드(Node)의 구조를 명확하게 정의하여 안정성을 높이는 반면, Python은 간결한 문법으로 더 빠르게 구현할 수 있다.</strong></p>

<p>연결 리스트는 각 요소가 데이터와 다음 요소를 가리키는 포인터(참조)를 함께 가지고 있는 선형 자료 구조이다. 배열과 달리 메모리에 연속적으로 위치하지 않아 삽입과 삭제가 효율적이다.</p>

<h4 id="1-노드node와-리스트-구조-정의">1. 노드(Node)와 리스트 구조 정의</h4>

<p>연결 리스트를 구현하는 첫 단계는 기본 단위인 <strong>노드</strong>를 정의하는 것이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">interface</code>나 <code class="language-plaintext highlighter-rouge">class</code>를 사용해 노드의 형태를 명확하게 정의한다. 타입 시스템 덕분에 <code class="language-plaintext highlighter-rouge">value</code>의 타입과 <code class="language-plaintext highlighter-rouge">next</code> 포인터가 <code class="language-plaintext highlighter-rouge">Node</code> 혹은 <code class="language-plaintext highlighter-rouge">null</code>임을 강제할 수 있다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 노드의 구조 정의</span>
<span class="kr">interface</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="nl">next</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 노드 클래스</span>
<span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="k">public</span> <span class="na">next</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 연결 리스트 클래스</span>
<span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">head</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">// ... 추가적인 메서드들</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">class</code>를 사용하여 노드를 정의한다. 타입 힌트(<code class="language-plaintext highlighter-rouge">Type Hint</code>)를 사용할 수는 있지만, TypeScript처럼 강제되지는 않는다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 노드 클래스
</span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># 연결 리스트 클래스
</span><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># ... 추가적인 메서드들
</span></code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-핵심-연산-노드-추가-및-순회">2. 핵심 연산: 노드 추가 및 순회</h4>

<p>가장 기본적인 연산인 ‘맨 뒤에 노드 추가’와 ‘리스트 순회’를 비교해 본다. 로직 자체는 동일하지만, 코드의 세부적인 표현에서 차이가 나타난다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 타입 검사를 통과해야 하므로 <code class="language-plaintext highlighter-rouge">null</code> 체크가 명시적으로 이루어진다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">head</span><span class="p">:</span> <span class="nx">Node</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="c1">// 맨 뒤에 노드 추가</span>
  <span class="k">public</span> <span class="nf">append</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">current</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 리스트 순회 및 출력</span>
  <span class="k">public</span> <span class="nf">printAll</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="kd">const</span> <span class="na">values</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">values</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> -&gt; </span><span class="dl">'</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: 문법이 더 간결하며, <code class="language-plaintext highlighter-rouge">None</code>을 활용한 <code class="language-plaintext highlighter-rouge">null</code> 체크가 자연스럽게 이루어진다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># 맨 뒤에 노드 추가
</span>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="k">return</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">new_node</span>
            
    <span class="c1"># 리스트 순회 및 출력
</span>    <span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s"> -&gt; </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>결론적으로, 두 언어 모두 동일한 자료 구조의 원리를 따라 연결 리스트를 구현한다. TypeScript는 제네릭(<code class="language-plaintext highlighter-rouge">T</code>)과 인터페이스를 통해 재사용 가능하고 타입-안전(type-safe)한 코드를 작성하도록 유도하는 반면, Python은 더 적은 코드로 빠르게 핵심 로직을 구현하는 데 강점을 보인다.</p>

<h3 id="typescript-vs-python-스택stack-구현-및-사용법">TypeScript vs. Python: 스택(Stack) 구현 및 사용법</h3>

<p>스택(Stack) 역시 TypeScript와 Python 모두 내장된 자료 구조가 아니므로, <strong>배열(리스트)을 활용하여 직접 구현하는 것이 일반적이다.</strong> 두 언어의 구현 방식은 매우 유사하며, 핵심적인 차이는 <strong>TypeScript의 타입-안전성(Type-Safety)과 Python의 간결함</strong>에서 비롯된다.</p>

<p>스택은 ‘마지막에 들어온 것이 가장 먼저 나가는’(LIFO, Last-In, First-Out) 원칙을 따르는 자료 구조이다. 접시를 쌓고 위에서부터 차례로 꺼내는 것을 생각하면 이해하기 쉽다.</p>

<h4 id="1-스택의-구현-방식">1. 스택의 구현 방식</h4>

<p>배열(리스트)의 끝에서 데이터를 추가하고 제거하는 <code class="language-plaintext highlighter-rouge">push</code>와 <code class="language-plaintext highlighter-rouge">pop</code> 연산은 스택의 LIFO 동작 원리와 완벽하게 일치한다. 따라서 배열을 감싸는(wrapping) 클래스를 만들어 스택을 구현하는 것이 가장 효율적이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 제네릭(<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>)을 사용하여 어떤 타입의 데이터든 담을 수 있는 타입-안전한 스택 클래스를 정의한다. 내부 배열을 <code class="language-plaintext highlighter-rouge">private</code>으로 선언하여 외부에서 직접 접근하는 것을 막고, <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code> 같은 메서드를 통해서만 조작하도록 캡슐화하는 것이 일반적이다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 스택에 데이터 추가 (push)</span>
  <span class="nf">push</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 스택에서 데이터 추출 (pop)</span>
  <span class="nf">pop</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 스택의 가장 위 데이터 확인 (peek)</span>
  <span class="nf">peek</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 스택이 비어있는지 확인</span>
  <span class="nf">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: Python의 리스트는 그 자체로 스택처럼 사용될 수 있다. <code class="language-plaintext highlighter-rouge">append()</code> 메서드가 <code class="language-plaintext highlighter-rouge">push</code> 역할을, <code class="language-plaintext highlighter-rouge">pop()</code> 메서드가 <code class="language-plaintext highlighter-rouge">pop</code> 역할을 한다. 가독성과 재사용성을 위해 클래스로 감싸는 것이 좋은 관례이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 관례적으로 _ 를 붙여 내부에서만 사용함을 표시
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 스택에 데이터 추가 (push)
</span>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># 스택에서 데이터 추출 (pop)
</span>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="c1"># 혹은 예외 발생
</span>
    <span class="c1"># 스택의 가장 위 데이터 확인 (peek)
</span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 음수 인덱싱 활용
</span>        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 스택이 비어있는지 확인
</span>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-핵심-연산-비교">2. 핵심 연산 비교</h4>

<p>스택의 핵심 연산인 <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code>, <code class="language-plaintext highlighter-rouge">peek</code>를 비교하면 두 언어의 철학 차이가 드러난다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">TypeScript</th>
      <th style="text-align: left">Python (List 기반)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**Push (추가)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items.push(item)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items.append(item)</code></td>
      <td style="text-align: left">TypeScript는 <code class="language-plaintext highlighter-rouge">push</code>, Python은 <code class="language-plaintext highlighter-rouge">append</code>를 사용하여 배열(리스트)의 끝에 요소를 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**Pop (추출)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items.pop()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items.pop()</code></td>
      <td style="text-align: left">두 언어 모두 동일한 이름의 <code class="language-plaintext highlighter-rouge">pop()</code> 메서드를 사용하며, 배열의 마지막 요소를 제거하고 반환한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**Peek (확인)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items[items.length - 1]</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items[-1]</code></td>
      <td style="text-align: left">Python의 음수 인덱싱(<code class="language-plaintext highlighter-rouge">-1</code>)이 마지막 요소를 가리키므로 코드가 더 간결하다.</td>
    </tr>
  </tbody>
</table>

<p>결론적으로, 스택을 구현하는 알고리즘은 두 언어에서 동일하다. TypeScript는 정적 타입을 통해 의도치 않은 타입의 데이터가 스택에 들어오는 것을 컴파일 시점에 막아주어 안정성을 높여준다. 반면, Python은 특유의 간결한 문법(음수 인덱싱 등)을 통해 더 빠르게 코드를 작성할 수 있는 장점이 있다.</p>

<blockquote>
  <p>언더바(<code class="language-plaintext highlighter-rouge">_</code>)의 의미</p>
  <ul>
    <li>싱글 언더스코어 : <code class="language-plaintext highlighter-rouge">_var</code>(보호된 멤버)
  클래스 상에서 싱글 언더스코어는 보호된 멤버라는 뜻, 즉, 내부 사용용이니 조심히 사용하는 것을 권장한다는 의미를 내포함. 클래스 서계자의 의도와 다르게 사용될 수 있으니 주의가 필요함.</li>
    <li>더블 언더스코어 : <code class="language-plaintext highlighter-rouge">__var</code>(비공개 멤버)
  외부에서 사용을 적극적으로 막기 위해 사용되는 케이스. Python 인터프리터가 이 변수의 이름을 Name Mangling 이라는 기술로, 사용시 내부적으로 <code class="language-plaintext highlighter-rouge">__items</code> 를 <code class="language-plaintext highlighter-rouge">__ClassName__items</code> 로 형태를 바꾸며, 사용시 AttributeError 가 발생될 수 있다.</li>
  </ul>
</blockquote>

<h3 id="typescript-vs-python-큐queue-구현-및-사용법">TypeScript vs. Python: 큐(Queue) 구현 및 사용법</h3>
<p>큐(Queue)를 구현할 때, <strong>Python은 <code class="language-plaintext highlighter-rouge">collections</code> 모듈에 포함된 <code class="language-plaintext highlighter-rouge">deque</code>라는 매우 효율적인 자료 구조를 기본으로 제공한다.</strong> 반면, <strong>TypeScript는 내장된 큐 자료 구조가 없어 개발자가 직접 구현해야 하며, 간단한 배열(Array)을 사용하거나 성능을 위해 연결 리스트(Linked List)를 기반으로 만들어야 한다.</strong></p>

<p>큐는 ‘가장 먼저 들어온 것이 가장 먼저 나가는’(FIFO, First-In, First-Out) 원칙을 따르는 자료 구조이다. 은행 창구나 놀이공원의 줄서기를 생각하면 쉽게 이해할 수 있다.</p>

<h4 id="1-큐-구현-방식의-핵심-차이">1. 큐 구현 방식의 핵심 차이</h4>

<p>큐의 핵심은 한쪽 끝(rear)에서는 데이터를 추가하고, 반대쪽 끝(front)에서는 데이터를 제거하는 것이다. 이 “앞에서 제거하는” 연산 때문에 일반적인 배열(리스트)을 사용하면 성능 문제가 발생할 수 있다.</p>

<ul>
  <li><strong>배열의 비효율성</strong>: 배열의 맨 앞 요소를 제거(<code class="language-plaintext highlighter-rouge">shift()</code> 또는 <code class="language-plaintext highlighter-rouge">pop(0)</code>)하면, 그 뒤의 모든 요소들을 한 칸씩 앞으로 당겨야 한다. 이 작업은 배열의 크기가 클수록 오래 걸리는, 즉 성능이 좋지 않은 연산(시간 복잡도 O(n))이다.</li>
  <li><strong>Python의 해결책</strong>: Python은 이러한 문제를 해결하기 위해 양쪽 끝에서 데이터를 추가하고 제거하는 속도(O(1))가 매우 빠른 <code class="language-plaintext highlighter-rouge">deque</code>(데크, double-ended queue)를 제공한다.</li>
  <li><strong>TypeScript의 선택지</strong>: TypeScript는 개발자가 상황에 맞게 구현 방식을 선택해야 한다.
    <ol>
      <li><strong>간단한 구현</strong>: 배열의 <code class="language-plaintext highlighter-rouge">shift()</code> 메서드를 사용해 간단히 구현 (데이터가 적을 때 유용).</li>
      <li><strong>성능적 구현</strong>: 이전에 다룬 연결 리스트를 기반으로 직접 구현 (데이터가 많고 성능이 중요할 때).</li>
    </ol>
  </li>
</ul>

<hr />

<h4 id="2-python-collectionsdeque-활용">2. Python: <code class="language-plaintext highlighter-rouge">collections.deque</code> 활용</h4>

<p>Python에서 큐를 구현할 때는 <code class="language-plaintext highlighter-rouge">deque</code>를 사용하는 것이 가장 표준적이고 효율적인 방법이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># deque 객체를 내부에서 사용한다.
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_items</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>

    <span class="c1"># 큐의 뒤쪽에 데이터 추가 (enqueue)
</span>    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># 큐의 앞쪽에서 데이터 추출 (dequeue)
</span>    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="c1"># popleft()는 O(1) 시간 복잡도를 가진다.
</span>            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 큐의 가장 앞 데이터 확인 (peek)
</span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 큐가 비어있는지 확인
</span>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span>
</code></pre></div></div>

<hr />

<h4 id="3-typescript-배열-또는-연결-리스트-활용">3. TypeScript: 배열 또는 연결 리스트 활용</h4>

<p>TypeScript에서는 내장된 <code class="language-plaintext highlighter-rouge">deque</code>가 없으므로, 두 가지 방식으로 접근할 수 있다.</p>

<h5 id="1-배열을-이용한-간단한-구현">1. 배열을 이용한 간단한 구현</h5>

<p>가장 직관적이고 빠르게 구현할 수 있는 방법이지만, 성능 저하의 가능성을 인지하고 있어야 한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 큐의 뒤쪽에 데이터 추가 (enqueue)</span>
  <span class="nf">enqueue</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 큐의 앞쪽에서 데이터 추출 (dequeue)</span>
  <span class="nf">dequeue</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="c1">// shift()는 O(n)의 시간 복잡도를 가져 성능에 불리할 수 있다.</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 큐의 가장 앞 데이터 확인 (peek)</span>
  <span class="nf">peek</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 큐가 비어있는지 확인</span>
  <span class="nf">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-성능을-위한-연결-리스트-기반-구현">2. 성능을 위한 연결 리스트 기반 구현</h5>

<p>데이터의 양이 많고, 추가/삭제가 빈번하게 일어나는 등 성능이 중요한 상황에서는 연결 리스트를 기반으로 큐를 구현하는 것이 정석이다. 연결 리스트의 <code class="language-plaintext highlighter-rouge">head</code>에서 노드를 제거하고(<code class="language-plaintext highlighter-rouge">dequeue</code>), <code class="language-plaintext highlighter-rouge">tail</code>에 새로운 노드를 추가(<code class="language-plaintext highlighter-rouge">enqueue</code>)하는 방식이다. 이 경우, 두 연산 모두 O(1)의 빠른 시간 복잡도를 보장받을 수 있다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[자료구조와 알고리즘 (feat, TS와 Python 을 얹은)]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차 (3)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-03.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차 (3)" /><published>2025-09-09T00:00:00+00:00</published><updated>2025-09-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-03.html"><![CDATA[<h2 id="자료구조와-알고리즘-feat-ts와-python-을-얹은">자료구조와 알고리즘 (feat, TS와 Python 을 얹은)</h2>

<h3 id="typescript-vs-python-해시-테이블hash-table-사용법">TypeScript vs. Python: 해시 테이블(Hash Table) 사용법</h3>
<p>Python과 TypeScript 모두 해시 테이블(Hash Table) 기능을 언어의 핵심적인 내장 기능으로 제공한다.** Python은 <strong>딕셔너리(<code class="language-plaintext highlighter-rouge">dict</code>)가 이 역할을 수행하며, TypeScript(JavaScript)에서는 일반 객체(<code class="language-plaintext highlighter-rouge">Object</code>)와 더불어 <code class="language-plaintext highlighter-rouge">Map</code> 객체</strong>를 사용하는 것이 정석이다. <code class="language-plaintext highlighter-rouge">Map</code> 객체는 키(key)의 타입이 자유롭다는 점에서 Python의 딕셔너리와 더 유사하다.</p>

<p>해시 테이블은 <strong>Key-Value 쌍</strong>으로 데이터를 저장하는 자료 구조로, 키를 해시 함수(Hash Function)에 통과시켜 얻은 인덱스(Index)에 값을 저장한다. 이 방식 덕분에 데이터의 추가, 검색, 삭제가 평균적으로 매우 빠른 시간 복잡도(O(1))를 가진다.</p>

<h4 id="1-해시-테이블의-선언과-초기화">1. 해시 테이블의 선언과 초기화</h4>

<p>두 언어 모두 직관적인 문법으로 해시 테이블을 생성할 수 있다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: 중괄호 <code class="language-plaintext highlighter-rouge">{}</code>를 사용하여 딕셔너리를 생성하는 것이 가장 일반적이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 빈 딕셔너리 생성
</span><span class="n">hash_table</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># 초기 값을 가진 딕셔너리 생성
</span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">is_active</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript</strong>: JavaScript의 <code class="language-plaintext highlighter-rouge">Map</code> 객체를 사용하는 것이 가장 강력하고 권장되는 방법이다. <code class="language-plaintext highlighter-rouge">Map</code>은 모든 타입의 값을 키로 사용할 수 있어 유연성이 높다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 빈 Map 생성 (key: string, value: any)</span>
<span class="kd">const</span> <span class="nx">hashTable</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// 초기 값을 가진 Map 생성</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span><span class="o">&gt;</span><span class="p">([</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">isActive</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">]</span>
<span class="p">]);</span>
</code></pre></div>    </div>

    <p>물론, JavaScript의 일반 객체(<code class="language-plaintext highlighter-rouge">{}</code>)도 해시 테이블처럼 사용할 수 있지만, 키가 문자열이나 심볼(Symbol) 타입으로 제한되는 단점이 있다.</p>
  </li>
</ul>

<hr />

<h4 id="2-데이터-추가-접근-삭제">2. 데이터 추가, 접근, 삭제</h4>

<p>Key를 이용해 데이터를 조작하는 방식은 두 언어가 매우 유사하다.</p>

<ul>
  <li>
    <p><strong>Python</strong>:</p>

    <ul>
      <li><strong>추가/수정</strong>: <code class="language-plaintext highlighter-rouge">hash_table[key] = value</code></li>
      <li><strong>접근</strong>: <code class="language-plaintext highlighter-rouge">hash_table[key]</code> (키가 없으면 <code class="language-plaintext highlighter-rouge">KeyError</code> 발생) 또는 <code class="language-plaintext highlighter-rouge">hash_table.get(key)</code> (키가 없으면 <code class="language-plaintext highlighter-rouge">None</code> 반환)</li>
      <li><strong>삭제</strong>: <code class="language-plaintext highlighter-rouge">del hash_table[key]</code></li>
    </ul>

    <!-- end list -->

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>

<span class="c1"># 추가/수정
</span><span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span>
<span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">city</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Seoul</span><span class="sh">"</span>

<span class="c1"># 접근
</span><span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">])</span>       <span class="c1"># "John Doe"
</span><span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">email</span><span class="sh">"</span><span class="p">))</span>  <span class="c1"># None
</span>
<span class="c1"># 삭제
</span><span class="k">del</span> <span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="c1"># {'name': 'John Doe', 'city': 'Seoul'}
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript (<code class="language-plaintext highlighter-rouge">Map</code> 객체 기준)</strong>:</p>

    <ul>
      <li><strong>추가/수정</strong>: <code class="language-plaintext highlighter-rouge">hashTable.set(key, value)</code></li>
      <li><strong>접근</strong>: <code class="language-plaintext highlighter-rouge">hashTable.get(key)</code> (키가 없으면 <code class="language-plaintext highlighter-rouge">undefined</code> 반환)</li>
      <li><strong>삭제</strong>: <code class="language-plaintext highlighter-rouge">hashTable.delete(key)</code></li>
      <li><strong>키 존재 여부 확인</strong>: <code class="language-plaintext highlighter-rouge">hashTable.has(key)</code></li>
    </ul>

    <!-- end list -->

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// 추가/수정</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span> <span class="c1">// 수정</span>

<span class="c1">// 접근</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// "Jane Doe"</span>

<span class="c1">// 키 존재 여부 확인</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>

<span class="c1">// 삭제</span>
<span class="nx">user</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span> <span class="c1">// Map(1) { 'name' =&gt; 'Jane Doe' }</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="3-순회-iteration">3. 순회 (Iteration)</h4>

<p>해시 테이블의 모든 Key-Value 쌍을 순회하는 방법도 유사한 패턴을 가진다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">for</code> 루프와 함께 <code class="language-plaintext highlighter-rouge">.keys()</code>, <code class="language-plaintext highlighter-rouge">.values()</code>, <code class="language-plaintext highlighter-rouge">.items()</code> 메서드를 활용한다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>

<span class="c1"># Key 순회
</span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">user</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># name, age
</span>      
<span class="c1"># Value 순회
</span><span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">user</span><span class="p">.</span><span class="nf">values</span><span class="p">():</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># "John Doe", 30
</span>      
<span class="c1"># Key, Value 동시 순회
</span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">user</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
  <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript (<code class="language-plaintext highlighter-rouge">Map</code> 객체 기준)</strong>: <code class="language-plaintext highlighter-rouge">forEach</code> 루프나 <code class="language-plaintext highlighter-rouge">for...of</code> 구문을 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span><span class="p">([</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="p">]);</span>

<span class="c1">// forEach 사용 (value, key 순서)</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// for...of 사용 (key, value 순서)</span>
<span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="typescript-vs-python-트리tree-구조-구현-및-사용법">TypeScript vs. Python: 트리(Tree) 구조 구현 및 사용법</h3>

<p><strong>Python과 TypeScript 모두 트리(Tree)는 내장된 자료 구조가 아니므로, 일반적으로 클래스(Class)를 이용해 직접 노드(Node)와 트리 관계를 정의하여 구현해야 한다.</strong> 두 언어의 구현 로직은 거의 동일하지만, <strong>TypeScript는 제네릭과 타입 시스템을 통해 노드가 가질 데이터의 타입을 명확히 하여 안정성을 확보</strong>하는 반면, <strong>Python은 더 간결하고 유연한 코드로 빠르게 구현</strong>할 수 있다는 점에서 차이를 보인다.</p>

<p>트리는 이름 그대로 나무를 뒤집어 놓은 듯한 계층적 자료 구조이다. 최상위 노드인 루트(Root)에서 시작해 여러 자식 노드(Child Node)가 가지처럼 뻗어 나가는 형태를 가진다. 이진 트리(Binary Tree), 이진 탐색 트리(Binary Search Tree) 등 다양한 종류가 있지만, 여기서는 가장 기본이 되는 노드와 트리 구조의 구현에 초점을 맞춘다.</p>

<h4 id="1-노드node-및-트리tree-클래스-정의">1. 노드(Node) 및 트리(Tree) 클래스 정의</h4>

<p>트리를 구성하는 가장 기본 단위는 데이터와 자식 노드들의 참조를 담고 있는 ‘노드’이다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: 클래스를 이용해 간단하게 노드를 정의할 수 있다. 자식 노드들은 보통 리스트(list)로 관리한다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 트리 노드 클래스
</span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 자식 노드를 담을 리스트
</span>
    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">child_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child_node</span><span class="p">)</span>

<span class="c1"># 트리 클래스 (루트 노드를 가짐)
</span><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root_node</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript</strong>: 제네릭(<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>)을 활용하여 노드가 담을 데이터의 타입을 지정하고, <code class="language-plaintext highlighter-rouge">children</code> 배열 역시 해당 노드 타입의 배열임을 명시하여 타입 안정성을 높인다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 트리 노드 클래스</span>
<span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="k">public</span> <span class="na">children</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 자식 노드를 담을 배열</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">addChild</span><span class="p">(</span><span class="na">childNode</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">childNode</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 트리 클래스</span>
<span class="kd">class</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">root</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">rootNode</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="nx">rootNode</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-트리-순회-tree-traversal">2. 트리 순회 (Tree Traversal)</h4>

<p>트리의 모든 노드를 방문하는 것을 순회(Traversal)라고 한다. 대표적인 방법으로 깊이 우선 탐색(DFS, Depth-First Search)과 너비 우선 탐색(BFS, Breadth-First Search)이 있다. 여기서는 DFS를 재귀(Recursion) 방식으로 구현하는 예를 보인다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: 재귀 호출을 이용해 간결하게 DFS를 구현할 수 있다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root_node</span>

    <span class="c1"># 깊이 우선 탐색 (DFS)
</span>    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">):</span>
        <span class="c1"># 현재 노드의 값을 출력 (또는 다른 작업 수행)
</span>        <span class="nf">print</span><span class="p">(</span><span class="n">start_node</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
            
        <span class="c1"># 자식 노드들을 재귀적으로 방문
</span>        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">start_node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="c1"># 사용 예시
</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">E</span><span class="sh">"</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">tree</span> <span class="o">=</span> <span class="nc">Tree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="n">tree</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">root</span><span class="p">)</span> <span class="c1"># 결과: A B D E C
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript</strong>: 로직은 Python과 동일하지만, 노드의 타입을 명시하여 코드의 명확성을 높인다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">root</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ... 생성자 ...</span>

  <span class="c1">// 깊이 우선 탐색 (DFS)</span>
  <span class="k">public</span> <span class="nf">dfs</span><span class="p">(</span><span class="na">startNode</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c1">// 현재 노드의 값을 출력 (또는 다른 작업 수행)</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">startNode</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="s2"> `</span><span class="p">);</span>

    <span class="c1">// 자식 노드들을 재귀적으로 방문</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">startNode</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 사용 예시</span>
<span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">root</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="nx">root</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">D</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">E</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tree</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">root</span><span class="p">);</span> <span class="c1">// 결과: A B D E C</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="힙heap-구현-및-사용법">힙(Heap) 구현 및 사용법</h3>
<p>힙(Heap)의 경우, <strong>Python은 <code class="language-plaintext highlighter-rouge">heapq</code>라는 강력한 내장 라이브러리를 제공</strong>하여 즉시 사용 가능하지만, <strong>TypeScript는 직접 클래스로 구현해야 한다.</strong></p>

<p>힙은 ‘완전 이진 트리’의 일종으로, 부모 노드의 값이 항상 자식 노드의 값보다 작거나 같은(최소 힙, Min Heap) 혹은 크거나 같은(최대 힙, Max Heap) 속성을 만족하는 자료 구조이다. 우선순위 큐(Priority Queue)를 구현하는 데 주로 사용된다.</p>

<h4 id="1-python-heapq-모듈-활용">1. Python: <code class="language-plaintext highlighter-rouge">heapq</code> 모듈 활용</h4>

<p>Python은 <code class="language-plaintext highlighter-rouge">heapq</code> 모듈을 통해 일반 리스트를 최소 힙처럼 다룰 수 있는 함수들을 제공한다. 이는 매우 효율적이고 파이썬다운(Pythonic) 방식이다.</p>

<ul>
  <li><strong>핵심</strong>: 별도의 힙 클래스 없이, <strong>일반 리스트를 <code class="language-plaintext highlighter-rouge">heapq</code> 함수에 전달하여</strong> 힙 연산을 수행한다.</li>
</ul>

<!-- end list -->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># heapq 모듈은 최소 힙(Min Heap)을 기본으로 한다.
</span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 힙에 원소 추가 (heappush)
</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="c1"># 결과: [1, 3, 7, 4] (힙 속성을 만족하는 리스트)
</span>
<span class="c1"># 힙에서 가장 작은 원소 삭제 및 반환 (heappop)
</span><span class="n">smallest</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">smallest</span><span class="p">)</span> <span class="c1"># 결과: 1
</span><span class="nf">print</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>     <span class="c1"># 결과: [3, 4, 7]
</span></code></pre></div></div>

<h4 id="2-typescript-직접-클래스로-구현">2. TypeScript: 직접 클래스로 구현</h4>

<p>TypeScript는 내장 힙이 없으므로, 배열을 기반으로 힙의 핵심 연산(sift-up, sift-down)을 포함하는 클래스를 직접 구현해야 한다.</p>

<ul>
  <li><strong>핵심</strong>: <code class="language-plaintext highlighter-rouge">insert</code> 시에는 추가된 노드를 부모와 비교하며 위로 올리고(<code class="language-plaintext highlighter-rouge">siftUp</code>), <code class="language-plaintext highlighter-rouge">delete</code> 시에는 루트 노드를 제거한 뒤 마지막 노드를 루트로 가져와 자식과 비교하며 아래로 내린다(<code class="language-plaintext highlighter-rouge">siftDown</code>).</li>
</ul>

<!-- end list -->

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최소 힙 (Min Heap) 구현</span>
<span class="kd">class</span> <span class="nc">MinHeap</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">heap</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 부모-자식 인덱스 계산을 위한 헬퍼 함수들</span>
  <span class="k">private</span> <span class="nf">getParentIndex</span><span class="p">(</span><span class="na">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">getLeftChildIndex</span><span class="p">(</span><span class="na">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">getRightChildIndex</span><span class="p">(</span><span class="na">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">swap</span><span class="p">(</span><span class="na">i1</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="na">i2</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i1</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i2</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i2</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i1</span><span class="p">]];</span> <span class="p">}</span>

  <span class="c1">// 힙에 원소 추가</span>
  <span class="k">public</span> <span class="nf">insert</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">siftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 가장 작은 원소(루트) 삭제</span>
  <span class="k">public</span> <span class="k">delete</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">deletedValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">siftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">deletedValue</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="nf">siftUp</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="cm">/* ... 부모와 비교하며 위로 올리는 로직 ... */</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">siftDown</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="cm">/* ... 자식과 비교하며 아래로 내리는 로직 ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="그래프graph-구현-및-사용법">그래프(Graph) 구현 및 사용법</h3>

<p>그래프(Graph)는 두 언어 모두 내장 기능이 없어 <strong>직접 구현</strong>해야 하며, 주로 Python은 딕셔너리(<code class="language-plaintext highlighter-rouge">dict</code>)를, <strong>TypeScript는 <code class="language-plaintext highlighter-rouge">Map</code> 객체</strong>를 이용해 인접 리스트(Adjacency List) 형태로 표현하는 것이 일반적이다.</p>

<p>그래프는 정점(Vertex 또는 Node)과 그 정점을 연결하는 간선(Edge)의 집합으로 이루어진 자료 구조이다. 소셜 네트워크, 지하철 노선도 등이 그래프의 대표적인 예이다.</p>

<h4 id="1-python-딕셔너리를-이용한-인접-리스트">1. Python: 딕셔너리를 이용한 인접 리스트</h4>

<p>Python에서는 딕셔너리를 사용하여 각 정점을 키(key)로, 해당 정점에 인접한 정점들의 리스트를 값(value)으로 가지는 인접 리스트(Adjacency List) 방식으로 그래프를 표현하는 것이 매우 일반적이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 키: 정점, 값: 인접 정점 리스트
</span>        <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vertex1</span><span class="p">,</span> <span class="n">vertex2</span><span class="p">):</span>
        <span class="c1"># 무방향 그래프(Undirected Graph)의 경우 양쪽에 모두 추가
</span>        <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">vertex1</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">vertex2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">vertex2</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">vertex1</span><span class="p">)</span>

<span class="c1"># 사용 예시
</span><span class="n">graph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">)</span> 
<span class="c1"># 결과: {'A': ['B'], 'B': ['A', 'C'], 'C': ['B']}
</span></code></pre></div></div>

<h4 id="2-typescript-map-객체를-이용한-인접-리스트">2. TypeScript: <code class="language-plaintext highlighter-rouge">Map</code> 객체를 이용한 인접 리스트</h4>

<p>TypeScript에서는 키의 타입이 자유로운 <code class="language-plaintext highlighter-rouge">Map</code> 객체를 사용하여 인접 리스트를 구현하는 것이 가장 유연하고 안정적인 방법이다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Graph</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// 키: 정점, 값: 인접 정점 배열</span>
  <span class="k">private</span> <span class="na">adjacencyList</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>

  <span class="k">public</span> <span class="nf">addVertex</span><span class="p">(</span><span class="na">vertex</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">vertex</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">vertex</span><span class="p">,</span> <span class="p">[]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">addEdge</span><span class="p">(</span><span class="na">vertex1</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">vertex2</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c1">// 무방향 그래프(Undirected Graph)의 경우</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">)?.</span><span class="nf">push</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">)?.</span><span class="nf">push</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 사용 예시</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">graph</span><span class="p">);</span> 
<span class="cm">/* 결과: 
Graph {
  adjacencyList: Map(3) { 'A' =&gt; [ 'B' ], 'B' =&gt; [ 'A', 'C' ], 'C' =&gt; [ 'B' ] }
}
*/</span>
</code></pre></div></div>

<h3 id="python-자료-구조별-구현-특징-요약">Python 자료 구조별 구현 특징 요약</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">자료 구조</th>
      <th style="text-align: left">구현 방식 및 특징</th>
      <th style="text-align: left">관련 라이브러리 및 설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**배열**&lt;br&gt;(Array)</td>
      <td style="text-align: left">내장 타입인 <code class="language-plaintext highlighter-rouge">list</code>를 사용한다. 크기가 동적으로 변하며, 모든 타입의 데이터를 담을 수 있는 동적 배열이다.</td>
      <td style="text-align: left">내장 <code class="language-plaintext highlighter-rouge">list</code>: 기본적으로 사용.<code class="language-plaintext highlighter-rouge">array</code> 모듈: C와 유사한 단일 타입의 고정 배열이 필요할 때 사용.</td>
    </tr>
    <tr>
      <td style="text-align: left">연결 리스트&lt;br&gt;(Linked List)</td>
      <td style="text-align: left">내장 기능이 없어 <code class="language-plaintext highlighter-rouge">Node</code> 클래스를 직접 정의하여 구현한다. 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가진다.</td>
      <td style="text-align: left">(직접 구현): 별도의 표준 라이브러리가 없어 직접 구현이 일반적이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">스택&lt;br&gt;(Stack)</td>
      <td style="text-align: left">내장 **<code class="language-plaintext highlighter-rouge">list</code>**를 그대로 사용한다. <code class="language-plaintext highlighter-rouge">append()</code>가 <code class="language-plaintext highlighter-rouge">push</code> 역할을, <code class="language-plaintext highlighter-rouge">pop()</code>이 <code class="language-plaintext highlighter-rouge">pop</code> 역할을 하여 LIFO 구조를 자연스럽게 만족한다.</td>
      <td style="text-align: left">내장 <code class="language-plaintext highlighter-rouge">list</code>: 스택을 위한 완벽한 기능을 제공하므로 별도 라이브러리가 불필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">큐&lt;br&gt;(Queue)</td>
      <td style="text-align: left">**<code class="language-plaintext highlighter-rouge">list</code>**의 <code class="language-plaintext highlighter-rouge">pop(0)</code>는 비효율적이므로, 양방향 데이터 입출력이 빠른 <code class="language-plaintext highlighter-rouge">deque</code> 객체를 사용하는 것이 정석이다.</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">collections.deque</code>: <code class="language-plaintext highlighter-rouge">append()</code> (enqueue)와 <code class="language-plaintext highlighter-rouge">popleft()</code> (dequeue) 연산이 모두 O(1) 시간 복잡도를 가지는 최적의 라이브러리이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">해시 테이블&lt;br&gt;(Hash Table)</td>
      <td style="text-align: left">내장 타입인 <code class="language-plaintext highlighter-rouge">dict</code>를 사용한다. Key-Value 쌍으로 데이터를 저장하며, 매우 빠른 속도로 데이터를 검색, 추가, 삭제할 수 있다.</td>
      <td style="text-align: left">내장 <code class="language-plaintext highlighter-rouge">dict</code>: 기본 해시 테이블. <code class="language-plaintext highlighter-rouge">collections.defaultdict</code>: 존재하지 않는 키를 조회할 때 기본값을 자동으로 생성해준다.</td>
    </tr>
    <tr>
      <td style="text-align: left">트리&lt;br&gt;(Tree)</td>
      <td style="text-align: left">내장 기능이 없어 <code class="language-plaintext highlighter-rouge">TreeNode</code> 클래스를 직접 정의하여 구현한다. 노드가 데이터와 자식 노드 리스트(또는 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 포인터)를 가진다.</td>
      <td style="text-align: left">(직접 구현): 목적에 맞는 트리(이진 트리, 이진 탐색 트리 등)를 직접 클래스로 구현해야 한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">힙&lt;br&gt;(Heap)</td>
      <td style="text-align: left">일반 **<code class="language-plaintext highlighter-rouge">list</code>**를 <code class="language-plaintext highlighter-rouge">heapq</code> 모듈의 함수들로 제어하여 최소 힙(Min Heap)으로 사용한다. 리스트 자체가 힙이 되는 방식이다.</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">heapq</code>: <code class="language-plaintext highlighter-rouge">heappush</code>, <code class="language-plaintext highlighter-rouge">heappop</code> 등의 함수를 통해 리스트를 효율적인 우선순위 큐로 만들어주는 표준 라이브러리이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">그래프&lt;br&gt;(Graph)</td>
      <td style="text-align: left">내장 기능이 없다. 주로 <code class="language-plaintext highlighter-rouge">dict</code>를 이용한 인접 리스트 방식으로 구현한다. 딕셔너리의 키는 정점, 값은 인접 정점 리스트이다.</td>
      <td style="text-align: left">(직접 구현): <code class="language-plaintext highlighter-rouge">dict</code>와 <code class="language-plaintext highlighter-rouge">list</code>를 조합해 직접 구현한다. 복잡한 분석이 필요하면 <code class="language-plaintext highlighter-rouge">networkx</code> 같은 전문 라이브러리를 사용한다.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[자료구조와 알고리즘 (feat, TS와 Python 을 얹은)]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/cs-09-02-01.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차" /><published>2025-09-08T00:00:00+00:00</published><updated>2025-09-08T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/cs-09-02-01</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/cs-09-02-01.html"><![CDATA[<h2 id="자료구조와-알고리즘">자료구조와 알고리즘</h2>

<h3 id="알고리즘-성능-분석">알고리즘 성능 분석</h3>
<p>알고리즘의 효율성을 객관적으로 평가하는 방법을 배우는 단계이다. 모든 자료구조와 알고리즘을 이해하는 데 기반이 된다.</p>

<ul>
  <li>시간 복잡도 (Time Complexity): 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 데이터의 크기와 연관 지어 표기하는 방법이다. (예: O(1), O(log n), O(n), O(n log n), O(n²))</li>
  <li>공간 복잡도 (Space Complexity): 알고리즘이 실행되는 동안 사용하는 메모리의 양을 표기하는 방법이다.</li>
</ul>

<h4 id="시간-복잡도time-complexity">시간 복잡도(Time Complexity)</h4>
<p>알고리즘을 실행하는데 필요한 연산횟수를 측정하는 것이다. 실제 실행시간이 아니고 빅오 표기법으로 사용하는데, 이는 데이터 크기(n)가 무한히 커졌을 때의 최악의 경우(worst-case)를 기준으로 성능을 표기하는 방법이다.</p>

<ul>
  <li>O(1) - 상수 시간 (Constant Time)
    <ul>
      <li>설명: 입력 데이터의 크기와 상관없이 항상 일정한 수의 연산만 수행한다. 가장 빠른 속도이다.</li>
      <li>예시: 배열의 특정 인덱스(arr[i])에 접근하는 것.</li>
    </ul>
  </li>
  <li>O(log n) - 로그 시간 (Logarithmic Time)
    <ul>
      <li>설명: 연산을 한 번 수행할 때마다 탐색해야 할 데이터의 양이 절반씩 줄어든다.</li>
      <li>예시: 정렬된 배열에서 <strong>이진 탐색(Binary Search)</strong>을 하는 경우.</li>
    </ul>
  </li>
  <li>O(n) - 선형 시간 (Linear Time)
    <ul>
      <li>설명: 입력 데이터의 크기(n)에 비례하여 연산 횟수가 증가한다.</li>
      <li>예시: 배열의 모든 요소를 한 번씩 순회하는 for 반복문.</li>
    </ul>
  </li>
  <li>O(n log n) - 로그 선형 시간 (Log-Linear Time)
    <ul>
      <li>설명: 데이터의 크기(n)에 log n을 곱한 만큼 연산 횟수가 증가한다. 대부분의 효율적인 정렬 알고리즘이 여기에 속한다.</li>
      <li>예시: 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort).</li>
    </ul>
  </li>
  <li>O(n²) - 이차 시간 (Quadratic Time)
    <ul>
      <li>설명: 입력 데이터의 크기(n)의 제곱에 비례하여 연산 횟수가 증가한다. 데이터가 커지면 성능이 급격히 저하됩니다.</li>
      <li>예시: 이중 for 반복문을 사용하여 배열의 모든 요소 쌍을 비교하는 경우 (예: 버블 정렬).</li>
    </ul>
  </li>
</ul>

<h4 id="공간-복잡도space-complexity">공간 복잡도(Space Complexity)</h4>
<p>알고리즘 실행될 때, 추가적으로 사용되는 메모리 양을 측정한다. 입력데이터 자체를 저장하는 공간은 계산에서 제외하며, 문제 해결을 위해 별도로 사용하는 메모리 공간을 기준으로 한다.</p>

<ul>
  <li>주요 공간 복잡도 예시
    <ul>
      <li>O(1) - 상수 공간(Constant Space)
        <ul>
          <li>설명 : 입력 데이터의 크기와 상관없이 일정한 양의 메모리 사용</li>
        </ul>
      </li>
      <li>O(n) - 선형 공간(Linear Space)
        <ul>
          <li>설명 : 입력 데이터 크기(n)에 비례하여 추가적인 메모리 공간이 필요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="시간과-공간의-관계trade-off">시간과 공간의 관계(Trade-off)</h4>
<p>알고리즘을 설계할 때 시간과 공간은 종종 상충관계를 가진다.</p>

<ul>
  <li>시간을 단축하려면 더 많은 메모리를 사용해야할 수 있다.</li>
  <li>메모리를 아끼려면 더 많은 연산을 수행해야 할 수도 있다.</li>
</ul>

<p>핵심은 그렇기에 문제의 요구사항이나 시스템 제약을 고려하여 시간 복잡도와 공간복잡도 사이의 균형을 맞추는게 중요하다.</p>

<h4 id="복잡도-계산-방법">복잡도 계산 방법</h4>

<p>복잡도 계산은 코드의 연산 횟수를 <code class="language-plaintext highlighter-rouge">n</code>에 대한 함수로 표현한 뒤, 빅오 표기법 규칙에 따라 단순화하는 과정이다.</p>

<p><strong>3단계 계산법</strong></p>

<ol>
  <li><strong>기본 연산 단위 찾기:</strong> 알고리즘의 핵심이 되는 반복적인 연산을 찾는다. (주로 반복문 내부)</li>
  <li><strong>연산 횟수를 ‘n’으로 표현하기:</strong> 입력 크기 <code class="language-plaintext highlighter-rouge">n</code>에 따라 기본 연산이 몇 번 수행되는지 식으로 표현한다. (예: <code class="language-plaintext highlighter-rouge">n² + n</code>)</li>
  <li><strong>빅오 표기법으로 단순화하기:</strong> 아래 두 규칙을 적용한다.
    <ul>
      <li><strong>규칙 1: 최고차항만 남긴다.</strong> <code class="language-plaintext highlighter-rouge">n² + n</code>에서 가장 영향력이 큰 <code class="language-plaintext highlighter-rouge">n²</code>만 남긴다.</li>
      <li><strong>규칙 2: 상수 계수를 제거한다.</strong> <code class="language-plaintext highlighter-rouge">2n</code>에서 계수 <code class="language-plaintext highlighter-rouge">2</code>를 제거하여 <code class="language-plaintext highlighter-rouge">n</code>으로 표기한다.</li>
    </ul>
  </li>
</ol>

<h4 id="파이썬-코드로-보는-계산-예시">파이썬 코드로 보는 계산 예시</h4>

<h5 id="예시-1-on"><strong>예시 1: O(n)</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">linear_example</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># 1. 기본 연산
</span>    <span class="k">return</span> <span class="n">total</span>
</code></pre></div></div>

<ul>
  <li><strong>연산 횟수:</strong> 기본 연산이 <code class="language-plaintext highlighter-rouge">n</code>번 반복되므로, 연산 횟수는 <code class="language-plaintext highlighter-rouge">n</code>이다.</li>
  <li><strong>빅오 표기:</strong> <code class="language-plaintext highlighter-rouge">O(n)</code>이다.</li>
</ul>

<h5 id="예시-2-on"><strong>예시 2: O(n²)</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quadratic_example</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 1. 기본 연산
</span>    <span class="k">return</span> <span class="n">count</span>
</code></pre></div></div>

<ul>
  <li><strong>연산 횟수:</strong> 기본 연산이 <code class="language-plaintext highlighter-rouge">n * n</code>번 반복되므로, 연산 횟수는 <code class="language-plaintext highlighter-rouge">n²</code>이다.</li>
  <li><strong>빅오 표기:</strong> <code class="language-plaintext highlighter-rouge">O(n²)</code>이다.</li>
</ul>

<h5 id="예시-3-olog-n"><strong>예시 3: O(log n)</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">logarithmic_example</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># ... O(1) 연산 ...
</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># 1. 핵심 연산 (탐색 범위가 절반씩 줄어드는 효과)
</span></code></pre></div></div>

<ul>
  <li><strong>연산 횟수:</strong> <code class="language-plaintext highlighter-rouge">i</code>가 2의 거듭제곱으로 증가하므로, 반복 횟수는 <code class="language-plaintext highlighter-rouge">log₂n</code>에 비례한다.</li>
  <li><strong>빅오 표기:</strong> <code class="language-plaintext highlighter-rouge">O(log n)</code>이다.</li>
</ul>

<hr />

<h4 id="심화-및-실용적-고려사항">심화 및 실용적 고려사항</h4>

<ul>
  <li><strong>시간과 공간의 상충 관계(Trade-off):</strong> 시간을 단축하기 위해 더 많은 메모리를 사용하거나(예: 메모이제이션), 메모리를 아끼기 위해 더 많은 연산을 수행할 수 있다.</li>
  <li><strong>캐시 효율성 (Cache Locality):</strong> 이론적인 복잡도가 같더라도, 데이터가 메모리에 연속적으로 배치된 <strong>배열</strong>이 비연속적인 <strong>연결 리스트</strong>보다 CPU 캐시 효율이 높아 실제 속도는 더 빠르다.</li>
  <li><strong>재귀의 공간 복잡도:</strong> 재귀 함수는 호출될 때마다 <strong>콜 스택(Call Stack)</strong>에 메모리를 사용하므로, 재귀의 최대 깊이가 공간 복잡도가 된다. (예: <code class="language-plaintext highlighter-rouge">n</code> 깊이의 재귀는 <code class="language-plaintext highlighter-rouge">O(n)</code> 공간을 사용)</li>
</ul>

<h3 id="주요-자료구조">주요 자료구조</h3>
<p>데이터를 목적에 맞게 효율적으로 저장하고 관리하는 방법에 대한 학습 단계이다.</p>

<ul>
  <li>선형 자료구조
    <ul>
      <li>배열(Array)</li>
      <li>연결 리스트(Linked List)</li>
      <li>스택(Stack)</li>
      <li>큐(Queue)</li>
    </ul>
  </li>
  <li>비 선형 자료구조
    <ul>
      <li>해시 테이블(Hash Table)</li>
      <li>트리(Tree) : 이진트리, 이진 탐색 트리, AVL 트리, 레드블랙 트리 등</li>
      <li>힙(Heap) : 우선순위 큐</li>
      <li>그래프(Graph)</li>
    </ul>
  </li>
</ul>

<h4 id="선형-자료구조">선형 자료구조</h4>

<h5 id="배열과-연결-리스트">배열과 연결 리스트</h5>

<p>가장 기본적이면서 면접에서 비교 질문으로 자주 나오는 자료구조이다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>배열(Array)</th>
      <th>연결리스트(Linked List)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>핵심 개념</td>
      <td>데이터가 메모리 상에 연속적으로 저장된다.</td>
      <td>각 데이터(노드)가 다음 데이터의 주소를 가지는 형태로 연결된다.</td>
    </tr>
    <tr>
      <td>탐색(접근)</td>
      <td>인덱스를 통한 O(1) 시간의 빠른 임의 접근이 가능하다.</td>
      <td>처음부터 순차적으로 탐색해야 하므로 O(n) 시간이 소요된다.</td>
    </tr>
    <tr>
      <td>삽입/삭제</td>
      <td>중간에 데이터를 추가/삭제 시, 뒤따르는 모든 데이터를 이동시켜야 하므로 O(n) 시간이 걸린다.</td>
      <td>포인터(주소) 연결만 변경하면 되므로 O(1) 시간의 빠른 삽입/삭제가 가능하다. (단, 해당 위치를 탐색하는 시간은 별도)</td>
    </tr>
    <tr>
      <td>메모리</td>
      <td>크기가 고정되어 있고, 연속된 메모리 공간을 할당받는다.</td>
      <td>크기가 가변적이며, 필요할 때마다 메모리를 할당하여 비연속적인 공간을 사용한다.</td>
    </tr>
  </tbody>
</table>

<h5 id="스택과-큐">스택과 큐</h5>

<p>데이터의 입출력 순서를 제어하는 특징을 가진 자료구조이다.</p>

<ul>
  <li>스택
    <ul>
      <li>개념: 후입선출(LIFO, Last-In First-Out) 구조이다. 가장 마지막에 넣은 데이터가 가장 먼저 나온다.</li>
      <li>주요 연산 : push(데이터 추가), pop(데이터 제거)</li>
      <li>활용 예시 : 함수 호출 스택, DFS(깊이 우선 탐색), 괄호 검사, 뒤로 가기 기능</li>
      <li>Python 구현 : 파이썬의 기본 리스트(list)와 append(), pop() 메서드를 사용하면 스택을 쉽게 구현할 수 있다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 스택 예시 코드
</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># push
</span><span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span> <span class="c1"># 3 출력
</span><span class="nf">print</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span> <span class="c1"># 2 출력
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>큐(Queue)
    <ul>
      <li>개념 : 선입선출(FIFO, First-In First-Out) 구조이다. 가장 먼저 넣은 데이터가 가장 먼저 나온다.</li>
      <li>주요 연산 : enqueue(데이터 추가), dequeue(데이터 제거)</li>
      <li>활용 예시 : 너비 우선 탐색(BFS), 프린터 작업 큐, 메시지 큐</li>
      <li>Python 구현 : 리스트의 pop(0)은 O(n)의 비효율을 야기하므로, 양방향 입출력이 O(1)인 collections.deque를 사용하는 것이 표준이다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="c1"># 큐 예시 코드
</span><span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
<span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># enqueue
</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span> <span class="c1"># 1 출력 (dequeue)
</span><span class="nf">print</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span> <span class="c1"># 2 출력
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="비선형-자료구조">비선형 자료구조</h4>

<p>데이터가 계층적 또는 네트워크 형태로 저장되는 구조이다.</p>

<ul>
  <li>해시테이블
    <ul>
      <li>개념: 키(Key)와 값(Value)을 한 쌍으로 저장하는 자료구조이다. 내부적으로 해시 함수를 사용하여 키를 배열의 인덱스로 변환하여 데이터를 저장하므로, 매우 빠른 데이터 탐색이 가능하다.</li>
      <li>시간 복잡도: 평균적으로 삽입, 삭제, 탐색 모두 O(1)이다.</li>
      <li>해시 충돌 (Hash Collision): 서로 다른 키가 해시 함수를 통해 같은 인덱스로 변환되는 상황이다. 이 경우 성능 저하가 발생하며, 최악의 경우 O(n)까지 시간이 걸릴 수 있다.</li>
      <li>충돌 해결 방안: 체이닝(Chaining, 해당 인덱스에 연결 리스트를 사용)과 개방 주소법(Open Addressing, 다른 빈 공간을 찾아 저장)이 대표적이다.</li>
      <li>Python 구현: 파이썬의 딕셔너리(dict)가 해시 테이블로 구현되어 있다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 해시 테이블 예시 코드 (Dictionary)
</span><span class="n">hash_table</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">hash_table</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">jarvis</span><span class="sh">'</span>
<span class="n">hash_table</span><span class="p">[</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="nf">print</span><span class="p">(</span><span class="n">hash_table</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">])</span> <span class="c1"># 'jarvis' 출력 (O(1)에 가까운 속도)
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>트리 
계층적인 관계를 표현하는 데 사용되는 자료구조이다.
    <ul>
      <li>이진 탐색 트리 (Binary Search Tree, BST)
        <ul>
          <li>특징: 부모 노드를 기준으로 왼쪽 서브 트리에는 부모보다 작은 값, 오른쪽 서브 트리에는 부모보다 큰 값이 저장된다.</li>
          <li>성능: 평균적으로 탐색, 삽입, 삭제에 O(log n)의 시간이 걸리지만, 트리가 한쪽으로 치우쳐진 최악의 경우 O(n)이 될 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자가 균형 이진 탐색 트리 (Self-Balancing BST)
    <ul>
      <li>개념: 데이터의 삽입 및 삭제 시 자동으로 트리의 균형을 맞추어 최악의 경우에도 O(log n)의 성능을 보장하는 트리이다.</li>
      <li>종류: AVL 트리, 레드-블랙 트리 등이 있으며, 레드-블랙 트리는 데이터베이스 인덱싱 등에서 널리 사용된다.</li>
    </ul>
  </li>
  <li>힙
    <ul>
      <li>개념: 최댓값이나 최솟값을 빠르게 찾아내기 위해 고안된 완전 이진 트리 기반의 자료구조이다. 부모 노드는 항상 자식 노드보다 크거나(최대 힙) 작아야(최소 힙) 한다.</li>
      <li>시간 복잡도: 데이터 삽입 및 삭제 시 O(log n)이다. 최댓값/최솟값 확인은 O(1)이다.</li>
      <li>활용 예시: 우선순위 큐(Priority Queue)를 구현하는 데 주로 사용된다.</li>
      <li>Python 구현: heapq 모듈은 최소 힙을 제공한다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># 최소 힙 예시 코드
</span><span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">))</span> <span class="c1"># 가장 작은 값인 1 출력
</span><span class="nf">print</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">))</span> <span class="c1"># 다음으로 작은 값인 4 출력
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>그래프 
정점(Vertex)과 그 정점을 연결하는 간선(Edge)으로 이루어진 자료구조이다.</li>
  <li>그래프 표현 방식
    <ul>
      <li>인접 행렬: 2차원 배열을 사용하여 정점 간 연결 관계를 표현한다. 구현이 간단하지만 O(V²)의 공간이 필요하다(V: 정점 수).</li>
      <li>인접 리스트: 각 정점에 연결된 정점들을 리스트로 표현한다. O(V+E)의 공간이 필요하여 효율적이다(E: 간선 수).</li>
    </ul>
  </li>
  <li>대표적인 탐색 알고리즘
    <ul>
      <li>너비 우선 탐색 (BFS): 큐를 사용하여 가까운 정점부터 탐색한다. 최단 경로 찾기에 사용된다.</li>
      <li>깊이 우선 탐색 (DFS): 스택(또는 재귀)을 사용하여 한 방향으로 끝까지 탐색한다. 모든 경로 탐색에 사용된다.</li>
    </ul>
  </li>
</ul>

<h3 id="핵심-알고리즘">핵심 알고리즘</h3>
<p>알고리즘은 문제 해결 능력을 직접적으로 보여주는 지표이다. 면접에서는 특정 알고리즘의 구현 능력뿐만 아니라, 문제 상황에 가장 적합한 알고리즘과 설계 기법을 선택하고 그 이유를 설명하는 능력이 중요하다.</p>

<ul>
  <li>주요 알고리즘 유형
    <ul>
      <li>정렬(Sorting) : 버블 정렬, 선택 정렬, 삽입 정렬, 병합 정렬, 퀵 정렬, 힙 정렬 등</li>
      <li>탐색(Searching) : 이진 탐색, 너비 우선 탐색(BFS), 깊이 우선 탐색(DFS) 등</li>
    </ul>
  </li>
  <li>알고리즘 설계 기법(패러다임)
    <ul>
      <li>분할 정복(Devide and Conquer) : 큰 문제를 작은 단위로 나누어 해결하는 기법 (예: 병합 정렬, 퀵 정렬)</li>
      <li>탐욕법(Greedy Algorithm) : 매 순간 최선의 선택을 하여 최종 해답을 찾는 기법</li>
      <li>동적 프로그래밍(Dynamic Programming) : 작은 문제의 해를 저장하고 재활용하여 큰 문제를 해결하는 기법</li>
      <li>백트래킹(Backtracking) : 해를 찾는 도중 막히면 이전으로 돌아가 다른 경로를 탐색하는 기법</li>
    </ul>
  </li>
</ul>

<h4 id="주요-알고리즘-유형">주요 알고리즘 유형</h4>

<h5 id="정렬-sorting">정렬 (Sorting)</h5>

<p>데이터를 특정 순서에 따라 나열하는 알고리즘이다. 각 정렬 방식의 시간 복잡도와 공간 복잡도, 그리고 안정성(stable) 여부를 비교하여 이해하는 것이 핵심이다.</p>

<ul>
  <li><strong>O(n²) 정렬 알고리즘: 선택, 삽입, 버블 정렬</strong>
    <ul>
      <li>개념: 구현이 비교적 간단하지만, 데이터의 크기가 커질수록 성능이 급격히 저하된다.</li>
      <li><strong>삽입 정렬 (Insertion Sort):</strong> 정렬된 부분 배열에 새로운 원소를 적절한 위치에 삽입하는 방식이다. 이미 대부분 정렬된 데이터에 대해서는 매우 효율적이다.</li>
    </ul>

    <!-- end list -->

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 삽입 정렬 예시 코드
</span><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="n">arr</span>
</code></pre></div>    </div>
  </li>
  <li><strong>O(n log n) 정렬 알고리즘: 병합, 퀵, 힙 정렬</strong>
    <ul>
      <li>개념: 분할 정복 등의 기법을 사용하여 효율성을 높인 알고리즘이다. 일반적인 상황에서 주로 사용된다.</li>
      <li><strong>퀵 정렬 (Quick Sort):</strong> 하나의 피벗(pivot)을 기준으로 작은 값과 큰 값을 나누어 정렬을 반복하는 방식이다. 평균적으로 매우 빠르지만, 피벗 선택에 따라 최악의 경우 O(n²)이 될 수 있다.</li>
    </ul>

    <!-- end list -->

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 퀵 정렬 예시 코드
</span><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">less</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">equal</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">greater</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">less</span><span class="p">)</span> <span class="o">+</span> <span class="n">equal</span> <span class="o">+</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="탐색-searching">탐색 (Searching)</h5>

<p>데이터 집합에서 원하는 값을 찾아내는 알고리즘이다.</p>

<ul>
  <li><strong>이진 탐색 (Binary Search)</strong>
    <ul>
      <li>개념: <strong>정렬된</strong> 데이터에서만 사용 가능한 탐색 기법이다. 탐색 범위를 계속해서 절반으로 줄여나가며 O(log n)의 시간 복잡도를 가진다.</li>
      <li>동작: 중앙값(mid)과 찾고자 하는 값을 비교하여, 작으면 왼쪽, 크면 오른쪽 부분 배열을 대상으로 탐색을 반복한다.
<!-- end list --></li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 이진 탐색 예시 코드 (재귀)
</span><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mid</span>
    <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>그래프 탐색: 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)</strong>
    <ul>
      <li><strong>BFS (Breadth-First Search):</strong> 큐(Queue)를 사용하여 시작 정점과 가까운 정점부터 차례대로 탐색한다. 최단 경로를 찾는 문제에 주로 활용된다.</li>
      <li><strong>DFS (Depth-First Search):</strong> 스택(Stack)이나 재귀 함수를 사용하여 한 방향으로 최대한 깊게 들어간 후, 더 이상 갈 곳이 없으면 이전 정점으로 돌아와 다른 방향을 탐색한다. 모든 경로를 탐색하는 문제에 적합하다.</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="알고리즘-설계-기법-패러다임">알고리즘 설계 기법 (패러다임)</h4>

<p>문제 해결을 위한 접근법이자 사고의 틀이다.</p>

<h5 id="분할-정복-divide-and-conquer">분할 정복 (Divide and Conquer)</h5>

<ul>
  <li>개념: 해결하기 어려운 큰 문제를 해결 가능한 작은 문제들로 나눈 뒤(Divide), 각 작은 문제를 해결하고(Conquer), 그 결과를 합쳐(Combine) 원래 문제의 답을 구하는 전략이다.</li>
  <li>대표 예시: 퀵 정렬, 병합 정렬</li>
</ul>

<h5 id="탐욕법-greedy-algorithm">탐욕법 (Greedy Algorithm)</h5>

<ul>
  <li>개념: 각 단계에서 그 순간에 가장 최적이라고 생각되는 선택을 하는 방식이다. 이렇게 만들어진 지역적인 최적해의 연속이 전역적인 최적해로 이어진다고 가정한다.</li>
  <li>특징: 항상 최적의 해를 보장하지는 않으므로, 탐욕법을 적용할 수 있는 문제인지 정당성을 분석하는 과정이 필수적이다.</li>
  <li>대표 예시: 최소 신장 트리를 찾는 크루스칼/프림 알고리즘, 거스름돈 문제</li>
</ul>

<h5 id="동적-프로그래밍-dynamic-programming-dp">동적 프로그래밍 (Dynamic Programming, DP)</h5>

<ul>
  <li>개념: 큰 문제를 작은 하위 문제들로 나누어 푸는 점은 분할 정복과 같지만, 하위 문제들의 해가 중복되는 경우 그 결과를 <strong>메모이제이션(Memoization)</strong>하여 재활용함으로써 계산 횟수를 줄이는 기법이다.</li>
  <li>적용 조건: 최적 부분 구조(Optimal Substructure)와 중복되는 부분 문제(Overlapping Subproblems)라는 두 가지 속성을 만족하는 문제에 적용할 수 있다.</li>
  <li>구현 방식: 하향식(Top-down, 재귀 + 메모이제이션), 상향식(Bottom-up, 반복문 + 테이블)</li>
  <li>
    <p>대표 예시: 피보나치 수열, 최장 공통 부분 수열(LCS)</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 동적 프로그래밍 예시 (피보나치 수열 - 메모이제이션)
</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1"># 계산 결과를 저장할 딕셔너리
</span>
<span class="k">def</span> <span class="nf">fib_dp</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">fib_dp</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fib_dp</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="백트래킹-backtracking">백트래킹 (Backtracking)</h5>

<ul>
  <li>개념: 모든 가능한 경우의 수를 탐색하는 완전 탐색 기법을 기반으로 하되, 해가 될 가능성이 없는 경로는 더 이상 탐색하지 않고 이전 단계로 되돌아가(backtrack) 다른 경로를 탐색하는 전략이다.</li>
  <li>특징: 불필요한 탐색을 줄여(가지치기, Pruning) 탐색의 효율을 높인다. DFS와 구현 방식이 유사하다.</li>
  <li>대표 예시: N-Queens 문제, 미로 찾기, 스도쿠 풀이</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><summary type="html"><![CDATA[자료구조와 알고리즘]]></summary></entry><entry><title type="html">코테 학습 - ‘유연 근무제’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘유연 근무제’" /><published>2025-09-08T00:00:00+00:00</published><updated>2025-09-08T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/388351">원본 문제 보러가기</a></p>

<h2 id="2025년-9월-8일-프로그래머스-코딩-테스트-출근-이벤트-문제-풀이-python">2025년 9월 8일: 프로그래머스 코딩 테스트 ‘출근 이벤트’ 문제 풀이 (Python)</h2>

<p>프로그래머스 코딩 테스트 문제 중 ‘출근 이벤트’라는 문제를 풀이하였다. 유연근무제를 시행하는 회사에서 직원들의 출근 희망 시각과 실제 출근 기록을 바탕으로 상품을 받을 직원이 몇 명인지 계산하는 문제였다. 초기 풀이 후, 코드 리뷰를 통해 더 효율적이고 ‘파이썬스러운’ 코드로 개선하는 과정을 거쳤다.</p>

<h3 id="문제의-핵심-core-of-the-problem">문제의 핵심 (Core of the Problem)</h3>

<p>문제의 핵심은 크게 두 가지였다.</p>

<ol>
  <li><strong>출근 인정 시각 계산:</strong> 직원들이 설정한 출근 희망 시각에 10분을 더한 시각까지 출근을 인정한다는 점이다. 여기서 단순히 숫자를 더하는 것이 아니라, 분이 60분을 넘어가면 시간(Hour)이 바뀌는 경우를 정확하게 처리해야 했다.</li>
  <li><strong>주말 제외 및 요일 계산:</strong> 토요일과 일요일은 이벤트에 영향을 주지 않으므로, 이 날짜들은 출근 여부 확인에서 제외해야 했다. <code class="language-plaintext highlighter-rouge">startday</code>를 기준으로 요일을 정확히 계산하여 평일(월~금)에만 조건을 적용하는 것이 중요하였다.</li>
</ol>

<h3 id="초기-풀이-과정-initial-solution-process">초기 풀이 과정 (Initial Solution Process)</h3>

<p>처음에는 다음과 같은 단계로 문제를 해결하였다.</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">makeMaxLimit(limit)</code> 함수 구현:</strong>
    <ul>
      <li>주어진 <code class="language-plaintext highlighter-rouge">limit</code>에 10분을 더하여 출근 인정 시각을 계산하는 핵심 함수였다.</li>
      <li><strong>접근 방식:</strong> 시각을 <strong>문자열로 변환</strong>하여 시(hour)와 분(minutes)을 분리하였다.</li>
      <li>분에 10을 더한 후, 60 이상이 되면 시를 1 증가시키고 분에서 60을 빼는 로직을 적용하였다.</li>
      <li>최종 시와 분을 다시 정수 형태의 시각으로 변환하여 반환하였다.</li>
    </ul>
  </li>
  <li><strong>헬퍼(Helper) 함수 구현:</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">isPass(dayNumber)</code>:</strong> <code class="language-plaintext highlighter-rouge">dayNumber</code>가 평일(1~5)인지 확인하는 함수.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">checkCondition(limit, targetTime)</code>:</strong> 출근 시각이 인정 시각 내에 있는지 확인하는 함수.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">solution</code> 메인 함수:</strong>
    <ul>
      <li>초기 <code class="language-plaintext highlighter-rouge">answer</code>는 전체 직원 수로 설정하고, 지각 시 <strong>1씩 차감</strong>하는 방식을 사용하였다.</li>
      <li>요일 계산은 <code class="language-plaintext highlighter-rouge">index</code> 변수를 1씩 증가시키고, 8이 되면 1로 초기화하는 방식을 사용하였다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">eventTarget</code>이라는 플래그 변수</strong>를 두어 직원의 지각 여부를 추적하고, 반복문이 끝난 뒤 이 플래그를 확인하여 <code class="language-plaintext highlighter-rouge">answer</code>를 차감하였다.</li>
    </ul>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPass</span><span class="p">(</span><span class="n">dayNumber</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dayNumber</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="bp">False</span>
    
<span class="k">def</span> <span class="nf">checkCondition</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">targetTime</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">targetTime</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">makeMaxLimit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">핵심중에 핵심으로 시간의 10분 추가 되었을 때 어떻게 처리할지를 판단하는 부분. 최대 유효 시간이 10분이고, 10분 추가시 분과 시간의 변화를 고려해야함</span><span class="sh">"""</span>
    <span class="n">limitStr</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
    <span class="n">limitStrHour</span> <span class="o">=</span> <span class="sh">''</span>
    <span class="n">limitStrMinutes</span> <span class="o">=</span> <span class="sh">''</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">limitStr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">limitStrHour</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">limitStrMinutes</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limitStrHour</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">limitStrMinutes</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    
    <span class="n">limitIntHour</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">limitStrHour</span><span class="p">)</span>
    <span class="n">limitIntMinutes</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">limitStrMinutes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">limitIntMinutes</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">limitIntHour</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">limitIntMinutes</span> <span class="o">-=</span> <span class="mi">60</span>

    <span class="n">limit</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">limitIntHour</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">limitIntMinutes</span><span class="p">)</span>

    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">schedules</span><span class="p">,</span> <span class="n">timelogs</span><span class="p">,</span> <span class="n">startday</span><span class="p">):</span>
    <span class="c1"># 목표 스케쥴 =&gt; 명수, 목표 기준 확인
</span>    <span class="c1"># timelogs =&gt; 분해, 기준 비교 =&gt; startDay 검토하여 스킵할 날짜 체크 =&gt; 문제 없으면 상품 제공
</span>
    <span class="c1"># n 명의 상황 기록 =&gt; 기록 배열 분리 
</span>    <span class="c1"># start day 기준으로 체킹 =&gt; 도중에 이벤트 조건에 맞지 않으면 =&gt; 문제
</span>    <span class="c1"># 가장 효과적인 데이터 타입은? 
</span>    <span class="n">targetList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">schedules</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">limit</span><span class="sh">"</span><span class="p">:</span> <span class="nf">makeMaxLimit</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
            <span class="sh">"</span><span class="s">timelog</span><span class="sh">"</span><span class="p">:</span> <span class="n">timelogs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">})</span>
        <span class="n">targetList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">answer</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">targetList</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targetList</span><span class="p">:</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="sh">"</span><span class="s">limit</span><span class="sh">"</span><span class="p">]</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="sh">"</span><span class="s">timelog</span><span class="sh">"</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">startday</span>
        <span class="n">eventTarget</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>
            <span class="k">if</span> <span class="nf">isPass</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nf">checkCondition</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
                <span class="n">eventTarget</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eventTarget</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">-=</span> <span class="mi">1</span>
                
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<h3 id="코드-개선과-새로운-교훈-code-improvement-and-new-lessons">코드 개선과 새로운 교훈 (Code Improvement and New Lessons)</h3>

<p>초기 풀이도 정답이었지만, 코드의 효율성, 가독성, 그리고 ‘파이썬스러움’에 대해 깊이 배우며 다음과 같이 코드를 개선할 수 있었다.</p>

<ol>
  <li><strong>시간 계산의 효율화: 문자열 변환 vs 산술 연산</strong>
    <ul>
      <li>가장 큰 깨달음이었다. 문자열로 변환하고 슬라이싱하는 대신, <strong>몫(<code class="language-plaintext highlighter-rouge">//</code>)과 나머지(<code class="language-plaintext highlighter-rouge">%</code>) 연산</strong>을 사용하면 훨씬 간결하고 빠르게 시간 계산이 가능했다. 이는 불필요한 형 변환 비용을 줄여주는 효율적인 방법이다. 수학적으로 생각을 하는게 중요한데… 쉽지 않다 ㅠ</li>
      <li><code class="language-plaintext highlighter-rouge">(개선 후) limit_hours = limit // 100</code>, <code class="language-plaintext highlighter-rouge">limit_minutes = limit % 100 + 10</code></li>
    </ul>
  </li>
  <li><strong>Pythonic 네이밍 컨벤션: <code class="language-plaintext highlighter-rouge">snake_case</code></strong>
    <ul>
      <li>TypeScript 와 NestJS 에 절여진 내 뇌는 여전히 카멜을 쓰게 만들었다… 파이썬에서는 함수와 변수명에 <code class="language-plaintext highlighter-rouge">camelCase</code>가 아닌 <code class="language-plaintext highlighter-rouge">snake_case</code>를 사용하는 것이 <strong>PEP 8</strong> 스타일 가이드의 표준이라는 것을 배웠다. (예: <code class="language-plaintext highlighter-rouge">makeMaxLimit</code> -&gt; <code class="language-plaintext highlighter-rouge">make_max_limit</code>) 이는 코드의 가독성과 파이썬 커뮤니티 내의 일관성을 위한 중요한 약속이다.</li>
    </ul>
  </li>
  <li><strong>효율적인 순회와 플래그 변수 제거: <code class="language-plaintext highlighter-rouge">zip</code>과 <code class="language-plaintext highlighter-rouge">for-else</code></strong>
    <ul>
      <li>별도의 데이터 구조를 만들 필요 없이 <code class="language-plaintext highlighter-rouge">zip(schedules, timelogs)</code>를 사용하면 두 리스트를 깔끔하게 병렬로 순회할 수 있었다.</li>
      <li>가장 신기했던 것은 <strong><code class="language-plaintext highlighter-rouge">for-else</code> 구문</strong>이었다. 이 구문을 사용하면 <code class="language-plaintext highlighter-rouge">eventTarget</code>과 같은 <strong>플래그 변수 없이도</strong> “반복문이 <code class="language-plaintext highlighter-rouge">break</code>로 중단되지 않고 무사히 끝났을 때”를 처리할 수 있었다. 이는 코드를 훨씬 직관적이고 우아하게 만들어 주었다. 진짜 희안한게 무지하게 많은 Python…</li>
    </ul>
  </li>
  <li><strong>직관적인 로직: 차감보다 덧셈, 순환에는 나머지 연산</strong>
    <ul>
      <li>전체에서 차감하는 방식보다, <strong>조건을 통과한 대상만 세는 방식(<code class="language-plaintext highlighter-rouge">answer = 0</code> 시작)</strong>이 로직을 더 이해하기 쉽게 만들었다.</li>
      <li>요일을 계산할 때 <code class="language-plaintext highlighter-rouge">if</code>문으로 8이 되는지 검사하는 대신, <strong>나머지 연산자(<code class="language-plaintext highlighter-rouge">%</code>)</strong>를 활용(<code class="language-plaintext highlighter-rouge">(startday + index - 1) % 7 + 1</code>)하여 순환하는 값을 훨씬 간결하게 처리할 수 있었다.</li>
    </ul>
  </li>
  <li><strong>성능 개선</strong>
    <ul>
      <li>기존 코드는 1000개 까지 변수가 들어올 수 있고, 실제 풀이시 4ms 정도로 속도가 오래 걸렸다. 그러나 신규 코드로 개선으로 루프가 1회로 줄어들면서, 1ms 이하로 떨어지게 만들어낼 수 있었다.</li>
    </ul>
  </li>
</ol>

<h3 id="개선의-결과-the-result-of-improvement">개선의 결과 (The Result of Improvement)</h3>

<p>이러한 배움을 통해 코드는 다음과 같이 발전하였다.</p>

<ul>
  <li><strong>가독성:</strong> <code class="language-plaintext highlighter-rouge">snake_case</code> 적용, <code class="language-plaintext highlighter-rouge">zip</code>, <code class="language-plaintext highlighter-rouge">for-else</code> 구문 활용으로 코드의 의도가 훨씬 명확해졌다.</li>
  <li><strong>간결성:</strong> 불필요한 <code class="language-plaintext highlighter-rouge">if-else</code>문, 플래그 변수, 복잡한 요일 계산 로직이 제거되어 코드가 짧고 깔끔해졌다.</li>
  <li><strong>효율성:</strong> 비효율적인 문자열 변환 로직이 빠른 산술 연산으로 대체되었다.</li>
  <li><strong>Pythonic:</strong> 코드가 파이썬의 철학과 스타일에 더 가까워져, 다른 파이썬 개발자가 이해하기 쉬운 코드가 되었다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 개선 버전
</span>
<span class="k">def</span> <span class="nf">is_pass</span><span class="p">(</span><span class="n">dayNumber</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dayNumber</span> <span class="o">&lt;</span> <span class="mi">6</span>

<span class="k">def</span> <span class="nf">make_max_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">limit_hours</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">//</span> <span class="mi">100</span>
    <span class="n">limit_minutes</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">limit_minutes</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">limit_hours</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">limit_minutes</span> <span class="o">-=</span> <span class="mi">60</span>

    <span class="k">return</span> <span class="n">limit_hours</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">limit_minutes</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">schedules</span><span class="p">,</span> <span class="n">timelogs</span><span class="p">,</span> <span class="n">startday</span><span class="p">):</span>

    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span> 

    <span class="k">for</span> <span class="n">limit</span><span class="p">,</span> <span class="n">logs</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">schedules</span><span class="p">,</span> <span class="n">timelogs</span><span class="p">):</span>
        <span class="n">max_limit</span> <span class="o">=</span> <span class="nf">make_max_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">log</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">logs</span><span class="p">):</span>
            <span class="n">current_day</span> <span class="o">=</span> <span class="p">(</span><span class="n">startday</span> <span class="o">+</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nf">is_pass</span><span class="p">(</span><span class="n">current_day</span><span class="p">)</span> <span class="ow">and</span> <span class="n">log</span> <span class="o">&gt;</span> <span class="n">max_limit</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># for - else 구문 처음 봄 개신기 
</span>            <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">42 Seoul - 000_libft</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-00.html" rel="alternate" type="text/html" title="42 Seoul - 000_libft" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-00</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-00.html"><![CDATA[<h2 id="-libft-c-언어와의-첫-만남-나만의-라이브러리-만들기">🚀 Libft: C 언어와의 첫 만남, 나만의 라이브러리 만들기</h2>

<p>개발에 답은 없다. 왜냐면 개발이란 그렇기 때문이다.</p>

<p>도구들은 다양하고, 그 도구들의 어떤 연결이 얼마나 복잡하고, 최적화되며, 그걸 통해 동일한 결과라도 놀라운 결론에 도달하는가. 특히나 단 한 사람의 이야기가 아니라, 여러 사람들의 협업이 되면 그 때부터 개발은 단순히 ‘만든다’의 영역에서 ‘예술’까지도 넘볼 수 있는 꽤나 그럴 싸한 작품이 된다.</p>

<p>42 프랑스를 거쳐, 42 서울은 그런 철학을 인정한다.</p>

<p>그렇기에 답은 없고, 그저 모두에게 제공되는 것은 단 하나의 명제였다. 문제는 줄게, 답은 너가 찾아봐. 그리고 동료들과 그 과정을 치밀하게, 은밀하게, 그리고 치열하게 고민해봐.</p>

<p>다시 후기를 작성하게 된 지금 이순간에도 42서울의 그 가치는, 그 과정은 개발이 왜 매력적이고, 이제는 왜 ‘나에게 맞는 일이다’ 라고 생각하게 되었는가를 다시 한 번 느끼게 만든다.</p>

<p>그렇기에 <code class="language-plaintext highlighter-rouge">ft(forty two)</code>라는 키워드는 유난히 익숙하지만, 동시에 ‘뭔지 모를 느낌’을 주는 키워드이며, 그런 키워드와 함께 시작하는 <code class="language-plaintext highlighter-rouge">libft</code>라는 과제는 42 서울에서의 내 첫 번째 프로젝트이자, C언어의 깊은 물에 처음으로 발을 담갔던 순간으로 기억한다.</p>

<p>오픈 소스라는 키워드는 만드는 행위의 평등함을 추구했고, 그 와중에 생겨난 리눅스라는 시스템과 그 철학은 커져가면서 현대 컴퓨팅의 정수이다. 그리고 그런 리눅스의 표준, 기반들은 처음에 보기엔 생소했다. 왜 굳이 이런걸? 이라고 그때 당시에는 생각했지만, 지금 생각해보면 결국 지금, 양자 컴퓨팅에, AI 등 온갖 키워드의 시발점이 단어 하나를 메모리에 올리는 작업에서 비롯되었음을 깨달았다는 점에서 개발자들에게 컴퓨터의 이해는 어디서 오는가? 한다면 바로 여기서부터라고 자신있게 말할 수 있을 것이다.</p>

<p>C 표준 라이브러리 함수들을 직접 내 손으로 구현해야 했던 이 과제는, 마치 C언어의 심장부를 해부하는 것과 같은 경험이었다. 수많은 밤을 <code class="language-plaintext highlighter-rouge">man</code> 페이지와 함께 지새우며, 포인터와 메모리 주소와 씨름, printf 를 로직의 위치 위치마다 찍어보던 그 과정… 지금 생각하면 얼마나 고통스러웠는지 모른다.</p>

<p>이 프로젝트는 단순히 함수를 베끼는 것이 아니라, 그 작동 원리, 컴퓨터의 소통 방식을 근본부터 이해하고, 나만의 코드로 재창조하는 과정이었다.</p>

<h2 id="-주요-학습-내용-key-learnings">📚 주요 학습 내용 (Key Learnings)</h2>

<p><code class="language-plaintext highlighter-rouge">libft</code> 프로젝트는 크게 세 부분으로 나눌 수 있다.</p>

<p>표준 라이브러리 함수를 구현하는 <strong>Part 1</strong>,</p>

<p>조금 더 복잡하고 유용한 함수들을 만드는 <strong>Part 2</strong>,</p>

<p>그리고 연결 리스트(Linked List)를 다루는 <strong>Bonus</strong> 파트</p>

<h3 id="1-표준-라이브러리-함수-재구현-re-implementing-standard-library-functions">1. 표준 라이브러리 함수 재구현 (Re-implementing Standard Library Functions)</h3>

<p>여기서는 C 언어를 기반으로 리눅스 시스템이 사용하는 언어의 특징, 그리고 그 언어를 통해 다시 사람의 명령을 어떻게 표현하면 될지, OS 가 어떻게 이해하는지를 가장 기본적으로 이해하는 방법을 배웠다.</p>

<ol>
  <li><strong>메모리 다루기 (<code class="language-plaintext highlighter-rouge">&lt;string.h&gt;</code> 등)</strong>: <code class="language-plaintext highlighter-rouge">memset</code>, <code class="language-plaintext highlighter-rouge">memcpy</code>, <code class="language-plaintext highlighter-rouge">memmove</code> 같은 함수들을 만들면서 포인터와 메모리에 대한 이해가 깊어졌다. 특히 <code class="language-plaintext highlighter-rouge">memcpy</code>와 <code class="language-plaintext highlighter-rouge">memmove</code>의 차이점, C 언어의 메모리 사용 방식에 따라, 메모리 오버랩(overlap) 문제가 발견하고, 어떻게 해결하는지를 배웠다. “아니, 그냥 복사하면 되는 거 아냐?” 싶은데, 주소 값이 겹칠 때의 그 미묘한 차이를 이해하고, C 언어라는 걸 기반으로 무언가를 만든다고 하는 것은, 언어의 정해진 특성들을 기반으로 어떤 한계가 생기는지 처음 이해했던 순간이었다.</li>
  <li><strong>문자열 갖고 놀기 (<code class="language-plaintext highlighter-rouge">&lt;string.h&gt;</code> 등)</strong>: <code class="language-plaintext highlighter-rouge">strlen</code>, <code class="language-plaintext highlighter-rouge">strlcpy</code>, <code class="language-plaintext highlighter-rouge">strlcat</code>, <code class="language-plaintext highlighter-rouge">strchr</code>, <code class="language-plaintext highlighter-rouge">strncmp</code> 등등… C언어에서 문자열이 사실상 <code class="language-plaintext highlighter-rouge">char</code> 배열이며, 자료 타입들은 결국 이러한 데이터열의 연속임을 배웠다. 특히 문자열의 편집 과정에서, 데이터의 ‘단위’를 위한 <code class="language-plaintext highlighter-rouge">NULL</code> 문자의 중요성과 버퍼 오버플로우(buffer overflow)를 방지하기 위한 <code class="language-plaintext highlighter-rouge">strlcpy</code>의 소중함 등을 느낄 수 있는 시간이었다.</li>
  <li><strong>문자 판별과 변환 (<code class="language-plaintext highlighter-rouge">&lt;ctype.h&gt;</code> 등)</strong>: <code class="language-plaintext highlighter-rouge">isalpha</code>, <code class="language-plaintext highlighter-rouge">isdigit</code>, <code class="language-plaintext highlighter-rouge">isalnum</code> 같은 함수들은 비교적 간단했지만, 컴퓨터가 사람의 언어를 표현하는 아스키 문자 등에 대해 완벽한 이해가 필요 했다.</li>
  <li><strong>문자열을 숫자로 (<code class="language-plaintext highlighter-rouge">&lt;stdlib.h&gt;</code> 등)</strong>: 가장 난이도 있는 영역이었는데, <code class="language-plaintext highlighter-rouge">atoi</code>를 구현하면서 온갖 예외 케이스(공백, 부호, 숫자 아닌 문자 등)가 왜 생기는지, 그리고 특히나 동료 학습을 통해 이런 예외 처리가 얼마나 중요한지를(…) 뼈저리게 깨달았던 기억이난다.</li>
</ol>

<h3 id="2-나만의-유틸리티-함수-구현-implementing-additional-utility-functions">2. 나만의 유틸리티 함수 구현 (Implementing Additional Utility Functions)</h3>

<p>Part 1이 ‘모방’의 단계였다면, Part 2는 ‘창조’의 단계였다. 주어진 명세에 따라 Part 1에서 만든 아주 기초 단위의, 메모리 상의 데이터 하나를 수정하거나, 데이터를 다른 데이터 형식으로 바꾸는 등의 기술을 배웠으니, 이것들을 래핑(wrapping) 해보는 것을 요구했다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ft_split</code></strong>: 이 녀석이 아마 최종 보스 였을 것이다. 😂 문자열을 특정 구분자(delimiter) 기준으로 쪼개서 2차원 배열에 담아 반환하는 함수인데, 메모리 동적 할당과 당시 배열의 관점, 특히 차원을 가지고 배열을 만드는 것이 머릿속에 구조화가 전혀 되지 않아(…) 정말 어려웠다. 할당해야 할 메모리의 크기를 정확히 계산하고, 오류가 났을 때 이미 할당된 메모리를 모두 해제(<code class="language-plaintext highlighter-rouge">free</code>)해주는 누수(leak) 방지 처리까지… 컴퓨터가 깨끗하게 일을 시작해, 마무리 짓기까지 정말 많은 걸 배울 수 있었던 함수였다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ft_itoa</code></strong>: 정수를 문자열로 바꾸는 이 함수는 <code class="language-plaintext highlighter-rouge">INT_MIN</code> 같은 극단적인 케이스를 처리하는 게 핵심이었다. 사실 split 을 어려워하여 먼저 했었는데, 결국 각 자료타입이 표현할 수 있는 숫자의 양, 그리고 위에서 언급한 케이스들 조사를 하면서 정말 많이 틀렸었던 기억이 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ft_substr</code>, <code class="language-plaintext highlighter-rouge">ft_strjoin</code>, <code class="language-plaintext highlighter-rouge">ft_strtrim</code></strong>: 문자열을 자르고, 합치고, 특정 문자를 제거하는 등, 전에는 단순히 메서드 하나가 하나의 전체 작업을 담당하고 있었다면 그것을 구분하고, 단계를 구성하는 연습을 이 메서드들 기반으로 처음 해봤던 기억이난다.</li>
</ul>

<h3 id="3-보너스-연결-리스트-다루기-handling-linked-lists">3. 보너스: 연결 리스트 다루기 (Handling Linked Lists)</h3>

<p>배열까지는 접근했으나, 다음을 살짝 맛볼 수 있는 기회가 해당 보너스 내용이었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_list</span>
<span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">content</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_list</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>					<span class="n">t_list</span><span class="p">;</span>
</code></pre></div></div>

<p>추상화된 개념, ‘노드’는 꽤나 신선했다. 머릿속에서, 혹은 수학이나 과학에서 사용되는 개념의 캡슐을 만들고, 그 캡슐을 활용한 추상적인 표현을 오히려 구조로 만드는 과정. 그렇게 되었을 때, 단순한 수식으로 풀어 내려면 복잡할 수 있는 것을 좀더 가시적으로 인지하기 용이하게 만든다는 개념은, 수포자였던 나에게는 대단히 신선한 충격이었다.</p>

<p>이처럼 간단한 구조체로 노드(node)를 만들고, 그 노드들을 엮어서 리스트를 만들고, 새로운 노드를 추가하고(<code class="language-plaintext highlighter-rouge">lstnew</code>, <code class="language-plaintext highlighter-rouge">lstadd_front</code>, <code class="language-plaintext highlighter-rouge">lstadd_back</code>), 리스트를 순회하고(<code class="language-plaintext highlighter-rouge">lstiter</code>), 삭제하는(<code class="language-plaintext highlighter-rouge">lstdelone</code>, <code class="language-plaintext highlighter-rouge">lstclear</code>) 등… 연결 리스트의 기본적인 모든 것을 구현했을 때, 더 복잡한 문제나 데이터의 처리를 훨씬 빠르게 대응하는게 가능했다. 특히 <code class="language-plaintext highlighter-rouge">t_list **lst</code>처럼 이중 포인터를 사용해서 리스트의 시작 주소 자체를 변경해야 했던 <code class="language-plaintext highlighter-rouge">ft_lstadd_front</code> 같은 함수는 포인터에 대한 이해도를 한 단계 끌어올려준 기억이었다.</p>

<h2 id="️-makefile의-마법-the-magic-of-makefile">🛠️ Makefile의 마법 (The Magic of Makefile)</h2>

<p>프로그래밍, 코딩만 하다보면 잊는 경우도 많고, 특히 요즘은 인터프리팅 언어를 많이 쓰게 되다보니 잊고 살았지만. 본 과제에서는 C 코드뿐만 아니라 <code class="language-plaintext highlighter-rouge">Makefile</code> 작성법을 제대로 배운 첫 경험이기도 했다. 단순히 <code class="language-plaintext highlighter-rouge">gcc</code> 명령어를 나열하는 것을 넘어, 변수를 사용하고, <code class="language-plaintext highlighter-rouge">%.o: %.c</code> 같은 규칙을 만들고, <code class="language-plaintext highlighter-rouge">all</code>, <code class="language-plaintext highlighter-rouge">clean</code>, <code class="language-plaintext highlighter-rouge">fclean</code>, <code class="language-plaintext highlighter-rouge">re</code>, <code class="language-plaintext highlighter-rouge">bonus</code> 같은 목표(target)를 설정하면서 빌드 자동화를 지정하여 컴퓨터가 이해할 수 있는 목적 파일을 만들어낸다. 이 과정을 통해 만들어진 <code class="language-plaintext highlighter-rouge">libft.a</code>라는 정적 라이브러리(static library)는 그 뒤로 C 언어를 사용하는 동안 유용한 도구가 되어 주었다.</p>

<h2 id="-성찰-및-배운-점-reflection--lessons-learned">🤔 성찰 및 배운 점 (Reflection &amp; Lessons Learned)</h2>

<p><code class="language-plaintext highlighter-rouge">libft</code> 과제를 동료들과 이야기 하고, 메모리나, 추상적 개념을 설명하거나, Makefile에 아스키 이펙트를 넣는 등의 작업은 정말 재밌는 작업이자, 시간 가는 줄 모르는 작업이었다.</p>

<ul>
  <li><strong>메모리, 그리고 포인터</strong>: C가 왜 강력하고, 동시에 왜 위험한 언어인지 몸소 체험했다. 내가 직접 메모리를 할당하고 해제하면서 왜 그리 문제가 되고, 실제로 다른 언어들을 쓰게 되는 이유가 뭔지를 알 수 있었다.</li>
  <li><strong>문제 해결 능력</strong>: <code class="language-plaintext highlighter-rouge">man</code> 페이지를 친구 삼아, 수많은 오류와 세그폴(segmentation fault)을 디버깅하면서 끈질기게 문제를 파고들었다. 특히 man 페이지는 영어로 되어 있기도 하고 개발자의 언어로 적혀 있다보니 ‘간결’ 하지만 동시에 어느 영역에서 얼마나 이 메서드가 움직이는 건가? 와 같은 내용들을 다 파악할 수 없다는 점에서 첫 과제는 대략 1달의 시간이 들었다.</li>
  <li><strong>코드 규약(Norm)</strong>: 42의 엄격한 코드 스타일 규약(Norminette)이란 것도 일종의 불만 이었다. 몇자 내에 작성이 되어야하고, 언어의 컨벤션을 지켜야 하는 등의 일들은 도대체 왜 그렇게까지 필요한가 라고 의문을 품었었는데, 지금 생각하면 얼마나 중요한 ‘프로세스’였는지를 새삼 느낄 수 있다.</li>
</ul>

<p>돌이켜보면 <code class="language-plaintext highlighter-rouge">libft</code>는 단순한 과제가 아니라, C언어라는 세계를 탐험하기 위한 나만의 지도와 나침반을 만드는 과정이었어. 비록 힘들었지만, 이 프로젝트를 통해 얻은 지식과 경험은 앞으로 어떤 어려움이 닥쳐도 헤쳐나갈 수 있는 단단한 기초가 되어주었다. 특히나 정말 빠른 친구들은 순식간에 완성시키고 다른 과제를 하곤 했다. 그걸 바라보는 내 입장에선 참 당연히 비교적인 생각, 내가 정말 이 분야에 어울리는 사람인가? 하는 불평, 불만도 생겼지만 오히려 끝까지 붙잡고 한달에 걸쳐 완성했던 내 프로젝트를 통해, ‘하면 된다’라는 막연하지만 확고한 신뢰감이 생겼던 첫 프로젝트가 아니었나 싶다. 💪</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🚀 Libft: C 언어와의 첫 만남, 나만의 라이브러리 만들기]]></summary></entry><entry><title type="html">42 Seoul - 001_get_next_line</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-01.html" rel="alternate" type="text/html" title="42 Seoul - 001_get_next_line" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-01</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-01.html"><![CDATA[<h2 id="-get_next_line-상태를-기억한다는-것의-의미">📄 Get_Next_Line: ‘상태’를 기억한다는 것의 의미</h2>

<p>만약 컴퓨터에게 기억이 없다면 어떻게 될까? 모든 연산은 그저 일회성으로 끝나고, 방금 전에 했던 작업을 다시 이어가는 것은 불가능할 것이다. <code class="language-plaintext highlighter-rouge">libft</code>가 C언어의 문법과 메모리 조작이라는 ‘행위’에 집중하는 과제였다면, <code class="language-plaintext highlighter-rouge">get_next_line</code>(이하 GNL)은 컴퓨터가 어떻게 ‘상태(state)’를 기억하고 연속적인 작업을 처리하는지에 대한 깊은 통찰을 요구하는, 완전히 새로운 차원의 도전이었다.</p>

<p>“파일에서 한 줄씩 읽어오라”는 명제는 단순해 보였다. 하지만 이내 깨달았다. 이것은 단순히 파일을 읽는 기술을 넘어, ‘시간’이라는 축 위에서 데이터의 흐름을 제어하고, 함수의 생명주기를 뛰어넘는 ‘기억’을 구현해야 하는 문제라는 것을. C언어의 저수준(low-level) 파일 입출력과 씨름하며, <code class="language-plaintext highlighter-rouge">static</code>이라는 키워드에 담긴 철학을 비로소 이해하게 된 여정이었다.</p>

<h3 id="-핵심-개념-정복하기-conquering-core-concepts">🧠 핵심 개념 정복하기 (Conquering Core Concepts)</h3>

<p>GNL의 세계로 들어가기 위해선, 컴퓨터의 가장 기본적인 소통 방식을 먼저 이해해야 했다.</p>

<h4 id="1-파일-디스크립터file-descriptor-추상화의-첫걸음">1. 파일 디스크립터(File Descriptor): 추상화의 첫걸음</h4>

<p>우리가 키보드를 두드리고, 모니터를 보고, 파일을 읽는 모든 행위는 운영체제(OS)의 눈에는 그저 ‘데이터의 흐름’일 뿐이다. OS는 이 복잡한 장치들을 <code class="language-plaintext highlighter-rouge">0</code>(표준 입력), <code class="language-plaintext highlighter-rouge">1</code>(표준 출력), <code class="language-plaintext highlighter-rouge">2</code>(표준 에러)와 같은 정수 번호로 단순화하여 우리에게 제공한다. 이것이 바로 <strong>파일 디스크립터(FD)</strong>다. <code class="language-plaintext highlighter-rouge">open()</code> 함수를 통해 파일을 열면, OS는 새로운 번호표를 발급하며 “자, 이제 이 번호로 파일과 소통해”라고 말해주는 것과 같다. GNL은 이 번호표 하나에 의지해 거대한 파일의 내용을 한 줄씩 탐험하는 항해사와 같았다.</p>

<h4 id="2-read와-buffer_size-경계-위의-줄타기">2. <code class="language-plaintext highlighter-rouge">read()</code>와 <code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>: 경계 위의 줄타기</h4>

<p>GNL의 유일한 무기는 <code class="language-plaintext highlighter-rouge">read</code> 함수였다. 이 함수는 <code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>라는 정해진 크기만큼만 데이터를 가져온다. 여기서 GNL의 본질적인 딜레마가 시작된다. 우리가 읽으려는 ‘한 줄’이라는 개념은 지극히 인간적인 단위이지만, 컴퓨터는 그저 바이트(byte)의 흐름으로 세상을 본다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>가 한 줄보다 작으면, 개행 문자(<code class="language-plaintext highlighter-rouge">\n</code>)를 만날 때까지 여러 번 <code class="language-plaintext highlighter-rouge">read</code>를 호출해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>가 한 줄보다 크면, 한 줄을 읽고도 데이터가 버퍼에 남는다.</li>
</ul>

<p>바로 이 ‘남아버린 데이터’를 어떻게 처리할 것인가? 이번 호출에서 남은 데이터를 다음 호출을 위해 어딘가에 고이 보관해두어야만 했다. 함수가 호출되고 끝나는 찰나의 순간을 넘어, 다음을 기약하는 ‘기억’이 필요했다.</p>

<h4 id="3-마법의-키워드-static-함수에-영혼을-불어넣다">3. 마법의 키워드, <code class="language-plaintext highlighter-rouge">static</code>: 함수에 영혼을 불어넣다</h4>

<p>이 문제의 해답은 바로 <code class="language-plaintext highlighter-rouge">static</code> 변수에 있다. ✨</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">get_next_line</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">backup</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수가 끝나면 사라지는 일반 지역 변수와 달리, <code class="language-plaintext highlighter-rouge">static</code> 변수는 프로그램이 시작될 때 단 한 번 메모리에 할당되어 프로그램이 끝날 때까지 자신의 값을 유지한다. 즉, GNL 함수가 수십, 수백 번 호출되어도 <code class="language-plaintext highlighter-rouge">backup</code> 변수는 마치 어제의 일을 기억하는 사람처럼, 이전에 읽고 남겨둔 데이터를 간직하고 있는 것이다.</p>

<p>이 <code class="language-plaintext highlighter-rouge">static</code> 변수 <code class="language-plaintext highlighter-rouge">backup</code>에 <code class="language-plaintext highlighter-rouge">read</code>로 읽어온 내용을 계속 이어 붙이고(<code class="language-plaintext highlighter-rouge">strjoin</code>), 개행 문자를 발견하면 그 앞부분까지를 세상에 내보내고(<code class="language-plaintext highlighter-rouge">return</code>), <code class="language-plaintext highlighter-rouge">backup</code>에는 개행 문자 뒤의 나머지 약속을 담아두는 것. 이 로직을 깨달았을 때, 나는 비로소 함수에서 아주 기본적인 ‘상태’라는 걸 보관하는 방법을 배울 수 있었다.</p>

<h3 id="️-나의-gnl-구현기-my-gnl-implementation-journey">🛠️ 나의 GNL 구현기 (My GNL Implementation Journey)</h3>

<p>그러나 알다시피 머리로 이해하는 것과 손으로 구현하는 것은 천지 차이다.</p>

<ol>
  <li><strong>읽고, 쌓고, 또 쌓고</strong>: <code class="language-plaintext highlighter-rouge">read</code> 함수가 더 이상 읽을 것이 없을 때까지, 또는 개행을 만날 때까지 반복문을 돌았다. <code class="language-plaintext highlighter-rouge">backup</code>이라는 공간에 <code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>만큼의 벽돌을 계속해서 쌓아 올리는 과정이었다. 이 과정에서 <code class="language-plaintext highlighter-rouge">ft_strjoin</code>은 나의 든든한 시멘트가 되어주었다.</li>
  <li><strong>자르고, 내보내고</strong>: 마침내 개행이라는 이정표를 만나면, 그곳까지의 길을 잘라내어 결과로 반환한다.</li>
  <li><strong>기억하고, 준비하고</strong>: 그리고 가장 중요했던 단계. <code class="language-plaintext highlighter-rouge">backup</code> 변수에는 잘라내고 남은 나머지 부분을 담아, 다음 호출의 시작점이 될 수 있도록 준비시켰다. 이 과정에서 수없이 터져 나오는 메모리 누수(leak)를 막기 위해 <code class="language-plaintext highlighter-rouge">free</code>와 사투를 벌였다. 정말 이 부분에서 생길 수 있는 에러, 특히 반복되는데 내가 놓치지 않으려면 구조적으로 생각해야 했고, C언어가 왜 그토록 정교한 메모리 관리를 요구하는지 온몸으로 깨달았다. (정말이지, 세그폴 화면은 다시 보고 싶지 않다… 😇)</li>
</ol>

<h3 id="-보너스-여러-개의-기억을-동시에-bonus-multiple-states-at-once">✨ 보너스: 여러 개의 기억을 동시에 (Bonus: Multiple States at Once!)</h3>

<p>필수 파트의 GNL은 <code class="language-plaintext highlighter-rouge">static</code> 변수 하나에 의존하기에, 오직 하나의 기억(파일)만 유지할 수 있었다. 하지만 보너스 파트는 <code class="language-plaintext highlighter-rouge">여러 파일을 동시에 열고</code>, 각 파일의 읽기 상태를 독립적으로 기억하라는 더 높은 차원의 과제를 제시했다.</p>

<p>하나의 뇌로는 여러 사람의 기억을 동시에 관리할 수 없듯, <code class="language-plaintext highlighter-rouge">static</code> 변수 하나로는 부족했다. 해결책은 ‘기억의 목록’을 만드는 것이다.</p>

<p>파일 디스크립터(FD)를 열쇠 삼아, 각 열쇠에 맞는 <code class="language-plaintext highlighter-rouge">backup</code> 데이터를 저장하는 배열(<code class="language-plaintext highlighter-rouge">static char *backup[OPEN_MAX]</code>)이나 연결 리스트를 활용했다.</p>

<p>GNL이 특정 <code class="language-plaintext highlighter-rouge">fd</code>와 함께 호출되면, 우리는 기억의 목록에서 해당 <code class="language-plaintext highlighter-rouge">fd</code>에 맞는 기억을 꺼내 작업을 이어간다는 것을 구조화 하는 것이 관건이었다.</p>

<h3 id="-성찰-및-배운-점-reflection--lessons-learned">🤔 성찰 및 배운 점 (Reflection &amp; Lessons Learned)</h3>

<p>GNL은 나에게 ‘보이지 않는 것을 다루는 법’을 가르쳐줬다.</p>

<ul>
  <li><strong>상태 관리의 본질</strong>: 파일 입출력을 넘어, ‘상태’라는 추상적인 개념을 어떻게 코드 레벨에서 구체화하고 유지하는지 깊이 이해하게 되었다. 이는 나중에 웹 서버가 수많은 클라이언트의 연결 상태를 기억하거나, UI 프레임워크가 컴포넌트의 이전 상태를 기억하는 등 모든 프로그래밍의 근간이 되는 원리였다. 이제는 정말 다양한 도구나, 개념이 있고, 사실 조금 더 곰곰히 생각해보면 ‘static’이 내부에 당연히 녹아 있겠지만, 이제는 다소 구식(….) 방법임을 새삼 느끼긴한다. 그러나 결국 최적화가 필요하고, 데이터를 더 고속으로, 더 빠르게 처리해야한다면 어쩌면 다시 끄집어낼 기회가 오지 않을까, 그렇게 생각해본다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">static</code>의 철학</strong>: <code class="language-plaintext highlighter-rouge">static</code>은 단순한 C언어의 키워드가 아니었다. 함수의 생명주기를 초월하여 데이터를 보존하는, C언어가 제공하는 가장 원시적이면서도 강력한 상태 관리 도구임을 깨달았다. 그때는 얼마나 빠른가? 이걸 기반으로 꽤나 호들갑을 떨었던(…) 기억이 난다.</li>
  <li><strong>디버깅과의 처절한 사투</strong>: 끝없이 터지는 메모리 누수와 세그폴은 나를 좌절시켰지만, 동시에 메모리의 할당과 해제의 흐름을 집요하게 추적하는 인내심과 문제 해결 능력을 길러주었다. 그게 핵심이기도 했다. 특히 보너스를 하게 되면, FD 의 관리가 병렬로 진행되는데, 조건이 추가될 수록 당연히 기존 내용을 두고, 다른 내용을 찾아온다는 작업이 이제는 머릿속에 그려지기에 어디서 뭘 잡아야 하는가? 를 기억하지만, 그땐 정말 힘들었다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">get_next_line</code>은 한 줄의 문장을 읽어낸다라고 쉽게 이야긴 했지만, 핵심은 상태를 저장하고, 어떤 비즈니스 로직을 거치고, 또 거기서 여러 파일을 다룬다면 어떤 과정으로 작업을 왔다 갔다 할 수 있는지, 그 논리적 로직이 뭔지를 실질적으로 배우는 기회였다고 생각한다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[📄 Get_Next_Line: ‘상태’를 기억한다는 것의 의미]]></summary></entry><entry><title type="html">42 Seoul - 002_born2beroot</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-02.html" rel="alternate" type="text/html" title="42 Seoul - 002_born2beroot" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-02</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-02.html"><![CDATA[<h2 id="-born2beroot-시스템의-주인이-된다는-것">🐧 Born2beroot: 시스템의 주인이 된다는 것</h2>

<p>GUI의 안락한 유저 인터페이스 뒤편, 모든 것이 날것의 텍스트로 존재하는 세상이 있다. <code class="language-plaintext highlighter-rouge">libft</code>와 <code class="language-plaintext highlighter-rouge">get_next_line</code>이 C언어라는 도구를 날카롭게 벼리는 과정이었다면, <code class="language-plaintext highlighter-rouge">born2beroot</code>는 그 도구를 들고 그곳의 법칙을 세우는 ‘설계자’의 역할을 경험하는 것을 요구한 첫 과제였다. 지금 생각해보면 Ops 영역을 처음으로 맛본게 아닐가 싶다.</p>

<p>이 과제는 단순한 서버 구축 기술을 배우는 것을 넘어선다. 사용자의 입장에서 시스템이 ‘제공하는’ 기능을 수동적으로 사용하던 관점에서 벗어나, 시스템의 모든 요소를 직접 제어하고 책임지는 관리자의 시점으로 전환하는 근본적인 패러다임의 변화를 경험하게 했다.</p>

<p>약간 가오를 잡는 역할을(ㅋㅋ) 하게 해주기도 하고, 검은 화면의 커서 깜빡임은 더 이상 공포의 대상이 아니라, 시스템과 직접 대화하는 강력하고 정밀한 언어임을 깨닫는 여정이었다. OS 라는 바탕, GUI 뒤에서 동작하는 실제 OS 라는 것을 이해하는 기회가 이 과제에서 첫 삽을 떳다고 볼수 있었다.</p>

<h3 id="-시스템-아키텍트의-청사진-무無에서-유有를-창조하다">📜 시스템 아키텍트의 청사진: 무(無)에서 유(有)를 창조하다</h3>

<p><code class="language-plaintext highlighter-rouge">born2beroot</code>의 목표는 명확했다. 우선 OS 라는 것을 이해한다. 그리고 그 바탕에서 가상 머신이라는 격리된 공간을 또 다시 이해한다.</p>

<p>환경을 설정한다는 것이 가지는 리스크를 최소화하는 방법을 배우고 나면, 데비안(Debian) 리눅스 서버를 오직 명령줄 인터페이스(CLI)만을 사용하여 요구사항에 맞춰 구축한다.</p>

<p>이는 마치 건축가가 허허벌판에 건물을 올리듯, 디스크 파티셔닝으로 기초 공사를 하고, 사용자 계정으로 골조를 세우며, 보안 정책과 방화벽으로 견고한 외벽을 쌓아 올리는 과정이었다.</p>

<p>모든 결정에는 이유 물음표를 띄워졌으며,모든 명령어는 시스템에 영구적인 흔적을 남기는 만큼, 이 과제를 하던 이들, OS 를 모르는 이들에게는 과정 하나 하나가 통곡의 반복을 이어나가야 했다.</p>

<h3 id="-핵심-과업들-단순한-설정을-넘어-원리를-이해하다">🔑 핵심 과업들: 단순한 설정을 넘어 원리를 이해하다</h3>

<p>과제를 수행하며 마주한 핵심 과업들은 시스템 관리의 근간을 이루는 개념들을 담고 있다.</p>

<ol>
  <li><strong>LVM(Logical Volume Manager) 파티셔닝</strong>: 물리적인 디스크의 한계를 넘어 논리적으로 공간을 분할하고 관리하는 방법을 배웠다. 이는 하드웨어를 소프트웨어적으로 추상화하여 유연성과 확장성을 확보하는, 현대 스토리지 관리의 핵심 원리를 체득하는 과정이었다. 고정된 칸막이(기본 파티션)가 아닌, 필요에 따라 늘이고 줄일 수 있는 가변적인 공간(논리 볼륨)의 개념을 이해하게 되었다. 또한 이러한 파티셔닝의 목표는 하드웨어 구축 시 특정 영역의 OS 의 역할에 따라 적절하게 대응하고, 보다 복잡한 시스템이라면 특정 하드웨어를 사용하는 등을 고려하고, 이를 통해 최적의 환경을 구축하거나 위험한 상황에 대응하여 서비스가 지속될 수 있는 방법이 무엇인지 배우는 아주 기초적 단편을 이해할 수 있었다.</li>
  <li><strong>강력한 암호 정책 (PAM)</strong>: <code class="language-plaintext highlighter-rouge">/etc/pam.d/common-password</code> 파일을 수정하며 사용자의 비밀번호 규칙을 강화하는 것은, 시스템 보안의 첫걸음이자 가장 중요한 원칙인 ‘선제적 방어’의 개념을 배우는 것이다. 복잡성, 주기적 변경, 재사용 금지 등의 규칙은 외부의 위협을 막는 최소한의 방어선이며 이를 OS 차원에서 어떻게 하는지, 리눅스 시스템은 무엇을 활용하는지 배울 수 있었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo</code> 권한 관리</strong>: <code class="language-plaintext highlighter-rouge">sudoers</code> 설정을 통해 최고 관리자(root) 권한의 사용을 통제하고 기록하는 것은 ‘최소 권한 원칙(Principle of Least Privilege)’을 실현하는 과정이었다. 모든 <code class="language-plaintext highlighter-rouge">sudo</code> 명령어 실행 시도를 로그로 남기는 것은 시스템의 모든 관리 행위에 대한 ‘감사 추적(Audit Trail)’의 중요성을 일깨워주었다. 지금은 이해하고 있지만, 시스템 내에서 동작하는 프로세스는 OS 의 주인인 유저가 동작시키기도 하지만, 시스템 구축 과정에서 이러한 권한을 제한된 계정으로 만들어 사용하게 만듦으로써 그 계정이 할 수 있는 동작의 한계를 지정하고, 이를 통해 시스템 전체에 대한 제한을 제공하는 것은, Ops 차원의 상당한 노하우임을 나중에 깨달았다.</li>
  <li><strong>SSH 포트 변경 및 UFW 방화벽 설정</strong>: 서버 개발과 관리, 유지보수 차원에서 본다면 원격의 접속은 가장 필수이자 기본이 된다. 그러나 이를 정해져있는데로 활용하는 것은 자칫 보안의 구멍을 만들 수 있다. SSH 포트(22)를 비표준 포트(4242)로 변경하고 UFW를 통해 해당 포트만 허용하는 작업은, 시스템의 ‘대문’을 지키는 가장 기본적인 보안 조치였다. 이는 무차별적인 자동화 공격(Brute-force attack)의 표적이 될 가능성을 낮추고, 허가된 경로 외의 모든 접근을 차단하는 ‘화이트리스트’ 기반 보안 모델의 기초를 다지는 경험이었다.</li>
  <li><strong>사용자 및 그룹 관리</strong>: 사용자를 생성하고 <code class="language-plaintext highlighter-rouge">user42</code> 및 <code class="language-plaintext highlighter-rouge">sudo</code> 그룹에 소속시키는 과정은, 역할 기반 접근 제어(RBAC, Role-Based Access Control)의 개념을 이해하게 했다. 각 사용자에게 필요한 최소한의 권한만을 부여함으로써, 시스템의 안정성을 높이고 잠재적인 보안 위협을 줄일 수 있음을 배웠다. 3번과 함께 생각해볼 여지가 있던 영역이었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">monitoring.sh</code> 스크립트와 <code class="language-plaintext highlighter-rouge">cron</code></strong>: 시스템 구축이나 사용에서 정말 핵심 중에 하나. 스크립트를 작성하고 이를 활용해 시스템 단계에서 각 프로세스들을 관리하는 기능은 지금도 흥미진진한 주제였다. 여기서는 주기적으로 서버의 상태를 보고하는 셸 스크립트를 작성하고 <code class="language-plaintext highlighter-rouge">cron</code>으로 자동화하는 것을 통해 시스템을 살아있는 유기체처럼 지속적으로 관찰하는 ‘모니터링’을 만들어보았다. 이는 문제가 발생했을 때 사후에 대응하는 것을 넘어, 시스템의 상태를 능동적으로 파악하고 예측하는 인프라 관리의 기본 자세를 길러주었다.</li>
</ol>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p>옛날 옛적, Windows Vista를 쓰던 시절 난 학생이었다.
무슨 변덕일까 윈도우 대신 새로운걸 경험해보고 싶다면서 OS 를 우분투를 깔아본 적도 있었다.
그때는 CLI 라는 개념이 뭔지도 모르는 상태로, GUI 없이 명령어를 쳐서 최적화 하는 작업은 그냥 아무것도 모르고 치면 되는 ‘전문가’들의 영역이라고 생각했다.
또한 그때 OS 는 어찌보면 좋은 성능의 새롭고 신선한 그림이 나오는 ‘게임기’ 취급을 했었다(ㅋㅋ)</p>

<p>그런데 <code class="language-plaintext highlighter-rouge">born2beroot</code>과제를 하면서 OS 를 다시 이해하자, 체계란게 뭐고, 개발에서 어떻게 활용하는가, 이런 부분을 꽤나 알 수 있었다.</p>

<ul>
  <li><strong>관점의 전환 (사용자에서 관리자로)</strong>: 더 이상 나는 시스템이 정해준 규칙 안에서 움직이는 사용자가 아니었다. 시스템의 규칙을 직접 만들고, 그 결과에 책임을 지는 관리자의 무게를 느끼며, 컴퓨터와의 관계가 근본적으로 재정의되었다.</li>
  <li><strong>CLI는 언어다</strong>: 처음 마주했을 때의 막막함과 달리, CLI는 시스템의 내부 구조와 직접 소통할 수 있는 가장 강력하고 효율적인 언어임을 깨달았다. 마우스 클릭으로는 결코 닿을 수 없는 깊이까지 시스템을 제어할 수 있는 힘을 얻었다.</li>
  <li><strong>모든 개발의 기초 체력</strong>: 서버 위에서 애플리케이션이 동작하는 한, 개발자는 운영체제로부터 자유로울 수 없다. 이 과제를 통해 다진 네트워크, 보안, 사용자 권한, 파일 시스템에 대한 이해는, 향후 어떤 애플리케이션을 개발하든 문제의 근본 원인을 파악하고 해결할 수 있는 단단한 기초 체력이 되어주었다.</li>
  <li><strong>신비로운 서버의 첫 걸음</strong>: 기본 세팅, 거기에 워드프레스를 설치하는 등의 작업으로 해놓고, 호스트에서 포트포워딩으로 접근하는 작업, 그렇게하여 웹 사이트가 딱 떴을 때 그 감각은 서버, 서빙이란게 뭔지 처음으로 제대로 이해한 순간이었다.</li>
</ul>

<p>결론적으로 <code class="language-plaintext highlighter-rouge">born2beroot</code>는 단순한 서버 세팅 가이드가 아니었다. 그것은 개발자로서 내가 서 있는 땅, 즉 운영체제라는 기반을 두 발로 직접 딛고 이해하게 만든, 진정한 의미의 ‘뿌리 내리기’ 과정이었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="Linux" /><category term="DevOps" /><summary type="html"><![CDATA[🐧 Born2beroot: 시스템의 주인이 된다는 것]]></summary></entry><entry><title type="html">42 Seoul - 003_printf</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-03.html" rel="alternate" type="text/html" title="42 Seoul - 003_printf" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-03.html"><![CDATA[<h2 id="️-ft_printf--데이터의-표현을-책임진다는-것의-의미">🖨️ ft_printf : 데이터의 ‘표현’을 책임진다는 것의 의미</h2>

<p>우리가 프로그래밍 세계에 입문하며 가장 먼저 배우는 주문은 아마 <code class="language-plaintext highlighter-rouge">printf("Hello, World!");</code>일 것이다.</p>

<p>너무나 당연하게, 마치 공기처럼 사용해왔던 이 함수는 컴퓨터 내부의 추상적인 데이터(숫자, 주소)를 인간이 인지할 수 있는 ‘문자’의 형태로 번역해주는 마법과도 같다.</p>

<p>처음, 디버그 툴을 배우기 전에 가장 쉽게, 가장 많이 쓰는 디버깅 툴도 보통 print 계열이리라.</p>

<p><code class="language-plaintext highlighter-rouge">born2beroot</code>가 시스템이라는 땅을 이해하는 과정이었다면, <code class="language-plaintext highlighter-rouge">ft_printf</code>는 그 땅 위에서 오가는 데이터의 ‘표현’을 직접 설계하고 책임지는, 언어의 번역가가 되어보는 과제였다.</p>

<p>이 과제의 핵심은 <strong>‘정해지지 않음’</strong>을 다루는 데 있다. 컴파일 시점에는 몇 개의 인자가, 어떤 타입으로 들어올지 전혀 알 수 없는 상황.</p>

<p>C언어의 엄격한 타입 시스템에 살짝 열린 뒷문을 통해, 함수의 호출 규약(Calling Convention)과 스택 메모리의 작동 방식을 어렴풋이나마 엿보며, 유연함의 대가가 얼마나 큰 책임감을 요구하는지(…) 알게 되는 과정이였다.</p>

<p>사실 이 과제를 먼저 해야 하는 것이었음에도, born2beroot 를 먼저 하게 된 이유도, 실질, 이 프로젝트가 가지는 방대함, 고려해야하는 우선순위 등 기존의 과제들과 격이 다른 수준의 것이었음이 가장 큰 문제였다.</p>

<h3 id="-가변-인자의-이해-약속과-신뢰의-메커니즘">🎩 가변 인자의 이해: 약속과 신뢰의 메커니즘</h3>

<p><code class="language-plaintext highlighter-rouge">ft_printf</code>의 구현은 <code class="language-plaintext highlighter-rouge">&lt;stdarg.h&gt;</code> 헤더에 정의된 매크로들을 이해하는 것에서 시작된다. 이는 단순한 기능 습득이 아니라, 함수를 호출하는 쪽과 호출되는 쪽 사이의 보이지 않는 ‘약속’을 이해하는 과정이었다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">va_list</code>, <code class="language-plaintext highlighter-rouge">va_start</code>, <code class="language-plaintext highlighter-rouge">va_arg</code>, <code class="language-plaintext highlighter-rouge">va_end</code>: 이 네 가지 도구는 컴파일러가 스택에 차례대로 쌓아둔 인자들을, 프로그래머가 제공한 ‘서식 문자열’이라는 지도를 보고 올바른 크기(타입)만큼씩 순서대로 읽어 나갈 수 있게 해주는 메커니즘이다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">printf</code> 함수는 서식 지정자 <code class="language-plaintext highlighter-rouge">%d</code>를 보고 “다음에 올 인자는 int 크기만큼 읽어야겠군”이라고 <strong>신뢰</strong>하고 <code class="language-plaintext highlighter-rouge">va_arg</code>를 실행한다. 만약 이 신뢰가 깨지면(예: <code class="language-plaintext highlighter-rouge">%d</code>에 <code class="language-plaintext highlighter-rouge">char*</code>를 전달), 프로그램은 곧바로 정의되지 않은 동작(Undefined Behavior)의 나락으로 떨어진다.</p>

<h3 id="-서식-지정자-파싱-작은-언어의-해석기interpreter-만들기">🧩 서식 지정자 파싱: 작은 언어의 해석기(Interpreter) 만들기</h3>

<p>처음 기본적인 메서드의 구조는 <code class="language-plaintext highlighter-rouge">ft_printf</code>의 본질은 서식 문자열(format string)이라는 작은 언어를 해석하고, 그에 맞는 동작을 수행하는 작은 해석기를 만드는 것과 같았다.</p>

<ol>
  <li><strong>문자열 순회 및 분기</strong>: 프로그램은 전달받은 서식 문자열을 루프를 통해 한 글자씩 읽다가, 제어 문자인 <code class="language-plaintext highlighter-rouge">%</code>를 만나면 해석기 모드로 전환된다. 이후 따라오는 문자에 따라 어떤 종류의 ‘번역’을 수행할지 결정해야 했다.</li>
  <li><strong>데이터 타입별 번역</strong>:
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">s</code>, <code class="language-plaintext highlighter-rouge">%</code></strong>: 가장 기본적인 번역. 데이터를 그대로 표현하거나(<code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">s</code>), 제어 문자를 일반 문자로 탈출(<code class="language-plaintext highlighter-rouge">%%</code>)시키는 역할을 담당했다. 특히 <code class="language-plaintext highlighter-rouge">s</code> 처리 시 <code class="language-plaintext highlighter-rouge">NULL</code> 포인터가 들어오는 예외 상황을 어떻게 다룰지는 ‘안정성’에 대한 첫 번째 시험대였다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">u</code></strong>: 2진수로 저장된 정수 데이터를 10진수 문자열로 변환하는 핵심적인 번역 과정. <code class="language-plaintext highlighter-rouge">libft</code>에서 만든 <code class="language-plaintext highlighter-rouge">ft_itoa</code>를 활용하고, 부호 없는 정수(<code class="language-plaintext highlighter-rouge">unsigned int</code>)를 처리하며 컴퓨터의 숫자 표현 범위를 다시 한번 상기하게 되었다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">X</code></strong>: 10진법에 익숙한 인간의 시각을 16진법으로 바꾸는 번역. 이는 메모리 주소나 비트 연산 결과를 확인할 때 왜 16진법이 유용한지에 대한 실용적인 이해로 이어졌다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">p</code></strong>: 가장 추상적인 개념인 ‘메모리 주소’를 눈에 보이는 16진수 문자열로 시각화하는 번역. 이는 포인터라는 개념을 단순한 변수가 아닌, 실제 물리 메모리 상의 한 점을 가리키는 구체적인 값으로 인지하게 만들었다.</li>
    </ul>
  </li>
</ol>

<h3 id="️-코드-구조화의-여정-기능에서-설계로">🏗️ 코드 구조화의 여정: 기능에서 설계로</h3>

<p>초기 버전은 거대한 <code class="language-plaintext highlighter-rouge">if-else</code> 혹은 <code class="language-plaintext highlighter-rouge">switch</code> 문 안에 모든 변환 로직을 담으려는 시도를 했다. 하지만 이는 곧 유지보수의 재앙으로 이어진다는 것을 빠르게 깨달았다.</p>

<p>‘처리’의 단위를 처음에는 어차피 비슷한 기능들의 나열이고, 그러니 전체를 모든 로직에서 처리하게 하는 구조는, 어쩌면 사람의 인식에서는 당연한 것이다. 노션에 로직을 설계하던 당시, 얼마나 괜찮다고 느꼈는지- 생각보다 자신감있게 그 설계를 괜찮다고 동료들에게도 자랑했던 기억이 난다.</p>

<p>하지만 위에서 말한 듯 재앙이 될 수 있다는 사실은 명확했다. 메서드로 구분되지 못하고, if-else, switch 의 사용은 결국 한 단어, 한 글자마다 조건문을 도는 것이었고, 수 많은 예외 케이스들을 만나는 순간 어디서 어떤 에러가 나는지를 알기가 매우 까다로웠다.</p>

<p>심지어 같은 로직이라고 생각하는 조건들도, 결국 겹치고 얽히다보면 논리적으로 빈틈이 생기는 경우도 있었고, 이러한 사실은 <code class="language-plaintext highlighter-rouge">메서드</code> 로 구분을 하고, 로직을 모듈화 하는 것이 왜 중요한지, 그리고 그 논리의 단위를 얼마나 <code class="language-plaintext highlighter-rouge">작게</code> 해야 하는지 아주 중요한 부분을 배울 수 있는 기회였다고 생각한다.</p>

<p>또한 저장 및 출력을 할 때 서식 지정자를 만날 때마다 <code class="language-plaintext highlighter-rouge">write</code> 시스템 콜을 직접 호출하는 방식과, 출력할 문자열 조각들을 자료구조(연결 리스트 등)에 담아두었다가 마지막에 한 번에 출력하는 방식 사이에서 고민하다가 성능의 차이를 느껴 직접 호출하는 방식으로의 개선되는 과정 등…</p>

<p>단순히 ‘기능 구현’을 넘어 ‘효율적인 설계’에 대한 아주 큰 고민들의 첫 문턱이 아니었나 싶다. 이 프로젝트까지 와서야 비로소 복잡한 문제를 잘게 나누어 정복하는 소프트웨어 공학의 기본 원칙을 체득할 수 있었다.</p>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">ft_printf</code>는 매일 사용하던 도구의 내부를 분해하고 재조립해보는 소중한 경험이었다.</p>

<ul>
  <li><strong>추상화의 이면</strong>: <code class="language-plaintext highlighter-rouge">printf</code>라는 편리한 추상화 계층 덕분에 데이터가 어떻게 ‘표현’되는지에 대한 고민 없이 개발할 수 있었다. 그 이면에는 가변 인자 처리, 데이터 타입 변환, 예외 처리 등 수많은 복잡한 과정이 숨어있음을 알 수 있었다.</li>
  <li><strong>신뢰 기반의 프로그래밍</strong>: C언어의 가변 인자 기능은 타입 체크를 컴파일러가 아닌 프로그래머의 책임으로 돌린다. 이는 유연함을 제공하는 대신, 사소한 실수가 프로그램 전체를 무너뜨릴 수 있는 위험성을 내포하고 있음을, 즉 C언어가 프로그래머를 얼마나 신뢰하는(혹은 방임하는) 언어인지 몸소 체험했고, 그렇기에 어떻게 대응해두는 것, 에러 핸들링을 어떤 식으로 하는 것으로 시스템 전체의 안전성을 유지할 수 있는지를 배우는 기회가 되었다.</li>
  <li><strong>문제 분할의 중요성</strong>: 하나의 거대한 문제를 ‘파싱’, ‘정수 변환’, ‘16진수 변환’ 등 작고 명확한 단위의 함수로 나누는 과정은, 이후 더 복잡한 프로젝트를 마주했을 때 어떻게 접근해야 하는지에 대한 훌륭한 훈련이 되었다.</li>
</ul>

<p>결론적으로 <code class="language-plaintext highlighter-rouge">ft_printf</code>는 단순히 문자열을 출력하는 함수를 만드는 과제가 아니었다. 컴퓨터 내부의 비트(bit) 덩어리를 인간이 이해할 수 있는 의미 있는 정보로 ‘번역’하고 ‘표현’하는 책임이 전적으로 프로그래머에게 있음을 깨닫게 한, 개발자로서의 책임감과 시야를 한 단계 넓혀준 프로젝트였다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🖨️ ft_printf : 데이터의 ‘표현’을 책임진다는 것의 의미]]></summary></entry><entry><title type="html">42 Seoul - 004_Minitalk</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-04.html" rel="alternate" type="text/html" title="42 Seoul - 004_Minitalk" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-04</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-04.html"><![CDATA[<h2 id="-minitalk--신호signal로-쌓아-올린-통신의-규약protocol">📢 Minitalk : 신호(Signal)로 쌓아 올린 통신의 규약(Protocol)</h2>

<p><code class="language-plaintext highlighter-rouge">printf</code>가 데이터의 ‘표현’을 다루는 과제였다면, <code class="language-plaintext highlighter-rouge">Minitalk</code>는 한 걸음 더 나아가, 분리된 프로세스들 사이에 어떻게 ‘의미’를 전달할 수 있는지에 대한 근본적인 질문을 던진다.</p>

<p>이 과제의 요구사항은 지극히 미니멀리즘하다: 네트워크 소켓 없이, 오직 두 종류의 유닉스 시그널(<code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR2</code>)만을 이용해 문자열을 전송하라.</p>

<p>본래 시그널은 프로세스를 중단시키거나(<code class="language-plaintext highlighter-rouge">SIGINT</code>), 특정 상태를 알리는 등 단방향의 강제적인 ‘사건(Event)’을 통지하기 위한 원시적인 메커니즘이자 OS 단에서 제공하는 안전 장치이다.</p>

<p><code class="language-plaintext highlighter-rouge">Minitalk</code>는 이 제약 조건을 역으로 이용하여, 가장 혼란스럽고 원시적인 통신 수단 위에 어떻게 질서정연한 ‘규약(Protocol)’을 세우고 안정적인 통신 채널을 구축할 수 있는지 온몸으로 증명해야 하는, 시스템 프로그래밍의 정수가 담긴 과제였다.</p>

<h3 id="-통신의-첫-단추-약속convention의-탄생">💡 통신의 첫 단추: 약속(Convention)의 탄생</h3>

<p>모든 통신은 ‘약속’에서 시작한다. <code class="language-plaintext highlighter-rouge">Minitalk</code>의 세계에서는 두 개의 시그널이 알파벳의 역할을 맡는다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SIGUSR1</code>은 비트(bit) <strong>0</strong>을 의미한다.</li>
  <li><code class="language-plaintext highlighter-rouge">SIGUSR2</code>는 비트(bit) <strong>1</strong>을 의미한다.</li>
</ul>

<p>이 지극히 단순한 약속 하나가 무질서한 신호에 의미를 부여하는 첫걸음이다.</p>

<p>시그널을 받으면, 이에 따라 프로세스가 OS 단의 개입을 인지하게 되고, 그 결과로 약속된 신호의 모음을 보내준다.</p>

<p>예를 들어 문자 ‘A’(ASCII 65, 이진수 <code class="language-plaintext highlighter-rouge">01000001</code>)를 보내는 행위로</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR2</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR2</code></p>
</blockquote>

<p>와 같은 8개의 시그널을 순차적으로 발신하는 행위로 번역된다.</p>

<p>이는 현대 네트워크 통신의 가장 밑단에 있는 물리 계층(Physical Layer)에서 전기 신호의 전압 차이를 0과 1로 해석하는 원리와 정확히 일치한다. 나는 이 과제에서 시그널을 통해 가장 원시적인 형태의 물리 계층을 직접 구현한 것이다.</p>

<h3 id="-프로토콜의-설계-주소-지정-직렬화-그리고-동기화">🤝 프로토콜의 설계: 주소 지정, 직렬화, 그리고 동기화</h3>

<p>단순히 0과 1을 보낼 수 있다고 해서 통신이 완성되지는 않는다. 단순히 통신을 하는 인코딩과 디코딩의 절차일 텐데, 결국 통신이라고 하는 것이 의미 있는 데이터 교환을 위해서는 정교한 프로토콜로의 구성이 필요시 된다.</p>

<ol>
  <li><strong>주소 지정 (Addressing) - <code class="language-plaintext highlighter-rouge">PID</code></strong>: 서버는 시작과 동시에 자신의 <code class="language-plaintext highlighter-rouge">PID(Process ID)</code>를 출력한다. 이는 네트워크에서 서버가 자신의 IP 주소와 포트 번호를 알리는 것과 같다. <code class="language-plaintext highlighter-rouge">PID</code>는 운영체제가 각 프로세스에게 부여한 고유한 주소이며, 클라이언트는 <code class="language-plaintext highlighter-rouge">kill</code> 시스템 콜을 통해 이 주소로 정확하게 신호를 보낼 수 있다. 통신의 가장 기본인 ‘누가 누구에게’ 보내는지를 명확히 하는 단계다.</li>
  <li><strong>직렬화와 역직렬화 (Serialization &amp; Deserialization) - 비트 연산</strong>:
    <ul>
      <li><strong>클라이언트 (송신자)</strong>: 문자(char)라는 고수준 데이터를 <code class="language-plaintext highlighter-rouge">(character &gt;&gt; i) &amp; 1</code>과 같은 비트 연산을 통해 8개의 비트 스트림으로 분해(직렬화)한다. 이는 통신 채널(시그널)을 통해 보낼 수 있는 형태로 데이터를 가공하는 과정이다.</li>
      <li><strong>서버 (수신자)</strong>: <code class="language-plaintext highlighter-rouge">sigaction</code>을 통해 등록된 핸들러 함수는 비동기적으로 도착하는 시그널들을 수신한다. 이 핸들러는 <code class="language-plaintext highlighter-rouge">char_byte = (char_byte &lt;&lt; 1) | bit;</code> 코드를 통해 흩어져서 도착한 비트들을 다시 8비트의 문자(char)로 조립(역직렬화)한다. 이는 외부의 비동기적 이벤트를 처리하는 <strong>이벤트 기반 프로그래밍(Event-driven programming)</strong>의 핵심 모델을 직접 구현하는 경험이었다.</li>
    </ul>
  </li>
  <li><strong>흐름 제어 (Flow Control) - 동기화</strong>: 만약 클라이언트가 일방적으로 시그널을 폭주시키면 서버는 이를 모두 처리하지 못하고 유실된다. 이를 막기 위해 <strong>핸드셰이크(Handshake)</strong> 기반의 동기화 프로토콜을 도입해야 했다.
    <ul>
      <li>클라이언트는 1비트를 보낸 후 <code class="language-plaintext highlighter-rouge">pause()</code>로 응답을 기다린다.</li>
      <li>서버는 1비트를 성공적으로 처리한 후, <code class="language-plaintext highlighter-rouge">kill</code>을 통해 클라이언트에게 <strong>ACK(Acknowledgement)</strong> 신호를 보낸다.</li>
      <li>ACK 신호를 받은 클라이언트는 비로소 다음 비트를 보낸다.</li>
      <li>이 ‘보내고-받고-확인하는’ 과정은 신뢰성 있는 통신의 대명사인 TCP 프로토콜의 흐름 제어 원리와 정확히 같다. 이러한 구성은 가장 원시적인 재료로 현대적인 통신 프로토콜의 핵심 개념을 재창조한 것이다.</li>
    </ul>
  </li>
</ol>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">Minitalk</code>를 한마디로 정리한다면 운영체제와의 깊은 교감을 통해 통신의 본질을 탐구하게 한 과제였다.</p>

<ul>
  <li><strong>프로토콜 설계의 본질</strong>: 통신은 단순한 데이터 전송이 아니라, 양측이 동의한 엄격한 ‘규칙의 집합’ 위에서 이루어진다. 주소 지정, 데이터 표현, 순서 보장, 오류 제어 등 모든 현대 네트워크 프로토콜에 담긴 철학을 가장 단순한 형태로 압축해서 경험할 수 있었다. 당연히 이러한 통신을 이해하고 난 뒤, <code class="language-plaintext highlighter-rouge">우아한 종료(graceful termination)</code> 의 개념을 이해할 수 있었으며, 이는 이후 프로젝트, 회사에서의 업무에서도 서버 작업에서도 아주 톡톡히 효과를 해주었다.</li>
  <li><strong>비동기 프로그래밍의 이해</strong>: 프로그램의 흐름이 나의 코드가 아닌 외부의 이벤트(시그널)에 의해 결정되는 이벤트 기반의 작업, 아주 원시적이지만 맛보기를 하고 직접 다루어 볼 수 있었다.</li>
  <li><strong>추상화에 대한 감사</strong>: 매일 당연하게 사용하던 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 소켓 통신이 얼마나 많은 복잡성을 감추고 우리에게 편리함을 제공하는지, 가장 낮은 수준의 통신을 구현해보고 나서야 비로소 실감하게 되었다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[📢 Minitalk : 신호(Signal)로 쌓아 올린 통신의 규약(Protocol)]]></summary></entry></feed>