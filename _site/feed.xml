<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-10-09T14:52:03+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">Ubuntu 서버 설정 할 때 snap 사용 시 주의해야하는 이유는?</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue.html" rel="alternate" type="text/html" title="Ubuntu 서버 설정 할 때 snap 사용 시 주의해야하는 이유는?" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue.html"><![CDATA[<h2 id="ubuntu에서-docker를-sudo-없이-사용하려다-발견한-snap-설치의-함정">Ubuntu에서 Docker를 sudo 없이 사용하려다 발견한 snap 설치의 함정</h2>

<h3 id="문제-상황">문제 상황</h3>

<p>Project 를 위하여 Ubuntu 서버 머신을 한대 구했다. Geekom의 A5 7530U 칩셋 탑재 제품으로 윈도우 데스크탑은 나쁘지 않으나, 전성비나, 항시 켜놓고 사용 하기 위함, WSL의 번거로움 등을 고려할 때, 온전한 리눅스 전용 머신의 필요성으로 미니 PC 를 한대 구매했다.</p>

<p>Ubuntu 22.04 LTS 기반으로 설치 후, 개발환경 설정, 컨테이너 활용을 위해 Docker 설정까지 끝냈었다. 그리하여 Docker 명령어를 실행할 때마다 <code class="language-plaintext highlighter-rouge">sudo</code>를 입력하는 것이 번거로워, 일반 사용자 계정을 docker 그룹에 추가하려고 했다. 그런데 예상치 못한 문제들이 연쇄적으로 발생했는데…</p>

<h3 id="발견한-문제들">발견한 문제들</h3>

<h4 id="1-docker-그룹이-존재하지-않음">1. docker 그룹이 존재하지 않음</h4>

<p>일반적으로 Docker를 설치하면 자동으로 생성되는 <code class="language-plaintext highlighter-rouge">docker</code> 그룹이 시스템에 존재하지 않았다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/group | <span class="nb">grep </span>docker
<span class="c"># 결과: 아무것도 출력되지 않음</span>
</code></pre></div></div>

<h4 id="2-systemctl로-docker-서비스를-찾을-수-없음">2. systemctl로 Docker 서비스를 찾을 수 없음</h4>

<p>Docker가 분명 설치되어 있고 실행도 되는데, <code class="language-plaintext highlighter-rouge">systemctl status docker</code> 명령이 작동하지 않았다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
<span class="c"># Docker version 24.x.x 등 정상 출력</span>

systemctl status docker
<span class="c"># Unit docker.service could not be found.</span>
</code></pre></div></div>

<h4 id="3-원인-snap으로-설치된-docker">3. 원인: snap으로 설치된 Docker</h4>

<p>Docker 그룹이 설정이 안되는 경우는 공식 가이드 문서에서 볼 때 수동 설치만 해주면 되는 것이었다. <a href="https://docs.docker.com/engine/install/linux-postinstall/">링크</a>
단, 다른 문제들에 대해서는 찾아본 결과 snap 패키지였던 것이 문제의 근본 원인이었다. (이번엔 편한게 해보겠다고 스토어로 GUI 로 설치했더니만…)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snap list | <span class="nb">grep </span>docker
<span class="c"># docker    xx.x.x    xxxx    latest/stable    canonical    -</span>
</code></pre></div></div>

<h3 id="snap-vs-apt-무엇이-다른가">snap vs apt: 무엇이 다른가?</h3>

<h4 id="snap의-특징">snap의 특징</h4>

<p>snap은 Ubuntu에서 개발한 독립적인 패키지 시스템으로, 다음과 같은 특징이 있다:</p>

<ul>
  <li><strong>완전한 격리(confinement)</strong>: 앱을 샌드박스 환경에서 실행</li>
  <li><strong>자체 포함(self-contained)</strong>: 모든 의존성을 패키지 내부에 포함</li>
  <li><strong>보안 우선</strong>: 시스템 리소스 접근이 제한적</li>
  <li><strong>자동 업데이트</strong>: 백그라운드에서 자동으로 업데이트</li>
</ul>

<h4 id="apt의-특징">apt의 특징</h4>

<p>전통적인 패키지 관리 시스템으로:</p>

<ul>
  <li><strong>시스템 통합</strong>: 시스템 라이브러리를 직접 공유</li>
  <li><strong>완전한 접근</strong>: 시스템 리소스에 제약 없이 접근</li>
  <li><strong>가벼움</strong>: 공유 라이브러리 사용으로 용량 절약</li>
  <li><strong>수동 관리</strong>: 사용자가 직접 업데이트 제어</li>
</ul>

<hr />
<h4 id="docker에는-왜-apt가-적합한가">Docker에는 왜 apt가 적합한가?</h4>

<p>결과적으로 차이점을 고려해본 결과  Docker는 시스템 레벨에서 동작하는 도구이므로:</p>

<ul>
  <li>호스트 파일시스템에 광범위하게 접근 필요</li>
  <li>네트워크, 프로세스, 저장소 등 시스템 리소스 제어 필요</li>
  <li>snap의 격리 정책이 오히려 제약으로 작용</li>
</ul>

<p>일반 사용자에게는 snap이 편리하고 안전하지만, <strong>서버 개발 도구로는 apt 방식이 훨씬 적합하다는 결론을 내릴 수 있었다</strong>.</p>

<h3 id="해결-방법-snap-제거-후-apt로-재설치">해결 방법: snap 제거 후 apt로 재설치</h3>

<h4 id="1-기존-snap-docker-제거">1. 기존 snap Docker 제거</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>snap remove docker
</code></pre></div></div>

<h4 id="2-기존-apt-docker-패키지-제거-있을-경우-대비">2. 기존 apt Docker 패키지 제거 (있을 경우 대비)</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt remove docker docker-engine docker.io containerd runc
</code></pre></div></div>

<h4 id="3-docker-공식-저장소에서-설치">3. Docker 공식 저장소에서 설치</h4>

<p><strong>필수 패키지 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> ca-certificates curl gnupg lsb-release
</code></pre></div></div>

<p><strong>Docker 공식 GPG 키 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo install</span> <span class="nt">-m</span> 0755 <span class="nt">-d</span> /etc/apt/keyrings
curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/docker.gpg
<span class="nb">sudo chmod </span>a+r /etc/apt/keyrings/docker.gpg
</code></pre></div></div>

<p><strong>Docker 저장소 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="se">\</span>
  <span class="s2">"deb [arch=</span><span class="si">$(</span>dpkg <span class="nt">--print-architecture</span><span class="si">)</span><span class="s2"> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu </span><span class="se">\</span><span class="s2">
  </span><span class="si">$(</span>lsb_release <span class="nt">-cs</span><span class="si">)</span><span class="s2"> stable"</span> | <span class="nb">sudo tee</span> /etc/apt/sources.list.d/docker.list <span class="o">&gt;</span> /dev/null
</code></pre></div></div>

<p><strong>Docker 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre></div></div>

<h4 id="4-일반-사용자로-docker-사용-설정">4. 일반 사용자로 Docker 사용 설정</h4>

<p><strong>docker 그룹에 사용자 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>usermod <span class="nt">-aG</span> docker <span class="nv">$USER</span>
</code></pre></div></div>

<p><strong>변경사항 적용:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newgrp docker
<span class="c"># 또는 로그아웃 후 재로그인</span>
</code></pre></div></div>

<p><strong>설치 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
docker run hello-world
</code></pre></div></div>

<h3 id="주의사항">주의사항</h3>

<h4 id="보안-고려사항">보안 고려사항</h4>

<p>docker 그룹에 속한 사용자는 <strong>root 권한과 동등한 접근</strong>이 가능하다. 이는 다음을 의미한다:</p>

<ul>
  <li>컨테이너를 통해 호스트 시스템의 모든 파일에 접근 가능</li>
  <li>권한 상승(privilege escalation) 위험 존재</li>
  <li>보안이 중요한 환경에서는 신중히 고려 필요</li>
</ul>

<h4 id="데이터-백업">데이터 백업</h4>

<p>snap에서 apt로 전환 시 기존 데이터가 삭제된다:</p>

<ul>
  <li>snap Docker 컨테이너 및 이미지: 모두 삭제됨</li>
  <li>볼륨 데이터 경로: <code class="language-plaintext highlighter-rouge">/var/snap/docker/</code>에서 <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>로 변경</li>
  <li>중요한 데이터가 있다면 사전에 <code class="language-plaintext highlighter-rouge">docker save</code>, <code class="language-plaintext highlighter-rouge">docker export</code> 등으로 백업 필요</li>
</ul>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://docs.docker.com/engine/install/linux-postinstall/">Docker 공식 문서 - Linux 설치 후 설정</a></li>
  <li><a href="https://docs.docker.com/engine/install/ubuntu/">Docker 공식 문서 - Ubuntu 설치</a></li>
  <li><a href="https://docs.docker.com/engine/security/rootless/">Docker 공식 문서 - Rootless 모드</a></li>
</ul>

<h3 id="결론">결론</h3>

<p>GUI를 통한 편리한 설치가 항상 최선은 아니네 싶다. 특히 개발 도구의 경우, 패키지 관리 방식에 따라 동작 방식과 시스템 통합 수준이 크게 달라진다. Docker처럼 시스템 레벨 접근이 필요한 도구는 snap보다 전통적인 apt 방식이 더 적합하며, 이를 통해 불필요한 제약 없이, 최적화된 개발 환경을 구축할 수 있다.</p>

<p>물론 일반 사용에선 전혀 그렇지 않다고 생각도 든다. 왜냐면 리눅스 시스템의 라이브러리의 의존성 문제로 업데이트를 잘못하면 큰일나는 경우를 몇 번 경험했고(…) 무지성하게 구글에서 명령어 긁어다가, install 박아버리는 순간 지옥이 펼쳐지는 경우를 생각한다면(…). 의존성을 확실하게 관리하고 마치 Docker 처럼 정확하게 컨테이너화 시키는게 확실히 이유가 있어 보였다. 이러한 지점에서 Ubuntu 가 일반 소비자용의 철학을 가진 OS 라는 점을, 새삼 느끼게 만든다. (근데 프로세스까지 독립적으로 관리하게 하는 건 좀…)</p>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="DevOps" /><category term="Docker" /><category term="Linux" /><summary type="html"><![CDATA[Ubuntu에서 Docker를 sudo 없이 사용하려다 발견한 snap 설치의 함정]]></summary></entry><entry><title type="html">Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html" rel="alternate" type="text/html" title="Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html"><![CDATA[<h2 id="obsidian--copilot---나만의-글쓰기-agent를-만들어보자">Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자</h2>
<h3 id="글쓰기의-길은-멀고도-험하다">글쓰기의 길은 멀고도 험하다</h3>

<p>기술 블로그를 써라.</p>

<p>프로젝트의 후기나, 느낀 점. 기술의 효용성이나 고민한 과정을 써라</p>

<p>개발자로 살아가는 이상, 노하우, 기술에 대한 이해를 표현하는 것이 프로그램의 ‘질’ 또는 ‘실력’을 결정한다는 개발 분야의 공통의 법칙은 언제나 우릴 괴롭힌다.</p>

<p>이에 끊임없이 글을 적어둬야 한다는 고통과 노이로제에 시달린다.</p>

<p>나 역시 글쓰기를 완전 잘한다거나 글을 뽑아내는 기계도 아니다. 그나마 글을 쓰는걸 좋아하는 편이라지만, 그럼에도 해야할 일 산더미인데, 언제 적냐.. 라는 말이 매번 튀어나온다. 글쓰기가 가장 시간을 많이 쓴다는 사실은 달라지지 않는다.</p>

<p>그러다가 최소 2-3주 걸릴 만한 미니 프로젝트, Obsidian + Copilot + gemini 의 에이전트 만들기를 진행해 보았다. 그리고 그걸 적용한 이 글. 이 글을 단 3일 만에 마무리 되었다면 믿겠는가?</p>

<p>AI를 활용해서 글을 대신 파바박, 하루 만에 뚝딱 하고 써주진 않지만… 그럼에도 이번 미니 프로젝트를 통해, 글쓰기, 학습에서 정말 도움이 되는 Agent 생성에 도전 그리고 나름의 결과를 만들어냈다.</p>

<p><strong>개인적으로 풀어내는 이 후기, 함께 적용 해본다면, 정말 괜찮게, 도움이 되는 글쓰기 보조 에이전트를 만들 수 있지 않을까?</strong> 조심스레 이야기를 시작해보고자 한다.</p>

<h2 id="본론">본론</h2>

<h3 id="시작은-obsidian-그리고-copilot">시작은 Obsidian 그리고 Copilot</h3>
<p>Notion 은 많이들 쓸 것이다. 언제 어디서든, 그리고 어떤 장비든 웹 기반의 Notion은 데이터를 저장하기에 적절하다고 생각하는 이들이 많다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-003.png" alt="" /></p>

<p>하지만 한때 이를 진지하게 써본 입장에서, Obsidian을 주력 정보 저장, 글쓰기 도구로 쓰게되었다. 이유는 다음과 같다.</p>

<ol>
  <li>Notion 업데이트 시 잔버그가 수시로 발생하는데, 데이터 영역까지 함께 문제가 되는 경우가 발생함.(데이터 삭제도 발생한다.)</li>
  <li>한글 유저는 영어보다 특히나 버그 발생률이 높다</li>
  <li>문서 양이 많아지면, 유료 계정임에도 검색 문제, 버벅거림 문제가 발생한다</li>
</ol>

<p>요즘은 많이 나아졌다고 하지만, 한 번쯤 API 문서 같은거 만들어두었다가 날려먹어보면, Notion은 쳐다보지도 않게 된다. 그냥 포트폴리오 를 위한 간단 공유용 정도면 모를까.</p>

<p>Obsidian은 가벼우며, 검색, 태깅 등 기본적인 기능이 강력하다. 특히나 퍼포먼스가 매우 훌륭하다. 플러그인도 제공하기 때문에, 이를 활용하면 Notion 그 이상의 확장성, 사용성, 글쓰는 데 편리함을 제공해준다. 그리고 운명 같은 날이 찾아왔으니… 바로 <code class="language-plaintext highlighter-rouge">Copilot</code> 이란 플러그인을 발견했을 때였다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-004.png" alt="" /></p>

<p>코파일럿. 누가보면 윈도우에서 만든 AI 인줄알 것 같다. 이 플러그인은 단어 의미대로의 윈도우의 AI와는 별도의 플러그인이다. 당당하게 유료 결제 버전도 존재하는데, 그에 대해선 나중에 이야기 하려고 하고, 지금은 이 녀석이 뭔가에 대해 설명해주려고 한다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-005.png" alt="" /></p>

<h3 id="ai-좀더-통합-좀더-효율적이게-분신-만들기">AI, 좀더 통합, 좀더 효율적이게.. 분신 만들기?</h3>

<p>AI 가 말 하나는 기똥차게 하고, 이미 VSC 나 각종 IDE 는 통합이 이루어졌다. 그런데 이 Copilot 은 글쓰기 도구인 Obsidian을 그렇게 만들어주는 프로그램이다. 설치 방법은 간단하다. 로컬 LLM 이나, api 키를 활용해 연결이 된다. 만약 API 발급이 궁금하면 하단의 글을 참고하면 좋다.</p>

<p>연결하고, 사용을 해보니 순간 머릿속에 스치는 게 있었다.</p>

<blockquote>
  <p>“이 정도 통합이면… 나 대신 글쓰기 해줄 수 있지 않을까?”</p>
</blockquote>

<p>본론으로 돌아와서 글쓰기. 생각해보면 학습, 개발을 하다보면 글쓸 자료는 넘쳐났다. 지금까지는 gemini + 기타 다른 ai  이런 식으로 하여 사용도 해보았고. gemini 의 세부 기능을 활용한다거나 gemini-cli 라는 프로그램으로 내 맥북 내부에서 llm 을 구동해 자료를 취합, 글을 써보기도 해보았다.</p>

<p>하지만 이런 방식이  대중화되거나 입소문을 많이 타진 않았다. 왜그런가? 우선, 다양한 자료, 글감은 여기저기 흩뿌려져 있는 경우가 있다. 설치도 복잡하고, 오류도 있다. 뿐만 아니라, 정리를 해서 어딘가에 모아서 글감들을 정리해도,  ‘나답게’, ‘내 냄새’ 가 나는 글로 만들 수 있냐! 라고 하면 그렇지 않기 때문에, 실상 내가 알고 있는 것들을 모아서 글을 쓰는 것과 큰 차이가 없는 것이다.</p>

<p>그러는 와중에 Copilot 의 기능으로 <code class="language-plaintext highlighter-rouge">Command</code>라는 기능을 발견하였다. 단순히 LLM 을 연결만 해주는게 아니라, 직접 명령을 적어서 매크로처럼 쓸 수 있는데, 심지어 프롬프트로 전역 설정하는 것들도 있는 것이 아닌가?</p>

<p><strong>그리고 아까 전 상황. 그렇다. 이정도면 나의 문체를 그대로 문서화, 프롬프트화 시켜서 등록을 해두면, ‘딸깍’ 하고 글을 써줄수 있지 않을까? 이 생각에 무릎을 탁친 나는 도전을 해보기로 하였다.</strong></p>

<h4 id="나를-분석해보자-how">나를 분석해보자 How?</h4>

<p>우선, 첫 시작은 나를 분석하는 것이다. 내가 누굴까? 글로 표현되는 나를 AI 가 모방하는게 우선이라고 생각했다. 나는 가능하면 나의 주관적 판단이 들어가는 것은 좋지 않다고 생각했다. 나의 주관은 나에 대한 여러 측면에 대해 ‘과소평가’ 와 ‘과대평가’가 함께 공존하고 있다고 생각하기 때문이다. 그러니 나에 대한 긍정 평가도 부정 평가도 아닌 어딘가의 제 3자 관점에서 분석을 하는 것이 가장 적절하다고 생각했다.</p>

<p>그런데 이제는 간단하다. 내가 쓴 글들을 다 가져와서 분석을 시키던가, 내 블로그에 AI 가 알아서 분석해라고 하는게 가능하다. 오히려 도구를 뭘 쓸지만 고민하면 되었다.  이에 Claude 와 Gemini 의 <code class="language-plaintext highlighter-rouge">deep research</code> 기능으로, 나의 글, 나의 문체에 대한 분석을 각각 요청했다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-006.png" alt="" />
<img src="/assets/images/posts/2025-10/2025-10-09-007.png" alt="" /></p>

<blockquote>
  <p>💡 핵심은 자신에 대한 분석을 준비하는 것이다. 방법의 제약은 없다. AI 를 활용해, 자신을 표현하는 자료들을 최대한 보여주면서 분석을 요청해라.</p>
</blockquote>

<h4 id="나의-분신을-등록해보았다">나의 분신을 등록해보았다.</h4>

<p>음~ 나의 계획은 완벽해! 이런 착각을 하며 Claude 와 Gemini 는 열심히 생각을, GPU가 녹고 있음을 느끼고 있었다. 이제 내가 퇴고만 해주면 되는게 아닌가! 새삼 AI 의 능력은 믿어 의심치 않고 있었고, 개발까지 가지 않아도 해결 될 수 있다는 이 행복한 시대를 살고 있음에 하늘을 향해 감사인사를 하면서, 기다렸다.</p>

<p>10분이 채 안되어, 결론은 순식간에 나왔고, 그 결과가 다음과 같았다.</p>

<pre><code class="language-plain"># gemini의 정확한 모사 버전
### Persona
당신은 '성실한 기술 기록자(Diligent Technical Archivist)'입니다. 당신의 주된 목표는 커리어 발전을 위해 스스로 학습한 기술 내용을 미래의 자신이 다시 참고할 수 있도록 정확하고 체계적으로 기록하는 것입니다. 당신의 글은 타인을 가르치기 위한 것이 아니라, 스스로의 이해를 완성하고 검증하기 위한 학습 과정의 산물입니다.

### Core Philosophy
모든 내용은 '촘촘한 학습'과 '치밀한 정리'라는 핵심 철학을 따라야 합니다. 피상적인 요약 대신, 공식 문서나 신뢰할 수 있는 자료를 기반으로 한 깊이 있고 상세한 내용을 우선시합니다. 정확성과 완전성이 가장 중요한 가치이며, 모든 기술적 설명은 검증 가능해야 합니다.

### Voice and Tone
- **어조**: 체계적이고, 객관적이며, 사실에 기반한 약간의 격식체를 사용합니다.
- **감정 배제**: 과장, 유머, 지나치게 친근한 말투는 피합니다.
- **목적 명시**: 글의 목적이 학습과 기록임을 명확히 하되, 독자를 가르치려는 듯한 계몽적인 어조는 사용하지 않습니다.

### Content Generation Modes
당신은 아래 두 가지 모드 중 하나로 콘텐츠를 생성해야 합니다. 각 모드는 목적과 형식 면에서 명확히 구분됩니다.

#### Mode 1: 심층 탐구 학습 로그 (Deep Dive Study Log)
- **목적**: Kubernetes, Docker, CS 기초 등 근본적이고 방대한 주제를 체계적으로 학습하고 정리합니다.
- **형식**:
    - 예상 읽기 시간 15~30분 분량의 긴 글을 작성합니다.
    - 공식 문서를 번역하거나 핵심 내용을 재구성하는 방식으로 정보를 전달합니다.
    - 복잡한 시스템을 구성 요소별로 나누어 상세히 설명합니다.
    - 제목은 '[기술명] - [세부 주제]' 형식을 따릅니다.
    - 논리적 흐름에 따라 명확한 소제목으로 내용을 구조화합니다.

#### Mode 2: 기술 메모 (Technical Memo)
- **목적**: 특정 도구 사용법, 문제 해결 과정, 설정 방법 등 구체적이고 실용적인 정보를 빠르게 기록합니다.
- **형식**:
    - 예상 읽기 시간 2~5분 분량의 짧고 간결한 글을 작성합니다.
    - '문제 상황 -&gt; 해결 과정 -&gt; 결과'의 구조를 명확히 합니다.
    - 필요한 경우 코드 스니펫, 설정 파일, 명령어 등을 정확히 포함합니다.
    - 제목은 'memo - [문제 또는 주제]'와 같이 직관적으로 작성합니다.

### Formatting and Structure
- **제목**: 기능적이고 내용을 명확히 설명하는 제목을 사용합니다.
- **마크다운**: 헤딩(##, ###), 목록(리스트), 코드 블록을 적극적으로 사용하여 가독성을 높입니다.
- **용어 사용**: 기술 용어는 한국어와 영어를 자연스럽게 혼용합니다. (예: 쿠버네티스 컨트롤 플레인(Control Plane))

### Task
이제 위의 모든 규칙을 준수하여 다음 요청을 수행해 주십시오:
[여기에 구체적인 콘텐츠 생성 요청 입력]
</code></pre>

<pre><code class="language-plain"># claude의 정확한 모사 버전
Paul2021-R 스타일로 글을 작성해주세요:

[문체 지침]
- 삼박자 수식어구로 리듬감 조성 (예: "종합적으로, 효율적으로, 효과적으로")
- 격식체 기본 + "...!" 감탄부호로 친근함 표현
- 영어 기술용어와 한국어 개념어 자연스럽게 혼용
- 불렛포인트와 계층적 구조로 체계적 정보 정리

[어조와 관점]
- 겸손하면서도 전문적인 태도 유지
- 솔직한 자기성찰과 현실적 사고
- 비전공자/학습자 관점에서의 공감과 조언
- 과정 중심적 서술 (결과보다는 시행착오 과정 중시)

[표현 스타일]
- 구체적 수치와 날짜로 생생함 표현
- 게임/레벨링 비유로 성장 과정 설명
- "하루 하루", "항상 고민하고, 궁금해하며" 같은 반복 패턴
- 실패 인정 후 교훈 도출하는 구조
</code></pre>

<p>내용은 읽으면 읽을수록 찰떡 같았다. 다소의 차이점은 Gemini의 경우 철학, 그리고 Mode 라는 식으로 내 글의 종류에 따라 다르게 접근하는 방법을 포함하여 프롬프트를 만들어주었다.</p>

<p>Claude 는 좀더 중립적이지만, 글의 형태를 따라하는 스타일 가이드 형태로 만들어준 것이 눈에 들어왔다. 그렇게 만들어진 내용들은 서로 특징은 다르지만 분명하게 ‘나’를 담고 있었다.</p>

<p>그렇게 생각하고 보니 하는 김에 이왕이면 글을 좀더 보완한다면 어떻게 하면 좋을까? 라는 생각도 들었다.  그렇기에 내 글의 아쉬운 점을 보완하는 프롬프트까지 만들어달라고 하였다.</p>

<pre><code class="language-plain"># gemini - 문체 개선 요청 버전 
### Persona
당신은 '전문가 멘토이자 성실한 기술 기록자(Expert Mentor and Diligent Archivist)'입니다. 당신은 자신의 심도 깊은 학습 과정을 기록함과 동시에, 당신과 비슷한 길을 걷는 다른 엔지니어들에게 의도적으로 명확하고 유용한 가이드를 제공합니다. 당신의 글은 개인적인 기록이자, 가치 있는 공유 자산입니다.

### Audience Awareness
당신의 글을 읽는 독자는 당신과 같이 똑똑한 엔지니어이지만, 당신과 동일한 사전 지식이나 맥락을 가지고 있지 않을 수 있다고 가정하십시오. 따라서 '무엇(what)'을 설명하기 전에 항상 '왜(why)'를 먼저 설명하여 동기를 부여하고 이해를 도와야 합니다.

### Core Philosophy
'촘촘한 학습'과 '치밀한 정리'의 원칙을 지키되, 이를 '명확한 전달'이라는 가치와 결합합니다. 기술적 정확성과 깊이를 유지하면서도, 독자가 개념을 직관적으로 이해할 수 있도록 돕는 것이 중요합니다.

### Narrative and Contextual Framing
모든 게시물은 반드시 다음 세 가지 구조적 요소를 포함해야 합니다.
1.  **도입부 - 맥락 설정 (Opening Context)**: 글의 시작 부분에 이 주제를 왜 지금 다루는지, 이것이 당신의 학습 여정에서 어떤 위치에 있는지를 1~2 문단으로 설명합니다.
2.  **본문 - 기술적 설명**: 핵심 기술 내용을 정확하고 상세하게 설명합니다.
3.  **결론부 - 개인적 종합 (Closing Synthesis)**: 글을 마무리하며, 이번 학습을 통해 얻은 핵심적인 깨달음, 다른 기술과의 연결점, 또는 개인적인 관점을 요약하여 제시합니다.

### Engagement and Readability Elements
콘텐츠 생성 시, 다음 요소들을 능동적으로 통합하여 가독성과 몰입도를 높여야 합니다.
- **비유 (Analogies)**: 복잡하고 추상적인 개념을 설명할 때, 독자의 직관적인 이해를 돕기 위한 적절한 비유를 포함시키십시오.
- **핵심 요약 (Key Takeaway)**: 각 중요 섹션이 끝나거나 글 전체의 마지막에, 핵심 내용을 강조하는 인용문(blockquote) 형식의 요약 박스를 추가하십시오.
- **질문형 소제목 (Interrogative Subheadings)**: "Service의 종류"와 같은 서술형 제목 대신, "쿠버네티스 Service에는 어떤 종류가 있으며, 각각은 언제 사용해야 하는가?"와 같은 질문형 제목을 사용하여 독자의 탐구심을 자극하십시오.

### Formatting and Structure
- **제목**: 기능적이면서도 독자의 흥미를 끌 수 있는 제목을 사용합니다.
- **마크다운**: 헤딩, 목록, 코드 블록, 인용문을 효과적으로 사용하여 시각적 계층 구조와 가독성을 극대화합니다.
- **용어 사용**: 기술 용어는 한국어와 영어를 자연스럽게 혼용합니다.

### Task
이제 위의 모든 규칙을 준수하여 다음 요청을 수행해 주십시오:
[여기에 구체적인 콘텐츠 생성 요청 입력]
</code></pre>

<pre><code class="language-plain"># claude - 문체 개선 요청 버전
Paul2021-R 스타일로 글을 작성해주세요:

[문체 지침]
- 삼박자 수식어구로 리듬감 조성 (예: "종합적으로, 효율적으로, 효과적으로")
- 격식체 기본 + "...!" 감탄부호로 친근함 표현
- 영어 기술용어와 한국어 개념어 자연스럽게 혼용
- 불렛포인트와 계층적 구조로 체계적 정보 정리

[어조와 관점]
- 겸손하면서도 전문적인 태도 유지
- 솔직한 자기성찰과 현실적 사고
- 비전공자/학습자 관점에서의 공감과 조언
- 과정 중심적 서술 (결과보다는 시행착오 과정 중시)

[표현 스타일]
- 구체적 수치와 날짜로 생생함 표현
- 게임/레벨링 비유로 성장 과정 설명
- "하루 하루", "항상 고민하고, 궁금해하며" 같은 반복 패턴
- 실패 인정 후 교훈 도출하는 구조
</code></pre>

<p>마지막으로 Gemini 와 Claude가 서로 다른 시각. 다른 형태의 프롬프트이니, 이걸 합치면 서로 부족한 부분을 보완하고, 완벽해지지 않을까? 아까 전에 언급했던 제 3의 관점의 완전체가 이것이라 생각했다. 화룡점정.</p>

<p>예전부터 gemini, 구글의 모델은 서비스 차원에서 과도한 긍정성, 아첨이 문제시 되기도 했는데, 그러니 서로 다른 관점을 엮거나 합친다면 얼마나 좋을까? 두 모델의 차이를 포함하여 온전한 프롬프트, 강력한 프롬프트를 상상했다. 머릿속에선 이미 나를 대신할 새로운 분신 1호의 탄생에 종이 울리고 있었다. 결과물을 만들 때였다.</p>

<h3 id="context-engineering">Context Engineering</h3>
<h4 id="-뭔가-이상하다--결과물의-상태가-">🤔 뭔가 이상하다 : 결과물의 상태가 ?</h4>

<p>나는 눈을 의심했다. 정리하고, 프롬프트를 등록하고, 데모 글을 작성해보기 위해 자료를 준비했다. 자동화 이전, 상당한 공을 드렸음에도 결과적으로 AI 가 뽑아낸 글은 뭔가 이상하다고 느꼈다.</p>

<p>분명히 나를 분석한 프롬프트고, 심지어 복합적인 시각을 녹이고자 AI 두개의, 다른 시각을 합쳐 만든 완벽한 프롬프트였다. 나를 정확하게 표현한 버전, 내 개선 포인트를 추가로 담은 버전… 온갖 노력을 다 했는데 너무 아쉬운 글들 뿐이지 않은가?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-008.png" alt="" /></p>

<p>글의 퀄리티는 내가 예상했던 수준에 미치지 못하는게 보였다. 이젠 에러 분석이 필요한 시점이었다. 내가 준비한 프롬프트는 다음과 같은 종류로 구성 되어 있었다.</p>

<blockquote>
  <ul>
    <li>Gemini 분석의 저자의 문체를 복사한 ‘정확도’ 버전</li>
    <li>Gemini 분석의 저자의 문체에서 개선사항을 포함한 ‘개선’ 버전</li>
    <li>Claude 분석의 저자의 문체를 복사한 ‘정확도’ 버전</li>
    <li>Claude 분석의 문체에서 개선사항을 포함한 ‘개선’ 버전</li>
  </ul>
</blockquote>

<p>이 버전들을 그냥 쓴게 아니라 언급한 바 Gemini 와 Claude 에게 다시 양측 자료를 제공해주면서, 합쳐진 최종 버전을 만들라고 했었다. 즉 최종 프롬프트는 다음과 같다.</p>

<ol>
  <li>Gemini 정확도 버전 + Claude 정확도 버전 =&gt; Gemini, Claude 각각 합치기를 요청
    <ul>
      <li>Gemini 정확도 버전</li>
      <li>Claude 정확도 버전</li>
    </ul>
  </li>
  <li>Gemini 개선 버전 + Claude 개선 버전 =&gt; Gemini, Claude 각각 합치기를 요청
    <ul>
      <li>Gemini 개선 버전</li>
      <li>Claude 개선 버전</li>
    </ul>
  </li>
</ol>

<p>이렇게하여 나름 통합적 사고가 가능한 프롬프트가 되었으리라 생각했다. 서로의 분석의 빈틈을 매꿔주리라 생각했던 것이다. 하지만…</p>

<p>gemini 정확도 버전의 프롬프트의 글들의 구성은 간소했다. 요구사항은 잘 따른 편이었으나, 정작 문단 구조가 길고, 줄 글이 되어서 가독성이 좋지 못했다. 단순히 나를 모방했다고 하기엔 특징이 너무 부족한 무미 건조한 글이 되어 있었다.</p>

<p>claude 정확도 버전은 인트로에 나의 철학이란 이름으로 42서울, 비전공자 등 굳이 쓸데없는 도입부를 만들어서 글을 작성하였다. 도입부가 굳이 쓸데없는 사족이 없어도 되는데 특정 단어들에 갇혀진 표현 뿐이었다. 학습, 공유, 자기 성장이 목적인 나에게 필요한 글의 구성은 아니었다.</p>

<p>개선버전의 경우엔 다행이도 글 자체의 느낌은 훨씬 좋았다. 그러나 이상하게 AI 개입이 좀더 많고 나의 의도를 넘어선 내용이 있었다. 나의 글의 특성을 모사하진 못한게 보였다. 오히려 AI의 느낌이 강해져버렸다.</p>

<p>정리하면, 선택지는 없었다. 뭔가 문제는 있었으니, 이젠 글이 문제가 아니라 프롬프트를 제대로 까봐야 한다는 판단이 들었다. 그리하여 이번에야말로 프롬프트를 제대로 읽어 보는 순간 납득이 가는 부분이 있었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-009.png" alt="" /></p>

<p>오리지날 원본 프롬프트들까지 준비하여 비교해본 결과, 구체적으로 차이점은 다음과 같았다.</p>

<ol>
  <li>Gemini 건 Claude 건 합치길 요청하여 얻은 결과물들은, 막상 양쪽의 모든 특성을 고려한게 아니라, 일정하게 프롬프트 내역이 빠져 있었다.</li>
  <li>Claude 버전은 공통적으로 기존의 내용에서 상당한 양의 가이드가 사라져 있었고, 스타일 가이드적인 특성이 훨씬 강했던 원본에 비해 Gemini의 철학이나 방향성에 대한 내용이 담겨 있었다.</li>
  <li>Gemini 버전의 경우 원본이 방향성, 철학, 태도 등이 담겨 있었는데, 이러한 부분의 내용이 사라져 있었다. 오히려 스타일 가이드가 일부만 들어가거나, 아예 빠져 있는 경우가 있었다.</li>
</ol>

<p>그리하야… 원본 프롬프트를 다시 써봐야 하겠다 는 생각에 원본 프롬프트로 글을 만들어 내는 것까지 진행해보고 난 뒤, 비로소 나는 결론을 내릴 수 있었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-010.png" alt="" /></p>

<p>내용을 읽어본다면 아마 납득이 갈 것이다. 원본 프롬프트들을 합쳐서 만든 프롬프트와는 달랐다. 오히려 더 나스러운 글을 만들어 낸 것이 보였고, 무엇보다 디테일 적 누락이 많은 부분 해소 되어 있었다. 이유가 무엇인가? 한참을 프롬프트와 결과물을 읽어보니, 이유를 알 수 있었다.</p>

<h4 id="프롬프트는">프롬프트는…</h4>

<h5 id="왜-프롬프트는-자동화가-이상하게-되었단-말인가">왜 프롬프트는 자동화가 이상하게 되었단 말인가?</h5>

<p>나는 두 가지 다른 관점의 프롬프트를 분석하게 해놓았고, 그 분석된 프롬프트를 기반으로 종합시켰을 때 프롬프트의 질이 올라갈 거라고 생각했다. 하지만 이는 ‘착각’이었다.</p>

<p>AI 들은 여러 관점의 합을 만들 때, ‘일반화’되어 버린다. 즉 고유한, 독특한 특징이 될 포인트를 잡는게 아니라, 여러 특징의 점을 찍다보니 결국 각이 많아지다 보면 원형이 되어 버리듯 아주 일반적인 내용화 되는 것이었고, 이런 점은 gemini 를 통해 합성한 프롬프트에서 나타났다. Claude 의 합성의 경우엔 오히려 정보가 손실된 경우도 있었고 말이다.</p>

<p>이러한 현상은 일종의 AI의 ‘정보 손실’의 특성이었다. AI 어텐션 메커니즘(Attention Mechanism) 원리를 생각해보면 보다 확실히 알 수 있다. 입력 정보가 많아질 수록, 중요도가 떨어지는 정보는 요약 과정에서  우선순위 면에서 밀리고, 이 과정이 길어지면 데이터는 누락이 될 수 있었다.</p>

<p>특히나 가장 ‘그럴듯 하게’ 다음 단어를 예측하는게 핵심인 AI 입장에서, 통계적으로 오히려 그럴듯한 결과를 내기 위해선 독특하거나, 독창적인 정보를 담기 보단 ‘일반적인’ 문장의 결과를 생성해내는 것이 오히려 더 프로그램 목적에 부합한다.  그 결과 오히려 모두를 포함하길 원한다는 사람의 요구가 명확히 없다면, 이는 곧 정보 손실, 두 내용의 중간 어딘가의 일반화된 내용을 출력하는 길로 이어지는 것이다.</p>

<h5 id="프롬프트는-바운더리를-생성한다">프롬프트는 바운더리를 생성한다.</h5>

<p>너무 당연하다고 생각할지도 모르겠지만, 이 표현이 의미하는 바는 매우 컸다. 예를 들어 키워드를 명료하게 설정한 프롬프트는 일종의 룰이 되어 버린다. ‘42서울 출신 개발자’ 라는 철학을 넣으니, 도입부에 이 키워드를 어떻게든 넣으려고 했다.</p>

<p>키워드가 되면 족쇄가 되어 호흡, 흐름, 무게감을 어떻게 내가 원하는 밸런스에 맞추는게 아니라, 오히려 프롬프트를 바운더리로 잡고, 억지로 그 내용을 도출시키는데 목적이 있는 듯 보였다. 그리고 이러한 특성이 작용하면, 원하는 글이 아닌, 억지스러운 글이 되는 것이었다.</p>

<p>또 한편으로, 프롬프트가 일부 사라져 구멍이 생겼던 프롬프트는, 오히려 AI 의 개입이 많아지면서 창의적인 면이나, 글이 좀더 입체적으로 보였다. 이렇게 되면 결국 본질적으로 나를 모사한다는 것과는 전혀 무관계한게 아니겠는가?</p>

<p>프롬프트가 아주 중요하고, 민감한 영역이기에, 역할의 지정, 할 일의 지정 차원에서는 의미가 있지만, 거기에 특정 키워드가 마치 배경 지식으로 작동 되면, 프롬프트는 일종의 저주같이 되어, 원하는 요구사항을 들어주지 못하는 경우가 발생할 수 있는 것이었다.</p>

<h5 id="전-과정을-맡기는-구조는-한계가-명확하다">전 과정을 맡기는 구조는 한계가 명확하다.</h5>

<p>이후에도 여러번의 테스트를 해보았다. 하지만 결정적으로 ‘한 방에 딸깍’ 이라는 말이 어울리는 느낌의 알아서 잘, 딱 맞는 작업을 해준다? 그건 꿈이었다.</p>

<p>전 프로세스를 세분화 하지 않고, 프롬프트로 무언갈 써내려가게 되면, 위의 1번의 이야기가 펼쳐지는데, 그렇다고 여기서 정말 내 스타일의 커스터마이징 잘된 글을 만드려면 프롬프트가 방대해져야 한다. 그렇다고 AI에게 모두 맡기면 AI는 빈 공간에 대한 내용을 AI 의 설정으로 채운다. 그러면 또 원하는 결과가 안 나오게 되는 여지가 생기는 것이고…</p>

<p>즉, 근본적으로 꼬리에 꼬리를 무는 문제들이 생기기에 ‘전 공정’을 맡긴다는 방식 자체가 오히려 목표 달성에 문제를 일으키는 것이다.</p>

<h5 id="결론-적으로">결론 적으로….</h5>

<p>결론적으로 내가 얻은 핵심 통찰, 이는 AI 를 통해 내가 원하는 혹은 나 그 자체를 모방하는 글을 써내려가려면, 주기적으로 진행 과정을 검토하거나, 수정하지 않으면 안된다. 완전 자율성을 못 부여하는 것은 아니지만, 이는 프로그래밍의 영역으로 고려해야할 것으로 보였다. 나의 예상과 가설은 아주 빠르게 무너져 내린 것이었다.</p>

<h4 id="빠른-판단--어떻게-해야-ai-가-내-글쓰기에-도움을-줄까">빠른 판단!  어떻게 해야 AI 가 내 글쓰기에 도움을 줄까?</h4>

<p>그러나 시간을 더 들이는 것은 옳지 못하다. 해야할 일이 쌓여 있는데, 현재 가능한 선에서의 효율을 찾는 것은 핵심이리라.</p>

<p>그리하여 지금 상황에서 최선은 뭘까? 하고 고민한 결과가 다음과 같았다.</p>

<ul>
  <li>딸깍 하고 한방에 되는 건 어렵다 =&gt; 오히려 역으로 단계 별로 가속화 시키는게 AI 를 잘 쓸 수 있다.</li>
  <li>프롬프트는 어떻게 해야 가장 베스트일까? =&gt; <code class="language-plaintext highlighter-rouge">Context</code> 와 <code class="language-plaintext highlighter-rouge">Prompt</code>를 나누자!</li>
</ul>

<p><img src="/assets/images/posts/2025-10/2025-10-09-011.png" alt="" /></p>

<p>우선, 프롬프트를 그렇다고 지정하지 않고, 그냥 매번 타이핑 친다는 것은 대단히 힘든 일인건 사실이다. 두고두고 쓰는게 편하지 않겠는가? 그런데 나에게 글이란 건 개발 일지, 정보 공유, 메모 등 엄청나게 다양한 역할, 종류가 
다양하다는 점을 체감했다.</p>

<p>나는 너무 심플하게 생각한 나머지, 글의 종류가 다르고, 프로세스가 다른데 마치 무안단물마냥 ‘줘’ 하면, AI 들이 알아서 내 공유된 개인정보로 알아서 만들어 줄거라는 순진한 생각을 한 것이다.</p>

<p>그러니 Gemini가 제공한 아이디어를 적극 develop 하기로 했다. <code class="language-plaintext highlighter-rouge">Mode</code> 라는 키워드를 추가했다. 메모나 정보의 요약글로 정보저장이 핵심인 글은 1번, 누군가의 공유하는 글, 정보만큼이나 생각과 나름의 사고 과정을 보여주는게 중요한 글은 2번… 이런 식으로 글의 종류를 나누었고, 이를 고려한 프롬프트를 별도로 하여서, 행동의 규정을 명확히 했다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-012.png" alt="" /></p>

<p>두 번째로, 최근 배웠던 단어 중 Context Engineering 이란 키워드가 있었다. 이 말의 의미는 현재는 프롬프트 엔지니어링 보다 AI에게 중요한건 AI 가 달라져도, 학습한 내용이나 설정이 좀 다를 순 있어도, ‘동일한 결과물’을 제공하는 제일 좋은 방법은 ‘Context Engineering’ 이라고 하는 것이다.</p>

<p>요구한 내용에서 할 일, 상황 맥락이 유사하면 결과 값도 유사하게 전달할 수 있다. 예를들어 나라는 존재를 모방한 글쓰기 특징을 갖춘다는 말은, 나의 맥락을 비슷하게 모사하거나, 바탕 정보는 그대로 둔 채로, 들어오는 요청에 따라 조금씩 액션은 달리 해야, 비로소 ‘나’ 스러운 결과가 나오는 것이다.</p>

<p>그러나 프롬프트 마다 일일이 이걸 담아내는 건 효과적이지 못하다. 행동(프롬프트)와 배경(맥락, 컨텍스트)를 분리하고 AI 가 나의 맥락, 글쓰기의 포인트나 특징, 철학에 가까운 사항들은 따로 정리하여 이해한다. 그렇게 모방된 인격 하에 행동을 수행해야 비로소 요구되는 정확한 답변이 가능한 것이다.</p>

<p>이에 <code class="language-plaintext highlighter-rouge">Hansol Persona</code> 란 파일로 만들었고, 마치 전역변수처럼 이 녀석을 추가하고 고려하도록 만들었다. 컨텍스트, 그리고 프롬프트를 분리하고, 아까 언급했듯이 <code class="language-plaintext highlighter-rouge">Mode</code> 라는 개념을 추가했다. 그 결과는 어땠을까?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-013.png" alt="" /></p>

<p>개인적으로 아주 ‘성공적’ 이라고 평가하고 싶다.</p>

<blockquote>
  <p>💡 프롬프트, 컨텍스트 가이드</p>
  <ol>
    <li>Copilot 에 인용할 자신의 Context 문서를 작성하고, 필요 시 해당 문서를 항상 추가해라.</li>
    <li>Command 에 프롬프트에 행당하는 부분만 기재한다. context 의 해당하는 부분은 배제하고, 이는 Persona 문서에 포함한다.</li>
    <li>프롬프트는 구체적인 단어를 기재하는 것은 지양한다. 가능하면 행동 지침으로 최대한 구체화 시켜라.</li>
    <li>내가 자동화 할 목표가 있다면, 그 목표의 ‘과정’을 프롬프트화 시켜라. 글 쓰기의 핵심이 개요 작성 -&gt; 근거 추가 -&gt; 살 붙이기 -&gt; 퇴고 이런 순서라면, 각 단계 별로 필요한 영역에 프롬프트를 별도로 만드는 게 최선이다.</li>
    <li>자신의 프로세스를 검증할 프롬프트, Context 를 준비하는 것도 좋다. =&gt; 이를 통해 제 3자의 검증을 효과적으로 수행해 줄 수 있다.</li>
    <li>마크다운 양식의 헤드, 리스트 등 우선순위를 나타내는 기호를 AI 는 우선순위로 실제 판단한다. 따라서 우선순위를 고려한 프롬프트가 중요하다.</li>
    <li>글의 철학, 가치관도 중요하지만, 스타일 가이드 쪽의 지정의 프롬프트가 훨씬 AI가 완성도 높은 구성을 해낸다. 정량적인 내용을 프롬프트에 담아라.</li>
    <li>AI 의 인격에 대한 부분도 context 로 준비하면 아첨, 과도한 긍정 평가를 최소화 시킬 수 있다. 평가, 분석, 보완 등의 역할을 원할 땐, 그에 따른 AI의 가상 인격을 생성해놓고 제공하자.</li>
  </ol>
</blockquote>

<h3 id="결과물-톺아보기">결과물 톺아보기</h3>

<p>2.5 flash 는 2.5 Pro 대비 이상한 말도 많고, 허술한 답변을 할 때도 많다. 그러나 놀랍게도 컨텍스트 + 모드 + 프롬프트의 테스트 결과는 말도 안될 정도의 퀄리티의 내용을 뽑아주었다. 이미 충분히 블로그 글로 올렸을 때 문제 없지 않을까? 싶은 수준의 완성도 였다.</p>

<p>톤앤 무드는 정돈 되어 있었고, 내 설정들과 함께 전달된 자료들의 의도들을 정확히 재조합하여, 자잘한 분석 결과 문서, 자료들 예시, 몇 문단으로 작성된 결론, 개요를 한번에 종합해주었다. 그것도 단 돈 몇 십원 수준으로 말이다.</p>

<p>특히나 SEO 를 고려한 태그라던지, 예상 제목 제안 사항 등, 단순히 글쓰기를 돕는것 만으로 끝이 아니라, 블로그를 관리하고, 기술적 보조자 역할도 톡톡히 단 한 번의 요청으로 얻어낼 수 있었다.</p>

<p>뿐만 아니라, 위에서 얻은 결론을 기반으로 프롬프트를 추가로 제작. 내 글에 대한 분석, 글의 문제점이나 글에서 논리적 모순 등을 잡아주는 ‘편집장’ 프롬프트도 설정해 보았더니, 놀라울 만큼 명확하고 확실한 평가를 해주었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-014.png" alt="" /></p>

<p>내 글 어디가 아쉽고, 어떤 점이 좋으며, 어떤 점에서 개선이 되면 좋을지. 제 3자 시선에서 평가해주는 프롬프트를 기반으로 나의 글을 세밀하게 분석해주었다. 특히나 너무 과한 내용이나 필요 없는 내용 등을 빠르게 캐치하고 검토해주었다. 가장 놀라운건 이것이 성능이 부족하다고 느껴 거의 쓰지 않던 2.5 flash 에서 가능하다는 점이다!</p>

<h3 id="pro-vs-flash">Pro vs Flash</h3>

<p>놀라움. 만족스러움을 느끼기도 잠시. 2.5 flash를 왜 사용했는가? 에서 시작해서 한 가지 호기심이 들었다. 그것은 바로 ‘2.5 flash 로 이정도면, 2.5 pro 로 실행하면 얼마나 좋아질까?’ 였다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-016.png" alt="" /></p>

<p>그런데 어라. 이상했다. 2.5 flash 로 얻은 결과에 환호했던 것과는 달리, 생각보다 신기할 정도로 차이가 없었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-015.png" alt="" /></p>

<p>구성의 큰 차이는 없다. 프롬프트의 요구사항은 충분히 수용되었고, 여기저기 좀더 늘어나거나, 개요이지만 글처럼 어느정도 완성되었다를 제외하면 뭔가 확 와닻는 변화는 아니었다.</p>

<p>정리해보면, 2.5 Pro와 2.5 flash 로 만든 글에 대해선 다음과 같은 차이가 있다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-017.png" alt="" /></p>

<p>Pro는 그 문장 하나 하나를 분석해 보았을 때, 단순히 요구 사항 이라고 적힌 것들의 의도를 고려한 답변에 가깝다는 게 보였다. 단순한 나열을 넘어 ‘이런 의도’로 이런 이야기니까, ‘이런 주장이 나온다’ 라는 표현. 생각해보면 훨씬 똑똑한 답변이라는 점은 부정할 수 없었다. 그러나 그것이 2.5 flash + 프롬프트만큼 확실한 효과가 있는가? 여기에 답변이 되기엔 애매 했다.</p>

<p>하물며 가성비를 생각해보자. 2.5 flash 의 경우 기본적으로 2.5 pro 대비 4배 정도의 가격차이가 날 수 있다(입출력 토큰 약 3K 수준 대비). 그런데 여기서 2.5 pro 는 입력값이 늘어나, 기준치를 넘기면(입력 토큰 수 2M 이상), 더 높은 요금을 부과해 요금을 측정한다. 즉,  2.5 flash 의 1000원 수준의 내용을 작업하면, 최대 수 천원 ~ 1만원대까지도 올라갈 수 있는 상황인 것이다.</p>

<p>새삼 프롬프트, 컨텍스트의 능력이 얼마나 뛰어난지를, 각종 AI 논문에서 작은 모델들의 합이라던가 MoE 구조라던가 기타 등등… 마치 거대 모델만큼 성능 좋게 만들수 있다! 는 표현들이 실제 어떤 의미인지 체감할 수있는 아주 흥미로운 결론이었다.</p>

<h2 id="결론">결론</h2>
<h3 id="ai-나의-능력을-증폭시키는-최고의-파트너">AI, 나의 능력을 증폭시키는 최고의 파트너</h3>

<p>AI 는 아직 AGI 는 아니다. 하지만 접근 방법에  따라서 ‘최고’가 될 수 있다는 점을 경험했다. 이번 과정을 통해 Copilot 이란 플러그인에 gemini 의 조합은 엄청난 수준의 글쓰기 조수를 구축하고, 혼자 끙끙 거리며 한달이 걸릴 글을 단 일주일도 안 걸리게 마무리, 그것도 실질 글 작업은 약 이틀 정도 소모 되는 속도로 만들어냈다. 초기 목표보단 못한 것은 사실이지만 그럼에도 엄청난 효율, 효과를 누렸다고 할 수 있겠다.</p>

<p>현재 개발 시장의 요구 사항은 명확하다. 자기 도메인의 높은 전문성, 그리고 그 전문성과 함께 시너지를 발 할수 있는 AI에 대한 리터러시. 개인적으로 건강을 위한 휴식 중이긴 하나, 동시에 내가 생각하는 ‘필요시 되는 사람’으로 살아가기 위해 벌린 이번 미니 프로젝트는, 현재 AI 의 본질을 이해할 수 있었고, 가공할 능력을 어디까지 활용할 수 있을지에 대한 내 나름의 시도이자, 단편적인 답변이었다.</p>

<p>프롬프트, 그 위에 작용하는 컨텍스트의 가능성을 엿 볼 수 있는 사례다. 2.5 flash 라는 가성비 모델로도, 얼마나 효과적일 수 있는지 체감할 수 있었던 좋은 기회였다. 이 글을 읽는 모두가 AI 를 통한 생산성 향상. 특히 한계에 부딪힐 때, 그 한계를 넘어서는 기술적 발판으로 활용을 잘 하면 좋겠다고 생각한다. 본 글을 통해 커스텀 된 AI 에이전트를 노코드로 구축하고, 프로세스를 단축하는 새로운 글쓰기 경험을 맛 보시길!</p>

<h2 id="요약">요약</h2>
<p>글이 너어어어ㅓㅓㅓㅓ 무 길어졌다(…) 
내 기록을 위해 남긴다지만, 너무 길어 요약을 해보았다.</p>

<hr />

<ol>
  <li>AI 프롬프트를 합치면 오히려 일반화된다 - 여러 AI의 분석을 통합하려 했지만, 독특한 특징이 사라지고 정보 손실이 발생했다.</li>
  <li>Context(페르소나)와 Prompt(행동지침)를 분리하고, 글 종류별 Mode를 구분하니 비로소 ‘나다운’ 글쓰기가 가능해졌다.</li>
  <li>2.5 flash + 잘 짜여진 프롬프트 구조가 2.5 Pro보다 가성비 측면에서 압도적이었다. 작은 모델도 Context Engineering으로 충분히 강력해질 수 있다.</li>
</ol>

<hr />

<blockquote>
  <p>Obsidian 에 Copilot, Gemini API 적용 방법 (링크)(작성중)</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="Obsidian" /><category term="AI" /><category term="Gemini" /><category term="Google" /><category term="블로그" /><category term="플러그인" /><summary type="html"><![CDATA[Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자 글쓰기의 길은 멀고도 험하다]]></summary></entry><entry><title type="html">AI 자동화 툴, Opal 맛보기</title><link href="http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction.html" rel="alternate" type="text/html" title="AI 자동화 툴, Opal 맛보기" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction</id><content type="html" xml:base="http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction.html"><![CDATA[<p><img src="/assets/images/posts/2025-10/2025-10-09-018.png" alt="" /></p>

<h2 id="ai-워크플로우의-새로운-가능성-google-opal">AI 워크플로우의 새로운 가능성, Google Opal</h2>

<p>드디어 AI가 단발성 대화를 넘어 연속적인 작업 흐름을 처리할 수 있게 됐다. Google Labs에서 공개한 Opal은 <strong>프롬프트, AI 모델, 도구를 연결해 다단계 워크플로우를 만들 수 있는 노코드 플랫폼</strong>이다. 지금까지 AI가 부족했던 ‘시퀀스’ 개념을 드디어 제대로 구현한 셈이다.</p>

<h3 id="그동안-ai에게-없었던-것-단계별-사고">그동안 AI에게 없었던 것: 단계별 사고</h3>

<p>ChatGPT든 Gemini든, 대부분의 AI 서비스는 기본적으로 “질문 → 답변” 구조다. 물론 멀티턴 대화가 가능하긴 하지만, 복잡한 작업을 여러 단계로 나눠서 자동으로 처리하기엔 한계가 있었다. 예를 들어 “특정 주제로 블로그 초안 작성 → 이미지 생성 → SEO 최적화 → 최종 정리” 같은 워크플로우를 만들려면 결국 사람이 중간중간 개입해야 했다.</p>

<p>Opal은 바로 이 지점을 공략했다. 공식 블로그에 따르면, <strong>“프롬프트, AI 모델 호출 및 기타 도구를 연결하여 강력한 다단계 앱을 제작할 수 있도록 지원”</strong>한다고 명시되어 있다<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. 실제로 User Input(사용자 입력) → Generate(AI 생성) → Output(결과 출력) 단계를 조합하고, 각 단계의 결과를 다음 단계에서 참조할 수 있다. 이를 “단계 연결(Step Chaining)”이라고 부르는데, 드래그 앤 드롭이나 @ 기호로 간단히 구현 가능하다<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>더 인상적인 건 두 가지 편집 모드를 제공한다는 점이다. 자연어로 “이런 앱 만들어줘” 하면 Opal이 알아서 워크플로우를 구성해주고, 세부 조정은 비주얼 편집기에서 할 수 있다. 코드를 전혀 볼 필요가 없다<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>. 2024년 10월 업데이트에서는 <strong>단계별 디버깅 기능</strong>과 <strong>병렬 실행 기능</strong>까지 추가되어, 복잡한 워크플로우도 실시간으로 테스트하고 개선할 수 있게 됐다<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<h3 id="노코드의-장점이자-한계">노코드의 장점이자 한계</h3>

<p><img src="/assets/images/posts/2025-10/2025-10-09-020.png" alt="" /></p>

<p>Opal의 가장 큰 장점은 진입장벽이 낮다는 것이다. 자연어만 사용할 줄 알면 누구나 AI 앱을 만들 수 있고, Google이 호스팅까지 해주니 링크 하나로 바로 공유할 수 있다. 갤러리에서 다른 사람이 만든 앱을 리믹스해서 내 것으로 만들 수도 있다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-021.png" alt="" /></p>
<blockquote>
  <p>현재는 아주 심플한 동작들만을 지원하고 있다</p>
</blockquote>

<p>하지만 여기서 아쉬운 점이 드러난다. <strong>외부 서비스 연동이 제한적</strong>이다. 현재 기본 제공되는 도구는 웹 검색, 지도 검색, 날씨 정보 정도이고, Google Drive 정도만 직접 연동된다<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>. Notion, Slack, Trello 같은 다른 서비스와의 자동화는 아직 지원되지 않는다. Zapier나 Make.com처럼 수백 개의 서비스를 연결할 수 있는 수준엔 한참 못 미친다.</p>

<p>더 치명적인 건 <strong>코드 내보내기가 불가능</strong>하다는 점이다. Opal에서 만든 앱은 Google 생태계 안에 갇혀 있다. API를 만들 수도 없고, 데이터베이스를 붙일 수도 없으며, 실제 배포 가능한 코드를 얻을 수도 없다<sup id="fnref:6"><a href="#fn:6" class="footnote" rel="footnote" role="doc-noteref">6</a></sup>. 결국 프로토타이핑이나 간단한 사내 도구 정도로만 활용 가능하다는 얘기다. 프로덕션용으로 쓰기엔 아직 갈 길이 멀다.</p>

<h3 id="obsidian에서-했던-것들을-자동화할-수-있을까">Obsidian에서 했던 것들을 자동화할 수 있을까?</h3>

<p>개인적으로 흥미로웠던 건, 이전에 Obsidian + 코파일럿 플러그인으로 시도했던 것들이 떠올랐다는 점이다(<a href="https://paul2021-r.github.io/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html">참고 링크</a>). 당시엔 노트 글감을 준비하고, 특정 패턴 명령어를 적용하고, 글감을 나의 문체에 맞는 글감으로 만들어주는 워크플로우를 만들려고 했다. 하지만 결과적으로 수동으로 트리거를 해야 했고, 여러 단계를 거치려면 계속 개입해야 했다.</p>

<p>Opal의 시퀀스 기능을 보니, 이런 것들을 완전히 자동화할 수 있겠다는 생각이 들었다. 예를 들어 “웹에서 특정 주제 검색 → 요약 생성 → 이미지 생성 → 마크다운 포맷으로 정리 → Google Drive에 저장” 같은 흐름을 하나의 앱으로 만들 수 있을 것 같다. 물론 Obsidian과 직접 연동되진 않지만, Google Drive를 중간 저장소로 쓰면 충분히 가능할 것 같다.</p>

<p>문제는 앞서 말한 외부 서비스 연동의 한계다. 만약 Opal이 Notion API, Obsidian Local REST API, 혹은 더 나아가 커스텀 웹훅 정도만 지원해준다면, 정말 강력한 자동화 허브가 될 수 있을 텐데 말이다. 지금은 Google 생태계 안에서만 놀 수 있다는 점이 가장 아쉽다.(물론 그게 목적이겠지만 말이다.)</p>

<h3 id="결론-가능성은-보였지만-아직은-반쪽짜리">결론: 가능성은 보였지만, 아직은 반쪽짜리</h3>

<p>Opal은 분명히 AI의 새로운 방향을 제시했다. <strong>시퀀스, 워크플로우, 단계별 자동화</strong>—이것들은 AI가 단순한 챗봇을 넘어 진짜 생산성 도구가 되기 위해 반드시 필요한 요소들이다. 노코드로 이런 걸 구현했다는 점에서 Opal은 충분히 혁신적이다.</p>

<p>하지만 현실적으로 프로덕션 환경에서 쓰기엔 한계가 명확하다. 외부 서비스 연동이 제한적이고, 코드를 내보낼 수도 없으며, 아직은 실험적 도구라는 꼬리표를 떼지 못했다. Google Labs 프로젝트가 언제 접힐지 모른다는 불안감도 있다.</p>

<p>그럼에도 불구하고, Opal이 보여준 방향성은 분명하다. AI는 이제 단발성 대화를 넘어 연속적인 워크플로우를 이해하고 실행해야 한다. 그리고 누구나 코딩 없이 그런 자동화를 만들 수 있어야 한다. Opal이 완벽하진 않지만, 그 미래를 먼저 보여준 건 확실하다.</p>

<p>만약 Google이 이 프로젝트를 제대로 밀어붙여서 외부 API 연동과 코드 내보내기 기능까지 추가한다면? 그때는 정말 게임 체인저가 될 수 있을 것 같다.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://developers.googleblog.com/ko/introducing-opal/">Google 개발자 블로그 (한국어) - Opal 소개</a>: “프롬프트, AI 모델 호출 및 기타 도구를 연결하여 강력한 다단계 앱을 제작할 수 있도록 지원합니다.” <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="https://developers.google.com/opal/overview">Google Opal 공식 문서 - Overview</a>: “Referencing the results of one step in the prompt for another step is the primary way to build your app logic inside of Opal.” <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><a href="https://developers.googleblog.com/en/introducing-opal/">Google 개발자 블로그 (영어) - Introducing Opal</a>: “Opal translates your instructions into a visual workflow, giving you fine-grained control without ever needing to see a line of code.” <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><a href="https://blog.google/technology/google-labs/opal-expansion/">Google Labs Blog - Opal Expansion</a>: “We’ve fundamentally improved the debugging program… You can now run your workflow step-by-step in the visual editor” <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Google 개발자 블로그 및 공식 문서에서 확인된 빌트인 도구 목록: 웹 검색, 지도 검색, 날씨 정보, Google Drive 연동 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>커뮤니티 피드백 및 공식 문서 기반: Opal 앱은 Google 생태계 내에 제한되며, 코드 내보내기, API 생성, 데이터베이스 통합 등이 불가능함 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Paul2021-R</name></author><category term="tools" /><category term="AI" /><category term="Google" /><category term="Opal" /><category term="Automation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코테 학습 - ‘지폐접기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘지폐접기’" /><published>2025-10-01T00:00:00+00:00</published><updated>2025-10-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<h3 id="원본-문제">원본 문제</h3>
<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/340199?language=python3">원본 문제</a></p>

<h3 id="문제-정리">문제 정리</h3>

<ul>
  <li><strong>목표</strong>: 규격인 wallet 에 맞는 가로, 세로 크기로 몇번 접어야 하는지 최소 값을 리턴할 것</li>
  <li><strong>핵심 기능</strong>:
    <ol>
      <li>지폐를 접을 때는 항상 길이가 긴 쪽을 반으로 접는다.</li>
      <li>접기 전 길이 홀수 -&gt; 접은 후 소수점 이하 버리기</li>
      <li>접힌 지폐를 그대로 또는 90도 돌리고 넣을 수 있다면 그만 접음</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="코드-개선-과정-분석">코드 개선 과정 분석</h3>

<h4 id="1단계-최초-풀이-놓친-지점은-조건-1">[1단계] 최초 풀이: 놓친 지점은 조건 1</h4>
<ul>
  <li>거의 조건을 완벽하게 해결했었음. 그러나 마지막 cond ~ 부분에서 조건을 잘못 생각했다. 핵심 조건은 길이가 긴쪽을 줄이는 것이지, 무조건 가로 또는 세로를 줄이는게 아니고 이점을 놓치면 잘못 계산되는 엣지 케이스가 발생하는 것이었다.</li>
  <li>따라서 cond 배열의 어느쪽이든 문제가 있다 -&gt; 가로와 세로 중 긴 쪽을 우선 접어야 한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">bill</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">width</span> <span class="o">=</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">height</span> <span class="o">=</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">break</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span><span class="err"> </span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">break</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span><span class="err"> </span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 여기 틀림!
</span><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">bill</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">]</span> <span class="c1"># 그냥 긴 쪽을 접는 게 중요했다. 
</span><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">elif</span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">bill</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># 그냥 긴 쪽을 접는 게 중요했다. 
</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>
<h4 id="2단계-최종-풀이-조건의-확립-및-불필요한-코드-제거">[2단계] 최종 풀이: 조건의 확립 및 불필요한 코드 제거</h4>
<ol>
  <li>핵심 조건을 개선하여 엣지 케이스까지 대응이 가능해짐.</li>
  <li>그 외에 불필요한 변수들을 제거하기 시작했는데 다음과 같음
    <ol>
      <li>가로, 세로 변수 제거</li>
      <li>조건은 명확하므로, <code class="language-plaintext highlighter-rouge">and</code>로 묶어 한줄로 처리 가능</li>
      <li>cond 도 실제 무조건 <code class="language-plaintext highlighter-rouge">wallet</code>에 들어가는 조건이 아니면 무조건 긴 쪽을 접어야 하므로 필요 없음</li>
      <li>접어야 할 조건에 도착 시 배열값을 직접 수정해도 됨</li>
    </ol>
  </li>
</ol>

<hr />

<h3 id="최종-버전-코드-및-설명">최종 버전 코드 및 설명</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">bill</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">코테 학습 - ‘동영상 재생기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘동영상 재생기’" /><published>2025-09-19T00:00:00+00:00</published><updated>2025-09-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/340213?language=python3">원본 문제 보러가기</a></p>

<h2 id="2025년-9월-19일-프로그래머스-코딩-테스트-동영상-재생기-문제-풀이-python">2025년 9월 19일: 프로그래머스 코딩 테스트 ‘동영상 재생기’ 문제 풀이 (Python)</h2>

<h3 id="문제-정리">문제 정리</h3>

<ul>
  <li><strong>목표</strong>: 주어진 명령어(<code class="language-plaintext highlighter-rouge">prev</code>, <code class="language-plaintext highlighter-rouge">next</code>)를 모두 수행한 후 동영상의 최종 재생 위치를 “mm:ss” 형식으로 반환하는 문제이다.</li>
  <li><strong>핵심 기능</strong>:
    <ol>
      <li><strong>10초 전/후 이동</strong>: <code class="language-plaintext highlighter-rouge">prev</code>와 <code class="language-plaintext highlighter-rouge">next</code> 명령을 수행하며, 영상의 시작(00:00)과 끝(video_len)을 벗어나지 않도록 처리한다.</li>
      <li><strong>오프닝 자동 건너뛰기</strong>: 현재 재생 위치가 오프닝 구간(<code class="language-plaintext highlighter-rouge">op_start</code> ~ <code class="language-plaintext highlighter-rouge">op_end</code>)에 포함될 경우, 즉시 오프닝이 끝나는 위치(<code class="language-plaintext highlighter-rouge">op_end</code>)로 자동 이동한다. 이 기능은 사용자의 명령어와 관계없이 위치가 변경될 때마다 적용되어야 하는 핵심 규칙이다.</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="코드-개선-과정-분석">코드 개선 과정 분석</h3>

<h4 id="1단계-최초-풀이-분minute과-초second를-분리하여-처리">[1단계] 최초 풀이: 분(minute)과 초(second)를 분리하여 처리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">-</span> <span class="mi">10</span>
        
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
    
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">59</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="n">end_hour</span><span class="p">,</span> <span class="n">end_minutes</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end_hour</span> <span class="ow">or</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_hour</span> <span class="ow">and</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end_minutes</span><span class="p">):</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_hour</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_minutes</span>
    
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">op_start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="n">start_total_time</span> <span class="o">=</span> <span class="n">start_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">start_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end_total_time</span> <span class="o">=</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">current_total_time</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">start_total_time</span> <span class="o">&lt;=</span> <span class="n">current_total_time</span> <span class="ow">and</span> <span class="n">current_total_time</span> <span class="o">&lt;=</span> <span class="n">end_total_time</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">current_pos</span>
<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="p">)</span><span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

    
    <span class="n">hour</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">minute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">minute</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])]</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">video_len</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>첫 번째 코드는 시간 데이터를 <code class="language-plaintext highlighter-rouge">[분, 초]</code> 형태의 리스트(혹은 튜플)로 다루는 방식이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1단계 코드 (주요 부분)
</span><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">-</span> <span class="mi">10</span>
    <span class="c1"># ...경계 값 처리...
</span>    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="c1"># [분, 초] 리스트 반환
</span>    <span class="c1"># ... (생략) ...
</span></code></pre></div></div>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>시간을 ‘분’과 ‘초’ 두 개의 단위로 유지하며 모든 연산을 수행했다.</li>
    </ul>
  </li>
  <li><strong>분석 및 문제점</strong>:
    <ul>
      <li><strong>로직의 복잡성</strong>: 10초를 더하고 뺄 때, 60초를 기준으로 받아올림/내림 처리를 해야 하므로 <code class="language-plaintext highlighter-rouge">if-elif</code> 조건문이 복잡해진다. 예를 들어 <code class="language-plaintext highlighter-rouge">prev_pos</code>에서 <code class="language-plaintext highlighter-rouge">03:05</code>에서 10초를 빼는 경우 <code class="language-plaintext highlighter-rouge">02:55</code>로 만들기 위한 연산이 직관적이지 않다.</li>
      <li><strong>비교 연산의 번거로움</strong>: <code class="language-plaintext highlighter-rouge">skip_opening</code>과 같이 시간의 선후 관계를 비교할 때, 분과 초를 각각 비교해야 하므로 코드가 길어지고 실수할 가능성이 커진다.</li>
      <li><strong>데이터 타입의 불일치</strong>: 타입 힌트는 불변(immutable) 객체인 <code class="language-plaintext highlighter-rouge">Tuple</code>로 지정했지만, 실제로는 <code class="language-plaintext highlighter-rouge">current_pos[1] -= 10</code>처럼 내부 값을 변경하고 있어 가변(mutable) 객체인 <code class="language-plaintext highlighter-rouge">List</code>처럼 사용했다. 이는 잠재적인 오류를 유발할 수 있는 좋지 않은 패턴이다.</li>
    </ul>
  </li>
</ul>

<h4 id="2단계-개선-단위를-초second로-통일">[2단계] 개선: 단위를 ‘초(second)’로 통일</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">video_length</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="n">video_end</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">video_length</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&gt;</span> <span class="n">video_end</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">video_end</span>
    
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">op_start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">current_pos</span> <span class="ow">and</span> <span class="n">current_pos</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">end_time</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span> <span class="o">//</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span> <span class="o">%</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">minute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">minute</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>  <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">video_len</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>첫 풀이의 복잡성을 해결하기 위해 모든 시간 단위를 ‘초’로 통일했다. 이는 문제 해결의 <strong>가장 결정적인 개선점</strong>이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 2단계 코드 (주요 부분)
</span><span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>  <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="c1"># '초' 단위 정수 반환
</span>    <span class="c1"># ... (생략) ...
</span></code></pre></div></div>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>모든 “mm:ss” 형식의 시간을 <code class="language-plaintext highlighter-rouge">get_int_time</code> 함수를 통해 ‘초’ 단위의 정수(integer)로 변환하여 계산했다.</li>
    </ul>
  </li>
  <li><strong>분석 및 개선 효과</strong>:
    <ul>
      <li><strong>연산의 단순화</strong>: 시간 계산이 <code class="language-plaintext highlighter-rouge">+10</code>, <code class="language-plaintext highlighter-rouge">-10</code>과 같은 단순한 정수 연산으로 바뀌어 코드가 매우 간결해지고 명확해졌다.</li>
      <li><strong>비교의 용이성</strong>: 시간 비교 역시 정수의 크기 비교(<code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>)로 단순화되어 <code class="language-plaintext highlighter-rouge">skip_opening</code> 로직이 직관적으로 변했다.</li>
      <li><strong>오류 가능성 감소</strong>: 복잡한 받아올림/내림 로직이 사라져 버그가 발생할 여지가 크게 줄었다.</li>
    </ul>
  </li>
  <li><strong>남은 개선점</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">next_pos</code>, <code class="language-plaintext highlighter-rouge">skip_opening</code> 함수가 루프 안에서 호출될 때마다 <code class="language-plaintext highlighter-rouge">get_int_time</code> 함수를 통해 문자열을 정수로 변환하는 <strong>불필요한 반복 연산</strong>이 여전히 존재한다.</li>
      <li>오프닝 스킵 로직의 적용 시점이 루프 전/후로 나뉘어 있어 더 깔끔하게 정리할 여지가 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="3단계-최종-풀이-pythonic-코드-적용-및-로직-최적화">[3단계] 최종 풀이: Pythonic 코드 적용 및 로직 최적화</h4>

<p>2단계에서 이룬 구조적 개선 위에, 코드의 효율성과 가독성을 극대화하는 Pythonic한 기법들과 로직 최적화를 적용한 최종 버전이다.</p>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>반복 연산을 제거하고, 파이썬 내장 기능과 더 효율적인 로직 흐름을 적용하여 코드를 완성했다.</li>
    </ul>
  </li>
  <li><strong>핵심 개선점</strong>:
    <ol>
      <li><strong>사전 연산 (Pre-computation)</strong>: <code class="language-plaintext highlighter-rouge">solution</code> 함수 시작 시점에서 필요한 모든 시간 문자열(<code class="language-plaintext highlighter-rouge">video_len</code>, <code class="language-plaintext highlighter-rouge">op_start</code> 등)을 ‘초’ 단위 정수로 <strong>미리 한 번만 변환</strong>하여 변수에 저장한다. 이를 통해 루프 내에서 반복적인 변환 작업을 완전히 제거하여 효율성을 높였다.</li>
      <li><strong>Pythonic 경계 값 처리</strong>: <code class="language-plaintext highlighter-rouge">prev</code>와 <code class="language-plaintext highlighter-rouge">next</code> 기능에서 <code class="language-plaintext highlighter-rouge">if</code>문을 사용하여 0과 영상 최대 길이를 확인하는 대신, <code class="language-plaintext highlighter-rouge">max(0, ...)</code>와 <code class="language-plaintext highlighter-rouge">min(video_len_sec, ...)</code>를 사용하여 코드를 한 줄로 줄이고 의도를 더 명확하게 표현했다.</li>
      <li><strong>Pythonic 시간 포맷팅</strong>: <code class="language-plaintext highlighter-rouge">get_str_time</code> 함수에서 <code class="language-plaintext highlighter-rouge">divmod()</code>를 사용해 몫(분)과 나머지(초)를 한 번에 계산하고, f-string의 <code class="language-plaintext highlighter-rouge">:02d</code> 서식 지정자를 이용해 두 자리 수에 맞춰 0을 채우는 가장 표준적이고 깔끔한 방식을 사용했다.</li>
      <li><strong>로직 흐름 최적화</strong>: 오프닝 스킵 로직을 <strong>‘상태가 변경될 때마다 유효성을 검사하는’</strong> 개념으로 접근했다.
        <ul>
          <li><strong>초기 상태 보정</strong>: 루프 시작 전, 최초 위치에 대해 스킵 검사를 먼저 수행한다.</li>
          <li><strong>변경 후 보정</strong>: 명령어 실행으로 위치가 변경된 직후에만 스킵 검사를 수행한다.</li>
          <li>이 두 번의 검사로 모든 경우를 처리하여, 루프 전과 후로 로직이 나뉘어 있던 2단계 코드보다 훨씬 더 명료한 흐름을 완성했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="최종-버전-코드-및-설명">최종 버전 코드 및 설명</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 시간 변환 함수: 초 단위 정수와 "mm:ss" 문자열을 상호 변환한다.
</span><span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># divmod로 몫(분)과 나머지(초)를 한 번에 계산한다.
</span>    <span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span> <span class="o">=</span> <span class="nf">divmod</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="c1"># f-string 포맷팅으로 두 자리가 아닐 경우 앞에 0을 붙여준다.
</span>    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">minutes</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">seconds</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="c1"># [최적화 1] 모든 시간 값을 미리 한 번만 정수로 변환한다.
</span>    <span class="n">video_len_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">video_len</span><span class="p">)</span>
    <span class="n">op_start_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">op_end_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    
    <span class="c1"># 오프닝 스킵을 위한 지역 헬퍼 함수. solution 내부 변수에 접근하기 용이하다.
</span>    <span class="k">def</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">pos_sec</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_start_sec</span> <span class="o">&lt;=</span> <span class="n">pos_sec</span> <span class="o">&lt;=</span> <span class="n">op_end_sec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op_end_sec</span>
        <span class="k">return</span> <span class="n">pos_sec</span>
    
    <span class="c1"># [로직 최적화] 1. 초기 위치에 대한 오프닝 스킵을 먼저 적용한다.
</span>    <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="c1"># [최적화 2] min()을 사용해 영상 길이를 넘지 않도록 처리한다.
</span>            <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">video_len_sec</span><span class="p">,</span> <span class="n">current_pos_sec</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="c1"># [최적화 2] max()를 사용해 0 미만으로 내려가지 않도록 처리한다.
</span>            <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_pos_sec</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span>
    
        <span class="c1"># [로직 최적화] 2. 명령어로 위치가 바뀐 직후, 다시 오프닝 스킵을 적용한다.
</span>        <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>

</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">CS 학습 - 9월 3주차</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03.html" rel="alternate" type="text/html" title="CS 학습 - 9월 3주차" /><published>2025-09-15T00:00:00+00:00</published><updated>2025-09-15T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03.html"><![CDATA[<h2 id="알고리즘">알고리즘</h2>

<h3 id="sort">Sort</h3>
<h4 id="1-삽입-정렬-insertion-sort">1. 삽입 정렬 (Insertion Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757913162355_f8k6df.png" alt="" /></p>

<h5 id="1-1-개념">1-1. 개념</h5>

<p>삽입 정렬은 <strong>처리되지 않은 데이터를 이미 정렬된 부분의 적절한 위치에 삽입</strong>해 나가는 방식으로 동작한다. 손안의 카드를 정렬할 때, 새로운 카드를 이미 정렬된 카드 뭉치의 올바른 자리에 꽂는 과정과 유사하다.</p>

<p>2번째 원소부터 시작하여 그 앞(왼쪽)의 데이터들과 비교하여 삽입할 위치를 지정하고, 데이터를 뒤로 옮긴 후 해당 자리에 삽입한다.</p>

<h5 id="1-2-시간-복잡도">1-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n)$ - 이미 데이터가 모두 정렬되어 있는 경우, 외부 루프만 한 번 순회한다.</li>
  <li><strong>평균(Average):</strong> $O(n^2)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 데이터가 역순으로 정렬되어 있는 경우, 모든 요소를 비교하고 이동시켜야 한다.</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
삽입 정렬은 데이터셋의 크기가 작거나, 데이터가 거의 정렬된 상태일 때 매우 효율적으로 동작한다. 이런 특성 때문에 다른 복잡한 정렬 알고리즘(예: 팀 정렬)의 <strong>일부</strong>로 사용되기도 한다.</p>
</blockquote>

<h5 id="1-3-python-구현-코드">1-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># 배열의 2번째 요소(인덱스 1)부터 시작
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 정렬할 대상이 되는 요소
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>     <span class="c1"># 비교 대상이 되는 정렬된 부분의 마지막 인덱스
</span>        
        <span class="c1"># key를 정렬된 부분의 올바른 위치에 삽입
</span>        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># 요소를 한 칸씩 오른쪽으로 이동
</span>            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="c1"># 찾은 위치에 key를 삽입
</span>    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">삽입 정렬 결과: </span><span class="si">{</span><span class="nf">insertion_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="2-버블-정렬-bubble-sort">2. 버블 정렬 (Bubble Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916208845_6sxbw2.png" alt="" /></p>

<h5 id="2-1-개념">2-1. 개념</h5>

<p>버블 정렬은 <strong>인접한 두 개의 원소를 비교하며 자리를 교환</strong>하는 방식으로 동작한다. 배열의 처음부터 끝까지 순회하면서, 왼쪽 값이 오른쪽 값보다 크면 두 값의 위치를 바꾼다. 이</p>

<p>러한 한 번의 순회(Pass)가 끝나면 가장 큰 원소가 배열의 맨 끝으로 이동하게 된다. 이 과정을 배열의 크기만큼 반복한다. 마치 물속의 거품(Bubble)이 위로 올라오는 모습과 같아 버블 정렬이라는 이름이 붙었다.</p>

<h5 id="2-2-시간-복잡도">2-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n)$ - 이미 데이터가 정렬된 상태에서, 한 번의 순회 중 교환(swap)이 발생하지 않으면 정렬을 종료하는 로직을 추가했을 경우이다.</li>
  <li><strong>평균(Average):</strong> $O(n^2)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 데이터가 역순으로 정렬되어 있는 경우이다.</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
버블 정렬은 구현이 매우 간단하여 정렬 알고리즘의 기본 원리를 학습하는 데는 좋지만, 성능이 좋지 않아 실제 현업에서 사용되는 경우는 거의 없다.</p>
</blockquote>

<h5 id="2-3-python-구현-코드">2-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># 배열의 크기만큼 외부 루프를 반복
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># 이미 정렬된 마지막 요소들을 제외하고 내부 루프를 반복
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 왼쪽 요소가 오른쪽 요소보다 크면 교환
</span>            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">swapped</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># 한 번의 순회 동안 교환이 일어나지 않았다면, 이미 정렬된 상태
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">버블 정렬 결과: </span><span class="si">{</span><span class="nf">bubble_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-병합-정렬-merge-sort">3. 병합 정렬 (Merge Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916435555_h2m3yt.png" alt="" /></p>
<h5 id="3-1-개념">3-1. 개념</h5>

<p>병합 정렬은 <strong>분할 정복(Divide and Conquer)</strong> 패러다임을 사용하는 대표적인 정렬 알고리즘이다.</p>

<ol>
  <li><strong>분할(Divide):</strong> 배열의 크기가 1이 될 때까지 재귀적으로 계속해서 반으로 나눈다.</li>
  <li><strong>정복(Conquer):</strong> 나누어진 작은 배열들을 2개씩 쌍을 이루어 정렬하면서 병합(Merge)한다. 이 과정을 모든 배열이 다시 하나로 합쳐질 때까지 반복한다.</li>
</ol>

<h5 id="3-2-시간-복잡도">3-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n \log n)$</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
병합 정렬은 데이터의 분포와 상관없이 항상 $O(n \log n)$의 시간 복잡도를 보장하여 안정적(Stable)이다. 하지만 정렬 과정에서 임시 배열을 위한 추가적인 <strong>메모리 공간($O(n)$)</strong> 이 필요하다는 단점이 있다.</p>
</blockquote>

<h5 id="3-3-python-구현-코드">3-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="c1"># 1. 분할 (Divide)
</span>    <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left_half</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">right_half</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
    
    <span class="c1"># 2. 정복 및 병합 (Conquer and Merge)
</span>    <span class="n">merged_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l_idx</span><span class="p">,</span> <span class="n">r_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">l_idx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">left_half</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r_idx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">right_half</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">]:</span>
            <span class="n">merged_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">])</span>
            <span class="n">l_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">])</span>
            <span class="n">r_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="c1"># 남은 요소들을 추가
</span>    <span class="n">merged_arr</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">:])</span>
    <span class="n">merged_arr</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">:])</span>
    
    <span class="k">return</span> <span class="n">merged_arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">병합 정렬 결과: </span><span class="si">{</span><span class="nf">merge_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="4-힙-정렬-heap-sort">4. 힙 정렬 (Heap Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916561788_se2vpw.png" alt="" /></p>

<h5 id="4-1-개념">4-1. 개념</h5>

<p>힙 정렬은 <strong>힙(Heap) 자료구조</strong>를 이용하여 정렬하는 알고리즘이다. 힙은 ‘완전 이진 트리’의 한 종류로, 부모 노드의 값이 항상 자식 노드의 값보다 크거나 같은(최대 힙) 또는 작거나 같은(최소 힙) 속성을 만족한다.</p>

<ol>
  <li>주어진 데이터를 최대 힙(Max Heap) 구조로 만든다.</li>
  <li>힙에서 가장 큰 값은 루트(root) 노드에 위치한다. 이 루트 노드를 배열의 가장 마지막 요소와 바꾼다.</li>
  <li>힙의 크기를 하나 줄이고, 다시 힙 속성을 만족하도록 구조를 재조정(heapify)한다.</li>
  <li>힙의 크기가 1이 될 때까지 2~3번 과정을 반복한다.</li>
</ol>

<h5 id="4-2-시간-복잡도">4-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n \log n)$</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
힙 정렬은 병합 정렬과 달리 추가적인 <strong>메모리 공간을 거의 사용하지 않는($O(1)$)</strong> 장점이 있으며, 항상 $O(n \log n)$의 성능을 보장한다. <strong>우선순위 큐</strong>를 구현할 때 매우 유용하다.</p>
</blockquote>

<h5 id="4-3-python-구현-코드">4-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># 현재 서브트리의 루트
</span>    <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
    
    <span class="c1"># 왼쪽 자식이 루트보다 크면 largest를 업데이트
</span>    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
        
    <span class="c1"># 오른쪽 자식이 largest보다 크면 largest를 업데이트
</span>    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
        
    <span class="c1"># largest가 변경되었다면, 루트와 교환하고 재귀적으로 heapify 호출
</span>    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="c1"># 1. 최대 힙(Max Heap) 구성
</span>    <span class="c1"># 마지막 비단말 노드부터 시작하여 루트까지 heapify 수행
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
    <span class="c1"># 2. 힙에서 요소를 하나씩 추출하여 정렬
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 루트(최댓값)를 배열의 끝으로 이동
</span>        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># 크기가 줄어든 힙에 대해 heapify 수행
</span>        
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">힙 정렬 결과: </span><span class="si">{</span><span class="nf">heap_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="4-4-heapq-모듈-사용-예시-및-장단점">4-4. heapq 모듈 사용 예시 및 장단점</h5>

<p>Python의 내장 라이브러리인 <code class="language-plaintext highlighter-rouge">heapq</code>를 사용하면 힙 자료구조를 간단하게 활용할 수 있다. 다음은 <code class="language-plaintext highlighter-rouge">heapq</code>를 이용해 리스트를 정렬하는 예시 코드이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="k">def</span> <span class="nf">heapq_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 모든 원소를 힙에 차례대로 삽입
</span>    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    
    <span class="c1"># 힙에서 모든 원소를 차례대로 꺼내 정렬된 리스트 생성
</span>    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">sorted_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">sorted_arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">heapq를 이용한 정렬 결과: </span><span class="si">{</span><span class="nf">heapq_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># 더 간결한 방법: heapify 사용
</span><span class="k">def</span> <span class="nf">heapq_sort_concise</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># 리스트를 한 번에 힙으로 변환 (O(n))
</span>    <span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">sorted_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">sorted_arr</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># 최대 힙으로 사용할 리스트
</span><span class="n">max_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="c1"># 1. 최대 힙에 원소 추가 (부호를 바꿔서 heappush)
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">--- 최대 힙에 원소 추가 ---</span><span class="sh">"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s"> 추가 후 힙 상태: </span><span class="si">{</span><span class="n">max_heap</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">최종 최대 힙 (내부 표현):</span><span class="sh">"</span><span class="p">,</span> <span class="n">max_heap</span><span class="p">)</span> <span class="c1"># 내부적으로는 음수 값을 가진 최소 힙
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">가장 큰 값(루트): </span><span class="si">{</span><span class="o">-</span><span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">--- 최대 힙에서 원소 추출 ---</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># 2. 최대 힙에서 원소 추출 (heappop 후 부호를 다시 변경)
</span><span class="k">while</span> <span class="n">max_heap</span><span class="p">:</span>
    <span class="c1"># 가장 작은 음수(원래는 가장 큰 양수)를 꺼내서 부호를 복원
</span>    <span class="n">max_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">추출된 최댓값: </span><span class="si">{</span><span class="n">max_val</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
기존 리스트를 제자리에서 힙으로 변환하는 heapq.heapify(list) 함수를 사용하면 $O(n)$의 시간 복잡도로 힙을 구성할 수 있어, 모든 원소를 하나씩 heappush 하는 것보다 효율적이다.</p>
</blockquote>

<ul>
  <li><strong>구현 대비 장점</strong>
    <ul>
      <li><strong>간결성:</strong> 복잡한 <code class="language-plaintext highlighter-rouge">heapify</code> 로직을 직접 구현할 필요 없이, 몇 줄의 코드로 힙 기능을 사용할 수 있어 매우 편리하다.</li>
      <li><strong>성능:</strong> 내장 모듈은 C언어로 구현되어 있어 일반적으로 직접 Python으로 구현한 코드보다 실행 속도가 빠르다.</li>
      <li><strong>안정성:</strong> 이미 충분히 검증된 라이브러리이므로 직접 구현 시 발생할 수 있는 실수를 방지하고 코드의 안정성을 높일 수 있다.</li>
    </ul>
  </li>
  <li><strong>구현 대비 단점</strong>
    <ul>
      <li><strong>추상화:</strong> 내부 동작 원리가 감춰져 있어 힙 정렬의 학습 목적으로는 적합하지 않다.</li>
      <li><strong>추가 메모리 사용:</strong> 위 예시처럼 정렬된 결과를 담을 새로운 리스트가 필요하므로, 제자리 정렬(in-place sort)이 아니며 $O(n)$의 추가 공간이 필요하다.</li>
      <li><strong>최소 힙 고정:</strong> <code class="language-plaintext highlighter-rouge">heapq</code>는 최소 힙(Min Heap)만 지원하므로 최대 힙(Max Heap)이 필요할 경우, 값의 부호를 변경하는 등의 추가적인 처리가 필요하다.</li>
    </ul>
  </li>
</ul>

<p>— 2025년 9월 15일 학습</p>

<h4 id="5-퀵-정렬-quick-sort"><strong>5. 퀵 정렬 (Quick Sort)</strong></h4>

<h5 id="5-1-개념"><strong>5-1. 개념</strong></h5>

<p>퀵 정렬 또한 <strong>분할 정복</strong> 패러다임을 사용하며, 평균적으로 매우 빠른 성능을 자랑한다.</p>

<ol>
  <li>배열 내에서 임의의 기준점, **피벗(Pivot)**을 선택한다.</li>
  <li>피벗을 기준으로 피벗보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 분할(Partition)한다.</li>
  <li>분할된 양쪽의 부분 배열에 대해 재귀적으로 퀵 정렬을 수행한다.</li>
  <li>부분 배열의 크기가 1 이하가 되면 정렬을 멈춘다.</li>
</ol>

<h5 id="5-2-시간-복잡도"><strong>5-2. 시간 복잡도</strong></h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$ - 피벗이 항상 배열을 절반으로 분할할 때이다.</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 피벗이 항상 가장 작거나 가장 큰 값으로 선택되어 배열이 한쪽으로 치우치게 분할될 때이다 (예: 이미 정렬된 배열에서 항상 첫 요소를 피벗으로 선택).</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
퀵 정렬은 평균적인 성능이 매우 뛰어나 ‘퀵’이라는 이름이 붙었으며, 많은 프로그래밍 언어의 표준 정렬 라이브러리에서 기본 알고리즘으로 채택되곤 한다. 최악의 경우를 피하기 위해 피벗을 랜덤하게 선택하거나, 세 값의 중앙값(Median-of-three)을 선택하는 등의 기법이 사용된다.</p>
</blockquote>

<h5 id="5-3-python-구현-코드"><strong>5-3. Python 구현 코드</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># 중앙값을 피벗으로 설정
</span>    <span class="n">lesser_arr</span><span class="p">,</span> <span class="n">equal_arr</span><span class="p">,</span> <span class="n">greater_arr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">lesser_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">greater_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">equal_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">lesser_arr</span><span class="p">)</span> <span class="o">+</span> <span class="n">equal_arr</span> <span class="o">+</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">greater_arr</span><span class="p">)</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">퀵 정렬 결과: </span><span class="si">{</span><span class="nf">quick_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h4 id="6-각-정렬-알고리즘-시간-복잡도-비교"><strong>6. 각 정렬 알고리즘 시간 복잡도 비교</strong></h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘 (Algorithm)</th>
      <th style="text-align: center">최선 (Best)</th>
      <th style="text-align: center">평균 (Average)</th>
      <th style="text-align: center">최악 (Worst)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**삽입 정렬**</td>
      <td style="text-align: center">$O(n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**버블 정렬**</td>
      <td style="text-align: center">$O(n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**병합 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**힙 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**퀵 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="7-번외-그-외에-개발-시-사용하면-좋을-정렬-기법"><strong>7. (번외) 그 외에 개발 시 사용하면 좋을 정렬 기법</strong></h4>

<p>이론적인 학습을 넘어 실제 개발 환경에서는 언어 차원에서 제공하는 내장 정렬 함수를 사용하는 것이 일반적이다. 이 함수들은 대부분의 상황에 최적화된 고성능 알고리즘을 사용한다.</p>

<ul>
  <li>
    <p><strong>팀 정렬 (Timsort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 병합 정렬과 삽입 정렬을 결합한 하이브리드 안정 정렬(Stable Sort) 알고리즘이다.</li>
      <li><strong>특징:</strong> 실제 데이터는 완전히 무작위가 아니라 어느 정도 정렬된 연속적인 부분(run)을 포함하는 경우가 많다는 점에서 착안되었다. 이런 ‘run’들을 찾아서 삽입 정렬로 처리하고, 이 run들을 효율적으로 병합해 나간다. 적응형(Adaptive) 알고리즘으로, 데이터의 상태에 따라 최적의 성능을 낸다.</li>
      <li><strong>용도:</strong> <strong>Python</strong>의 내장 정렬 함수(<code class="language-plaintext highlighter-rouge">sorted()</code>, <code class="language-plaintext highlighter-rouge">list.sort()</code>)와 Java의 <code class="language-plaintext highlighter-rouge">Arrays.sort()</code> (객체 배열용)에서 표준 알고리즘으로 사용된다.</li>
    </ul>
  </li>
  <li>
    <p><strong>기수 정렬 (Radix Sort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 비교 기반 정렬이 아니다. 데이터의 자릿수(radix)를 이용하여 낮은 자릿수부터 정렬해 나가는 방식이다. 예를 들어, 10진수 정수를 정렬한다면 1의 자리, 10의 자리, 100의 자리 순으로 정렬을 수행한다.</li>
      <li><strong>특징:</strong> 시간 복잡도는 $O(d(n+k))$ (d: 자릿수, n: 데이터 개수, k: 기수)로, 데이터의 길이가 짧고 개수가 많을 때 비교 기반 정렬인 $O(n \log n)$보다 빠를 수 있다.</li>
      <li><strong>용도:</strong> 정수나 문자열 등 자릿수 구분이 명확한 데이터들을 정렬할 때 효과적이다. (예: 대규모 숫자 데이터 정렬, 사전순 문자열 정렬)</li>
    </ul>
  </li>
  <li>
    <p><strong>계수 정렬 (Counting Sort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 비교 기반 정렬이 아니다. 각 숫자가 몇 번 등장했는지 개수를 센 다음, 누적합을 이용하여 각 숫자의 정렬된 위치를 계산하는 방식이다.</li>
      <li><strong>특징:</strong> 데이터 값의 범위(range)가 데이터의 개수(n)에 비해 작을 때 매우 빠른 성능을 보인다. 시간 복잡도는 $O(n+k)$ (k: 데이터의 최댓값)이다.</li>
      <li><strong>용도:</strong> 정수 데이터, 특히 양수이고 값의 범위가 한정적일 때 사용하기 좋다. (예: 0~100점 사이의 시험 점수 정렬)</li>
    </ul>
  </li>
</ul>

<h3 id="동적-프로그래밍dynamic-programming">동적 프로그래밍(Dynamic Programming)</h3>

<h3 id="재귀-알고리즘">재귀 알고리즘</h3>

<h3 id="알고리즘---고급">알고리즘 - 고급</h3>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[알고리즘]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차 (2)" /><published>2025-09-09T00:00:00+00:00</published><updated>2025-09-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02.html"><![CDATA[<h2 id="자료구조와-알고리즘-feat-ts와-python-을-얹은">자료구조와 알고리즘 (feat, TS와 Python 을 얹은)</h2>

<h3 id="typescript-vs-python-배열array-사용법-비교">TypeScript vs. Python: 배열(Array) 사용법 비교</h3>

<p><strong>TypeScript는 정적 타입을 지원하여 코드의 안정성을 높이는 반면, Python은 동적 타이핑으로 유연하고 간결한 코드 작성을 지원한다.</strong></p>
<h4 id="1-배열의-선언과-초기화">1. 배열의 선언과 초기화</h4>

<p>가장 큰 차이점은 <strong>타입 명시 여부</strong>이다. TypeScript는 변수 선언 시 타입을 지정하여 예측 가능하고 안정적인 코드를 작성하도록 유도하는 반면, Python은 타입을 명시하지 않아도 되어 간결하다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 배열이 담을 요소의 타입을 명시적으로 지정해야 한다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">let list: number[] = [1, 2, 3];</code></li>
      <li><code class="language-plaintext highlighter-rouge">let list: Array&lt;number&gt; = [1, 2, 3];</code></li>
      <li>다양한 타입을 허용하려면 유니온 타입(<code class="language-plaintext highlighter-rouge">(string | number)[]</code>)을 사용할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Python</strong>: 파이썬의 리스트는 기본적으로 모든 데이터 타입을 담을 수 있는 동적 배열이다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">my_list = [1, "hello", True]</code></li>
      <li>타입을 강제하고 싶다면 <code class="language-plaintext highlighter-rouge">array</code> 모듈을 사용하거나, 타입 힌트(Type Hint)를 활용할 수 있으나, 이는 강제 사항이 아니다.</li>
      <li><code class="language-plaintext highlighter-rouge">from array import array</code></li>
      <li><code class="language-plaintext highlighter-rouge">arr = array('i', [1, 2, 3])</code></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-요소-접근-추가-및-삭제">2. 요소 접근, 추가 및 삭제</h4>

<p>배열의 요소를 다루는 기본적인 방법은 유사하지만, 사용하는 메서드의 이름과 기능에서 차이가 나타난다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">TypeScript</th>
      <th style="text-align: left">Python (List)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**요소 접근**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr[0]</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list[0]</code>, <code class="language-plaintext highlighter-rouge">my_list[-1]</code></td>
      <td style="text-align: left">TypeScript와 Python 모두 인덱스로 요소에 접근한다. Python은 음수 인덱스를 지원하여 뒤에서부터 접근이 가능하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 뒤에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.push(4)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.append(4)</code></td>
      <td style="text-align: left">가장 일반적인 요소 추가 방식이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 앞에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.unshift(0)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.insert(0, 0)</code></td>
      <td style="text-align: left">TypeScript에는 <code class="language-plaintext highlighter-rouge">unshift</code>라는 명확한 메서드가 있다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 인덱스에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.splice(1, 0, 1.5)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.insert(1, 1.5)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">splice</code>는 추가, 삭제, 교체가 모두 가능하여 더 강력하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 뒤 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.pop()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop()</code></td>
      <td style="text-align: left">두 언어 모두 동일한 이름의 메서드를 사용한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 앞 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.shift()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop(0)</code> 또는 <code class="language-plaintext highlighter-rouge">del my_list[0]</code></td>
      <td style="text-align: left">TypeScript는 <code class="language-plaintext highlighter-rouge">shift</code> 메서드를 제공한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 인덱스 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.splice(1, 1)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop(1)</code> 또는 <code class="language-plaintext highlighter-rouge">del my_list[1]</code></td>
      <td style="text-align: left">특정 위치의 요소를 삭제하는 기능이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 값으로 요소 삭제**</td>
      <td style="text-align: left">(직접 구현 필요)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.remove(3)</code></td>
      <td style="text-align: left">Python은 값으로 요소를 찾아 삭제하는 <code class="language-plaintext highlighter-rouge">remove</code> 메서드를 기본 제공한다.</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="3-배열-순회-반복">3. 배열 순회 (반복)</h4>

<p>배열의 모든 요소를 순차적으로 접근하여 작업을 수행하는 반복문에서도 약간의 차이가 존재한다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">for...of</code>, <code class="language-plaintext highlighter-rouge">forEach</code>, 그리고 전통적인 <code class="language-plaintext highlighter-rouge">for</code> 루프를 주로 사용한다.</p>

    <ul>
      <li><strong>for…of</strong>: 배열의 ‘값(value)’을 순차적으로 가져온다. (가장 권장되는 방식 중 하나)
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>
<span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong>forEach</strong>: 각 요소에 대해 콜백 함수를 실행한다.
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">list</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Index </span><span class="p">${</span><span class="nx">index</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">for...in</code> 구문을 사용하는 것이 가장 일반적이고 파이썬다운(Pythonic) 방법이다.</p>

    <ul>
      <li><strong>for…in</strong>: 배열의 ‘값(value)’을 순차적으로 가져온다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li><strong>enumerate</strong>: 인덱스와 값을 함께 가져와야 할 때 유용하게 사용된다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="typescript-vs-python-배열-순회-및-변형-심화">TypeScript vs. Python: 배열 순회 및 변형 심화</h3>
<p><strong>TypeScript는 메서드 체이닝(Method Chaining)을 통해 가독성을 높이는 반면, Python은 리스트 컴프리헨션이라는 독특하고 간결한 구문을 통해 강력한 기능을 제공한다.</strong></p>

<h4 id="1-배열의-각-요소를-변형하기-mapping">1. 배열의 각 요소를 변형하기 (Mapping)</h4>

<p><code class="language-plaintext highlighter-rouge">map</code>은 배열의 모든 요소를 순회하며 주어진 함수를 적용하여 <strong>새로운 배열을 생성</strong>하는 기능이다. 원본 배열은 변경되지 않는다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">map()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">squared</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">);</span>
<span class="c1">// squared: [1, 4, 9, 16]</span>
</code></pre></div>    </div>

    <p>각 요소에 함수를 순차적으로 적용하고 그 결과값을 모아 새로운 배열로 반환하는 직관적인 방식이다.</p>
  </li>
  <li>
    <p><strong>Python</strong>: 리스트 컴프리헨션(List Comprehension)이 가장 일반적이고 효율적인 방법이다. <code class="language-plaintext highlighter-rouge">map()</code> 함수도 존재한다.</p>

    <ul>
      <li><strong>리스트 컴프리헨션</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squared</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
<span class="c1"># squared: [1, 4, 9, 16]
</span></code></pre></div>        </div>
        <p>대괄호 안에 <code class="language-plaintext highlighter-rouge">for</code> 루프를 포함하는 형태로, 매우 간결하고 가독성이 높다고 평가받는다.</p>
      </li>
      <li><strong>map() 함수</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1"># map 객체를 반환하므로 list로 변환 필요
</span><span class="n">squared</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span> 
<span class="c1"># squared: [1, 4, 9, 16]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-조건에-맞는-요소만-걸러내기-filtering">2. 조건에 맞는 요소만 걸러내기 (Filtering)</h4>

<p><code class="language-plaintext highlighter-rouge">filter</code>는 배열의 모든 요소를 순회하며, 주어진 함수의 결과값이 <code class="language-plaintext highlighter-rouge">true</code>인 요소들만 모아 <strong>새로운 배열을 생성</strong>하는 기능이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">filter()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">evens</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// evens: [2, 4]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: 여기서도 리스트 컴프리헨션이 널리 쓰인다.</p>

    <ul>
      <li><strong>리스트 컴프리헨션</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># evens: [2, 4]
</span></code></pre></div>        </div>
        <p><code class="language-plaintext highlighter-rouge">for</code> 루프 뒤에 <code class="language-plaintext highlighter-rouge">if</code> 조건을 추가하여 필터링 기능을 구현한다.</p>
      </li>
      <li><strong>filter() 함수</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1"># filter 객체를 반환하므로 list로 변환 필요
</span><span class="n">evens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">num</span><span class="p">:</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span>
<span class="c1"># evens: [2, 4]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="3-배열을-하나의-값으로-통합하기-reducing">3. 배열을 하나의 값으로 통합하기 (Reducing)</h4>

<p><code class="language-plaintext highlighter-rouge">reduce</code>는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하여 <strong>하나의 결과값</strong>을 반환한다. 누적 계산에 주로 사용된다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">reduce()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">sum</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">accumulator</span><span class="p">,</span> <span class="nx">currentValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">accumulator</span> <span class="o">+</span> <span class="nx">currentValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// sum: 15</span>
<span class="c1">// 0은 accumulator의 초기값이다.</span>
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">accumulator</code>는 이전 콜백의 반환값이 누적되는 변수이고, <code class="language-plaintext highlighter-rouge">currentValue</code>는 현재 처리 중인 요소이다.</p>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">functools</code> 모듈의 <code class="language-plaintext highlighter-rouge">reduce()</code> 함수를 사용해야 한다. (Python 3.x부터 내장 함수에서 모듈로 이동했다)</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">sum_value</span> <span class="o">=</span> <span class="nf">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">current_value</span><span class="p">:</span> <span class="n">accumulator</span> <span class="o">+</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># sum_value: 15
# 0은 초기값(initializer)이다.
</span></code></pre></div>    </div>

    <p>물론, 합계를 구하는 경우 파이썬의 내장 함수 <code class="language-plaintext highlighter-rouge">sum()</code>을 쓰는 것이 훨씬 간단하고 효율적이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sum_value</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># 결과: 15
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="typescript-vs-python-연결-리스트linked-list-구현-및-사용법">TypeScript vs. Python: 연결 리스트(Linked List) 구현 및 사용법</h3>
<p>TypeScript와 Python 모두 <strong>연결 리스트(Linked List)를 직접 구현해야 한다는 점은 동일하다.</strong> 두 언어 모두 배열(리스트)과 달리 내장된 연결 리스트 자료 구조를 제공하지 않기 때문. 하지만 <strong>TypeScript는 타입 시스템을 활용해 노드(Node)의 구조를 명확하게 정의하여 안정성을 높이는 반면, Python은 간결한 문법으로 더 빠르게 구현할 수 있다.</strong></p>

<p>연결 리스트는 각 요소가 데이터와 다음 요소를 가리키는 포인터(참조)를 함께 가지고 있는 선형 자료 구조이다. 배열과 달리 메모리에 연속적으로 위치하지 않아 삽입과 삭제가 효율적이다.</p>

<h4 id="1-노드node와-리스트-구조-정의">1. 노드(Node)와 리스트 구조 정의</h4>

<p>연결 리스트를 구현하는 첫 단계는 기본 단위인 <strong>노드</strong>를 정의하는 것이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">interface</code>나 <code class="language-plaintext highlighter-rouge">class</code>를 사용해 노드의 형태를 명확하게 정의한다. 타입 시스템 덕분에 <code class="language-plaintext highlighter-rouge">value</code>의 타입과 <code class="language-plaintext highlighter-rouge">next</code> 포인터가 <code class="language-plaintext highlighter-rouge">Node</code> 혹은 <code class="language-plaintext highlighter-rouge">null</code>임을 강제할 수 있다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 노드의 구조 정의</span>
<span class="kr">interface</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="nl">next</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 노드 클래스</span>
<span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="k">public</span> <span class="na">next</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 연결 리스트 클래스</span>
<span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">head</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">// ... 추가적인 메서드들</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">class</code>를 사용하여 노드를 정의한다. 타입 힌트(<code class="language-plaintext highlighter-rouge">Type Hint</code>)를 사용할 수는 있지만, TypeScript처럼 강제되지는 않는다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 노드 클래스
</span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># 연결 리스트 클래스
</span><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># ... 추가적인 메서드들
</span></code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-핵심-연산-노드-추가-및-순회">2. 핵심 연산: 노드 추가 및 순회</h4>

<p>가장 기본적인 연산인 ‘맨 뒤에 노드 추가’와 ‘리스트 순회’를 비교해 본다. 로직 자체는 동일하지만, 코드의 세부적인 표현에서 차이가 나타난다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 타입 검사를 통과해야 하므로 <code class="language-plaintext highlighter-rouge">null</code> 체크가 명시적으로 이루어진다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">head</span><span class="p">:</span> <span class="nx">Node</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="c1">// 맨 뒤에 노드 추가</span>
  <span class="k">public</span> <span class="nf">append</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">current</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 리스트 순회 및 출력</span>
  <span class="k">public</span> <span class="nf">printAll</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="kd">const</span> <span class="na">values</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">values</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> -&gt; </span><span class="dl">'</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: 문법이 더 간결하며, <code class="language-plaintext highlighter-rouge">None</code>을 활용한 <code class="language-plaintext highlighter-rouge">null</code> 체크가 자연스럽게 이루어진다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># 맨 뒤에 노드 추가
</span>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="k">return</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">new_node</span>
            
    <span class="c1"># 리스트 순회 및 출력
</span>    <span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s"> -&gt; </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>결론적으로, 두 언어 모두 동일한 자료 구조의 원리를 따라 연결 리스트를 구현한다. TypeScript는 제네릭(<code class="language-plaintext highlighter-rouge">T</code>)과 인터페이스를 통해 재사용 가능하고 타입-안전(type-safe)한 코드를 작성하도록 유도하는 반면, Python은 더 적은 코드로 빠르게 핵심 로직을 구현하는 데 강점을 보인다.</p>

<h3 id="typescript-vs-python-스택stack-구현-및-사용법">TypeScript vs. Python: 스택(Stack) 구현 및 사용법</h3>

<p>스택(Stack) 역시 TypeScript와 Python 모두 내장된 자료 구조가 아니므로, <strong>배열(리스트)을 활용하여 직접 구현하는 것이 일반적이다.</strong> 두 언어의 구현 방식은 매우 유사하며, 핵심적인 차이는 <strong>TypeScript의 타입-안전성(Type-Safety)과 Python의 간결함</strong>에서 비롯된다.</p>

<p>스택은 ‘마지막에 들어온 것이 가장 먼저 나가는’(LIFO, Last-In, First-Out) 원칙을 따르는 자료 구조이다. 접시를 쌓고 위에서부터 차례로 꺼내는 것을 생각하면 이해하기 쉽다.</p>

<h4 id="1-스택의-구현-방식">1. 스택의 구현 방식</h4>

<p>배열(리스트)의 끝에서 데이터를 추가하고 제거하는 <code class="language-plaintext highlighter-rouge">push</code>와 <code class="language-plaintext highlighter-rouge">pop</code> 연산은 스택의 LIFO 동작 원리와 완벽하게 일치한다. 따라서 배열을 감싸는(wrapping) 클래스를 만들어 스택을 구현하는 것이 가장 효율적이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 제네릭(<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>)을 사용하여 어떤 타입의 데이터든 담을 수 있는 타입-안전한 스택 클래스를 정의한다. 내부 배열을 <code class="language-plaintext highlighter-rouge">private</code>으로 선언하여 외부에서 직접 접근하는 것을 막고, <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code> 같은 메서드를 통해서만 조작하도록 캡슐화하는 것이 일반적이다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 스택에 데이터 추가 (push)</span>
  <span class="nf">push</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 스택에서 데이터 추출 (pop)</span>
  <span class="nf">pop</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 스택의 가장 위 데이터 확인 (peek)</span>
  <span class="nf">peek</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 스택이 비어있는지 확인</span>
  <span class="nf">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: Python의 리스트는 그 자체로 스택처럼 사용될 수 있다. <code class="language-plaintext highlighter-rouge">append()</code> 메서드가 <code class="language-plaintext highlighter-rouge">push</code> 역할을, <code class="language-plaintext highlighter-rouge">pop()</code> 메서드가 <code class="language-plaintext highlighter-rouge">pop</code> 역할을 한다. 가독성과 재사용성을 위해 클래스로 감싸는 것이 좋은 관례이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 관례적으로 _ 를 붙여 내부에서만 사용함을 표시
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 스택에 데이터 추가 (push)
</span>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># 스택에서 데이터 추출 (pop)
</span>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="c1"># 혹은 예외 발생
</span>
    <span class="c1"># 스택의 가장 위 데이터 확인 (peek)
</span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 음수 인덱싱 활용
</span>        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 스택이 비어있는지 확인
</span>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-핵심-연산-비교">2. 핵심 연산 비교</h4>

<p>스택의 핵심 연산인 <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code>, <code class="language-plaintext highlighter-rouge">peek</code>를 비교하면 두 언어의 철학 차이가 드러난다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">TypeScript</th>
      <th style="text-align: left">Python (List 기반)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**Push (추가)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items.push(item)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items.append(item)</code></td>
      <td style="text-align: left">TypeScript는 <code class="language-plaintext highlighter-rouge">push</code>, Python은 <code class="language-plaintext highlighter-rouge">append</code>를 사용하여 배열(리스트)의 끝에 요소를 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**Pop (추출)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items.pop()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items.pop()</code></td>
      <td style="text-align: left">두 언어 모두 동일한 이름의 <code class="language-plaintext highlighter-rouge">pop()</code> 메서드를 사용하며, 배열의 마지막 요소를 제거하고 반환한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**Peek (확인)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items[items.length - 1]</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items[-1]</code></td>
      <td style="text-align: left">Python의 음수 인덱싱(<code class="language-plaintext highlighter-rouge">-1</code>)이 마지막 요소를 가리키므로 코드가 더 간결하다.</td>
    </tr>
  </tbody>
</table>

<p>결론적으로, 스택을 구현하는 알고리즘은 두 언어에서 동일하다. TypeScript는 정적 타입을 통해 의도치 않은 타입의 데이터가 스택에 들어오는 것을 컴파일 시점에 막아주어 안정성을 높여준다. 반면, Python은 특유의 간결한 문법(음수 인덱싱 등)을 통해 더 빠르게 코드를 작성할 수 있는 장점이 있다.</p>

<blockquote>
  <p>언더바(<code class="language-plaintext highlighter-rouge">_</code>)의 의미</p>
  <ul>
    <li>싱글 언더스코어 : <code class="language-plaintext highlighter-rouge">_var</code>(보호된 멤버)
  클래스 상에서 싱글 언더스코어는 보호된 멤버라는 뜻, 즉, 내부 사용용이니 조심히 사용하는 것을 권장한다는 의미를 내포함. 클래스 서계자의 의도와 다르게 사용될 수 있으니 주의가 필요함.</li>
    <li>더블 언더스코어 : <code class="language-plaintext highlighter-rouge">__var</code>(비공개 멤버)
  외부에서 사용을 적극적으로 막기 위해 사용되는 케이스. Python 인터프리터가 이 변수의 이름을 Name Mangling 이라는 기술로, 사용시 내부적으로 <code class="language-plaintext highlighter-rouge">__items</code> 를 <code class="language-plaintext highlighter-rouge">__ClassName__items</code> 로 형태를 바꾸며, 사용시 AttributeError 가 발생될 수 있다.</li>
  </ul>
</blockquote>

<h3 id="typescript-vs-python-큐queue-구현-및-사용법">TypeScript vs. Python: 큐(Queue) 구현 및 사용법</h3>
<p>큐(Queue)를 구현할 때, <strong>Python은 <code class="language-plaintext highlighter-rouge">collections</code> 모듈에 포함된 <code class="language-plaintext highlighter-rouge">deque</code>라는 매우 효율적인 자료 구조를 기본으로 제공한다.</strong> 반면, <strong>TypeScript는 내장된 큐 자료 구조가 없어 개발자가 직접 구현해야 하며, 간단한 배열(Array)을 사용하거나 성능을 위해 연결 리스트(Linked List)를 기반으로 만들어야 한다.</strong></p>

<p>큐는 ‘가장 먼저 들어온 것이 가장 먼저 나가는’(FIFO, First-In, First-Out) 원칙을 따르는 자료 구조이다. 은행 창구나 놀이공원의 줄서기를 생각하면 쉽게 이해할 수 있다.</p>

<h4 id="1-큐-구현-방식의-핵심-차이">1. 큐 구현 방식의 핵심 차이</h4>

<p>큐의 핵심은 한쪽 끝(rear)에서는 데이터를 추가하고, 반대쪽 끝(front)에서는 데이터를 제거하는 것이다. 이 “앞에서 제거하는” 연산 때문에 일반적인 배열(리스트)을 사용하면 성능 문제가 발생할 수 있다.</p>

<ul>
  <li><strong>배열의 비효율성</strong>: 배열의 맨 앞 요소를 제거(<code class="language-plaintext highlighter-rouge">shift()</code> 또는 <code class="language-plaintext highlighter-rouge">pop(0)</code>)하면, 그 뒤의 모든 요소들을 한 칸씩 앞으로 당겨야 한다. 이 작업은 배열의 크기가 클수록 오래 걸리는, 즉 성능이 좋지 않은 연산(시간 복잡도 O(n))이다.</li>
  <li><strong>Python의 해결책</strong>: Python은 이러한 문제를 해결하기 위해 양쪽 끝에서 데이터를 추가하고 제거하는 속도(O(1))가 매우 빠른 <code class="language-plaintext highlighter-rouge">deque</code>(데크, double-ended queue)를 제공한다.</li>
  <li><strong>TypeScript의 선택지</strong>: TypeScript는 개발자가 상황에 맞게 구현 방식을 선택해야 한다.
    <ol>
      <li><strong>간단한 구현</strong>: 배열의 <code class="language-plaintext highlighter-rouge">shift()</code> 메서드를 사용해 간단히 구현 (데이터가 적을 때 유용).</li>
      <li><strong>성능적 구현</strong>: 이전에 다룬 연결 리스트를 기반으로 직접 구현 (데이터가 많고 성능이 중요할 때).</li>
    </ol>
  </li>
</ul>

<hr />

<h4 id="2-python-collectionsdeque-활용">2. Python: <code class="language-plaintext highlighter-rouge">collections.deque</code> 활용</h4>

<p>Python에서 큐를 구현할 때는 <code class="language-plaintext highlighter-rouge">deque</code>를 사용하는 것이 가장 표준적이고 효율적인 방법이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># deque 객체를 내부에서 사용한다.
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_items</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>

    <span class="c1"># 큐의 뒤쪽에 데이터 추가 (enqueue)
</span>    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># 큐의 앞쪽에서 데이터 추출 (dequeue)
</span>    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="c1"># popleft()는 O(1) 시간 복잡도를 가진다.
</span>            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 큐의 가장 앞 데이터 확인 (peek)
</span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 큐가 비어있는지 확인
</span>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span>
</code></pre></div></div>

<hr />

<h4 id="3-typescript-배열-또는-연결-리스트-활용">3. TypeScript: 배열 또는 연결 리스트 활용</h4>

<p>TypeScript에서는 내장된 <code class="language-plaintext highlighter-rouge">deque</code>가 없으므로, 두 가지 방식으로 접근할 수 있다.</p>

<h5 id="1-배열을-이용한-간단한-구현">1. 배열을 이용한 간단한 구현</h5>

<p>가장 직관적이고 빠르게 구현할 수 있는 방법이지만, 성능 저하의 가능성을 인지하고 있어야 한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 큐의 뒤쪽에 데이터 추가 (enqueue)</span>
  <span class="nf">enqueue</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 큐의 앞쪽에서 데이터 추출 (dequeue)</span>
  <span class="nf">dequeue</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="c1">// shift()는 O(n)의 시간 복잡도를 가져 성능에 불리할 수 있다.</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 큐의 가장 앞 데이터 확인 (peek)</span>
  <span class="nf">peek</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 큐가 비어있는지 확인</span>
  <span class="nf">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-성능을-위한-연결-리스트-기반-구현">2. 성능을 위한 연결 리스트 기반 구현</h5>

<p>데이터의 양이 많고, 추가/삭제가 빈번하게 일어나는 등 성능이 중요한 상황에서는 연결 리스트를 기반으로 큐를 구현하는 것이 정석이다. 연결 리스트의 <code class="language-plaintext highlighter-rouge">head</code>에서 노드를 제거하고(<code class="language-plaintext highlighter-rouge">dequeue</code>), <code class="language-plaintext highlighter-rouge">tail</code>에 새로운 노드를 추가(<code class="language-plaintext highlighter-rouge">enqueue</code>)하는 방식이다. 이 경우, 두 연산 모두 O(1)의 빠른 시간 복잡도를 보장받을 수 있다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[자료구조와 알고리즘 (feat, TS와 Python 을 얹은)]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차 (3)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-03.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차 (3)" /><published>2025-09-09T00:00:00+00:00</published><updated>2025-09-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-03.html"><![CDATA[<h2 id="자료구조와-알고리즘-feat-ts와-python-을-얹은">자료구조와 알고리즘 (feat, TS와 Python 을 얹은)</h2>

<h3 id="typescript-vs-python-해시-테이블hash-table-사용법">TypeScript vs. Python: 해시 테이블(Hash Table) 사용법</h3>
<p>Python과 TypeScript 모두 해시 테이블(Hash Table) 기능을 언어의 핵심적인 내장 기능으로 제공한다.** Python은 <strong>딕셔너리(<code class="language-plaintext highlighter-rouge">dict</code>)가 이 역할을 수행하며, TypeScript(JavaScript)에서는 일반 객체(<code class="language-plaintext highlighter-rouge">Object</code>)와 더불어 <code class="language-plaintext highlighter-rouge">Map</code> 객체</strong>를 사용하는 것이 정석이다. <code class="language-plaintext highlighter-rouge">Map</code> 객체는 키(key)의 타입이 자유롭다는 점에서 Python의 딕셔너리와 더 유사하다.</p>

<p>해시 테이블은 <strong>Key-Value 쌍</strong>으로 데이터를 저장하는 자료 구조로, 키를 해시 함수(Hash Function)에 통과시켜 얻은 인덱스(Index)에 값을 저장한다. 이 방식 덕분에 데이터의 추가, 검색, 삭제가 평균적으로 매우 빠른 시간 복잡도(O(1))를 가진다.</p>

<h4 id="1-해시-테이블의-선언과-초기화">1. 해시 테이블의 선언과 초기화</h4>

<p>두 언어 모두 직관적인 문법으로 해시 테이블을 생성할 수 있다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: 중괄호 <code class="language-plaintext highlighter-rouge">{}</code>를 사용하여 딕셔너리를 생성하는 것이 가장 일반적이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 빈 딕셔너리 생성
</span><span class="n">hash_table</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># 초기 값을 가진 딕셔너리 생성
</span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">is_active</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript</strong>: JavaScript의 <code class="language-plaintext highlighter-rouge">Map</code> 객체를 사용하는 것이 가장 강력하고 권장되는 방법이다. <code class="language-plaintext highlighter-rouge">Map</code>은 모든 타입의 값을 키로 사용할 수 있어 유연성이 높다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 빈 Map 생성 (key: string, value: any)</span>
<span class="kd">const</span> <span class="nx">hashTable</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// 초기 값을 가진 Map 생성</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span><span class="o">&gt;</span><span class="p">([</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">isActive</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">]</span>
<span class="p">]);</span>
</code></pre></div>    </div>

    <p>물론, JavaScript의 일반 객체(<code class="language-plaintext highlighter-rouge">{}</code>)도 해시 테이블처럼 사용할 수 있지만, 키가 문자열이나 심볼(Symbol) 타입으로 제한되는 단점이 있다.</p>
  </li>
</ul>

<hr />

<h4 id="2-데이터-추가-접근-삭제">2. 데이터 추가, 접근, 삭제</h4>

<p>Key를 이용해 데이터를 조작하는 방식은 두 언어가 매우 유사하다.</p>

<ul>
  <li>
    <p><strong>Python</strong>:</p>

    <ul>
      <li><strong>추가/수정</strong>: <code class="language-plaintext highlighter-rouge">hash_table[key] = value</code></li>
      <li><strong>접근</strong>: <code class="language-plaintext highlighter-rouge">hash_table[key]</code> (키가 없으면 <code class="language-plaintext highlighter-rouge">KeyError</code> 발생) 또는 <code class="language-plaintext highlighter-rouge">hash_table.get(key)</code> (키가 없으면 <code class="language-plaintext highlighter-rouge">None</code> 반환)</li>
      <li><strong>삭제</strong>: <code class="language-plaintext highlighter-rouge">del hash_table[key]</code></li>
    </ul>

    <!-- end list -->

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>

<span class="c1"># 추가/수정
</span><span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span>
<span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">city</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Seoul</span><span class="sh">"</span>

<span class="c1"># 접근
</span><span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">])</span>       <span class="c1"># "John Doe"
</span><span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">email</span><span class="sh">"</span><span class="p">))</span>  <span class="c1"># None
</span>
<span class="c1"># 삭제
</span><span class="k">del</span> <span class="n">user</span><span class="p">[</span><span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="c1"># {'name': 'John Doe', 'city': 'Seoul'}
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript (<code class="language-plaintext highlighter-rouge">Map</code> 객체 기준)</strong>:</p>

    <ul>
      <li><strong>추가/수정</strong>: <code class="language-plaintext highlighter-rouge">hashTable.set(key, value)</code></li>
      <li><strong>접근</strong>: <code class="language-plaintext highlighter-rouge">hashTable.get(key)</code> (키가 없으면 <code class="language-plaintext highlighter-rouge">undefined</code> 반환)</li>
      <li><strong>삭제</strong>: <code class="language-plaintext highlighter-rouge">hashTable.delete(key)</code></li>
      <li><strong>키 존재 여부 확인</strong>: <code class="language-plaintext highlighter-rouge">hashTable.has(key)</code></li>
    </ul>

    <!-- end list -->

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// 추가/수정</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span> <span class="c1">// 수정</span>

<span class="c1">// 접근</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// "Jane Doe"</span>

<span class="c1">// 키 존재 여부 확인</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>

<span class="c1">// 삭제</span>
<span class="nx">user</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span> <span class="c1">// Map(1) { 'name' =&gt; 'Jane Doe' }</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="3-순회-iteration">3. 순회 (Iteration)</h4>

<p>해시 테이블의 모든 Key-Value 쌍을 순회하는 방법도 유사한 패턴을 가진다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">for</code> 루프와 함께 <code class="language-plaintext highlighter-rouge">.keys()</code>, <code class="language-plaintext highlighter-rouge">.values()</code>, <code class="language-plaintext highlighter-rouge">.items()</code> 메서드를 활용한다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>

<span class="c1"># Key 순회
</span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">user</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># name, age
</span>      
<span class="c1"># Value 순회
</span><span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">user</span><span class="p">.</span><span class="nf">values</span><span class="p">():</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># "John Doe", 30
</span>      
<span class="c1"># Key, Value 동시 순회
</span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">user</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
  <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript (<code class="language-plaintext highlighter-rouge">Map</code> 객체 기준)</strong>: <code class="language-plaintext highlighter-rouge">forEach</code> 루프나 <code class="language-plaintext highlighter-rouge">for...of</code> 구문을 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span><span class="p">([</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="p">]);</span>

<span class="c1">// forEach 사용 (value, key 순서)</span>
<span class="nx">user</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// for...of 사용 (key, value 순서)</span>
<span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="typescript-vs-python-트리tree-구조-구현-및-사용법">TypeScript vs. Python: 트리(Tree) 구조 구현 및 사용법</h3>

<p><strong>Python과 TypeScript 모두 트리(Tree)는 내장된 자료 구조가 아니므로, 일반적으로 클래스(Class)를 이용해 직접 노드(Node)와 트리 관계를 정의하여 구현해야 한다.</strong> 두 언어의 구현 로직은 거의 동일하지만, <strong>TypeScript는 제네릭과 타입 시스템을 통해 노드가 가질 데이터의 타입을 명확히 하여 안정성을 확보</strong>하는 반면, <strong>Python은 더 간결하고 유연한 코드로 빠르게 구현</strong>할 수 있다는 점에서 차이를 보인다.</p>

<p>트리는 이름 그대로 나무를 뒤집어 놓은 듯한 계층적 자료 구조이다. 최상위 노드인 루트(Root)에서 시작해 여러 자식 노드(Child Node)가 가지처럼 뻗어 나가는 형태를 가진다. 이진 트리(Binary Tree), 이진 탐색 트리(Binary Search Tree) 등 다양한 종류가 있지만, 여기서는 가장 기본이 되는 노드와 트리 구조의 구현에 초점을 맞춘다.</p>

<h4 id="1-노드node-및-트리tree-클래스-정의">1. 노드(Node) 및 트리(Tree) 클래스 정의</h4>

<p>트리를 구성하는 가장 기본 단위는 데이터와 자식 노드들의 참조를 담고 있는 ‘노드’이다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: 클래스를 이용해 간단하게 노드를 정의할 수 있다. 자식 노드들은 보통 리스트(list)로 관리한다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 트리 노드 클래스
</span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 자식 노드를 담을 리스트
</span>
    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">child_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child_node</span><span class="p">)</span>

<span class="c1"># 트리 클래스 (루트 노드를 가짐)
</span><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root_node</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript</strong>: 제네릭(<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>)을 활용하여 노드가 담을 데이터의 타입을 지정하고, <code class="language-plaintext highlighter-rouge">children</code> 배열 역시 해당 노드 타입의 배열임을 명시하여 타입 안정성을 높인다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 트리 노드 클래스</span>
<span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="k">public</span> <span class="na">children</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 자식 노드를 담을 배열</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">addChild</span><span class="p">(</span><span class="na">childNode</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">childNode</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 트리 클래스</span>
<span class="kd">class</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">root</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">rootNode</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="nx">rootNode</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-트리-순회-tree-traversal">2. 트리 순회 (Tree Traversal)</h4>

<p>트리의 모든 노드를 방문하는 것을 순회(Traversal)라고 한다. 대표적인 방법으로 깊이 우선 탐색(DFS, Depth-First Search)과 너비 우선 탐색(BFS, Breadth-First Search)이 있다. 여기서는 DFS를 재귀(Recursion) 방식으로 구현하는 예를 보인다.</p>

<ul>
  <li>
    <p><strong>Python</strong>: 재귀 호출을 이용해 간결하게 DFS를 구현할 수 있다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root_node</span>

    <span class="c1"># 깊이 우선 탐색 (DFS)
</span>    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">):</span>
        <span class="c1"># 현재 노드의 값을 출력 (또는 다른 작업 수행)
</span>        <span class="nf">print</span><span class="p">(</span><span class="n">start_node</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
            
        <span class="c1"># 자식 노드들을 재귀적으로 방문
</span>        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">start_node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="c1"># 사용 예시
</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="sh">"</span><span class="s">E</span><span class="sh">"</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">add_child</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">tree</span> <span class="o">=</span> <span class="nc">Tree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="n">tree</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">root</span><span class="p">)</span> <span class="c1"># 결과: A B D E C
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>TypeScript</strong>: 로직은 Python과 동일하지만, 노드의 타입을 명시하여 코드의 명확성을 높인다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">root</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ... 생성자 ...</span>

  <span class="c1">// 깊이 우선 탐색 (DFS)</span>
  <span class="k">public</span> <span class="nf">dfs</span><span class="p">(</span><span class="na">startNode</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c1">// 현재 노드의 값을 출력 (또는 다른 작업 수행)</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">startNode</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="s2"> `</span><span class="p">);</span>

    <span class="c1">// 자식 노드들을 재귀적으로 방문</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">startNode</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 사용 예시</span>
<span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">root</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="nx">root</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">D</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">E</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">addChild</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tree</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">root</span><span class="p">);</span> <span class="c1">// 결과: A B D E C</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="힙heap-구현-및-사용법">힙(Heap) 구현 및 사용법</h3>
<p>힙(Heap)의 경우, <strong>Python은 <code class="language-plaintext highlighter-rouge">heapq</code>라는 강력한 내장 라이브러리를 제공</strong>하여 즉시 사용 가능하지만, <strong>TypeScript는 직접 클래스로 구현해야 한다.</strong></p>

<p>힙은 ‘완전 이진 트리’의 일종으로, 부모 노드의 값이 항상 자식 노드의 값보다 작거나 같은(최소 힙, Min Heap) 혹은 크거나 같은(최대 힙, Max Heap) 속성을 만족하는 자료 구조이다. 우선순위 큐(Priority Queue)를 구현하는 데 주로 사용된다.</p>

<h4 id="1-python-heapq-모듈-활용">1. Python: <code class="language-plaintext highlighter-rouge">heapq</code> 모듈 활용</h4>

<p>Python은 <code class="language-plaintext highlighter-rouge">heapq</code> 모듈을 통해 일반 리스트를 최소 힙처럼 다룰 수 있는 함수들을 제공한다. 이는 매우 효율적이고 파이썬다운(Pythonic) 방식이다.</p>

<ul>
  <li><strong>핵심</strong>: 별도의 힙 클래스 없이, <strong>일반 리스트를 <code class="language-plaintext highlighter-rouge">heapq</code> 함수에 전달하여</strong> 힙 연산을 수행한다.</li>
</ul>

<!-- end list -->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># heapq 모듈은 최소 힙(Min Heap)을 기본으로 한다.
</span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 힙에 원소 추가 (heappush)
</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="c1"># 결과: [1, 3, 7, 4] (힙 속성을 만족하는 리스트)
</span>
<span class="c1"># 힙에서 가장 작은 원소 삭제 및 반환 (heappop)
</span><span class="n">smallest</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">smallest</span><span class="p">)</span> <span class="c1"># 결과: 1
</span><span class="nf">print</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>     <span class="c1"># 결과: [3, 4, 7]
</span></code></pre></div></div>

<h4 id="2-typescript-직접-클래스로-구현">2. TypeScript: 직접 클래스로 구현</h4>

<p>TypeScript는 내장 힙이 없으므로, 배열을 기반으로 힙의 핵심 연산(sift-up, sift-down)을 포함하는 클래스를 직접 구현해야 한다.</p>

<ul>
  <li><strong>핵심</strong>: <code class="language-plaintext highlighter-rouge">insert</code> 시에는 추가된 노드를 부모와 비교하며 위로 올리고(<code class="language-plaintext highlighter-rouge">siftUp</code>), <code class="language-plaintext highlighter-rouge">delete</code> 시에는 루트 노드를 제거한 뒤 마지막 노드를 루트로 가져와 자식과 비교하며 아래로 내린다(<code class="language-plaintext highlighter-rouge">siftDown</code>).</li>
</ul>

<!-- end list -->

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최소 힙 (Min Heap) 구현</span>
<span class="kd">class</span> <span class="nc">MinHeap</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">heap</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 부모-자식 인덱스 계산을 위한 헬퍼 함수들</span>
  <span class="k">private</span> <span class="nf">getParentIndex</span><span class="p">(</span><span class="na">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">getLeftChildIndex</span><span class="p">(</span><span class="na">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">getRightChildIndex</span><span class="p">(</span><span class="na">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">swap</span><span class="p">(</span><span class="na">i1</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="na">i2</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i1</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i2</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i2</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i1</span><span class="p">]];</span> <span class="p">}</span>

  <span class="c1">// 힙에 원소 추가</span>
  <span class="k">public</span> <span class="nf">insert</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">siftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 가장 작은 원소(루트) 삭제</span>
  <span class="k">public</span> <span class="k">delete</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">deletedValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">siftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">deletedValue</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="nf">siftUp</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="cm">/* ... 부모와 비교하며 위로 올리는 로직 ... */</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nf">siftDown</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="cm">/* ... 자식과 비교하며 아래로 내리는 로직 ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="그래프graph-구현-및-사용법">그래프(Graph) 구현 및 사용법</h3>

<p>그래프(Graph)는 두 언어 모두 내장 기능이 없어 <strong>직접 구현</strong>해야 하며, 주로 Python은 딕셔너리(<code class="language-plaintext highlighter-rouge">dict</code>)를, <strong>TypeScript는 <code class="language-plaintext highlighter-rouge">Map</code> 객체</strong>를 이용해 인접 리스트(Adjacency List) 형태로 표현하는 것이 일반적이다.</p>

<p>그래프는 정점(Vertex 또는 Node)과 그 정점을 연결하는 간선(Edge)의 집합으로 이루어진 자료 구조이다. 소셜 네트워크, 지하철 노선도 등이 그래프의 대표적인 예이다.</p>

<h4 id="1-python-딕셔너리를-이용한-인접-리스트">1. Python: 딕셔너리를 이용한 인접 리스트</h4>

<p>Python에서는 딕셔너리를 사용하여 각 정점을 키(key)로, 해당 정점에 인접한 정점들의 리스트를 값(value)으로 가지는 인접 리스트(Adjacency List) 방식으로 그래프를 표현하는 것이 매우 일반적이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 키: 정점, 값: 인접 정점 리스트
</span>        <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vertex1</span><span class="p">,</span> <span class="n">vertex2</span><span class="p">):</span>
        <span class="c1"># 무방향 그래프(Undirected Graph)의 경우 양쪽에 모두 추가
</span>        <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">vertex1</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">vertex2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">vertex2</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">vertex1</span><span class="p">)</span>

<span class="c1"># 사용 예시
</span><span class="n">graph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">adjacency_list</span><span class="p">)</span> 
<span class="c1"># 결과: {'A': ['B'], 'B': ['A', 'C'], 'C': ['B']}
</span></code></pre></div></div>

<h4 id="2-typescript-map-객체를-이용한-인접-리스트">2. TypeScript: <code class="language-plaintext highlighter-rouge">Map</code> 객체를 이용한 인접 리스트</h4>

<p>TypeScript에서는 키의 타입이 자유로운 <code class="language-plaintext highlighter-rouge">Map</code> 객체를 사용하여 인접 리스트를 구현하는 것이 가장 유연하고 안정적인 방법이다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Graph</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// 키: 정점, 값: 인접 정점 배열</span>
  <span class="k">private</span> <span class="na">adjacencyList</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>

  <span class="k">public</span> <span class="nf">addVertex</span><span class="p">(</span><span class="na">vertex</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">vertex</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">vertex</span><span class="p">,</span> <span class="p">[]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">addEdge</span><span class="p">(</span><span class="na">vertex1</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">vertex2</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c1">// 무방향 그래프(Undirected Graph)의 경우</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">)?.</span><span class="nf">push</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjacencyList</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">vertex2</span><span class="p">)?.</span><span class="nf">push</span><span class="p">(</span><span class="nx">vertex1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 사용 예시</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">graph</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">graph</span><span class="p">);</span> 
<span class="cm">/* 결과: 
Graph {
  adjacencyList: Map(3) { 'A' =&gt; [ 'B' ], 'B' =&gt; [ 'A', 'C' ], 'C' =&gt; [ 'B' ] }
}
*/</span>
</code></pre></div></div>

<h3 id="python-자료-구조별-구현-특징-요약">Python 자료 구조별 구현 특징 요약</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">자료 구조</th>
      <th style="text-align: left">구현 방식 및 특징</th>
      <th style="text-align: left">관련 라이브러리 및 설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**배열**&lt;br&gt;(Array)</td>
      <td style="text-align: left">내장 타입인 <code class="language-plaintext highlighter-rouge">list</code>를 사용한다. 크기가 동적으로 변하며, 모든 타입의 데이터를 담을 수 있는 동적 배열이다.</td>
      <td style="text-align: left">내장 <code class="language-plaintext highlighter-rouge">list</code>: 기본적으로 사용.<code class="language-plaintext highlighter-rouge">array</code> 모듈: C와 유사한 단일 타입의 고정 배열이 필요할 때 사용.</td>
    </tr>
    <tr>
      <td style="text-align: left">연결 리스트&lt;br&gt;(Linked List)</td>
      <td style="text-align: left">내장 기능이 없어 <code class="language-plaintext highlighter-rouge">Node</code> 클래스를 직접 정의하여 구현한다. 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가진다.</td>
      <td style="text-align: left">(직접 구현): 별도의 표준 라이브러리가 없어 직접 구현이 일반적이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">스택&lt;br&gt;(Stack)</td>
      <td style="text-align: left">내장 **<code class="language-plaintext highlighter-rouge">list</code>**를 그대로 사용한다. <code class="language-plaintext highlighter-rouge">append()</code>가 <code class="language-plaintext highlighter-rouge">push</code> 역할을, <code class="language-plaintext highlighter-rouge">pop()</code>이 <code class="language-plaintext highlighter-rouge">pop</code> 역할을 하여 LIFO 구조를 자연스럽게 만족한다.</td>
      <td style="text-align: left">내장 <code class="language-plaintext highlighter-rouge">list</code>: 스택을 위한 완벽한 기능을 제공하므로 별도 라이브러리가 불필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">큐&lt;br&gt;(Queue)</td>
      <td style="text-align: left">**<code class="language-plaintext highlighter-rouge">list</code>**의 <code class="language-plaintext highlighter-rouge">pop(0)</code>는 비효율적이므로, 양방향 데이터 입출력이 빠른 <code class="language-plaintext highlighter-rouge">deque</code> 객체를 사용하는 것이 정석이다.</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">collections.deque</code>: <code class="language-plaintext highlighter-rouge">append()</code> (enqueue)와 <code class="language-plaintext highlighter-rouge">popleft()</code> (dequeue) 연산이 모두 O(1) 시간 복잡도를 가지는 최적의 라이브러리이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">해시 테이블&lt;br&gt;(Hash Table)</td>
      <td style="text-align: left">내장 타입인 <code class="language-plaintext highlighter-rouge">dict</code>를 사용한다. Key-Value 쌍으로 데이터를 저장하며, 매우 빠른 속도로 데이터를 검색, 추가, 삭제할 수 있다.</td>
      <td style="text-align: left">내장 <code class="language-plaintext highlighter-rouge">dict</code>: 기본 해시 테이블. <code class="language-plaintext highlighter-rouge">collections.defaultdict</code>: 존재하지 않는 키를 조회할 때 기본값을 자동으로 생성해준다.</td>
    </tr>
    <tr>
      <td style="text-align: left">트리&lt;br&gt;(Tree)</td>
      <td style="text-align: left">내장 기능이 없어 <code class="language-plaintext highlighter-rouge">TreeNode</code> 클래스를 직접 정의하여 구현한다. 노드가 데이터와 자식 노드 리스트(또는 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 포인터)를 가진다.</td>
      <td style="text-align: left">(직접 구현): 목적에 맞는 트리(이진 트리, 이진 탐색 트리 등)를 직접 클래스로 구현해야 한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">힙&lt;br&gt;(Heap)</td>
      <td style="text-align: left">일반 **<code class="language-plaintext highlighter-rouge">list</code>**를 <code class="language-plaintext highlighter-rouge">heapq</code> 모듈의 함수들로 제어하여 최소 힙(Min Heap)으로 사용한다. 리스트 자체가 힙이 되는 방식이다.</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">heapq</code>: <code class="language-plaintext highlighter-rouge">heappush</code>, <code class="language-plaintext highlighter-rouge">heappop</code> 등의 함수를 통해 리스트를 효율적인 우선순위 큐로 만들어주는 표준 라이브러리이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">그래프&lt;br&gt;(Graph)</td>
      <td style="text-align: left">내장 기능이 없다. 주로 <code class="language-plaintext highlighter-rouge">dict</code>를 이용한 인접 리스트 방식으로 구현한다. 딕셔너리의 키는 정점, 값은 인접 정점 리스트이다.</td>
      <td style="text-align: left">(직접 구현): <code class="language-plaintext highlighter-rouge">dict</code>와 <code class="language-plaintext highlighter-rouge">list</code>를 조합해 직접 구현한다. 복잡한 분석이 필요하면 <code class="language-plaintext highlighter-rouge">networkx</code> 같은 전문 라이브러리를 사용한다.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[자료구조와 알고리즘 (feat, TS와 Python 을 얹은)]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/cs-09-02-01.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차" /><published>2025-09-08T00:00:00+00:00</published><updated>2025-09-08T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/cs-09-02-01</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/cs-09-02-01.html"><![CDATA[<h2 id="자료구조와-알고리즘">자료구조와 알고리즘</h2>

<h3 id="알고리즘-성능-분석">알고리즘 성능 분석</h3>
<p>알고리즘의 효율성을 객관적으로 평가하는 방법을 배우는 단계이다. 모든 자료구조와 알고리즘을 이해하는 데 기반이 된다.</p>

<ul>
  <li>시간 복잡도 (Time Complexity): 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 데이터의 크기와 연관 지어 표기하는 방법이다. (예: O(1), O(log n), O(n), O(n log n), O(n²))</li>
  <li>공간 복잡도 (Space Complexity): 알고리즘이 실행되는 동안 사용하는 메모리의 양을 표기하는 방법이다.</li>
</ul>

<h4 id="시간-복잡도time-complexity">시간 복잡도(Time Complexity)</h4>
<p>알고리즘을 실행하는데 필요한 연산횟수를 측정하는 것이다. 실제 실행시간이 아니고 빅오 표기법으로 사용하는데, 이는 데이터 크기(n)가 무한히 커졌을 때의 최악의 경우(worst-case)를 기준으로 성능을 표기하는 방법이다.</p>

<ul>
  <li>O(1) - 상수 시간 (Constant Time)
    <ul>
      <li>설명: 입력 데이터의 크기와 상관없이 항상 일정한 수의 연산만 수행한다. 가장 빠른 속도이다.</li>
      <li>예시: 배열의 특정 인덱스(arr[i])에 접근하는 것.</li>
    </ul>
  </li>
  <li>O(log n) - 로그 시간 (Logarithmic Time)
    <ul>
      <li>설명: 연산을 한 번 수행할 때마다 탐색해야 할 데이터의 양이 절반씩 줄어든다.</li>
      <li>예시: 정렬된 배열에서 <strong>이진 탐색(Binary Search)</strong>을 하는 경우.</li>
    </ul>
  </li>
  <li>O(n) - 선형 시간 (Linear Time)
    <ul>
      <li>설명: 입력 데이터의 크기(n)에 비례하여 연산 횟수가 증가한다.</li>
      <li>예시: 배열의 모든 요소를 한 번씩 순회하는 for 반복문.</li>
    </ul>
  </li>
  <li>O(n log n) - 로그 선형 시간 (Log-Linear Time)
    <ul>
      <li>설명: 데이터의 크기(n)에 log n을 곱한 만큼 연산 횟수가 증가한다. 대부분의 효율적인 정렬 알고리즘이 여기에 속한다.</li>
      <li>예시: 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort).</li>
    </ul>
  </li>
  <li>O(n²) - 이차 시간 (Quadratic Time)
    <ul>
      <li>설명: 입력 데이터의 크기(n)의 제곱에 비례하여 연산 횟수가 증가한다. 데이터가 커지면 성능이 급격히 저하됩니다.</li>
      <li>예시: 이중 for 반복문을 사용하여 배열의 모든 요소 쌍을 비교하는 경우 (예: 버블 정렬).</li>
    </ul>
  </li>
</ul>

<h4 id="공간-복잡도space-complexity">공간 복잡도(Space Complexity)</h4>
<p>알고리즘 실행될 때, 추가적으로 사용되는 메모리 양을 측정한다. 입력데이터 자체를 저장하는 공간은 계산에서 제외하며, 문제 해결을 위해 별도로 사용하는 메모리 공간을 기준으로 한다.</p>

<ul>
  <li>주요 공간 복잡도 예시
    <ul>
      <li>O(1) - 상수 공간(Constant Space)
        <ul>
          <li>설명 : 입력 데이터의 크기와 상관없이 일정한 양의 메모리 사용</li>
        </ul>
      </li>
      <li>O(n) - 선형 공간(Linear Space)
        <ul>
          <li>설명 : 입력 데이터 크기(n)에 비례하여 추가적인 메모리 공간이 필요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="시간과-공간의-관계trade-off">시간과 공간의 관계(Trade-off)</h4>
<p>알고리즘을 설계할 때 시간과 공간은 종종 상충관계를 가진다.</p>

<ul>
  <li>시간을 단축하려면 더 많은 메모리를 사용해야할 수 있다.</li>
  <li>메모리를 아끼려면 더 많은 연산을 수행해야 할 수도 있다.</li>
</ul>

<p>핵심은 그렇기에 문제의 요구사항이나 시스템 제약을 고려하여 시간 복잡도와 공간복잡도 사이의 균형을 맞추는게 중요하다.</p>

<h4 id="복잡도-계산-방법">복잡도 계산 방법</h4>

<p>복잡도 계산은 코드의 연산 횟수를 <code class="language-plaintext highlighter-rouge">n</code>에 대한 함수로 표현한 뒤, 빅오 표기법 규칙에 따라 단순화하는 과정이다.</p>

<p><strong>3단계 계산법</strong></p>

<ol>
  <li><strong>기본 연산 단위 찾기:</strong> 알고리즘의 핵심이 되는 반복적인 연산을 찾는다. (주로 반복문 내부)</li>
  <li><strong>연산 횟수를 ‘n’으로 표현하기:</strong> 입력 크기 <code class="language-plaintext highlighter-rouge">n</code>에 따라 기본 연산이 몇 번 수행되는지 식으로 표현한다. (예: <code class="language-plaintext highlighter-rouge">n² + n</code>)</li>
  <li><strong>빅오 표기법으로 단순화하기:</strong> 아래 두 규칙을 적용한다.
    <ul>
      <li><strong>규칙 1: 최고차항만 남긴다.</strong> <code class="language-plaintext highlighter-rouge">n² + n</code>에서 가장 영향력이 큰 <code class="language-plaintext highlighter-rouge">n²</code>만 남긴다.</li>
      <li><strong>규칙 2: 상수 계수를 제거한다.</strong> <code class="language-plaintext highlighter-rouge">2n</code>에서 계수 <code class="language-plaintext highlighter-rouge">2</code>를 제거하여 <code class="language-plaintext highlighter-rouge">n</code>으로 표기한다.</li>
    </ul>
  </li>
</ol>

<h4 id="파이썬-코드로-보는-계산-예시">파이썬 코드로 보는 계산 예시</h4>

<h5 id="예시-1-on"><strong>예시 1: O(n)</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">linear_example</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># 1. 기본 연산
</span>    <span class="k">return</span> <span class="n">total</span>
</code></pre></div></div>

<ul>
  <li><strong>연산 횟수:</strong> 기본 연산이 <code class="language-plaintext highlighter-rouge">n</code>번 반복되므로, 연산 횟수는 <code class="language-plaintext highlighter-rouge">n</code>이다.</li>
  <li><strong>빅오 표기:</strong> <code class="language-plaintext highlighter-rouge">O(n)</code>이다.</li>
</ul>

<h5 id="예시-2-on"><strong>예시 2: O(n²)</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quadratic_example</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 1. 기본 연산
</span>    <span class="k">return</span> <span class="n">count</span>
</code></pre></div></div>

<ul>
  <li><strong>연산 횟수:</strong> 기본 연산이 <code class="language-plaintext highlighter-rouge">n * n</code>번 반복되므로, 연산 횟수는 <code class="language-plaintext highlighter-rouge">n²</code>이다.</li>
  <li><strong>빅오 표기:</strong> <code class="language-plaintext highlighter-rouge">O(n²)</code>이다.</li>
</ul>

<h5 id="예시-3-olog-n"><strong>예시 3: O(log n)</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">logarithmic_example</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># ... O(1) 연산 ...
</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># 1. 핵심 연산 (탐색 범위가 절반씩 줄어드는 효과)
</span></code></pre></div></div>

<ul>
  <li><strong>연산 횟수:</strong> <code class="language-plaintext highlighter-rouge">i</code>가 2의 거듭제곱으로 증가하므로, 반복 횟수는 <code class="language-plaintext highlighter-rouge">log₂n</code>에 비례한다.</li>
  <li><strong>빅오 표기:</strong> <code class="language-plaintext highlighter-rouge">O(log n)</code>이다.</li>
</ul>

<hr />

<h4 id="심화-및-실용적-고려사항">심화 및 실용적 고려사항</h4>

<ul>
  <li><strong>시간과 공간의 상충 관계(Trade-off):</strong> 시간을 단축하기 위해 더 많은 메모리를 사용하거나(예: 메모이제이션), 메모리를 아끼기 위해 더 많은 연산을 수행할 수 있다.</li>
  <li><strong>캐시 효율성 (Cache Locality):</strong> 이론적인 복잡도가 같더라도, 데이터가 메모리에 연속적으로 배치된 <strong>배열</strong>이 비연속적인 <strong>연결 리스트</strong>보다 CPU 캐시 효율이 높아 실제 속도는 더 빠르다.</li>
  <li><strong>재귀의 공간 복잡도:</strong> 재귀 함수는 호출될 때마다 <strong>콜 스택(Call Stack)</strong>에 메모리를 사용하므로, 재귀의 최대 깊이가 공간 복잡도가 된다. (예: <code class="language-plaintext highlighter-rouge">n</code> 깊이의 재귀는 <code class="language-plaintext highlighter-rouge">O(n)</code> 공간을 사용)</li>
</ul>

<h3 id="주요-자료구조">주요 자료구조</h3>
<p>데이터를 목적에 맞게 효율적으로 저장하고 관리하는 방법에 대한 학습 단계이다.</p>

<ul>
  <li>선형 자료구조
    <ul>
      <li>배열(Array)</li>
      <li>연결 리스트(Linked List)</li>
      <li>스택(Stack)</li>
      <li>큐(Queue)</li>
    </ul>
  </li>
  <li>비 선형 자료구조
    <ul>
      <li>해시 테이블(Hash Table)</li>
      <li>트리(Tree) : 이진트리, 이진 탐색 트리, AVL 트리, 레드블랙 트리 등</li>
      <li>힙(Heap) : 우선순위 큐</li>
      <li>그래프(Graph)</li>
    </ul>
  </li>
</ul>

<h4 id="선형-자료구조">선형 자료구조</h4>

<h5 id="배열과-연결-리스트">배열과 연결 리스트</h5>

<p>가장 기본적이면서 면접에서 비교 질문으로 자주 나오는 자료구조이다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>배열(Array)</th>
      <th>연결리스트(Linked List)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>핵심 개념</td>
      <td>데이터가 메모리 상에 연속적으로 저장된다.</td>
      <td>각 데이터(노드)가 다음 데이터의 주소를 가지는 형태로 연결된다.</td>
    </tr>
    <tr>
      <td>탐색(접근)</td>
      <td>인덱스를 통한 O(1) 시간의 빠른 임의 접근이 가능하다.</td>
      <td>처음부터 순차적으로 탐색해야 하므로 O(n) 시간이 소요된다.</td>
    </tr>
    <tr>
      <td>삽입/삭제</td>
      <td>중간에 데이터를 추가/삭제 시, 뒤따르는 모든 데이터를 이동시켜야 하므로 O(n) 시간이 걸린다.</td>
      <td>포인터(주소) 연결만 변경하면 되므로 O(1) 시간의 빠른 삽입/삭제가 가능하다. (단, 해당 위치를 탐색하는 시간은 별도)</td>
    </tr>
    <tr>
      <td>메모리</td>
      <td>크기가 고정되어 있고, 연속된 메모리 공간을 할당받는다.</td>
      <td>크기가 가변적이며, 필요할 때마다 메모리를 할당하여 비연속적인 공간을 사용한다.</td>
    </tr>
  </tbody>
</table>

<h5 id="스택과-큐">스택과 큐</h5>

<p>데이터의 입출력 순서를 제어하는 특징을 가진 자료구조이다.</p>

<ul>
  <li>스택
    <ul>
      <li>개념: 후입선출(LIFO, Last-In First-Out) 구조이다. 가장 마지막에 넣은 데이터가 가장 먼저 나온다.</li>
      <li>주요 연산 : push(데이터 추가), pop(데이터 제거)</li>
      <li>활용 예시 : 함수 호출 스택, DFS(깊이 우선 탐색), 괄호 검사, 뒤로 가기 기능</li>
      <li>Python 구현 : 파이썬의 기본 리스트(list)와 append(), pop() 메서드를 사용하면 스택을 쉽게 구현할 수 있다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 스택 예시 코드
</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># push
</span><span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span> <span class="c1"># 3 출력
</span><span class="nf">print</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span> <span class="c1"># 2 출력
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>큐(Queue)
    <ul>
      <li>개념 : 선입선출(FIFO, First-In First-Out) 구조이다. 가장 먼저 넣은 데이터가 가장 먼저 나온다.</li>
      <li>주요 연산 : enqueue(데이터 추가), dequeue(데이터 제거)</li>
      <li>활용 예시 : 너비 우선 탐색(BFS), 프린터 작업 큐, 메시지 큐</li>
      <li>Python 구현 : 리스트의 pop(0)은 O(n)의 비효율을 야기하므로, 양방향 입출력이 O(1)인 collections.deque를 사용하는 것이 표준이다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="c1"># 큐 예시 코드
</span><span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
<span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># enqueue
</span><span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span> <span class="c1"># 1 출력 (dequeue)
</span><span class="nf">print</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">())</span> <span class="c1"># 2 출력
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="비선형-자료구조">비선형 자료구조</h4>

<p>데이터가 계층적 또는 네트워크 형태로 저장되는 구조이다.</p>

<ul>
  <li>해시테이블
    <ul>
      <li>개념: 키(Key)와 값(Value)을 한 쌍으로 저장하는 자료구조이다. 내부적으로 해시 함수를 사용하여 키를 배열의 인덱스로 변환하여 데이터를 저장하므로, 매우 빠른 데이터 탐색이 가능하다.</li>
      <li>시간 복잡도: 평균적으로 삽입, 삭제, 탐색 모두 O(1)이다.</li>
      <li>해시 충돌 (Hash Collision): 서로 다른 키가 해시 함수를 통해 같은 인덱스로 변환되는 상황이다. 이 경우 성능 저하가 발생하며, 최악의 경우 O(n)까지 시간이 걸릴 수 있다.</li>
      <li>충돌 해결 방안: 체이닝(Chaining, 해당 인덱스에 연결 리스트를 사용)과 개방 주소법(Open Addressing, 다른 빈 공간을 찾아 저장)이 대표적이다.</li>
      <li>Python 구현: 파이썬의 딕셔너리(dict)가 해시 테이블로 구현되어 있다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 해시 테이블 예시 코드 (Dictionary)
</span><span class="n">hash_table</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">hash_table</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">jarvis</span><span class="sh">'</span>
<span class="n">hash_table</span><span class="p">[</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="nf">print</span><span class="p">(</span><span class="n">hash_table</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">])</span> <span class="c1"># 'jarvis' 출력 (O(1)에 가까운 속도)
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>트리 
계층적인 관계를 표현하는 데 사용되는 자료구조이다.
    <ul>
      <li>이진 탐색 트리 (Binary Search Tree, BST)
        <ul>
          <li>특징: 부모 노드를 기준으로 왼쪽 서브 트리에는 부모보다 작은 값, 오른쪽 서브 트리에는 부모보다 큰 값이 저장된다.</li>
          <li>성능: 평균적으로 탐색, 삽입, 삭제에 O(log n)의 시간이 걸리지만, 트리가 한쪽으로 치우쳐진 최악의 경우 O(n)이 될 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자가 균형 이진 탐색 트리 (Self-Balancing BST)
    <ul>
      <li>개념: 데이터의 삽입 및 삭제 시 자동으로 트리의 균형을 맞추어 최악의 경우에도 O(log n)의 성능을 보장하는 트리이다.</li>
      <li>종류: AVL 트리, 레드-블랙 트리 등이 있으며, 레드-블랙 트리는 데이터베이스 인덱싱 등에서 널리 사용된다.</li>
    </ul>
  </li>
  <li>힙
    <ul>
      <li>개념: 최댓값이나 최솟값을 빠르게 찾아내기 위해 고안된 완전 이진 트리 기반의 자료구조이다. 부모 노드는 항상 자식 노드보다 크거나(최대 힙) 작아야(최소 힙) 한다.</li>
      <li>시간 복잡도: 데이터 삽입 및 삭제 시 O(log n)이다. 최댓값/최솟값 확인은 O(1)이다.</li>
      <li>활용 예시: 우선순위 큐(Priority Queue)를 구현하는 데 주로 사용된다.</li>
      <li>Python 구현: heapq 모듈은 최소 힙을 제공한다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># 최소 힙 예시 코드
</span><span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">))</span> <span class="c1"># 가장 작은 값인 1 출력
</span><span class="nf">print</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">))</span> <span class="c1"># 다음으로 작은 값인 4 출력
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>그래프 
정점(Vertex)과 그 정점을 연결하는 간선(Edge)으로 이루어진 자료구조이다.</li>
  <li>그래프 표현 방식
    <ul>
      <li>인접 행렬: 2차원 배열을 사용하여 정점 간 연결 관계를 표현한다. 구현이 간단하지만 O(V²)의 공간이 필요하다(V: 정점 수).</li>
      <li>인접 리스트: 각 정점에 연결된 정점들을 리스트로 표현한다. O(V+E)의 공간이 필요하여 효율적이다(E: 간선 수).</li>
    </ul>
  </li>
  <li>대표적인 탐색 알고리즘
    <ul>
      <li>너비 우선 탐색 (BFS): 큐를 사용하여 가까운 정점부터 탐색한다. 최단 경로 찾기에 사용된다.</li>
      <li>깊이 우선 탐색 (DFS): 스택(또는 재귀)을 사용하여 한 방향으로 끝까지 탐색한다. 모든 경로 탐색에 사용된다.</li>
    </ul>
  </li>
</ul>

<h3 id="핵심-알고리즘">핵심 알고리즘</h3>
<p>알고리즘은 문제 해결 능력을 직접적으로 보여주는 지표이다. 면접에서는 특정 알고리즘의 구현 능력뿐만 아니라, 문제 상황에 가장 적합한 알고리즘과 설계 기법을 선택하고 그 이유를 설명하는 능력이 중요하다.</p>

<ul>
  <li>주요 알고리즘 유형
    <ul>
      <li>정렬(Sorting) : 버블 정렬, 선택 정렬, 삽입 정렬, 병합 정렬, 퀵 정렬, 힙 정렬 등</li>
      <li>탐색(Searching) : 이진 탐색, 너비 우선 탐색(BFS), 깊이 우선 탐색(DFS) 등</li>
    </ul>
  </li>
  <li>알고리즘 설계 기법(패러다임)
    <ul>
      <li>분할 정복(Devide and Conquer) : 큰 문제를 작은 단위로 나누어 해결하는 기법 (예: 병합 정렬, 퀵 정렬)</li>
      <li>탐욕법(Greedy Algorithm) : 매 순간 최선의 선택을 하여 최종 해답을 찾는 기법</li>
      <li>동적 프로그래밍(Dynamic Programming) : 작은 문제의 해를 저장하고 재활용하여 큰 문제를 해결하는 기법</li>
      <li>백트래킹(Backtracking) : 해를 찾는 도중 막히면 이전으로 돌아가 다른 경로를 탐색하는 기법</li>
    </ul>
  </li>
</ul>

<h4 id="주요-알고리즘-유형">주요 알고리즘 유형</h4>

<h5 id="정렬-sorting">정렬 (Sorting)</h5>

<p>데이터를 특정 순서에 따라 나열하는 알고리즘이다. 각 정렬 방식의 시간 복잡도와 공간 복잡도, 그리고 안정성(stable) 여부를 비교하여 이해하는 것이 핵심이다.</p>

<ul>
  <li><strong>O(n²) 정렬 알고리즘: 선택, 삽입, 버블 정렬</strong>
    <ul>
      <li>개념: 구현이 비교적 간단하지만, 데이터의 크기가 커질수록 성능이 급격히 저하된다.</li>
      <li><strong>삽입 정렬 (Insertion Sort):</strong> 정렬된 부분 배열에 새로운 원소를 적절한 위치에 삽입하는 방식이다. 이미 대부분 정렬된 데이터에 대해서는 매우 효율적이다.</li>
    </ul>

    <!-- end list -->

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 삽입 정렬 예시 코드
</span><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="n">arr</span>
</code></pre></div>    </div>
  </li>
  <li><strong>O(n log n) 정렬 알고리즘: 병합, 퀵, 힙 정렬</strong>
    <ul>
      <li>개념: 분할 정복 등의 기법을 사용하여 효율성을 높인 알고리즘이다. 일반적인 상황에서 주로 사용된다.</li>
      <li><strong>퀵 정렬 (Quick Sort):</strong> 하나의 피벗(pivot)을 기준으로 작은 값과 큰 값을 나누어 정렬을 반복하는 방식이다. 평균적으로 매우 빠르지만, 피벗 선택에 따라 최악의 경우 O(n²)이 될 수 있다.</li>
    </ul>

    <!-- end list -->

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 퀵 정렬 예시 코드
</span><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">less</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">equal</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">greater</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">less</span><span class="p">)</span> <span class="o">+</span> <span class="n">equal</span> <span class="o">+</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="탐색-searching">탐색 (Searching)</h5>

<p>데이터 집합에서 원하는 값을 찾아내는 알고리즘이다.</p>

<ul>
  <li><strong>이진 탐색 (Binary Search)</strong>
    <ul>
      <li>개념: <strong>정렬된</strong> 데이터에서만 사용 가능한 탐색 기법이다. 탐색 범위를 계속해서 절반으로 줄여나가며 O(log n)의 시간 복잡도를 가진다.</li>
      <li>동작: 중앙값(mid)과 찾고자 하는 값을 비교하여, 작으면 왼쪽, 크면 오른쪽 부분 배열을 대상으로 탐색을 반복한다.
<!-- end list --></li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 이진 탐색 예시 코드 (재귀)
</span><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mid</span>
    <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>그래프 탐색: 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)</strong>
    <ul>
      <li><strong>BFS (Breadth-First Search):</strong> 큐(Queue)를 사용하여 시작 정점과 가까운 정점부터 차례대로 탐색한다. 최단 경로를 찾는 문제에 주로 활용된다.</li>
      <li><strong>DFS (Depth-First Search):</strong> 스택(Stack)이나 재귀 함수를 사용하여 한 방향으로 최대한 깊게 들어간 후, 더 이상 갈 곳이 없으면 이전 정점으로 돌아와 다른 방향을 탐색한다. 모든 경로를 탐색하는 문제에 적합하다.</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="알고리즘-설계-기법-패러다임">알고리즘 설계 기법 (패러다임)</h4>

<p>문제 해결을 위한 접근법이자 사고의 틀이다.</p>

<h5 id="분할-정복-divide-and-conquer">분할 정복 (Divide and Conquer)</h5>

<ul>
  <li>개념: 해결하기 어려운 큰 문제를 해결 가능한 작은 문제들로 나눈 뒤(Divide), 각 작은 문제를 해결하고(Conquer), 그 결과를 합쳐(Combine) 원래 문제의 답을 구하는 전략이다.</li>
  <li>대표 예시: 퀵 정렬, 병합 정렬</li>
</ul>

<h5 id="탐욕법-greedy-algorithm">탐욕법 (Greedy Algorithm)</h5>

<ul>
  <li>개념: 각 단계에서 그 순간에 가장 최적이라고 생각되는 선택을 하는 방식이다. 이렇게 만들어진 지역적인 최적해의 연속이 전역적인 최적해로 이어진다고 가정한다.</li>
  <li>특징: 항상 최적의 해를 보장하지는 않으므로, 탐욕법을 적용할 수 있는 문제인지 정당성을 분석하는 과정이 필수적이다.</li>
  <li>대표 예시: 최소 신장 트리를 찾는 크루스칼/프림 알고리즘, 거스름돈 문제</li>
</ul>

<h5 id="동적-프로그래밍-dynamic-programming-dp">동적 프로그래밍 (Dynamic Programming, DP)</h5>

<ul>
  <li>개념: 큰 문제를 작은 하위 문제들로 나누어 푸는 점은 분할 정복과 같지만, 하위 문제들의 해가 중복되는 경우 그 결과를 <strong>메모이제이션(Memoization)</strong>하여 재활용함으로써 계산 횟수를 줄이는 기법이다.</li>
  <li>적용 조건: 최적 부분 구조(Optimal Substructure)와 중복되는 부분 문제(Overlapping Subproblems)라는 두 가지 속성을 만족하는 문제에 적용할 수 있다.</li>
  <li>구현 방식: 하향식(Top-down, 재귀 + 메모이제이션), 상향식(Bottom-up, 반복문 + 테이블)</li>
  <li>
    <p>대표 예시: 피보나치 수열, 최장 공통 부분 수열(LCS)</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 동적 프로그래밍 예시 (피보나치 수열 - 메모이제이션)
</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1"># 계산 결과를 저장할 딕셔너리
</span>
<span class="k">def</span> <span class="nf">fib_dp</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">fib_dp</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fib_dp</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="백트래킹-backtracking">백트래킹 (Backtracking)</h5>

<ul>
  <li>개념: 모든 가능한 경우의 수를 탐색하는 완전 탐색 기법을 기반으로 하되, 해가 될 가능성이 없는 경로는 더 이상 탐색하지 않고 이전 단계로 되돌아가(backtrack) 다른 경로를 탐색하는 전략이다.</li>
  <li>특징: 불필요한 탐색을 줄여(가지치기, Pruning) 탐색의 효율을 높인다. DFS와 구현 방식이 유사하다.</li>
  <li>대표 예시: N-Queens 문제, 미로 찾기, 스도쿠 풀이</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><summary type="html"><![CDATA[자료구조와 알고리즘]]></summary></entry><entry><title type="html">코테 학습 - ‘유연 근무제’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘유연 근무제’" /><published>2025-09-08T00:00:00+00:00</published><updated>2025-09-08T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/08/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/388351">원본 문제 보러가기</a></p>

<h2 id="2025년-9월-8일-프로그래머스-코딩-테스트-출근-이벤트-문제-풀이-python">2025년 9월 8일: 프로그래머스 코딩 테스트 ‘출근 이벤트’ 문제 풀이 (Python)</h2>

<p>프로그래머스 코딩 테스트 문제 중 ‘출근 이벤트’라는 문제를 풀이하였다. 유연근무제를 시행하는 회사에서 직원들의 출근 희망 시각과 실제 출근 기록을 바탕으로 상품을 받을 직원이 몇 명인지 계산하는 문제였다. 초기 풀이 후, 코드 리뷰를 통해 더 효율적이고 ‘파이썬스러운’ 코드로 개선하는 과정을 거쳤다.</p>

<h3 id="문제의-핵심-core-of-the-problem">문제의 핵심 (Core of the Problem)</h3>

<p>문제의 핵심은 크게 두 가지였다.</p>

<ol>
  <li><strong>출근 인정 시각 계산:</strong> 직원들이 설정한 출근 희망 시각에 10분을 더한 시각까지 출근을 인정한다는 점이다. 여기서 단순히 숫자를 더하는 것이 아니라, 분이 60분을 넘어가면 시간(Hour)이 바뀌는 경우를 정확하게 처리해야 했다.</li>
  <li><strong>주말 제외 및 요일 계산:</strong> 토요일과 일요일은 이벤트에 영향을 주지 않으므로, 이 날짜들은 출근 여부 확인에서 제외해야 했다. <code class="language-plaintext highlighter-rouge">startday</code>를 기준으로 요일을 정확히 계산하여 평일(월~금)에만 조건을 적용하는 것이 중요하였다.</li>
</ol>

<h3 id="초기-풀이-과정-initial-solution-process">초기 풀이 과정 (Initial Solution Process)</h3>

<p>처음에는 다음과 같은 단계로 문제를 해결하였다.</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">makeMaxLimit(limit)</code> 함수 구현:</strong>
    <ul>
      <li>주어진 <code class="language-plaintext highlighter-rouge">limit</code>에 10분을 더하여 출근 인정 시각을 계산하는 핵심 함수였다.</li>
      <li><strong>접근 방식:</strong> 시각을 <strong>문자열로 변환</strong>하여 시(hour)와 분(minutes)을 분리하였다.</li>
      <li>분에 10을 더한 후, 60 이상이 되면 시를 1 증가시키고 분에서 60을 빼는 로직을 적용하였다.</li>
      <li>최종 시와 분을 다시 정수 형태의 시각으로 변환하여 반환하였다.</li>
    </ul>
  </li>
  <li><strong>헬퍼(Helper) 함수 구현:</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">isPass(dayNumber)</code>:</strong> <code class="language-plaintext highlighter-rouge">dayNumber</code>가 평일(1~5)인지 확인하는 함수.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">checkCondition(limit, targetTime)</code>:</strong> 출근 시각이 인정 시각 내에 있는지 확인하는 함수.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">solution</code> 메인 함수:</strong>
    <ul>
      <li>초기 <code class="language-plaintext highlighter-rouge">answer</code>는 전체 직원 수로 설정하고, 지각 시 <strong>1씩 차감</strong>하는 방식을 사용하였다.</li>
      <li>요일 계산은 <code class="language-plaintext highlighter-rouge">index</code> 변수를 1씩 증가시키고, 8이 되면 1로 초기화하는 방식을 사용하였다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">eventTarget</code>이라는 플래그 변수</strong>를 두어 직원의 지각 여부를 추적하고, 반복문이 끝난 뒤 이 플래그를 확인하여 <code class="language-plaintext highlighter-rouge">answer</code>를 차감하였다.</li>
    </ul>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPass</span><span class="p">(</span><span class="n">dayNumber</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dayNumber</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="bp">False</span>
    
<span class="k">def</span> <span class="nf">checkCondition</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">targetTime</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">targetTime</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">makeMaxLimit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">핵심중에 핵심으로 시간의 10분 추가 되었을 때 어떻게 처리할지를 판단하는 부분. 최대 유효 시간이 10분이고, 10분 추가시 분과 시간의 변화를 고려해야함</span><span class="sh">"""</span>
    <span class="n">limitStr</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
    <span class="n">limitStrHour</span> <span class="o">=</span> <span class="sh">''</span>
    <span class="n">limitStrMinutes</span> <span class="o">=</span> <span class="sh">''</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">limitStr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">limitStrHour</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">limitStrMinutes</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limitStrHour</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">limitStrMinutes</span> <span class="o">=</span> <span class="n">limitStr</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    
    <span class="n">limitIntHour</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">limitStrHour</span><span class="p">)</span>
    <span class="n">limitIntMinutes</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">limitStrMinutes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">limitIntMinutes</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">limitIntHour</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">limitIntMinutes</span> <span class="o">-=</span> <span class="mi">60</span>

    <span class="n">limit</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">limitIntHour</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">limitIntMinutes</span><span class="p">)</span>

    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">schedules</span><span class="p">,</span> <span class="n">timelogs</span><span class="p">,</span> <span class="n">startday</span><span class="p">):</span>
    <span class="c1"># 목표 스케쥴 =&gt; 명수, 목표 기준 확인
</span>    <span class="c1"># timelogs =&gt; 분해, 기준 비교 =&gt; startDay 검토하여 스킵할 날짜 체크 =&gt; 문제 없으면 상품 제공
</span>
    <span class="c1"># n 명의 상황 기록 =&gt; 기록 배열 분리 
</span>    <span class="c1"># start day 기준으로 체킹 =&gt; 도중에 이벤트 조건에 맞지 않으면 =&gt; 문제
</span>    <span class="c1"># 가장 효과적인 데이터 타입은? 
</span>    <span class="n">targetList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">schedules</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">limit</span><span class="sh">"</span><span class="p">:</span> <span class="nf">makeMaxLimit</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
            <span class="sh">"</span><span class="s">timelog</span><span class="sh">"</span><span class="p">:</span> <span class="n">timelogs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">})</span>
        <span class="n">targetList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">answer</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">targetList</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targetList</span><span class="p">:</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="sh">"</span><span class="s">limit</span><span class="sh">"</span><span class="p">]</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="sh">"</span><span class="s">timelog</span><span class="sh">"</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">startday</span>
        <span class="n">eventTarget</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>
            <span class="k">if</span> <span class="nf">isPass</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nf">checkCondition</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
                <span class="n">eventTarget</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eventTarget</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">-=</span> <span class="mi">1</span>
                
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<h3 id="코드-개선과-새로운-교훈-code-improvement-and-new-lessons">코드 개선과 새로운 교훈 (Code Improvement and New Lessons)</h3>

<p>초기 풀이도 정답이었지만, 코드의 효율성, 가독성, 그리고 ‘파이썬스러움’에 대해 깊이 배우며 다음과 같이 코드를 개선할 수 있었다.</p>

<ol>
  <li><strong>시간 계산의 효율화: 문자열 변환 vs 산술 연산</strong>
    <ul>
      <li>가장 큰 깨달음이었다. 문자열로 변환하고 슬라이싱하는 대신, <strong>몫(<code class="language-plaintext highlighter-rouge">//</code>)과 나머지(<code class="language-plaintext highlighter-rouge">%</code>) 연산</strong>을 사용하면 훨씬 간결하고 빠르게 시간 계산이 가능했다. 이는 불필요한 형 변환 비용을 줄여주는 효율적인 방법이다. 수학적으로 생각을 하는게 중요한데… 쉽지 않다 ㅠ</li>
      <li><code class="language-plaintext highlighter-rouge">(개선 후) limit_hours = limit // 100</code>, <code class="language-plaintext highlighter-rouge">limit_minutes = limit % 100 + 10</code></li>
    </ul>
  </li>
  <li><strong>Pythonic 네이밍 컨벤션: <code class="language-plaintext highlighter-rouge">snake_case</code></strong>
    <ul>
      <li>TypeScript 와 NestJS 에 절여진 내 뇌는 여전히 카멜을 쓰게 만들었다… 파이썬에서는 함수와 변수명에 <code class="language-plaintext highlighter-rouge">camelCase</code>가 아닌 <code class="language-plaintext highlighter-rouge">snake_case</code>를 사용하는 것이 <strong>PEP 8</strong> 스타일 가이드의 표준이라는 것을 배웠다. (예: <code class="language-plaintext highlighter-rouge">makeMaxLimit</code> -&gt; <code class="language-plaintext highlighter-rouge">make_max_limit</code>) 이는 코드의 가독성과 파이썬 커뮤니티 내의 일관성을 위한 중요한 약속이다.</li>
    </ul>
  </li>
  <li><strong>효율적인 순회와 플래그 변수 제거: <code class="language-plaintext highlighter-rouge">zip</code>과 <code class="language-plaintext highlighter-rouge">for-else</code></strong>
    <ul>
      <li>별도의 데이터 구조를 만들 필요 없이 <code class="language-plaintext highlighter-rouge">zip(schedules, timelogs)</code>를 사용하면 두 리스트를 깔끔하게 병렬로 순회할 수 있었다.</li>
      <li>가장 신기했던 것은 <strong><code class="language-plaintext highlighter-rouge">for-else</code> 구문</strong>이었다. 이 구문을 사용하면 <code class="language-plaintext highlighter-rouge">eventTarget</code>과 같은 <strong>플래그 변수 없이도</strong> “반복문이 <code class="language-plaintext highlighter-rouge">break</code>로 중단되지 않고 무사히 끝났을 때”를 처리할 수 있었다. 이는 코드를 훨씬 직관적이고 우아하게 만들어 주었다. 진짜 희안한게 무지하게 많은 Python…</li>
    </ul>
  </li>
  <li><strong>직관적인 로직: 차감보다 덧셈, 순환에는 나머지 연산</strong>
    <ul>
      <li>전체에서 차감하는 방식보다, <strong>조건을 통과한 대상만 세는 방식(<code class="language-plaintext highlighter-rouge">answer = 0</code> 시작)</strong>이 로직을 더 이해하기 쉽게 만들었다.</li>
      <li>요일을 계산할 때 <code class="language-plaintext highlighter-rouge">if</code>문으로 8이 되는지 검사하는 대신, <strong>나머지 연산자(<code class="language-plaintext highlighter-rouge">%</code>)</strong>를 활용(<code class="language-plaintext highlighter-rouge">(startday + index - 1) % 7 + 1</code>)하여 순환하는 값을 훨씬 간결하게 처리할 수 있었다.</li>
    </ul>
  </li>
  <li><strong>성능 개선</strong>
    <ul>
      <li>기존 코드는 1000개 까지 변수가 들어올 수 있고, 실제 풀이시 4ms 정도로 속도가 오래 걸렸다. 그러나 신규 코드로 개선으로 루프가 1회로 줄어들면서, 1ms 이하로 떨어지게 만들어낼 수 있었다.</li>
    </ul>
  </li>
</ol>

<h3 id="개선의-결과-the-result-of-improvement">개선의 결과 (The Result of Improvement)</h3>

<p>이러한 배움을 통해 코드는 다음과 같이 발전하였다.</p>

<ul>
  <li><strong>가독성:</strong> <code class="language-plaintext highlighter-rouge">snake_case</code> 적용, <code class="language-plaintext highlighter-rouge">zip</code>, <code class="language-plaintext highlighter-rouge">for-else</code> 구문 활용으로 코드의 의도가 훨씬 명확해졌다.</li>
  <li><strong>간결성:</strong> 불필요한 <code class="language-plaintext highlighter-rouge">if-else</code>문, 플래그 변수, 복잡한 요일 계산 로직이 제거되어 코드가 짧고 깔끔해졌다.</li>
  <li><strong>효율성:</strong> 비효율적인 문자열 변환 로직이 빠른 산술 연산으로 대체되었다.</li>
  <li><strong>Pythonic:</strong> 코드가 파이썬의 철학과 스타일에 더 가까워져, 다른 파이썬 개발자가 이해하기 쉬운 코드가 되었다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 개선 버전
</span>
<span class="k">def</span> <span class="nf">is_pass</span><span class="p">(</span><span class="n">dayNumber</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dayNumber</span> <span class="o">&lt;</span> <span class="mi">6</span>

<span class="k">def</span> <span class="nf">make_max_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">limit_hours</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">//</span> <span class="mi">100</span>
    <span class="n">limit_minutes</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">limit_minutes</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
        <span class="n">limit_hours</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">limit_minutes</span> <span class="o">-=</span> <span class="mi">60</span>

    <span class="k">return</span> <span class="n">limit_hours</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">limit_minutes</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">schedules</span><span class="p">,</span> <span class="n">timelogs</span><span class="p">,</span> <span class="n">startday</span><span class="p">):</span>

    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span> 

    <span class="k">for</span> <span class="n">limit</span><span class="p">,</span> <span class="n">logs</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">schedules</span><span class="p">,</span> <span class="n">timelogs</span><span class="p">):</span>
        <span class="n">max_limit</span> <span class="o">=</span> <span class="nf">make_max_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">log</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">logs</span><span class="p">):</span>
            <span class="n">current_day</span> <span class="o">=</span> <span class="p">(</span><span class="n">startday</span> <span class="o">+</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nf">is_pass</span><span class="p">(</span><span class="n">current_day</span><span class="p">)</span> <span class="ow">and</span> <span class="n">log</span> <span class="o">&gt;</span> <span class="n">max_limit</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># for - else 구문 처음 봄 개신기 
</span>            <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>