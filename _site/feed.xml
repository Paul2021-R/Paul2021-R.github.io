<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-11-05T12:20:17+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">TIL - monitoring server 구축기 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/05/til-monitoring-server-2.html" rel="alternate" type="text/html" title="TIL - monitoring server 구축기 (2)" /><published>2025-11-05T00:00:00+00:00</published><updated>2025-11-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/05/til-monitoring-server-2</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/05/til-monitoring-server-2.html"><![CDATA[<h2 id="2025-11-05--monitoring-서버-구축하기">2025-11-05 : Monitoring 서버 구축하기</h2>

<p>드디어 모든 문제를 해결하였다.
HTTPS 를 통한 종단암호화를 마쳤으며
네트워크를 선행 구축하여 통로로 연결될 수 있도록 설정하였다. 
이제 남은 단 하나… 모니터링…!!</p>

<hr />

<h2 id="서버-아키텍쳐-구조도">서버 아키텍쳐 구조도</h2>

<p><img src="/assets/images/assets/project-monitoring-diagram.png" alt="" /></p>

<h2 id="핵심-설정-과정-및-트러블슈팅-qa">핵심 설정 과정 및 트러블슈팅 (Q&amp;A)</h2>

<p>구축 과정에서 몇 가지 중요한 개념과 문제를 마주했으며, 이를 해결하는 과정이 이번 TIL의 핵심이다.</p>

<h3 id="핵심-네트워크구조">핵심 네트워크구조</h3>

<p>네트워크의 설정이 난해했지만, 결국 핵심은 ‘외부’와 ‘내부’에 대한 명료함이다.</p>

<ol>
  <li><strong>내부 통신 (Docker Network):</strong> 모니터링 서버 <em>내부</em> 의 컨테이너들(e.g., <code class="language-plaintext highlighter-rouge">centre-prometheus</code>, <code class="language-plaintext highlighter-rouge">centre-grafana</code>, <code class="language-plaintext highlighter-rouge">NPM</code>)은 docker의 가상 네트워크를 통해 컨테이너 이름으로 통신한다. 이 통신은 Docker가 내부 DNS를 통해 처리하므로 외부 포트가 필요 없다.
    <ul>
      <li><strong>예시:</strong> NPM 프록시 설정 시 Grafana의 주소는 <code class="language-plaintext highlighter-rouge">http://centre-grafana:3000</code>이 된다.</li>
    </ul>
  </li>
  <li><strong>외부 통신 (Physical LAN):</strong> 모니터링 서버가 <em>다른</em> 물리적 서버에 접근할 때는 이 가상 네트워크를 쓸 수 없다. 반드시 외부 서버의 물리적 IP 주소와 <code class="language-plaintext highlighter-rouge">service-exporters</code>에서 <code class="language-plaintext highlighter-rouge">ports</code>로 외부에 노출시킨 포트(<code class="language-plaintext highlighter-rouge">9100</code>, <code class="language-plaintext highlighter-rouge">8081</code>)를 사용해야 한다.</li>
</ol>

<h3 id="restart-정책으로-always-대신-unless-stopped를-써야-한다"><code class="language-plaintext highlighter-rouge">restart</code> 정책으로 <code class="language-plaintext highlighter-rouge">always</code> 대신 <code class="language-plaintext highlighter-rouge">unless-stopped</code>를 써야 한다</h3>

<p>사실 항상 restart 의 정책이 어떻게 되는지 정확하게 알고 있지 못했기에 이번 기회에 알아보았다. 두 정책 모두 시스템 재부팅 시 컨테이너를 자동 재시작해준다. 하지만 결정적인 차이가 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">restart: always</code>: 관리자가 유지보수를 위해 <code class="language-plaintext highlighter-rouge">docker stop</code> 명령으로 컨테이너를 <em>수동 정지</em> 해도, Docker 데몬이 재시작되거나 시스템이 재부팅되면 컨테이너를 다시 켜버린다.</li>
  <li><code class="language-plaintext highlighter-rouge">restart: unless-stopped</code>: 관리자의 수동 정지 명령을 “존중”한다. 즉, 수동으로 정지된 컨테이너는 관리자가 명시적으로 다시 시작(<code class="language-plaintext highlighter-rouge">docker start</code>)하기 전까지는 꺼진 상태를 유지한다.</li>
</ul>

<p>이러한 결정적인 차이 때문에 유지보수 및 예측 가능성 측면에서 <code class="language-plaintext highlighter-rouge">unless-stopped</code>가 훨씬 안전한 정책이기에 향후엔 <code class="language-plaintext highlighter-rouge">unless-stopped</code>를 쓰려고 한다.</p>

<h3 id="prometheus_data-grafana_data를-gitignore에-추가해야-하는가"><code class="language-plaintext highlighter-rouge">prometheus_data</code>, <code class="language-plaintext highlighter-rouge">grafana_data</code>를 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 추가해야 하는가?</h3>

<p>설정을 찾아보다 보니, 볼륨의 연결이 필요했다. 이에 진행하면서, 해당 볼륨의 특성을 보았다. 처음엔 생성되는 것들이 git 으로 버전 관리되는걸로 하면 권한 문제가 생길 수 있다고 판단했었다. 하지만… <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 <strong>Named Volume</strong> (<code class="language-plaintext highlighter-rouge">grafana_data:/var/lib/grafana</code>)을 사용하기에 그럴 필요가 없다는 것을 배웠다.</p>

<ul>
  <li><strong>Named Volume:</strong> Docker가 관리하는 별도의 시스템 경로( <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/...</code>)에 데이터를 저장한다. Git 리포지토리 폴더 내에 파일이 생성되지 않으므로 <code class="language-plaintext highlighter-rouge">.gitignore</code>가 필요 없다.</li>
  <li><strong>Bind Mount:</strong> 만약 프로젝트 폴더에 직접 데이터를 저장하는 방식 (<code class="language-plaintext highlighter-rouge">./grafana_data:/var/lib/grafana</code>)을 사용했다면, 이 폴더는 Git이 추적하게 되므로 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 반드시 추가해야 했을 것이다.</li>
</ul>

<h3 id="prometheus와-grafana의-cpu메모리-제한은">Prometheus와 Grafana의 CPU/메모리 제한은?</h3>

<p>제한된 온프레미스 서버. 최적화된 설정을 위해 Docker 의 리소스 관리 기능을 활용하려고 생각하고, AI 와 이야기하며 현실적인 수준을 파악해보았다. 현재 설정된 리소스(Prometheus 0.5 CPU/512M, Grafana 0.3 CPU/256M)는 2대의 서버(호스트 2개 + 컨테이너 수십 개)를 모니터링하기에 충분히 넉넉하다는 판단 하에 설정하였다.</p>

<p>다만, 처음엔 이정도가 맞는가? 라는 의문은 가지고 있었다. 아무리 생각해도 이정도는 하고, 윈도우 95 시절인줄 알았지만…. AI가 제시한 의도를 보고 파악할 수 있었다. 이 리소스 제한의 주 목적은 성능 자체가 아니라, 만약의 버그나 매우 복잡한 쿼리로 인해 모니터링 컨테이너 하나가 서버의 전체 리소스를 고갈시켜, 모니터링 시스템은 물론 서버 전체를 다운시키는 것을 방지하는 ‘안전벽(safety wall)’ 역할을 하고, 그렇게 볼때 다소의 보수적인 설정은 충분히 설득력이 있었다.</p>

<h2 id="최종-설정-파일">최종 설정 파일</h2>

<p>위의 모든 과정을 거쳐 완성된 최종 설정 파일들이다.</p>

<h3 id="1-메인-서비스-서버-a5-server">1. 메인 서비스 서버 (A5 Server)</h3>

<p><code class="language-plaintext highlighter-rouge">service-exporters/docker-compose.yml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># main server watcher for monitoring structure 

services:
  #########################################################
  #  NodeExporter_Svc: 호스트 지표 (CPU, RAM, Disk)
  #########################################################
  node-exporter:
    image: prom/node-exporter:latest
    container_name: a5-node-exporter
    restart: unless-stopped
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
    pid: host
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: '64M'
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  #########################################################
  #  cAdvisor_Svc: 컨테이너 지표 (Docker)
  #########################################################
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: a5-cadvisor
    restart: unless-stopped
    ports:
      - "8081:8080" 
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    devices:
      - /dev/kmsg
    deploy:
      resources:
        limits:
          cpus: '0.15'
          memory: '128M'
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
</code></pre></div></div>

<h3 id="2-모니터링-서버-centre-server">2. 모니터링 서버 (Centre Server)</h3>

<p><code class="language-plaintext highlighter-rouge">monitoring-stack/docker-compose.yml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># monitoring structure + sub server watcher

services:
  #########################################################
  #  Prometheus: The core data collection service
  #########################################################
  prometheus:
    image: prom/prometheus:latest
    container_name: centre-prometheus
    restart: unless-stopped
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: '512M'

  #########################################################
  #  Grafana: The data visualization dashboard
  #########################################################
  grafana:
    image: grafana/grafana:latest
    container_name: centre-grafana
    restart: unless-stopped
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.3'
          memory: '256M'

  #########################################################
  #  NodeExporter_Mon: Host metrics for THIS server
  #########################################################
  node-exporter-mon:
    image: prom/node-exporter:latest
    container_name: centre-node-exporter
    restart: unless-stopped
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
    pid: host
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: '64M'

  #########################################################
  #  cAdvisor_Mon: Container metrics for THIS server
  #########################################################
  cadvisor-mon:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: centre-cadvisor
    restart: unless-stopped
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    devices:
      - /dev/kmsg
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.15'
          memory: '128M'

#########################################################
#  Shared Volumes and Networks
#########################################################
volumes:
  prometheus_data:
  grafana_data:

networks:
  my-central-proxy-network:
    external: true
    name: my-central-proxy-network 
</code></pre></div></div>

<h3 id="3-모니터링-두뇌-prometheus-config">3. 모니터링 “두뇌” (Prometheus Config)</h3>

<p><code class="language-plaintext highlighter-rouge">monitoring-stack/prometheus/prometheus.yml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>global:
  scrape_interval: 15s # How often to scrape targets

scrape_configs:
  # 1. Monitor Prometheus itself (Internal)
  - job_name: 'prometheus'
    static_configs:
      - targets: ['centre-prometheus:9090']

  # 2. Monitor the monitoring server's HOST (Internal)
  - job_name: 'monitoring_host'
    static_configs:
      - targets: ['centre-node-exporter:9100']

  # 3. Monitor the monitoring server's CONTAINERS (Internal)
  - job_name: 'monitoring_containers'
    static_configs:
      # cAdvisor's default port inside the container is 8080
      - targets: ['centre-cadvisor:8080']

  # 4. Monitor the REMOTE main service server's HOST (External)
  - job_name: 'service_host'
    static_configs:
      # A5 Server's physical IP and exposed port
      - targets: ['192.168.0.37:9100']

  # 5. Monitor the REMOTE main service server's CONTAINERS (External)
  - job_name: 'service_containers'
    static_configs:
      # A5 Server's physical IP and exposed port
      - targets: ['192.168.0.37:8081']
</code></pre></div></div>

<h3 id="4-gitignore">4. <code class="language-plaintext highlighter-rouge">.gitignore</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.DS_Store
Thumbs.db
.env
*.env.local
docker-compose.override.yml
</code></pre></div></div>

<h2 id="결과">결과</h2>

<p>모든 설정이 완료되고, Grafana에서 <code class="language-plaintext highlighter-rouge">https://grafana.paulryu93.ddns.net</code>에서 모든걸 볼 수 있었다.</p>

<p><img src="/assets/images/posts/2025-11/20251105-008.png" alt="" /></p>

<p><strong>Node Exporter (monitoring_host) 대시보드:</strong>
<img src="/assets/images/posts/2025-11/20251105-009.png" alt="" />
<img src="/assets/images/posts/2025-11/20251105-010.png" alt="" /></p>

<p><strong>cAdvisor (monitoring_containers) 대시보드:</strong>
<img src="/assets/images/posts/2025-11/20251105-011.png" alt="" />
<img src="/assets/images/posts/2025-11/20251105-012.png" alt="" /></p>

<p>이제 두 서버의 모든 호스트 및 컨테이너 지표를 중앙에서 실시간으로 모니터링할 수 있게 되었다!</p>

<hr />

<p>아직 알람 기능이라거나, 디테일한 접근은 되지 않았다. 
그러나</p>
<ul>
  <li>G/B 방식의 무중단 배포와 이를 위한 CI/CD Jenkins 파이프라인 구축</li>
  <li>Next.js 기반의 SPA 어플리케이션 서버</li>
  <li>MSA 방식의 NestJS 와 AI를 위한 FastAPI 서버</li>
  <li>이 모든것을 감시하는 Monitoring의 Grafana + Prometheus 설정
은 앞으로 더욱 흥미 진진한 제대로 된 스케일러블 서비스 구축의 ingnition 이 될 것같다…ㅎ</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><category term="Monitoring" /><category term="Grafana" /><category term="Prometheus" /><summary type="html"><![CDATA[2025-11-05 : Monitoring 서버 구축하기]]></summary></entry><entry><title type="html">TIL - monitoring server 구축기 &amp;amp; 지옥같은 네트워크 문제 해결기..</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-monitoring-server.html" rel="alternate" type="text/html" title="TIL - monitoring server 구축기 &amp;amp; 지옥같은 네트워크 문제 해결기.." /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-monitoring-server</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-monitoring-server.html"><![CDATA[<h2 id="2025-10-31--2025-11-03--monitoring-서버-구축하기--네트워크-문제-해결하기">2025-10-31 ~ 2025-11-03 : Monitoring 서버 구축하기 &amp; 네트워크 문제 해결하기</h2>

<p>구축하고 있는 NextJS 와, MSA 백엔드 서비스, AI 에이전트를 위한 모니터링 시스템을 구축하고 이를 기반으로 지속적으로 서비스의 상태를 확인하며 프로젝트를 진행해 나가려고 한다.</p>

<hr />

<h2 id="서버-아키텍쳐-구조도">서버 아키텍쳐 구조도</h2>

<p><img src="/assets/images/assets/project-monitoring-diagram.png" alt="" /></p>

<h3 id="아키텍처-구성-요소-및-역할">아키텍처 구성 요소 및 역할</h3>

<h4 id="1-사용자-users">1. 사용자 (Users)</h4>
<ul>
  <li><strong>Admin (관리자):</strong> ‘모니터링 서버’의 <code class="language-plaintext highlighter-rouge">Nginx_Mon</code>을 통해 Grafana 대시보드에 접속하여 전체 서버 인프라의 상태를 확인한다.</li>
  <li><strong>Public User (일반 사용자):</strong> ‘메인 서비스 서버’의 <code class="language-plaintext highlighter-rouge">Frontend</code> 애플리케이션에 접속하여 실제 모니터링 되고 있는 내용 중 일부를 볼 수 있다.</li>
</ul>

<hr />

<h4 id="2-모니터링-서버-ryzen-3400g">2. 모니터링 서버 (Ryzen 3400G)</h4>
<ul>
  <li><strong>Nginx_Mon (HTTPS 프록시):</strong> Admin의 Grafana 접속 요청을 받아 HTTPS 암호화 통신을 처리하고, 내부의 Grafana 컨테이너로 요청을 전달(리버스 프록시)하는 게이트웨이이다.</li>
  <li><strong>Grafana (데이터 시각화):</strong> Prometheus에 저장된 모든 지표(메트릭) 데이터를 가져와 관리자가 한눈에 볼 수 있도록 다양한 대시보드를 시각화한다.</li>
  <li><strong>Prometheus (데이터 수집/저장):</strong> 모니터링의 핵심이다. 두 서버의 모든 Exporter로부터 주기적으로 지표를 수집(Scrape)하고 시계열 데이터베이스(TSDB)에 저장한다.</li>
  <li><strong>NodeExporter_Mon (호스트 지표):</strong> 모니터링 서버 자체의 CPU, 메모리, 디스크, 네트워크 사용량 등 하드웨어 자원 지표를 Prometheus에 제공한다.</li>
  <li><strong>cAdvisor_Mon (컨테이너 지표):</strong> 모니터링 서버에서 실행 중인 Docker 컨테이너(Prometheus, Grafana 등)들의 개별 리소스 사용량 지표를 Prometheus에 제공한다.</li>
</ul>

<hr />

<h4 id="3-메인-서비스-서버-모니터링-대상">3. 메인 서비스 서버 (모니터링 대상)</h4>

<ul>
  <li><strong>App_1 (Frontend):</strong> Public User에게 보여지는 웹 애플리케이션(Project Mini Frontend)이다.</li>
  <li><strong>App_2 (Backend):</strong> 서비스의 비즈니스 로직을 처리하는 NestJS 및 FastAPI 기반의 MSA 백엔드 API 서버이다.</li>
  <li><strong>NodeExporter_Svc (호스트 지표):</strong> 메인 서비스 서버 자체의 하드웨어 자원 지표(CPU, RAM 등)를 Prometheus에 제공한다.</li>
  <li><strong>cAdvisor_Svc (컨테이너 지표):</strong> 메인 서비스 서버에서 실행 중인 모든 서비스 컨테이너(App_1, App_2 등)의 리소스 사용량 지표를 Prometheus에 제공한다.</li>
</ul>

<h2 id="프로세스">프로세스</h2>

<ol>
  <li>
    <p><strong>1단계: GitHub 리포지토리 구조 설계 및 초기화</strong></p>

    <ul>
      <li>단일 리포지토리 내에 <strong>모니터링 스택</strong>(Prometheus, Grafana)과 <strong>Exporter 스택</strong>(Node Exporter, cAdvisor)의 구성을 분리할 디렉터리 구조를 설계합니다.</li>
      <li><em>예시 구조:</em>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /monitoring-infra
  ├── monitoring-stack/          # [모니터링 서버(Ryzen 3400G)용]
  │   ├── docker-compose.yml
  │   └── prometheus/
  │       └── prometheus.yml     # Prometheus 설정 파일
  └── service-exporters/         # [메인 서비스 서버용]
      └── docker-compose.yml
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>2단계: ‘service-exporters’ 구성 파일 작성</strong>
    <ul>
      <li>모니터링 대상 서버(메인 서비스 서버)에서 실행될 <code class="language-plaintext highlighter-rouge">service-exporters/docker-compose.yml</code> 파일을 작성합니다.</li>
      <li>이 파일은 <strong>Node Exporter</strong>와 <strong>cAdvisor</strong> 컨테이너를 실행하는 내용을 포함합니다.</li>
    </ul>
  </li>
  <li><strong>3단계: ‘monitoring-stack’ 구성 파일 작성</strong>
    <ul>
      <li>모니터링 서버(Ryzen 3400G)에서 실행될 <code class="language-plaintext highlighter-rouge">monitoring-stack/docker-compose.yml</code> 파일을 작성합니다.</li>
      <li>이 파일은 <strong>Prometheus</strong>와 <strong>Grafana</strong> 컨테이너를 실행하는 내용을 포함합니다.</li>
      <li>동시에 <code class="language-plaintext highlighter-rouge">monitoring-stack/prometheus/prometheus.yml</code> 설정 파일을 작성합니다. 이 파일에는 2단계에서 실행될 Exporter들(메인 서비스 서버의 IP)을 수집 대상으로 지정합니다.</li>
    </ul>
  </li>
  <li><strong>4단계: 각 서버에 배포 실행</strong>
    <ul>
      <li><strong>[메인 서비스 서버에서]</strong>
        <ol>
          <li>프로젝트 리포지토리를 <code class="language-plaintext highlighter-rouge">git pull</code> 합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">service-exporters</code> 디렉터리로 이동합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">docker-compose up -d</code>를 실행하여 Exporter들을 활성화합니다.</li>
        </ol>
      </li>
      <li><strong>[모니터링 서버(Ryzen 3400G)에서]</strong>
        <ol>
          <li>프로젝트 리포지토리를 <code class="language-plaintext highlighter-rouge">git pull</code> 합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">monitoring-stack</code> 디렉터리로 이동합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">docker-compose up -d</code>를 실행하여 Prometheus와 Grafana를 활성화합니다.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>5단계: Grafana 대시보드 구성</strong>
    <ul>
      <li>웹 브라우저로 Grafana에 접속합니다.</li>
      <li>Prometheus를 데이터 소스로 추가합니다.</li>
      <li>Node Exporter 및 cAdvisor 용 대시보드를 Import하여 모니터링을 시작합니다.</li>
    </ul>
  </li>
</ol>

<h2 id="문제-해결-및-개선-절차">문제 해결 및 개선 절차</h2>

<h3 id="1-초기-스택-배포">1. 초기 스택 배포</h3>
<ul>
  <li>Docker Compose를 활용하여 모니터링 스택(Prometheus, Grafana) 및 Exporter(Node Exporter, cAdvisor) 컨테이너의 기본 배포를 성공적으로 완료하였다.</li>
  <li>Jenkins 서버 이전을 대비한 Nginx 리버스 프록시 기본 구성을 완료하였다.</li>
</ul>

<h3 id="2-온프레미스-네트워크-다중화-구성">2. 온프레미스 네트워크 다중화 구성</h3>
<p>신규 모니터링 서버(Ryzen 3400G) 도입에 따라 발생한 네트워크 문제를 해결하는 과정이다.</p>
<h4 id="21-443-포트-점유-및-ddns-라우팅-이슈">2.1. 443 포트 점유 및 DDNS 라우팅 이슈</h4>
<ul>
  <li><strong>문제:</strong> 단일 공유기 환경에서는 443 포트(HTTPS)를 메인 서버와 모니터링 서버로 동시에 포트 포워딩할 수 없는 문제가 발생하였다.</li>
  <li><strong>분석:</strong> DDNS 서비스는 도메인을 공인 IP에 매핑할 뿐, 포트 레벨의 라우팅을 지원하지 않는다. 포트 분배는 라우터(NAT)의 역할이다.</li>
  <li><strong>1차 해결:</strong> 물리적 네트워크 분리를 위해 2번째 공유기와 USB 이더넷 어댑터를 도입하였다. 각 공유기에 별도의 공인 IP를 할당받아 443 포트 점유 문제를 해결하고자 시도하였다.</li>
</ul>

<h4 id="22-게이트웨이-및-서브넷-충돌">2.2. 게이트웨이 및 서브넷 충돌</h4>
<ul>
  <li><strong>문제:</strong> 두 공유기가 동일한 기본 서브넷(예: <code class="language-plaintext highlighter-rouge">192.168.0.x</code>)을 사용함에 따라 게이트웨이 충돌이 발생하였고, 이로 인해 서브 공유기의 관리 페이지 접근이 불가한 현상이 나타났다.</li>
  <li><strong>2차 해결:</strong> 서브 공유기의 LAN 및 DHCP 설정을 <code class="language-plaintext highlighter-rouge">192.168.10.x</code>와 같이 고유한 서브넷 대역으로 변경하여 네트워크를 논리적으로 분리하였다.</li>
</ul>

<h3 id="3-isp-제약-및-아키텍처-변경">3. ISP 제약 및 아키텍처 변경</h3>
<p>1, 2차 해결책이 ISP단의 제약으로 인해 새로운 문제에 직면하였다.</p>
<h4 id="31-공인-ip-다중-할당-제한">3.1. 공인 IP 다중 할당 제한</h4>
<ul>
  <li><strong>문제:</strong> ISP(KT) 모뎀에서 두 개의 공인 IP 할당 요청을 비정상적인 트래픽으로 간주, 특정 MAC 주소의 연결을 차단하는 문제가 발생하였다. 2.1에서 시도한 물리적 네트워크 분리(공유기 2대 사용)가 무효화되었다.</li>
  <li><strong>3차 해결 (아키텍처 변경):</strong>
    <ol>
      <li><strong>클라우드 프록시 도입:</strong> 단일 진입점(Single Entry Point)으로 GCP 가상 인스턴스(VM)를 배치하였다.</li>
      <li><strong>L4 프록시 전환:</strong> GCP의 Nginx를 L7(HTTP) 프록시가 아닌 L4(TCP) 프록시 모드로 설정하여 트래픽을 단순 전달(forwarding)하도록 하였다.</li>
      <li><strong>SSL Passthrough 적용:</strong> 클라우드 프록시는 SSL/TLS 암호화를 복호화하지 않고, 암호화된 트래픽(TCP)을 그대로 온프레미스 서버로 전달한다.</li>
      <li><strong>종단간 암호화 유지:</strong> SSL Termination (암호화 복호화)은 최종 목적지인 온프레미스 Nginx 서버에서 직접 처리하도록 구성하여 종단간 암호화를 유지한다.</li>
      <li><strong>Client IP 보존:</strong> <strong>Proxy Protocol</strong>을 활성화하여 L4 프록시 환경에서 유실될 수 있는 원본 클라이언트 IP를 백엔드 서버로 전달하였다.</li>
    </ol>
  </li>
  <li><strong>결과:</strong> GCP 인스턴스를 경유하여 온프레미스 서버의 특정 포트(8888, 8889 등)로 트래픽을 성공적으로 포워딩하는 것을 확인하였다.</li>
</ul>

<h3 id="4-현재-블로킹-이슈-물리적-인프라-장애국내-dhcp-환경의-특징---가정용만인듯">4. 현재 블로킹 이슈: 물리적 인프라 장애(국내 DHCP 환경의 특징 - 가정용만인듯?)</h3>
<ul>
  <li><strong>문제:</strong> ISP 모뎀 자체의 노후화 또는 물리적 결함으로 추정되는 인터넷 신호의 간헐적 끊김 현상이 발생하였다.</li>
  <li><strong>영향:</strong> 온프레미스 환경의 모든 서버(메인 서비스, 모니터링)가 외부에서 접근 불가능한 상태(unreachable)가 되었다.</li>
  <li><strong>현황:</strong> 모뎀 하드웨어 문제 해결 전까지 모든 서버 배포 및 설정 작업이 중단(Blocked)되었다. 현재는 문제 해결 과정을 문서화하며 대기 중이다. (후… KT)</li>
  <li><strong>분석 및 결론:</strong> 핵심 문제는 DHCP 관련된 문제였다고 발견되었다. 모뎀을 교체하여 신상으로 했는데도 동일 증상(붙었다 끊어졌다)가 반복 되었다. 
거기다 주기적으로 붙었다 떨어지는것, 공유기는 이상이 없는 것을 발견하였다.</li>
  <li>결국 설정을 뒤지다가 문제의 핵심이 ‘고정IP’ 라는 결론에 다다르게 된다. 
<img src="/assets/images/posts/2025-11/20251104-001.png" alt="" />
<img src="/assets/images/posts/2025-11/20251104-002.png" alt="" /></li>
  <li><strong>고정할당 문제:</strong> ISP 는 공인 IP 주소 풀을 독접 관리하고, 사용자에게 필요시 해당 IP 를 제공하는 방식을 사용한다. 그런데 여기서 기본적으로 임대를 해주는 개념이고 결과적으로 L2 레이어에서 요청-응답-승인-갱신 절차를 거친다. 문제는 거기서 내가 뭣도 모르고, 공유기를 ‘고정IP 방식’으로 했다. 내 의도는 내 공인 IP 를 그대로 유지해달라! 는 요청이었는데, 이건 제공하는 쪽과 수신하는 쪽, 사이에서 고정 할당을 해주고, 그 뒤에 고정 할당을 했을 때 문제가 없는 것이다..!</li>
  <li><strong>DHCP 규약:</strong> 일방적으로 설정해두면, 공유기는 더이상 승인요청을 하지 않고, 갱신 요청을 보내지 않게 된다….ㅠㅠ 결과적으로 최초에 설정하거나, 연결이 끊어진 직후에 인터넷 시그널을 보내면 처음 성공한 상태에서 사용 가능한 시점까지만 제공 =&gt; 갱신없음 =&gt; 공유기에서 인터넷 패킷이 들어오지 않음 의 연속이었던 것이다(….)</li>
  <li>고정 IP 로 변경이 DHCP 규약을 안따르겠다(갱신 안함)라는 의도를 포함한 설정이란 걸 몰랐기에 생긴 문제였다.</li>
  <li>KT 의 경우 ISP 에서 기본적으로 Sticky IP 정책을 쓰기 때문에 DHCP 프로토콜 규약은 지키지만, 어지간하면 IP 가 안바뀌고, 개인 프로젝트라면 문제가 없는 것으로 판단하고 유동IP 방식으로 변경하였다.</li>
</ul>

<h3 id="5-https-인증서-발급-certbot과-nginx-사이에-400-bad-request-오류-발생">5. HTTPS 인증서 발급 Certbot과 Nginx 사이에 <code class="language-plaintext highlighter-rouge">400 Bad Request</code> 오류 발생</h3>

<p>GCP(Google Cloud Platform) VM에 Nginx를 설치하여 프록시 서버로 구성했다. 목적은 443 포트(TLS)와 80 포트(HTTP)로 들어오는 트래픽을 내부망에 있는 ‘Centre 서버’로 전달(proxy pass)하는 것이다.</p>

<p>이후 HTTPS 인증서를 발급받기 위해 Centre 서버에서 Certbot을 실행했으나, <code class="language-plaintext highlighter-rouge">400 Bad Request</code> 오류가 발생하며 인증이 계속 실패했다.</p>

<p>브라우저 개발자 도구로 확인 결과, 이 <code class="language-plaintext highlighter-rouge">400</code> 오류는 최종 목적인 Centre 서버가 아닌, 요청의 맨 앞단인 <strong>GCP 프록시 서버(<code class="language-plaintext highlighter-rouge">35.197.5.162</code>)</strong>가 직접 반환하는 것을 확인했다.</p>

<p>이번 문제의 핵심은 서로 다른 원인을 가진 두 개의 <code class="language-plaintext highlighter-rouge">400</code> 오류가 겹쳐 있었던 것이다.</p>

<h4 id="1-gcp-서버-stream과-http-모듈-충돌-핵심-원인">1. GCP 서버: <code class="language-plaintext highlighter-rouge">stream</code>과 <code class="language-plaintext highlighter-rouge">http</code> 모듈 충돌 (핵심 원인)</h4>

<ul>
  <li>
    <p><strong>원인:</strong> GCP 서버의 Nginx 설정(<code class="language-plaintext highlighter-rouge">nginx_target.conf</code>)이 443 포트와 80 포트 모두를 <code class="language-plaintext highlighter-rouge">stream</code> (TCP) 모듈로 처리하도록 되어 있었다.</p>
  </li>
  <li>
    <p><strong>충돌:</strong> Certbot과 브라우저는 80 포트에 <code class="language-plaintext highlighter-rouge">http</code> (<code class="language-plaintext highlighter-rouge">GET /...</code>) 요청을 보냈다. Nginx의 <code class="language-plaintext highlighter-rouge">stream</code> 모듈은 <code class="language-plaintext highlighter-rouge">http</code> 문법을 이해하지 못하므로, 이를 ‘형식에 맞지 않는 요청’으로 간주하여 <code class="language-plaintext highlighter-rouge">400</code> 오류를 반환했다.</p>
  </li>
  <li>
    <p><strong>해결:</strong> GCP 서버 Nginx 설정을 ‘하이브리드’ 모드로 수정했다. 443 포트는 <code class="language-plaintext highlighter-rouge">stream</code> 블록(TCP 프록시)으로 유지하되, 80 포트는 <code class="language-plaintext highlighter-rouge">http</code> 블록으로 분리하여 <code class="language-plaintext highlighter-rouge">proxy_pass</code> (HTTP 프록시)로 Centre 서버에 정상 전달되도록 조치했다.</p>
  </li>
</ul>

<h4 id="2-centre-서버-server_name-해시-버킷-제한">2. Centre 서버: <code class="language-plaintext highlighter-rouge">server_name</code> 해시 버킷 제한</h4>

<ul>
  <li>
    <p><strong>원인:</strong> Centre 서버의 Nginx 설정(<code class="language-plaintext highlighter-rouge">nginx_init.conf</code>)은 4개의 긴 도메인 이름을 하나의 <code class="language-plaintext highlighter-rouge">server_name</code> 지시어에 모두 나열했다. 이는 Nginx의 기본 <code class="language-plaintext highlighter-rouge">server_names_hash_bucket_size</code> (이름 처리 메모리) 제한을 초과하여 <code class="language-plaintext highlighter-rouge">400</code> 오류를 유발할 수 있는 잠재적 문제였다.</p>
  </li>
  <li>
    <p><strong>해결:</strong> <code class="language-plaintext highlighter-rouge">http</code> 블록 자체의 메모리(<code class="language-plaintext highlighter-rouge">server_names_hash_bucket_size 64;</code>)를 늘리는 대신, <code class="language-plaintext highlighter-rouge">server</code> 블록을 4개로 분리하여 각 블록이 1개의 <code class="language-plaintext highlighter-rouge">server_name</code>만 처리하도록 구조를 변경함으로써 문제를 우회하고 해결했다.</p>
  </li>
</ul>

<hr />

<h4 id="현상황-duckdns-네임서버-응답-대기">현상황: DuckDNS 네임서버 응답 대기</h4>

<p>GCP 서버와 Centre 서버의 Nginx 설정이 모두 완료되었다.</p>

<ul>
  <li>
    <p><strong>검증:</strong> 브라우저로 80 포트 접속 시, 의도했던 대로 GCP 프록시를 거쳐 Centre 서버의 Nginx가 <code class="language-plaintext highlighter-rouge">404 Not Found</code>를 정상적으로 반환한다.</p>
  </li>
  <li>
    <p><strong>로그:</strong> Centre 서버의 Nginx 로그에도 Certbot의 <code class="language-plaintext highlighter-rouge">.well-known</code> 경로 접근이 <code class="language-plaintext highlighter-rouge">200 OK</code>로 성공 처리된 것이 확인되었다.</p>
  </li>
  <li>
    <p><strong>현재 문제:</strong> Nginx 설정은 완벽하지만, Certbot은 <code class="language-plaintext highlighter-rouge">DNS problem: SERVFAIL</code> 오류를 반환하며 여전히 실패한다.</p>
  </li>
  <li>
    <p><strong>원인:</strong> <code class="language-plaintext highlighter-rouge">SERVFAIL</code>은 로컬 Nginx 설정 문제가 아니다. Let’s Encrypt 인증 서버가 <strong>DuckDNS 네임서버</strong>에 DNS 조회를 시도했으나, DuckDNS 서버가 불안정하여 “서버 실패(Server Failure)” 응답을 반환한 것이다.</p>
  </li>
  <li>
    <p><strong>상태:</strong> 모든 로컬 및 프록시 설정은 완료되었으며, DuckDNS 네임서버가 안정화되고 Let’s Encrypt의 ‘실패 캐시’가 만료되기를 <strong>대기 중</strong>이다.</p>
  </li>
</ul>

<h3 id="6-nginx-jenkins-n8n-서버-구축">6. Nginx, Jenkins, n8n 서버 구축</h3>
<p>우선 안된 HTTPS 를 연결할 수 없으니 일단 HTTP 상태에서 세팅을 해보았다.</p>
<h4 id="1-nginx">1. Nginx</h4>
<ul>
  <li><strong>설정 파일 수정</strong> :
    <div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">server</span> {
      <span class="n">listen</span> <span class="m">80</span>;
      <span class="n">server_name</span> {도메인};

      <span class="c"># Certbot 인증 경로
</span>      <span class="c"># 흑흑 얼른 되라고...
</span>      <span class="n">location</span> /.<span class="n">well</span>-<span class="n">known</span>/<span class="n">acme</span>-<span class="n">challenge</span>/ {
          <span class="n">root</span> /<span class="n">var</span>/<span class="n">www</span>/<span class="n">certbot</span>;
      }

      <span class="n">location</span> / {
          <span class="c"># Docker 이미지의 기본 Host 가 정해진다. 
</span>          <span class="c"># n8n 의 경우 http://n8n-server:5678 이다
</span>          <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">jenkins</span>-<span class="n">server</span>:<span class="m">8080</span>; 
          <span class="n">proxy_set_header</span> <span class="n">Host</span> $<span class="n">host</span>;
          <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span> $<span class="n">remote_addr</span>;
          <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">For</span> $<span class="n">proxy_add_x_forwarded_for</span>;
          <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">Proto</span> $<span class="n">scheme</span>;
      }
  }
</code></pre></div>    </div>
  </li>
  <li><strong>네트워크 공유:</strong>
    <ul>
      <li>도커 네트워크를 연결해야 한다. 하지만 개별 프로젝트로 관리되고 있는 상황에서 이걸 일일히 다시 하나의 Docker-compose 파일로 모으는 건 비효율적이라고 생각. 각자 사용하게 만들기 위해선 다음과 같이 하면된다.
        <ol>
          <li><code class="language-plaintext highlighter-rouge">docker network create {명칭}</code>: 해당 명령어로 네트워크를 미리 사전에 설정해둔다.</li>
          <li>각각의 컴포즈 파일에 <code class="language-plaintext highlighter-rouge">network</code> 항목에 해당 네트워크 명칭을 작성, <code class="language-plaintext highlighter-rouge">networks</code> 항목에 해당 항목을 기재하고 <code class="language-plaintext highlighter-rouge">external: true</code> 라고 넣으면 된다.
            <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="s">... 전략</span>
			
     <span class="na">networks</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="s">my-central-proxy-network</span>

 <span class="na">networks</span><span class="pi">:</span>
   <span class="na">my-central-proxy-network</span><span class="pi">:</span>
     <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div>            </div>
          </li>
          <li>제대로 proxy 전달에 대해서만 가리키고 있다면, 이것으로 HTTP 접속은 구현된다.
            <h4 id="2-jenkins-서버-백업-및-복구">2. Jenkins 서버 백업 및 복구</h4>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>백업하기:</strong>
    <ul>
      <li>기본적으로 Jenkins 는 jenkins_home 이라는 폴더 내부 데이터를 통째로 옮기면 백업과 복원이 용이한 구조다. 이를 위해 볼륨도 호스트와 공유하도록 설정했다면, 손쉽게 통째로 백업 및 복원하면 된다.</li>
      <li><code class="language-plaintext highlighter-rouge">tar -pczvf [압축파일명] [압축 대상 폴더]</code>: p 가 중요한데, 단순히 진행하게 되면 소유권 문제가 발생할 수 있다(시스템의 유저명칭 등이 같더라도 UID, GID 등의 불일치 문제가 발생할 수 있으므로) 이때 해당 옵션을 추가시 해당 기록까지 그대로 가져가준다.</li>
    </ul>
  </li>
  <li><strong>복원하기:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tar -xzvf [대상 압축파일명]</code>: jenkins_home 동일하게 진행해주면 되고, 젠킨스 컨테이너를 재시작하면 완벽하게 복원된다.</li>
    </ul>
  </li>
  <li><strong>문제상황:</strong> DooD 권한실패…!
    <ul>
      <li>DooD 구조를 하다보니 GID 가 같지 않으면 안되는데, 이게 아무래도 확실히 다를 수 밖에 없었다. 기존 메인 서버의 임시 Jenkins 서버는 1001 번이었지만, 이번 서버는 998번(…)</li>
      <li>자동으로 스크립트로 따오게 만들기도 가능하겠지만, 시간관계상 일단 하드코딩으로 Dockerfile에서 이를 설정해주는 작업을 해주었다.
        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ARG DOCKER_GID=984
  RUN groupadd -g ${DOCKER_GID} docker
  RUN usermod -aG docker jenkins
</code></pre></div>        </div>
      </li>
      <li>DooD 랑 호스트의 도커 시스템을 마운트하여도커 컨테이너 내부에서 호스트를 이용해 빌드를 하는 방식이다. 이를 통해 호스트 자원을 그대로 가져다 쓰고, 제어만 커테이너가 하게 된다. 단, 권한 문제를 비롯 제어시 민감한 부분들을 설정을 잘 해줄 필요가 있다.
        <h4 id="3-n8n-서버-http-상에서-열어주기">3. n8n 서버 HTTP 상에서 열어주기</h4>
      </li>
    </ul>
  </li>
  <li><strong>환경변수 설정:</strong> HTTP 환경에선 쓰지 못하게 하는 것이 기본이다. 당연히 종단간 암호화가 안된 상태에서 이걸 진행하게 되면 누군가가 볼 가능성이 당연히 너무 크고, 따라서 중간 탈취를 막아야 하기 때문이다. 그러나 부득불 공개를 해야 한다 or 해도 된다면(내부망 사용 등) 환경 변수를 설정하면된다.
    <pre><code class="language-docker-compose.yml">      environment:
        - GENERIC_TIMEZONE=${GENERIC_TIMEZONE}
        - N8N_SECURE_COOKIE=false # 1. HTTPS가 아니어도 쿠키 사용 허용
        - WEBHOOK_URL=${WEBHOOK_URL} # 2. n8n의 공개 주소 설정
</code></pre>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><category term="Monitoring" /><summary type="html"><![CDATA[2025-10-31 ~ 2025-11-03 : Monitoring 서버 구축하기 &amp; 네트워크 문제 해결하기]]></summary></entry><entry><title type="html">TIL - HTTPS 인증 받기, 그리고 NPM 도입</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-npm-plus-server.html" rel="alternate" type="text/html" title="TIL - HTTPS 인증 받기, 그리고 NPM 도입" /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-npm-plus-server</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-npm-plus-server.html"><![CDATA[<h2 id="2025-11-04--https-인증-받기-그리고-npm-도입">2025-11-04 : HTTPS 인증 받기, 그리고 NPM 도입</h2>

<p>다시 HTTPS 인증을 받으려고 해보았다. 이젠 서버에 등록도 되었겠지. Fail 캐싱도 해결되서 문제 없겠지 라는 생각으로 해보았다.</p>

<p><img src="/assets/images/posts/2025-11/20251104-003.png" alt="" /></p>
<blockquote>
  <p>으아ㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㄱㄱㄱㄱㄱㄱㄱㄱㄱㄱ</p>
</blockquote>

<p>내 시간을 도대체 얼마나 잡아 먹을 생각인가 DuckDNS!!! 라는 생각을 하고 검색으로 문제 해결 방법을 조사해보았다.</p>

<p>그러다 알게된 유사한 경험의 <a href="https://www.reddit.com/r/selfhosted/comments/1j2nkmv/dns_challenge_with_duckdnsorg_timeouts_and/">Reddit 글</a>. 답변을 확인해보니 다음과 같았다.</p>

<ol>
  <li>DNSSE 쿼리 처리가 걍 영구적으로 문제 있음</li>
  <li>HTTPS 인증 요청하면 아마 답 자체를 안하게 됨.</li>
  <li>그러면 님 무조건 timeout 발생함</li>
</ol>

<p>(….)</p>

<p>DuckDNS 의 영구적 문제가 있다는 걸 발견하자 오히려 마음이 편해졌다. 그리하여 NoIP 의 서비스를 구매. 어차피 쓸꺼 하고 화끈하게 2년치 구매를 해버렸다…내 십만원..흑흑 앞으로도 서비스를 만들수도 있으니..</p>

<p>어쨌든 그렇게 하고 보니 NPM 서비스라는 것을 발견하여 해당 방식을 적용 후기이다. <del>가즈아</del></p>

<hr />

<h2 id="nginx-proxy-manager-npm란-무엇인가">Nginx Proxy Manager (NPM)란 무엇인가?</h2>

<p>Nginx Proxy Manager(NPM)는 오픈소스 프로젝트 중 하나로, 강력한 웹 서버인 <strong>Nginx</strong>를 기반으로 한다.
Nginx의 핵심 기능 중 하나인 ‘리버스 프록시’를 누구나 쉽게 사용할 수 있도록 <strong>웹 기반의 그래픽 사용자 인터페이스(GUI)</strong> 를 제공하는 데 목적이 있다.
터미널에 접속하여 복잡한 <code class="language-plaintext highlighter-rouge">.conf</code> 설정 파일을 직접 작성하는 대신, 사용자는 웹 브라우저로 NPM 관리자 페이지(예: <code class="language-plaintext highlighter-rouge">http://서버IP:81</code>)에 접속하여 마우스 클릭과 폼 입력만으로 모든 설정을 완료할 수 있다.</p>

<h2 id="npm의-핵심-기능">NPM의 핵심 기능</h2>

<p>NPM이 제공하는 주요 기능은 크게 세 가지로 나눌 수 있다.</p>

<h3 id="1-리버스-프록시-reverse-proxy-관리">1. 리버스 프록시 (Reverse Proxy) 관리</h3>

<ul>
  <li><strong>호스트 기반 라우팅:</strong> 단일 공인 IP 주소와 80/443 포트를 사용하더라도, <code class="language-plaintext highlighter-rouge">jenkins.yourdomain.com</code>, <code class="language-plaintext highlighter-rouge">n8n.yourdomain.com</code> 등 서로 다른 도메인/서브도메인 요청을 받아, 내부의 각기 다른 서비스(예: <code class="language-plaintext highlighter-rouge">localhost:8080</code>, <code class="language-plaintext highlighter-rouge">localhost:5678</code>)로 정확하게 연결(전달)해준다.</li>
  <li><strong>간편한 설정:</strong> GUI의 ‘Proxy Hosts’ 메뉴에서 도메인 이름, 내부 IP 주소, 내부 포트만 입력하면 즉시 리버스 프록시 설정이 완료된다.</li>
</ul>

<h3 id="2-ssl-인증서-자동화-lets-encrypt">2. SSL 인증서 자동화 (Let’s Encrypt)</h3>

<ul>
  <li><strong>원클릭 SSL:</strong> Let’s Encrypt와 완벽하게 연동되어, GUI에서 스위치 하나만 켜면 자동으로 SSL 인증서를 발급받고 Nginx에 적용한다.</li>
  <li><strong>인증서 자동 갱신:</strong> 발급받은 인증서가 만료되기 전에 자동으로 갱신(Renew)하여 HTTPS가 중단되지 않게 한다.</li>
  <li><strong>DNS-01 챌린지 지원:</strong> (한솔의 현재 상황에 핵심) NoIP, Cloudflare 등 주요 DNS 서비스의 API를 지원한다. GUI에 API 키(또는 계정 정보)를 입력하면, <strong>와일드카드 인증서(<code class="language-plaintext highlighter-rouge">*.yourdomain.com</code>)</strong>를 복잡한 과정 없이 자동으로 발급받을 수 있다.</li>
</ul>

<h3 id="3-기타-편의-기능">3. 기타 편의 기능</h3>

<ul>
  <li><strong>접근 제어 (Access Lists):</strong> 특정 도메인에 대해 IP 기반 접근 제한 또는 사용자 로그인(HTTP Basic Auth)을 쉽게 설정할 수 있다.</li>
  <li><strong>리디렉션 (Redirection):</strong> 특정 주소로 들어온 요청을 다른 주소로 강제 이동(예: HTTP를 HTTPS로)시키는 규칙을 쉽게 생성한다.</li>
</ul>

<h2 id="왜-nginx-대신-npm을-사용하는가">왜 Nginx 대신 NPM을 사용하는가?</h2>

<ul>
  <li><strong>압도적인 편의성:</strong> Nginx 원본(Raw Nginx)은 모든 설정을 텍스트 파일(<code class="language-plaintext highlighter-rouge">nginx.conf</code>)로 관리한다. 문법이 복잡하고, 서비스 하나를 추가할 때마다 SSH 접속, 파일 수정, 문법 검사(<code class="language-plaintext highlighter-rouge">nginx -t</code>), 서비스 재시작(<code class="language-plaintext highlighter-rouge">reload</code>) 과정을 거쳐야 한다. NPM은 이 모든 것을 웹 GUI의 ‘저장’ 버튼 하나로 끝낸다.</li>
  <li><strong>SSL 설정의 간소화:</strong> 원본 Nginx에서 Let’s Encrypt를 쓰려면 ‘Certbot’이라는 별도 도구를 설치하고, Nginx와 연동하는 복잡한 명령어를 실행하며, 갱신을 위한 <code class="language-plaintext highlighter-rouge">cron</code> 작업을 수동으로 등록해야 한다. NPM은 이 모든 과정을 내부적으로 자동화했다.</li>
  <li><strong>낮은 진입 장벽:</strong> Nginx에 대한 깊은 지식이 없어도, NPM의 직관적인 GUI를 통해 누구나 강력한 리버스 프록시 환경을 구축할 수 있다.
<img src="/assets/images/posts/2025-11/20251104-004.png" alt="" /></li>
</ul>

<hr />
<h2 id="문제-해결-과정">문제 해결 과정</h2>
<h3 id="wildcard-ddns-실패">wildcard DDNS 실패</h3>
<ul>
  <li>NoIP 기준 wildcard 방식으로 url 을 설정하는 것이 가능하다.</li>
  <li>이렇게 설정하면 다행이(?) DNS 자리를 줄일 수 있었다. 
<img src="/assets/images/posts/2025-11/20251104-005.png" alt="" /></li>
</ul>

<blockquote>

  <ul>
    <li>그런데 이경우 HTTPS 설정을 해야 하는데, 이때는 방식 두 가지 중 하나로 가능하다.
      <ul>
        <li><strong>HTTP-01 방식:</strong> 개별 URL에 대해서 처리하는 방식</li>
        <li><strong>DNS-01 챌린지 방식:</strong> 특정 사이트 URL 이 소유주가 있음을 인정하여 직접 제어하고, 해당 도메인을 아예 인정해버리는 것. =&gt; 이걸 활용해야 원래는 wildcard 방식의 도메인 접근가능</li>
      </ul>
    </li>
    <li>하필이면… NoIP 는 DNS 프로바이더로  없었다. DNS-01 방식은 공용 포트도 불필요, 와일드카드를 위한 인증서용인데 어쩔수 없이 기본적인 HTTP-01 방식으로 마무리 했다. 
<img src="/assets/images/posts/2025-11/20251104-006.png" alt="" /></li>
    <li>HTTP-01 방식은 전통적인 nginx 의 설정을 그대로 옮긴다고 보면 되었다. 
<img src="/assets/images/posts/2025-11/20251104-007.png" alt="" /></li>
  </ul>
</blockquote>

<hr />

<p>하.. DNS-01 방식으로 삽질을 했다. 그런데 안된다는 걸 깨닫고 빠르게 하니 거의 10분? 이 안걸렸다.</p>

<p>다음부턴 NPM + 쉽게 연결하기로 해결해야지 ㅠ..</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><category term="Monitoring" /><summary type="html"><![CDATA[2025-11-04 : HTTPS 인증 받기, 그리고 NPM 도입]]></summary></entry><entry><title type="html">TIL - NextJS 데모 페이지 구축 (001)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/29/til-nextjs.html" rel="alternate" type="text/html" title="TIL - NextJS 데모 페이지 구축 (001)" /><published>2025-10-29T00:00:00+00:00</published><updated>2025-10-29T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/29/til-nextjs</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/29/til-nextjs.html"><![CDATA[<h2 id="2025-10-29--nextjs-프론트엔드-핵심-개념들">2025-10-29 : Next.js 프론트엔드 핵심 개념들</h2>

<p>오늘은 Next.js와 React를 사용한 프론트엔드 개발을 진행하고 몇 가지 핵심 개념을 살펴보았다. 백엔드 개발자에게 생소할 수 있는 개념들을 위주로 더 자세히 정리하고 코드 예시를 포함했다.</p>

<hr />

<h2 id="-백엔드-개발자가-알아두면-좋은-프론트엔드-개념">💡 백엔드 개발자가 알아두면 좋은 프론트엔드 개념</h2>

<h3 id="1-컴포넌트-렌더링-서버-컴포넌트-vs-클라이언트-컴포넌트-️-vs-">1. 컴포넌트 렌더링: 서버 컴포넌트 vs 클라이언트 컴포넌트 🖥️ vs 💻</h3>

<p>Next.js는 컴포넌트를 <strong>서버</strong>에서 그릴지(HTML 완성) <strong>클라이언트(브라우저)</strong> 에서 그릴지(JavaScript 사용) 결정할수 있다. 이는 백엔드의 서버 사이드 렌더링(SSR) vs 프론트엔드의 클라이언트 사이드 렌더링(CSR) 개념과 유사합니다.</p>
<ul>
  <li><strong>컴포넌트</strong> :
    <ul>
      <li><strong>개념</strong> : 사용자 인터페이스에서 재사용, 독립적인 조각으로 나누어 개발하는 방식으로 생성되는 대상.
        <ul>
          <li>Next.js 는 React를 기반으로 하여, React의 컴포넌트 개념을 그대로 따라간다.</li>
        </ul>
      </li>
      <li><strong>종류</strong> :
        <ul>
          <li><strong>함수 컴포넌트</strong> :
            <ul>
              <li>일반적인 형태</li>
              <li><code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>와 같은 React 훅을 사용하여 상태와 생명주기 기능을 활용 가능</li>
            </ul>
          </li>
          <li><strong>클래스 컴포넌트</strong>
            <ul>
              <li>ES6클래스로 작성됨.</li>
              <li>최신 React 개발에선 함수형을 권장함 .</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>Next.js에서 컴포넌트를 사용하는 이유</strong>
        <ul>
          <li>코드 구조화 및 관리 용이성</li>
          <li>개발 생산성 향상</li>
          <li>성능 최적화</li>
          <li>모듈화</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>서버 컴포넌트 (Server Component, RSC - 기본값):</strong>
    <ul>
      <li><strong>개념:</strong> 컴포넌트 코드가 서버에서 실행되어 최종 HTML로 변환된 후 브라우저로 전송된다. NestJS에서 <code class="language-plaintext highlighter-rouge">EJS</code>나 <code class="language-plaintext highlighter-rouge">Handlebars</code> 같은 템플릿 엔진을 사용해 HTML을 완성해서 보내는 것과 비슷하다.</li>
      <li><strong>장점:</strong>
        <ul>
          <li><strong>초기 로딩 속도:</strong> 브라우저는 완성된 HTML을 바로 보여줄 수 있어 초기 로딩이 빠르다.</li>
          <li><strong>SEO:</strong> 검색 엔진 봇이 완성된 HTML 컨텐츠를 쉽게 수집할 수 있다.</li>
          <li><strong>서버 자원 접근:</strong> DB 조회, 파일 시스템 접근 등 서버에서만 가능한 작업을 직접 수행할 수 있다.</li>
          <li><strong>번들 크기 감소:</strong> 서버에서만 실행되므로 브라우저로 보내는 JavaScript 양이 줄어든다.</li>
        </ul>
      </li>
      <li><strong>제한:</strong> 사용자와의 상호작용(클릭, 입력 등)이나 브라우저 상태(예: <code class="language-plaintext highlighter-rouge">window</code> 객체)에 구조적으로 접근할 수 없다. 즉, <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">onClick</code> 등을 사용할 수 없다.</li>
    </ul>
  </li>
  <li><strong>클라이언트 컴포넌트 (Client Component):</strong>
    <ul>
      <li><strong>개념:</strong> 파일 맨 위에 <code class="language-plaintext highlighter-rouge">"use client";</code> 지시어를 추가하여 명시하면 사용이 가능해짐. 이 컴포넌트의 JavaScript 코드는 브라우저로 다운로드되고 실행된다. 우리가 흔히 아는 React 컴포넌트.</li>
      <li><strong>장점:</strong>
        <ul>
          <li><strong>상호작용:</strong> <code class="language-plaintext highlighter-rouge">useState</code> (상태 관리), <code class="language-plaintext highlighter-rouge">useEffect</code> (라이프사이클 관리), <code class="language-plaintext highlighter-rouge">onClick</code> (이벤트 핸들링) 등을 사용하여 동적인 사용자 인터페이스를 만들 수 있다.</li>
          <li><strong>브라우저 API 접근:</strong> <code class="language-plaintext highlighter-rouge">localStorage</code>, <code class="language-plaintext highlighter-rouge">window</code> 객체 등 브라우저 환경에서만 사용 가능한 API를 활용할 수 있다.</li>
        </ul>
      </li>
      <li><strong>단점:</strong>
        <ul>
          <li><strong>초기 로딩:</strong> 브라우저가 JavaScript 파일을 다운로드하고 실행해야 컴포넌트가 그려지므로, 서버 컴포넌트보다 초기 로딩이 느릴 수 있다(Hydration 과정 필요).</li>
          <li><strong>번들 크기 증가:</strong> 브라우저로 보내는 JavaScript 양이 늘어나고 이는 트래픽이다.</li>
        </ul>
      </li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx 맨 위에 추가하여 클라이언트 컴포넌트임을 명시
  "use client";
    
  import { useState } from 'react';
    
  export default function MyInteractiveComponent() {
    const [count, setCount] = useState(0);
    
    return (
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt; // 버튼 이벤트 
                Count: {count}
      &lt;/button&gt;
    );
  }
</code></pre>
  </li>
</ul>

<h3 id="2-상태state-관리와-리렌더링-usestate-훅-">2. 상태(State) 관리와 리렌더링: <code class="language-plaintext highlighter-rouge">useState</code> 훅 🔄</h3>

<p>React 컴포넌트는 UI에 영향을 미치는 <strong>상태(State)</strong> 를 가질 수 있다. <code class="language-plaintext highlighter-rouge">useState</code>는 함수 컴포넌트에서 상태를 추가하고 관리하기 위한 <strong>훅(Hook)</strong> 이다.</p>
<ul>
  <li><strong>훅(Hook):</strong> 함수 컴포넌트에서 React의 기능(상태 관리, 라이프사이클 등)을 “연결(hook into)”할 수 있게 해주는 특별한 함수들이다. <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useContext</code> 등이 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">useState</code> 사용법:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">const [stateVariable, setStateFunction] = useState(initialState);</code></li>
      <li><code class="language-plaintext highlighter-rouge">stateVariable</code>: 현재 상태 값을 저장하는 변수 (읽기 전용).</li>
      <li><code class="language-plaintext highlighter-rouge">setStateFunction</code>: 이 상태 값을 <strong>업데이트하는 함수</strong>. 이 함수를 호출해야만 React가 컴포넌트를 <strong>리렌더링(Re-render)</strong> 하여 변경된 상태를 화면에 반영한다.</li>
      <li><code class="language-plaintext highlighter-rouge">initialState</code>: 상태의 초기값. 컴포넌트가 처음 렌더링될 때 사용하다.</li>
    </ul>
  </li>
  <li><strong>백엔드와의 비교:</strong>
    <ul>
      <li>상태는 DB에 저장되는 영구 데이터와는 다르게 컴포넌트 인스턴스가 살아있는 동안만 유지되는 <strong>메모리상의 임시 데이터</strong>이다 (NestJS 서비스의 멤버 변수와 유사)</li>
      <li>가장 큰 차이점은 React는 <code class="language-plaintext highlighter-rouge">setStateFunction</code> 호출을 통해 상태 변경을 감지하고, <strong>선언적으로(declaratively)</strong> UI를 업데이트한다는 점이다 . 개발자는 “상태를 이렇게 바꿔줘”라고만 명령하면, React가 알아서 DOM을 효율적으로 조작하여 화면을 변경한다.</li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx
  "use client";
    
  import { useState } from 'react';
    
  // ... (projects 배열 정의)
    
  export default function Home() {
    // isProjectsOpen: 현재 프로젝트 목록이 열려있는지 여부 (true/false)
    // setIsProjectsOpen: isProjectsOpen 값을 변경하는 함수
    // useState(false): 초기값은 false (닫힌 상태)
    const [isProjectsOpen, setIsProjectsOpen] = useState(false);
    
    // 버튼 클릭 시 호출될 함수
    const toggleProjects = () =&gt; {
      // 현재 isProjectsOpen 값의 반대값으로 상태를 업데이트 (일종의 업데이트 )
      setIsProjectsOpen(!isProjectsOpen);
    };
    
    return (
      // ... (생략)
      &lt;button
        onClick={toggleProjects} // 버튼 클릭 시 toggleProjects 함수 실행
        aria-expanded={isProjectsOpen}
      &gt;
        {/* ... SVG 아이콘 ... */}
      &lt;/button&gt;
      // ...
      {isProjectsOpen &amp;&amp; ( // isProjectsOpen이 true일 때만 하위 목록 렌더링
        &lt;ul&gt;
          {/* ... 프로젝트 링크 목록 ... */}
        &lt;/ul&gt;
      )}
      // ...
    );
  }
    
</code></pre>
  </li>
</ul>

<h3 id="3-스타일링-tailwind-css-유틸리티-우선-접근법-">3. 스타일링: Tailwind CSS 유틸리티 우선 접근법 🎨</h3>

<p>Tailwind CSS는 미리 정의된 수많은 <strong>유틸리티 클래스</strong>를 제공한다. 개발자는 이러한 클래스들을 HTML 요소의 <code class="language-plaintext highlighter-rouge">className</code> 속성에 직접 조합하여 스타일을 적용 할 수 있다.</p>

<ul>
  <li><strong>유틸리티 우선(Utility-First):</strong> <code class="language-plaintext highlighter-rouge">button-primary</code> 같은 <strong>의미론적(semantic)</strong> 클래스 대신, <code class="language-plaintext highlighter-rouge">bg-blue-600</code>, <code class="language-plaintext highlighter-rouge">py-3</code>, <code class="language-plaintext highlighter-rouge">font-semibold</code> 같이 <strong>시각적 기능</strong>에 집중된 작은 클래스들을 조합한다.</li>
  <li><strong>작동 방식:</strong>
    <ol>
      <li>개발자가 <code class="language-plaintext highlighter-rouge">className="text-center font-bold"</code>라고 작성한다</li>
      <li>빌드 시 Tailwind CSS가 프로젝트 내의 모든 <code class="language-plaintext highlighter-rouge">className</code>을 스캔한다.</li>
      <li>사용된 유틸리티(<code class="language-plaintext highlighter-rouge">text-center</code>, <code class="language-plaintext highlighter-rouge">font-bold</code>)에 해당하는 CSS 규칙(<code class="language-plaintext highlighter-rouge">.text-center { text-align: center; }</code>, <code class="language-plaintext highlighter-rouge">.font-bold { font-weight: 700; }</code>)을 생성해준다.</li>
      <li>이 생성된 CSS를 <code class="language-plaintext highlighter-rouge">globals.css</code> 파일에 주입한다.</li>
      <li>브라우저는 HTML의 <code class="language-plaintext highlighter-rouge">class</code> 속성과 CSS 파일의 규칙을 매칭하여 스타일을 적용한다.</li>
    </ol>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">tailwind.config.ts</code>:</strong> 테마(색상, 글꼴 크기 등) 커스터마이징, 플러그인 추가, <code class="language-plaintext highlighter-rouge">darkMode</code> 전략 설정 등을 위한 설정 파일이다.</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">globals.css</code>:</strong> Tailwind의 기본 스타일(<code class="language-plaintext highlighter-rouge">@tailwind base;</code>), 컴포넌트 스타일(<code class="language-plaintext highlighter-rouge">@tailwind components;</code>), 유틸리티 스타일(<code class="language-plaintext highlighter-rouge">@tailwind utilities;</code>)을 주입하는 역할과, 직접 작성한 커스텀 CSS 클래스를 추가하는 역할을 한다.</p>

    <pre><code class="language-TypeScript">  // login/page.tsx 예시
  &lt;div className="flex min-h-screen items-center justify-center bg-gray-100"&gt;
    {/* flex: display: flex;
      min-h-screen: min-height: 100vh;
      items-center: align-items: center;
      justify-center: justify-content: center;
      bg-gray-100: 배경색 지정
    */}
    &lt;div className="w-full max-w-md rounded-lg bg-white p-8 shadow-md"&gt;
      {/*
        w-full: width: 100%;
        max-w-md: max-width: 28rem;
        rounded-lg: border-radius: 0.5rem;
        bg-white: background-color: white;
        p-8: padding: 2rem;
        shadow-md: box-shadow 적용
      */}
      &lt;h1 className="mb-6 text-center text-3xl font-bold text-gray-800"&gt;
        로그인
        {/*
          mb-6: margin-bottom: 1.5rem;
          text-center: text-align: center;
          text-3xl: font-size: 1.875rem; line-height: 2.25rem;
          font-bold: font-weight: 700;
          text-gray-800: 글자색 지정
        */}
      &lt;/h1&gt;
      {/* ... */}
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>
  </li>
</ul>

<h3 id="4-nextjs-특화-컴포넌트-link와-image-">4. Next.js 특화 컴포넌트: <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code>와 <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> ✨</h3>

<p>성능 향상을 위해 Next.js는 표준 HTML 태그의 기능을 확장한 자체 컴포넌트를 제공한다. 따라서 표준 HTML 태그가 아닌 태그들을 써야 하는 경우가 있다.</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> 컴포넌트:</strong>
    <ul>
      <li><strong>역할:</strong> 페이지 간 이동을 처리한다. 내부적으로 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 태그를 렌더링하지만, 동작 방식이 다르다.</li>
      <li><strong>핵심 기능 (클라이언트 사이드 라우팅):</strong>
        <ul>
          <li>클릭 시 브라우저가 페이지 전체를 새로고침하지 않는다.</li>
          <li>대신, JavaScript를 사용하여 URL을 변경하고 필요한 페이지만 동적으로 로드하여 교체한다 (SPA처럼 동작).(레이아웃 기반으로 최초 접근 위치에서 자식만 교체 한다던가…)</li>
          <li>결과로서 매우 빠르고 부드러운 페이지 전환 경험을 제공한다.</li>
        </ul>
      </li>
      <li><strong>프리페칭(Prefetching):</strong> 기본적으로 <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code>가 화면에 보이면, 해당 링크가 가리키는 페이지의 코드를 백그라운드에서 미리 다운로드한다. 사용자가 클릭했을 때 거의 즉시 페이지가 로드된다.</li>
      <li><strong>사용법:</strong> <code class="language-plaintext highlighter-rouge">href</code> 속성으로 이동할 경로를 지정한다.</li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx 예시
  import Link from 'next/link';
    
  &lt;Link href="/login" className="text-blue-600 hover:underline"&gt;
    Login Page
  &lt;/Link&gt;
</code></pre>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 컴포넌트:</strong>
    <ul>
      <li><strong>역할:</strong> 이미지를 표시합니다. 내부적으로 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 태그를 렌더링하지만, 강력한 최적화 기능을 추가한다.</li>
      <li><strong>핵심 기능 (자동 이미지 최적화):</strong>
        <ul>
          <li><strong>사이즈 최적화:</strong> 다양한 화면 크기(데스크탑, 모바일 등)에 맞는 이미지 크기를 자동으로 생성하고 제공한다.</li>
          <li><strong>포맷 최적화:</strong> 브라우저가 지원하는 경우, 이미지를 WebP나 AVIF 같은 최신 포맷으로 자동 변환하여 용량을 최적화 시킨다.</li>
          <li><strong>지연 로딩 (Lazy Loading):</strong> 기본적으로 이미지가 사용자의 뷰포트(화면 영역)에 들어올 때까지 로딩을 지연시켜 초기 페이지 로딩 속도를 향상시킵니다. (<code class="language-plaintext highlighter-rouge">priority</code> 속성으로 비활성화 가능, 필요한 경우 즉시 로딩을 요청할 수 있다.)</li>
          <li><strong>CLS(Cumulative Layout Shift) 방지:</strong> <code class="language-plaintext highlighter-rouge">width</code>와 <code class="language-plaintext highlighter-rouge">height</code> 속성을 필수로 요구하여, 이미지가 로드되기 전에 해당 공간을 미리 확보함으로써 레이아웃이 갑자기 변경되는 현상을 방지한다.</li>
        </ul>
      </li>
      <li><strong>사용법:</strong> <code class="language-plaintext highlighter-rouge">src</code>, <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, <code class="language-plaintext highlighter-rouge">alt</code> 속성이 필수(이걸 몰라서 왜 에러가 뜨지? 하고 한참 해맸다.). <code class="language-plaintext highlighter-rouge">src</code>는 <code class="language-plaintext highlighter-rouge">public</code> 폴더 기준의 절대 경로 또는 외부 URL을 사용한다.</li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx 예시
  import Image from 'next/image';
    
  &lt;Image
    src="/main.png" // public 폴더의 main.png
    alt="메인 비주얼"
    width={800}    // 이미지 원본 너비
    height={800}   // 이미지 원본 높이
    priority       // 이 이미지는 중요하므로 먼저 로드
  /&gt;
</code></pre>
  </li>
</ul>

<hr />

<h2 id="-질문-목록-qa">❓ 질문 목록 (Q&amp;A)</h2>

<h3 id="q1-맨-위에-use-client의-역할은">Q1: 맨 위에 <code class="language-plaintext highlighter-rouge">"use client"</code>의 역할은?</h3>

<p><strong>A:</strong> 해당 파일(모듈)이 <strong>클라이언트 컴포넌트</strong>임을 명시하는 지시어다. <code class="language-plaintext highlighter-rouge">"use client"</code>가 선언된 파일과 그 파일에서 import하는 모든 모듈은 클라이언트 번들에 포함되어 브라우저에서 실행된다. 이는 <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code> 같은 React 훅이나 <code class="language-plaintext highlighter-rouge">onClick</code> 같은 브라우저 이벤트를 사용하기 위해 필수적이다. 반대로, 이 지시어가 없으면 기본적으로 <strong>서버 컴포넌트</strong>로 간주되므로 클라이언트 사이드의 이벤트에 대해서 인식이 불가능하다.</p>

<h3 id="q2-usestatefalse는-기본값을-선정하는-건가-isprojectsopen과-setisprojectsopen-두-가지의-역할과-차이는">Q2: <code class="language-plaintext highlighter-rouge">useState(false)</code>는 기본값을 선정하는 건가? <code class="language-plaintext highlighter-rouge">isProjectsOpen</code>과 <code class="language-plaintext highlighter-rouge">setIsProjectsOpen</code> 두 가지의 역할과 차이는?</h3>

<p><strong>A:</strong></p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">useState()</code>의 인자로 전달된 값(<code class="language-plaintext highlighter-rouge">false</code> 등)은 해당 상태 변수의 <strong>초기값(initial state)</strong>. 컴포넌트가 처음 마운트될 때 이 값으로 상태가 초기화된다.(해당 코드에선 접혀있는 상태로 시작해야 하므로 false를 넣고, 대신 statetFunction에서 not 처리를 해준다.)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">isProjectsOpen</code>: <strong>현재 상태 값</strong>을 담고 있는 변수. JSX 내에서 이 값을 읽어 UI를 조건부로 렌더링하거나 표시할 수 있다. 이 변수는 직접 수정할 수 없다 (예: <code class="language-plaintext highlighter-rouge">isProjectsOpen = true;</code> 불가).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">setIsProjectsOpen</code>: <code class="language-plaintext highlighter-rouge">isProjectsOpen</code> 상태를 <strong>업데이트하는 함수</strong>다. 이 함수에 새로운 상태 값을 전달하여 호출하면 (<code class="language-plaintext highlighter-rouge">setIsProjectsOpen(true);</code> 또는 <code class="language-plaintext highlighter-rouge">setIsProjectsOpen(prev =&gt; !prev);</code>), React는 상태 변경을 감지하고 컴포넌트를 리렌더링하여 UI를 갱신한다. 이것이 전형적인 React에서 상태를 변경하는 방법이다.</p>
  </li>
</ul>

<h3 id="q3-const-toggle로-화살표-함수는-usestate에-사용하기-위해-설정해주는-일종의-변수형-메서드인-건가">Q3: <code class="language-plaintext highlighter-rouge">const toggle~</code>로 화살표 함수는 <code class="language-plaintext highlighter-rouge">useState</code>에 사용하기 위해 설정해주는 일종의 변수형 메서드인 건가?</h3>

<p><strong>A:</strong> “일종의 변수형 메서드” 또는 더 정확히는 <strong>이벤트 핸들러 함수</strong>라고 볼 수 있다. <code class="language-plaintext highlighter-rouge">useState</code> 자체에 필요한 것은 아니다. 단, 상태를 변경하는 로직(예: <code class="language-plaintext highlighter-rouge">setIsProjectsOpen(!isProjectsOpen)</code>)을 <code class="language-plaintext highlighter-rouge">&lt;button&gt;</code>의 <code class="language-plaintext highlighter-rouge">onClick</code> 속성에 직접 넣는 대신, 별도의 함수(<code class="language-plaintext highlighter-rouge">toggleProjects</code>)로 분리하여 정의한 것이다. 이렇게 하면 코드가 더 깔끔해지고, 로직이 복잡해질 경우 관리하기 용이하며, 필요하다면 다른 곳에서 재사용할 수도 있다.</p>

<pre><code class="language-TypeScript">// 이벤트 핸들러 함수 정의
const toggleProjects = () =&gt; {
  setIsProjectsOpen(prevState =&gt; !prevState); // 이전 상태를 기반으로 토글
};

// JSX에서 이벤트 핸들러로 함수 연결
&lt;button onClick={toggleProjects}&gt;...&lt;/button&gt;
</code></pre>

<h3 id="q4-nextjs에서-주로-사용한다는-html이-아닌-자체-태그들link라던가이-있는데-왜-이걸-써야-하고-안-쓰면-안-되는-이유가-있는지">Q4: Next.js에서 주로 사용한다는 HTML이 아닌 자체 태그들(<code class="language-plaintext highlighter-rouge">Link</code>라던가)이 있는데, 왜 이걸 써야 하고, 안 쓰면 안 되는 이유가 있는지?</h3>

<p><strong>A:</strong> <strong>성능 최적화와 향상된 사용자 경험</strong>을 위해서 Next.js의 자체 컴포넌트 사용이 강력히 권장한다. 안 쓴다고 해서 앱이 작동하지 않는 것은 아니지만, Next.js를 사용하는 핵심 이점들을 놓치게 된다.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> vs <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>:</strong> <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code>는 <strong>클라이언트 사이드 라우팅</strong>을 구현하여 페이지 전환 시 전체 새로고침 없이 변경된 부분만 업데이트한다. 이는 훨씬 빠르고 부드러운 사용자 경험(SPA와 유사)을 제공합니다. 또한, <strong>프리페칭</strong> 기능으로 미리 다음 페이지를 로드하여 전환 속도를 더욱 높인다. 일반 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 태그는 전통적인 서버 방식의 페이지 이동(전체 새로고침)을 만들고, 당연히 동작은 하나 전체를 새로 그려야 한다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> vs <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>:</strong> <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code>는 <strong>자동으로 이미지를 최적화</strong>한다(사이즈 조절, WebP 변환, 지연 로딩 등). 이는 페이지 로딩 속도를 크게 개선하고 대역폭 사용량을 줄여준다. 또한 <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>를 강제하여 레이아웃 쉬프트(CLS) 문제를 예방한다. 일반 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 태그는 이러한 최적화 기능을 제공하지 않고 직접 처리해야 한다.</p>
  </li>
</ul>

<h3 id="q5-button-컴포넌트의-svg-태그에서--안에-넣으면-일종의-함수로-동작하는-건지-그리고-fill-stroke와-같은-classname에-안-들어간-별도의-요소들은-그냥-svg-태그의-요소들인-건지">Q5: <code class="language-plaintext highlighter-rouge">button</code> 컴포넌트의 <code class="language-plaintext highlighter-rouge">svg</code> 태그에서 <code class="language-plaintext highlighter-rouge">${}</code> 안에 넣으면 일종의 함수로 동작하는 건지? 그리고 <code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">stroke</code>와 같은 <code class="language-plaintext highlighter-rouge">className</code>에 안 들어간 별도의 요소들은 그냥 <code class="language-plaintext highlighter-rouge">svg</code> 태그의 요소들인 건지?</h3>

<p><strong>A:</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">${...}</code>: 이것은 함수 호출이 아니라, JavaScript의 <strong>템플릿 리터럴(Template Literal)</strong> 내에서 <strong>표현식 삽입(Expression Interpolation)</strong> 을 사용하는 문법이다. 백틱(<code class="language-plaintext highlighter-rouge">`</code>)으로 감싸진 문자열 안에서 <code class="language-plaintext highlighter-rouge">${}</code>를 사용하면, 중괄호 안의 JavaScript 코드가 평가되고 그 결과값이 문자열의 해당 위치에 삽입한다. 예시 코드에서는 <code class="language-plaintext highlighter-rouge">isProjectsOpen</code> 상태에 따라 <code class="language-plaintext highlighter-rouge">rotate-180</code> 클래스를 조건부로 추가하여 아이콘의 회전 상태를 제어한다.</p>

    <pre><code class="language-JavaScript">  // className 속성에 템플릿 리터럴 사용
  &lt;svg
    className={`h-5 w-5 transition-transform ${ // 백틱(`)으로 시작
      isProjectsOpen ? 'rotate-180' : '' // ${} 안에 삼항 연산자 표현식
    }`} // 백틱(`)으로 끝
    // ... (SVG 속성들)
  &gt;
    {/* ... */}
  &lt;/svg&gt;
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">stroke</code>, <code class="language-plaintext highlighter-rouge">viewBox</code>, <code class="language-plaintext highlighter-rouge">xmlns</code>, <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">strokeLinecap</code>, <code class="language-plaintext highlighter-rouge">strokeLinejoin</code>, <code class="language-plaintext highlighter-rouge">strokeWidth</code>:  이 속성들은 <code class="language-plaintext highlighter-rouge">className</code>과는 별개로 <strong>SVG(Scalable Vector Graphics) 표준 명세에 정의된 고유한 속성(attributes)</strong> 이다. 벡터 그래픽의 모양, 색상, 선 스타일 등을 정의하는 데 사용됩니다. Tailwind CSS 클래스와는 직접적인 관련이 없다.</p>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025-10-29 : Next.js 프론트엔드 핵심 개념들]]></summary></entry><entry><title type="html">TIL - Prettier &amp;amp; ESLint 적용</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-prettier-eslint.html" rel="alternate" type="text/html" title="TIL - Prettier &amp;amp; ESLint 적용" /><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-prettier-eslint</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-prettier-eslint.html"><![CDATA[<h2 id="2025-10-28--prettier--eslint-설정-in-nextjs-project">2025-10-28 : Prettier &amp; ESLint 설정 in Next.js Project</h2>

<p>오늘은 Next.js 프로젝트 (<code class="language-plaintext highlighter-rouge">project-mini-frontend/app</code>)에 코드 포매터인 <strong>Prettier</strong>와 린터인 <strong>ESLint</strong>를 설정하고, 두 도구가 충돌 없이 협력하도록 연동을 적용하고 개념에 대해 학습했다.</p>

<hr />

<h3 id="1-prettier-설정-">1. Prettier 설정 💅</h3>

<p>코드 스타일의 일관성을 자동으로 유지하기 위해 Prettier를 도입했다.</p>

<ul>
  <li><strong>설치:</strong> <code class="language-plaintext highlighter-rouge">pnpm</code>을 사용하여 <code class="language-plaintext highlighter-rouge">prettier</code>와 ESLint와의 충돌 방지용 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code>를 개발 의존성으로 설치했다.
    <pre><code class="language-Bash">  cd app
  pnpm add -D prettier eslint-config-prettier
</code></pre>
    <p><img src="/assets/images/til/25-10/251031-001.png" alt="" /></p>
    <blockquote>
      <p>프로젝트 구조 때문에 app 에 들어가서 해야 하는게 귀찮다…</p>
    </blockquote>
  </li>
  <li><strong>설정 파일 (<code class="language-plaintext highlighter-rouge">.prettierrc.json</code>):</strong> 프로젝트 루트(<code class="language-plaintext highlighter-rouge">app/</code>)에 설정 파일을 생성하여 팀의 코드 포매팅 규칙(세미콜론, 따옴표, 줄 바꿈 등)을 정의했다. 우선은 가장 추천하는 설정값을 그대로 적용시켰다.
    <pre><code class="language-JSON">  // .prettierrc.json
  {
    "semi": true, // 끝에 세미 콜론으로 종료 표시 
    "trailingComma": "all", // 객체, 배열의 여러줄로 나열 시 마지막 항목 뒤에도 쉼표 붙이기 
    "singleQuote": true,// 자스에서 문자열은 무조건 작은따옴표로 통일 
    "printWidth": 80, // 코드 한줄의 최대 길이를 80자로 제어 
    "tabWidth": 2, // 들여쓰기는 스페이스 2칸 
    "endOfLine": "auto" // 줄바꿈 스타일을 OS에 맞춰 자동화 
  }
</code></pre>
    <p><img src="/assets/images/til/25-10/251031-004.png" alt="" /></p>
  </li>
  <li><strong>무시 파일 (<code class="language-plaintext highlighter-rouge">.prettierignore</code>):</strong> <code class="language-plaintext highlighter-rouge">node_modules</code>, <code class="language-plaintext highlighter-rouge">.next</code> 등 포매팅 대상에서 제외할 파일 및 폴더를 지정하는 파일을 생성했다. 설정을 안하니 빌드된 결과물까지도 판단하기에 특히 dist, build 폴더 등은 반드시 해둬야 한다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      # .prettierignore
      node_modules
      .next
      .pnpm-store
      dist
      build
      public
</code></pre></div>    </div>
    <p><img src="/assets/images/til/25-10/251031-005.png" alt="" />
  <img src="/assets/images/til/25-10/251031-006.png" alt="" /></p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">package.json</code> 스크립트 추가:</strong> 코드 포매팅을 실행(<code class="language-plaintext highlighter-rouge">format</code>)하거나 검사(<code class="language-plaintext highlighter-rouge">format:check</code>)하는 스크립트를 추가했다. CI에서는 주로 <code class="language-plaintext highlighter-rouge">format:check</code>를 사용한다. 특히 <code class="language-plaintext highlighter-rouge">format:check</code>의 추가는 Jenkins 기반의 무중단 배포 전 테스트를 위한 용도이다.
    <pre><code class="language-JSON">  // package.json scripts
  "scripts": {
    // ...
    "format": "prettier --write .",
    "format:check": "prettier --check ."
  },
</code></pre>
    <p><img src="/assets/images/til/25-10/251031-007.png" alt="" />
  <img src="/assets/images/til/25-10/251031-008.png" alt="" /></p>
    <blockquote>
      <p>깔끔하게 에러 체킹이 되는것 까지 확인하였고, Jenkins 무중단 배포에서 해당 검사 기능을 추가하였다.</p>
    </blockquote>
  </li>
</ul>

<hr />

<h3 id="2-eslint와-prettier-연동-">2. ESLint와 Prettier 연동 🤝</h3>

<p>ESLint(코드 품질)와 Prettier(코드 스타일)는 일부 규칙(예: 줄 길이, 따옴표)이 겹쳐 충돌할 수 있다. 이를 해결하기 위해 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code>를 사용하여 ESLint의 스타일 관련 규칙을 비활성화하고, 스타일링은 전적으로 Prettier에게 맡기는 걸로 수정하였다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">eslint.config.mjs</code> 설정:</strong> ESLint 설정 파일(<code class="language-plaintext highlighter-rouge">app/eslint.config.mjs</code>)에서 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code>를 <code class="language-plaintext highlighter-rouge">import</code>하고, 설정 배열의 <strong>맨 마지막</strong>에 추가하여 Prettier와 충돌하는 ESLint 규칙을 껐다.
    <pre><code class="language-JavaScript">  // eslint.config.mjs
  import prettierConfig from 'eslint-config-prettier';
    
  export default [
    // ... (기존 ESLint 설정들)
    
    // 맨 마지막에 추가하여 스타일 규칙 충돌 방지
    prettierConfig, 
  ];
</code></pre>
  </li>
  <li><strong>역할 분담:</strong> 자꾸 헷갈리는 부분이기에 정리해보면…
    <ul>
      <li><strong>ESLint:</strong> 코드의 논리적 오류, 잠재적 버그, 안티 패턴 등 <strong>코드 품질</strong>에 집중.</li>
      <li><strong>Prettier:</strong> 들여쓰기, 줄 바꿈, 따옴표 등 오직 <strong>코드 스타일</strong>만 관리.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-eslint-검사-범위-설정-ignoring-files-">3. ESLint 검사 범위 설정 (Ignoring Files) 🚫</h3>

<p>ESLint가 불필요한 파일(예: 빌드 결과물)을 검사하지 않도록 설정했다.</p>

<ul>
  <li>
    <p><strong>문제:</strong> 기본 설정에서는 <code class="language-plaintext highlighter-rouge">pnpm lint</code> 실행 시 Next.js의 빌드 폴더인 <code class="language-plaintext highlighter-rouge">.next/</code> 내부까지 검사하는 문제가 있다.</p>
  </li>
  <li>
    <p><strong>해결 (<code class="language-plaintext highlighter-rouge">eslint.config.mjs</code>):</strong> ESLint의 최신 설정 방식(Flat Config)에서는 <code class="language-plaintext highlighter-rouge">.eslintignore</code> 파일 대신, <code class="language-plaintext highlighter-rouge">eslint.config.mjs</code> 파일 내부에 <code class="language-plaintext highlighter-rouge">ignores</code> 속성을 사용하여 무시할 경로를 직접 지정 가능하다. 설정 배열의 <strong>앞부분</strong>에 추가하여 전역적으로 적용했다.</p>

    <pre><code class="language-JavaScript">  // eslint.config.mjs
  import prettierConfig from 'eslint-config-prettier';
    
  export default [
    // ignores 설정을 배열 앞부분에 추가
    {
      ignores: [
        'node_modules/**', // node_modules 폴더
        '.next/**',        // Next.js 빌드 폴더
        'public/**',       // public 폴더 (선택 사항)
      ],
    },
    
    // ... (기존 설정들)
    prettierConfig,
  ];
    
</code></pre>
  </li>
</ul>

<hr />

<h2 id="질문-정리">질문 정리</h2>
<h3 id="eslint와-prettier의-관계-및-연동할-필요가-있을까">ESLint와 Prettier의 관계 및 연동할 필요가 있을까?</h3>

<p>ESLint와 Prettier는 현대 웹 개발 환경에서 코드의 일관성과 품질을 유지하기 위해 사용되는 핵심 도구이다. 두 도구는 목적이 다르지만, 일부 기능 영역이 겹쳐 충돌이 발생할 수 있다고 한다. 따라서 이 둘을 올바르게 연동하여 각자의 역할을 명확히 분리하는 것이 중요하고 그래서 차이를 이해해야 한다.</p>

<hr />

<h4 id="각-도구의-핵심-역할">각 도구의 핵심 역할</h4>

<h5 id="eslint-린터-linter">ESLint (린터, Linter)</h5>

<p>ESLint는 코드의 <strong>품질(Quality)</strong> 을 검사하는 도구다. 주요 목적은 잠재적인 버그나 안티 패턴을 찾아내어 코드의 논리적 오류를 방지하는 것이다.</p>
<ul>
  <li><strong>주요 기능</strong>:
    <ul>
      <li>문법 오류 검사</li>
      <li>사용되지 않는 변수 탐지</li>
      <li><code class="language-plaintext highlighter-rouge">React Hooks</code>의 잘못된 사용 등 프레임워크 규칙 검사</li>
      <li>논리적 안티 패턴 식별</li>
    </ul>
  </li>
</ul>

<h5 id="prettier-코드-포매터-code-formatter">Prettier (코드 포매터, Code Formatter)</h5>

<p>Prettier는 코드의 <strong>스타일(Style)</strong> 을 통일하는 도구이다. 코드가 어떻게 “보이는지”에만 집중하며, 매우 ‘독단적인(Opinionated)’ 규칙을 적용하여 모든 개발자가 동일한 코드 서식을 갖도록 강제한다.</p>

<ul>
  <li><strong>주요 기능</strong>:
    <ul>
      <li>들여쓰기 (예: 2칸 공백)</li>
      <li>문자열 따옴표 통일 (예: 작은따옴표)</li>
      <li>줄 바꿈 (예: 80자 초과 시)</li>
      <li>세미콜론(;) 자동 추가 또는 제거</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="연동의-필요성-규칙의-충돌">연동의 필요성: 규칙의 충돌</h4>

<p>문제는 ESLint의 규칙 중에도 코드 스타일을 다루는 부분이 있다는 것이다. (예: <code class="language-plaintext highlighter-rouge">max-len</code> (최대 줄 길이), <code class="language-plaintext highlighter-rouge">semi</code> (세미콜론 사용 여부), <code class="language-plaintext highlighter-rouge">quotes</code> (따옴표 종류) 등)</p>

<p>만약 두 도구를 별다른 설정 없이 함께 사용하면, 동일한 코드 스타일에 대해 서로 다른 규칙을 강요하며 충돌하게 된다.</p>

<ul>
  <li><strong>충돌 예시</strong>:
    <ul>
      <li><strong>ESLint 규칙</strong>: “한 줄은 최대 100자까지 허용한다.”</li>
      <li><strong>Prettier 규칙</strong>: “한 줄은 80자가 넘으면 무조건 줄 바꿈한다.”</li>
      <li><strong>결과</strong>: 개발자가 90자 코드를 작성하면, Prettier는 강제로 줄을 바꾸고, ESLint는 이 변경이 불필요하다고 판단하거나 그 반대의 상황이 발생하여, 저장 시마다 코드가 계속 변경되거나 에러가 발생한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="해결-방안-eslint-config-prettier">해결 방안: <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code></h4>

<p>이 충돌을 해결하기 위해 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code> 패키지를 사용한다.</p>

<p>이 패키지의 유일한 역할은 <strong>ESLint의 규칙 중 Prettier와 겹치는 모든 스타일 관련 규칙을 비활성화(off)</strong> 하는 것이다.</p>

<p>이를 통해 코드 스타일에 대한 제어권은 100% Prettier에게 위임하고, ESLint는 오직 코드 품질 검사에만 집중하도록 역할을 명확히 분리할 수 있다.</p>

<hr />

<h4 id="최종-역할-분담">최종 역할 분담</h4>

<p>올바르게 연동된 환경에서의 최종 역할은 다음과 같다.</p>

<ul>
  <li><strong>ESLint</strong>: 코드의 <strong>논리적 품질</strong>만 검사한다.
    <ul>
      <li>(예: “이 변수는 사용되지 않았습니다.”, “React Hook의 의존성 배열이 잘못되었습니다.”)</li>
    </ul>
  </li>
  <li><strong>Prettier</strong>: 코드의 <strong>시각적 스타일</strong>만 관리한다.
    <ul>
      <li>(예: “들여쓰기는 2칸입니다.”, “문자열은 작은따옴표로 통일합니다.”)</li>
    </ul>
  </li>
</ul>

<h4 id="그렇게-좋은데-기본-설정이-아닌-이유는-">그렇게 좋은데… 기본 설정이 아닌 이유는 ?</h4>

<ol>
  <li><strong>목적의 차이</strong>: ESLint(품질)는 버그 방지를 위해 필수적이지만, Prettier(스타일)는 팀의 ‘선택’ 사항이다.</li>
  <li><strong>도구의 독립성</strong>: 두 도구는 서로 다른 목적을 위해 별개로 개발된 독립적인 프로젝트이다.</li>
  <li><strong>스타일의 주관성</strong>: Prettier는 매우 ‘독단적인’ 스타일을 강제한다. 모든 개발팀이 이 스타일에 동의하는 것은 아니며, 다른 포매터(dprint 등)를 선택할 수도 있다. 따라서 프레임워크가 특정 스타일을 기본으로 강제하지 않는다.</li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025-10-28 : Prettier &amp; ESLint 설정 in Next.js Project]]></summary></entry><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (1)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/1-til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (1)" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/1-til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/1-til-jenkins.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h2 id="01-jenkins">01 Jenkins</h2>

<h3 id="개념">개념</h3>
<ul>
  <li>Jenkins는 소프트웨어 개발에서 지속적인 통합(Continuous Integration, CI)과 지속적인 배포(Continuous Deployment, CD)를 자동화하는 데 사용되는 오픈 소스 자동화 서버다.</li>
  <li>개발자가 코드를 변경하고 저장소에 커밋(commit)하면, Jenkins는 자동으로 코드를 빌드(build)하고, 테스트(test)하며, 배포하는 일련의 과정을 수행한다.</li>
  <li>개발 프로세스의 효율성을 높이고, 오류를 조기에 발견하며, 궁극적으로 안정적인 소프트웨어 릴리스(release)를 가능하게 하는 도구이다.
    <h3 id="왜--jenkins-와-같은-전문-툴이-필요한가--지속적인-통합continuous-integrateion-ci">왜  Jenkins 와 같은 전문 툴이 필요한가? : 지속적인 통합(Continuous Integrateion, CI)</h3>
  </li>
  <li><strong>오류 조기 발견</strong>: 코드가 자주 통합되고 테스트되므로, 통합 과정에서 발생하는 오류나 버그를 개발 초기에 발견하고 수정할 수 있다. 이는 문제 해결 비용을 크게 절감한다.</li>
  <li><strong>코드 품질 향상</strong>: 자동화된 테스트를 통해 코드의 일관성과 안정성을 유지하며, 개발자들은 더 높은 품질의 코드를 작성하는 데 집중할 수 있게 만든다.</li>
  <li><strong>개발 생산성 증대</strong>: 수동으로 빌드하고 테스트하는 시간을 줄여 개발자들이 새로운 기능 개발에 더 많은 시간을 할애할 수 있도록 한다.</li>
  <li><strong>팀 협업 강화</strong>: 개발자들이 서로의 코드 변경 사항을 빠르게 공유하고 통합함으로써 팀 전체의 협업 효율성을 높인다.</li>
</ul>

<h3 id="왜-jenkins-와-같은-전문-툴이-필요한가--지속적인-배포continuous-deployment-cd">왜 Jenkins 와 같은 전문 툴이 필요한가? : 지속적인 배포(Continuous Deployment, CD)</h3>
<ul>
  <li><strong>빠른 릴리스 주기</strong>: 새로운 기능이나 버그 수정 사항을 신속하게 사용자에게 제공하여 시장 변화에 빠르게 대응할 수 있다.</li>
  <li><strong>배포 프로세스 자동화</strong>: 수동 배포 과정에서 발생할 수 있는 인적 오류를 제거하고, 배포의 일관성과 신뢰성을 확보한다.</li>
  <li><strong>위험 감소</strong>: 작고 빈번한 배포를 통해 한 번의 배포로 인한 위험 부담을 줄이고, 문제가 발생하더라도 빠르게 롤백(rollback)하거나 수정할 수 있다.</li>
  <li><strong>피드백 루프 단축</strong>: 사용자 피드백을 빠르게 수집하고 다음 개발 주기에 반영함으로써 제품 개선 속도를 높인다.</li>
</ul>

<h3 id="jenkins-의-역할은">Jenkins 의 역할은</h3>
<ul>
  <li><strong>코드 변경 감지</strong>: Git, SVN 등 다양한 버전 관리 시스템(VCS)과 연동하여 코드 저장소의 변경 사항을 지속적으로 감지한다.</li>
  <li><strong>자동 빌드</strong>: 변경된 코드를 자동으로 가져와 컴파일(compile)하고, 필요한 의존성(dependency)을 설치하며, 실행 가능한 아티팩트(artifact)를 생성한다.</li>
  <li><strong>자동 테스트</strong>: 단위 테스트(unit test), 통합 테스트(integration test), 성능 테스트(performance test) 등 다양한 유형의 테스트를 자동으로 실행하여 코드의 품질과 안정성을 검증한다.</li>
  <li><strong>자동 배포</strong>: 테스트를 통과한 아티팩트를 개발, 스테이징(staging), 프로덕션 환경 등 지정된 서버에 자동으로 배포한다.</li>
  <li><strong>파이프라인 오케스트레이션(Orchestration)</strong>: 빌드, 테스트, 배포 등 CI/CD의 모든 단계를 하나의 파이프라인으로 정의하고, 각 단계의 실행 순서와 조건을 관리한다.</li>
  <li><strong>알림 및 보고</strong>: 빌드 및 배포 결과에 대한 성공/실패 알림을 이메일, Slack, Discord 등 다양한 채널로 전송하고, 상세한 보고서를 제공한다.</li>
</ul>

<h3 id="jenkins-의-장점">Jenkins 의 장점</h3>
<ul>
  <li><strong>오픈 소스 및 확장성</strong>: 무료로 사용할 수 있는 오픈 소스이며, 수많은 플러그인을 통해 거의 모든 종류의 빌드, 테스트, 배포 도구와 연동하여 기능을 확장할 수 있다.</li>
  <li><strong>다양한 환경 지원</strong>: Java, Python, Node.js, .NET 등 다양한 프로그래밍 언어와 프레임워크(framework)를 지원하며, Docker, Kubernetes와 같은 컨테이너(container) 기술과도 쉽게 통합된다.</li>
  <li>
    <p><strong>강력한 파이프라인 기능</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 통해 CI/CD 파이프라인을 코드로 정의하고 버전 관리할 수 있어, 파이프라인의 재현성(reproducibility)과 유지보수성(maintainability)을 높다. (예시: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>)
```Groovy
pipeline {
agent any</p>

    <p>environment {
    GHCR_CREDS_ID = ‘ghcr-creds’
    GITHUB_CREDS_ID = ‘github-creds’
    TARGET_SSH_CREDS_ID = ‘a5-localhost-jenkins’</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TARGET_DEPLOY_SERVER = 'GEEKOM-A5-Server'

DISCORD_CREDS_ID = 'discord-webhook-url'
</code></pre></div>    </div>
  </li>
</ul>

<p>// … 중략</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stages {
// code pull
    stage('Checkout') {
        steps {
            echo "1. Get the latest code from GitHub"
            git credentialsId: GITHUB_CREDS_ID, url: 'https://github.com/paul2021-r/project-mini-frontend.git', branch: 'main'
        }
    }
</code></pre></div></div>

<p>// … 중략</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>post {
    success {
        echo "Deployment succeeded. Now send a discord notification."
        script {
            withCredentials([string(credentialsId: DISCORD_CREDS_ID, variable: 'DISCORD_URL')]) {
                def message = "{\"content\": \"🚀 Build Process is successfully finished : **[${env.JOB_NAME}]** - **#${env.BUILD_NUMBER}**\"}"
</code></pre></div></div>

<p>// … 후략</p>

<p>}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
*   **활발한 커뮤니티 지원**: 전 세계적으로 많은 사용자와 개발자들이 활발하게 활동하며, 다양한 문제 해결과 기능 개선에 기여하고 있다. 이는 풍부한 자료와 지원을 받을 수 있다는 장점으로 이어진다.
*   **시각화 및 모니터링**: Blue Ocean과 같은 플러그인을 통해 파이프라인의 실행 과정을 시각적으로 확인하고, 빌드 상태를 실시간으로 모니터링할 수 있다.

### Jenkins 의 아키텍쳐 
- 단일 빌드도 가능하나, 여러 프로젝트를 동시에 처리하는 경우 분산 빌드(Distrivuted Builds) 아키텍처를 활용한다. 이러한 아키텍쳐는 컨트롤러와 노드로 구분되며 각기 역할을 분담하면 Jenkins 의 확장성, 효율성에 도움이 된다. 단, 어디까지나 시스템과 리소스의 상황에 따라 최적화 시키는것이 중요하다. 
#### Jenkins Master(컨트롤러)
   - **작업 스케줄링 및 관리**: 빌드 작업을 언제, 어떤 Agent에서 실행할지 결정하고, 전체 파이프라인의 흐름을 관리한다. 
*   **Agent 연결 관리**: 등록된 Agent들과의 연결을 유지하고, Agent의 상태를 모니터링한다.
*   **설정 및 플러그인 관리**: Jenkins의 전반적인 설정, 사용자 관리, 보안 설정, 그리고 설치된 플러그인들을 관리합니다. `project-mini-jenkins` 프로젝트의 `jenkins/casc.yaml` 파일은 Master의 설정을 코드로 관리하는 예시입니다.
*   **빌드 결과 저장**: 빌드 로그, 테스트 결과, 아티팩트 등 빌드 관련 데이터를 저장하고 관리한다.
*   **UI 제공**: 웹 인터페이스를 통해 사용자에게 Jenkins의 모든 기능과 빌드 현황을 제공합한다.

#### Jenkins Agent(노드/ 실행기)
*   **작업 실행**: Master로부터 전달받은 빌드 스크립트(예: `Jenkinsfile`에 정의된 `sh` 명령어)를 실행하여 코드 빌드, 테스트, 배포 등의 작업을 수행한다. 
*   **다양한 환경 지원**: Agent는 물리 서버, 가상 머신(VM), Docker 컨테이너 등 다양한 형태로 구성될 수 있다. 각 Agent는 특정 운영체제, 소프트웨어 버전, 라이브러리 등 특정 빌드 환경을 제공 일정하게 제공할 수 있다.
*   **확장성**: 필요한 경우 Agent를 추가하여 Jenkins 시스템의 처리 용량을 쉽게 확장할 수 있다. 이는 동시에 더 많은 빌드 작업을 처리하거나, 특정 환경이 필요한 작업을 분리하여 실행하는 데 유용하다.
*   **격리된 환경**: 각 Agent는 독립적인 환경에서 작업을 수행하므로, 한 Agent에서 실행되는 작업이 다른 Agent의 작업에 영향을 미치지 않는다. 이는 빌드 환경의 일관성과 안정성을 보장해줘, 서로의 충돌이나 호스트 OS에 영향을 주지 않을 수 있다.

#### 분산 빌드(Distributed Builds, Master-Slave)
- Jenkins 마스터와 하나 이상의 Agent를 준비하고, 빌드를 하여 여러 머신에 분산하여 처리하는 방법을 의미한다. 이 방식의 이점은 아래와 같다. 

*   **부하 분산 (Load Balancing)**: Master의 부하를 줄이고, 빌드 작업을 여러 Agent에 분산하여 동시에 더 많은 작업을 처리할 수 있다. 이는 빌드 큐(queue)를 줄이고 전체 CI/CD 파이프라인의 처리량을 증가시킨다.
*   **환경 격리 (Environment Isolation)**: 각 Agent가 독립적인 빌드 환경을 제공하므로, 서로 다른 프로젝트나 다른 버전의 소프트웨어가 필요한 빌드 작업을 충돌 없이 실행할 수 있다. 예를 들어, 한 Agent는 Java 8 환경에서 빌드하고, 다른 Agent는 Node.js 18 환경에서 빌드할 수 있다.
*   **확장성 (Scalability)**: 빌드 요구사항이 증가함에 따라 Agent를 쉽게 추가하거나 제거할 수 있어, Jenkins 시스템의 확장성을 유연하게 관리할 수 있다.
*   **안정성 (Reliability)**: 특정 Agent에 문제가 발생하더라도 다른 Agent에서 작업을 계속 수행할 수 있으므로, 전체 CI/CD 시스템의 안정성이 향상된다.

- `project-mini-frontend` 프로젝트는 jenkins 시스템을 활용하고, `Jenkinsfile`을 이용하여 Host 서버에서 Docker 컨테이너로 구성되어 있다. 또한 Jenkins 컨테이너는 DooD(Docker-out-of-Docker) 패턴을 통해 Jenkins Master 컨테이너 자체가 Agent 역할을 겸한다. 
- 그러나 여기에 다른 서버를 추가한다면, Master 와 Agent 를 분리할 수 있고, 특히 용도와 리소스에 맞게 분리한다면 서버의 역할에 따라 빌드하는 노드를 별도로 가져갈 수도 있고, 안정성을  더 강화할 수도 있다.

### Docker 를 이용한 Jenkins 설치 
- Jenkins를 Docker 컨테이너로 설치하는 것은 환경 설정의 일관성을 보장하고, 배포 및 관리를 용이하게 하는 현대적인 방법이다.
- 또한 컨테이너화 함을 통해, Jenkins 환경을 모듈화시킬 수 있어 다양한 리소스에 이식할 수 있고, 또 동일한 CICD 환경 구축을 가능케한다.
- 다양한 패턴이 있겠지만, 많지 않은 리소스 상황, 그리고 Host 의 자원을 완전하게 이용하기 위하여 Jenkins Master 컨테이너가 안에서 Host 의 도커를 조작할 수 있도록 하는 DooD 패턴을 이번 프로젝트에 활용했다. 이를 통해 환경 구축과 내용의 격리는 컨테이너 내에 이루었지만, 실제 빌드는 Host 에서 구성되는 형태를 취한다.

#### DooD 를 위한 docker-compose.yml

```yaml
# project-mini-jenkins/docker-compose.yml
services:
  jenkins:
    build:
      context: jenkins
    container_name: jenkins-server
    ports:
      - "12345:8080"
    volumes:
      - ./jenkins_home:/var/jenkins_home
      # Docker CLI 사용을 위해 호스트로 마운트
      - /var/run/docker.sock:/var/run/docker.sock
      - /usr/bin/docker:/usr/bin/docker
      - /usr/bin/docker-compose:/usr/bin/docker-compose
    environment:
      - CASC_JENKINS_CONFIG=/var/jenkins_home/casc.yaml
    entrypoint: &gt;
      bash -c "
        cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;
        /usr/bin/tini -- /usr/local/bin/jenkins.sh
      "
</code></pre></div></div>

<p>주요 내용은 다음과 같다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">build</code></strong>: <code class="language-plaintext highlighter-rouge">context: jenkins</code>는 <code class="language-plaintext highlighter-rouge">jenkins</code> 디렉토리 내의 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 사용하여 이미지를 빌드하도록 지시한다.</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">container_name</code></strong>: 컨테이너 이름을 <code class="language-plaintext highlighter-rouge">jenkins-server</code>로 지정하여 쉽게 식별할 수 있도록 했다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ports</code></strong>: 호스트의 <code class="language-plaintext highlighter-rouge">12345</code> 포트를 컨테이너의 <code class="language-plaintext highlighter-rouge">8080</code> 포트(Jenkins 기본 포트)에 매핑하여 외부에서 Jenkins에 접근할 수 있도록 하고, 자주 사용되는 포트 점유를 피한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">volumes</code></strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">./jenkins_home:/var/jenkins_home</code>: Jenkins의 데이터(설정, 빌드 기록, 플러그인 등)를 호스트의 <code class="language-plaintext highlighter-rouge">jenkins_home</code> 디렉토리에 영구적으로 저장하도록 마운트한다. 이는 컨테이너가 삭제되더라도 데이터가 보존되도록 하며, 명시적으로 해당 폴더에 남기에, 해당 데이터를 이동하면 다른 서버로 이식이 용이하다.</li>
      <li><code class="language-plaintext highlighter-rouge">/var/run/docker.sock:/var/run/docker.sock</code>: 호스트의 Docker 소켓을 컨테이너 내부에 마운트한다. 이 설정은 Jenkins 컨테이너가 호스트의 Docker 데몬과 통신하여 Docker 명령어를 실행할 수 있도록 하는 DooD 패턴의 핵심으로, 공유되지 않으면 내부에서 외부로의 조종이 불가능하다.</li>
      <li><code class="language-plaintext highlighter-rouge">/usr/bin/docker:/usr/bin/docker</code>, <code class="language-plaintext highlighter-rouge">/usr/bin/docker-compose:/usr/bin/docker-compose</code>: 호스트의 Docker 및 Docker Compose 바이너리를 컨테이너 내부에 마운트하여 Jenkins가 이들을 직접 사용할 수 있도록 했다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">environment</code></strong>: <code class="language-plaintext highlighter-rouge">CASC_JENKINS_CONFIG</code> 환경 변수를 설정하여 JCasC 설정 파일의 경로를 지정한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">entrypoint</code></strong>: Jenkins 컨테이너가 시작될 때 <code class="language-plaintext highlighter-rouge">casc.yaml</code> 파일을 <code class="language-plaintext highlighter-rouge">jenkins_home</code>으로 복사하고 Jenkins를 실행하는 스크립트를 정의하였다. 해당 entrypoint 설정은 Dockerfile의 기본 설정이 있더라도, 이를 무시하고 덮어씌워진다.</li>
</ul>

<h3 id="jenkins-초기-설정">Jenkins 초기 설정</h3>

<h4 id="초기-관리자-비밀번호-확인">초기 관리자 비밀번호 확인</h4>

<ol>
  <li><strong>Jenkins 컨테이너 실행</strong>: <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 명령으로 Jenkins 컨테이너를 실행한다.</li>
  <li><strong>로그 확인</strong>: 다음 명령어를 사용하여 Jenkins 컨테이너의 로그를 확인한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs jenkins-server
</code></pre></div>    </div>
    <p>로그 출력에서 <code class="language-plaintext highlighter-rouge">Please use the following password to proceed to installation:</code> 또는 유사한 메시지 뒤에 나오는 긴 문자열이 초기 관리자 비밀번호다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************
</code></pre></div>    </div>
    <p>(여기서 <code class="language-plaintext highlighter-rouge">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code> 부분이 실제 비밀번호다.)</p>
  </li>
</ol>

<h4 id="초기-설정-진행-절차">초기 설정 진행 절차</h4>

<ol>
  <li><strong>Jenkins 웹 인터페이스 접속</strong>: 웹 브라우저를 열고 <code class="language-plaintext highlighter-rouge">http://localhost:12345</code> (또는 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에 설정된 포트)로 접속.</li>
  <li><strong>관리자 비밀번호 입력</strong>: 위에서 확인한 초기 관리자 비밀번호를 입력하고 <code class="language-plaintext highlighter-rouge">Continue</code>를 클릭</li>
  <li><strong>플러그인 설치</strong>: <code class="language-plaintext highlighter-rouge">Install suggested plugins</code>를 선택하여 권장 플러그인을 설치하거나, <code class="language-plaintext highlighter-rouge">Select plugins to install</code>을 선택하여 필요한 플러그인만 설치할 수 있다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트의 <code class="language-plaintext highlighter-rouge">jenkins/plugins.txt</code>와 <code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code>을 사용한다면, 플러그인과 기본 설정은 자동으로 적용된다.</li>
  <li><strong>관리자 계정 생성</strong>: 초기 관리자 비밀번호를 사용한 후, 새로운 관리자 계정(사용자 이름, 비밀번호, 이름, 이메일)을 생성한다. 이 계정은 이후 Jenkins에 로그인할 때 사용된다.</li>
  <li><strong>Jenkins URL 설정</strong>: Jenkins 인스턴스의 URL을 설정합니다. 기본값으로 두거나 필요에 따라 변경할 수 있다.</li>
</ol>

<p>이 과정을 통해 Jenkins 서버의 초기 설정이 완료되며, CI/CD 파이프라인을 구축하고 관리할 준비가 된다. 단 여기서 중요한 지점으로,</p>

<p>1) 실제 프로젝트를 위한 플러그인을 설치할 것이 무엇이 있는지 판단 및 밑설치를 미리 해둬야 예상외의 발생 에러를 잡을 수 있다. 최초 설치시 아주 기본적인 내용만 있고, 빌드 자체를 위한 도구 정도만 설치됨. 이에 dockerfile 을 통해 컨테이너 내부에서 조작할 도구들과, jenkins 자체를 위한 플러그인(예, ssh agent)등을 정확하게 보고 미리 설치해놓아야 한다. 
2) 외부에서 신호를 수신하여 동작하는 등의 것이 있을 경우, HTTPS 를 통한 외부 접속 통로를 확보해둔 설계가 필요할 수 있다. GitHub 의 웹훅이나, 다양한 도구들의 연결 시 HTTPS 가 필수인 경우가 많다. 이를 고려하지 않은 설계가 되면 완전 자동화를 만들기 어려울 수 있다. (수동 호출 및 빌드는 HTTP 환경으로도 충분)</p>

<h3 id="jenkins-plugin">Jenkins Plugin</h3>

<h4 id="역할">역할</h4>
<ul>
  <li><strong>기능 확장</strong>: Jenkins 코어(core)에 없는 새로운 기능을 추가한다. 예를 들어, 특정 버전 관리 시스템(Git, SVN), 빌드 도구(Maven, Gradle), 클라우드 플랫폼(AWS, Azure), 알림 서비스(Slack, Discord) 등과의 연동 기능을 제공한다.</li>
  <li><strong>통합 용이성</strong>: 다양한 개발 및 운영 도구와의 통합을 간소화하여, 복잡한 CI/CD 파이프라인을 쉽게 구축할 수 있도록 돕는다.</li>
  <li><strong>사용자 정의</strong>: 특정 프로젝트나 조직의 요구사항에 맞춰 Jenkins 환경을 사용자 정의할 수 있는 유연성을 제공한다.</li>
  <li><strong>생산성 향상</strong>: 반복적이고 수동적인 작업을 자동화하고, 개발 프로세스의 병목 현상을 제거하여 개발 생산성을 향상시킨다.</li>
</ul>

<h4 id="핵심-플러그인-정리">핵심 플러그인 정리</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">configuration-as-code</code> (Jenkins Configuration as Code Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins의 시스템 설정, 플러그인 설정, 보안 설정 등을 YAML 파일(<code class="language-plaintext highlighter-rouge">casc.yaml</code>)로 정의하고 관리할 수 있도록 한다. 이를 통해 Jenkins 환경을 코드로서 버전 관리하고, 여러 Jenkins 인스턴스 간에 일관된 설정을 적용할 수 있다.</li>
      <li><strong>중요성</strong>: Jenkins 환경의 재현성(reproducibility)과 유지보수성(maintainability)을 크게 향상시켜 DevOps 원칙을 실현하는 데 필수.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">git</code> (Git Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Git 저장소와 Jenkins를 연동하여 소스 코드를 가져오고, Git 관련 작업을 수행할 수 있도록 한다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서 <code class="language-plaintext highlighter-rouge">git credentialsId: GITHUB_CREDS_ID, url: '...', branch: 'main'</code>와 같은 명령을 사용할 수 있게 한다.</li>
      <li><strong>중요성</strong>: 대부분의 현대 소프트웨어 개발에서 Git이 버전 관리 시스템으로 사용되므로, CI/CD 파이프라인의 시작점인 소스 코드 가져오기 기능을 제공하는 핵심 플러그인.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">workflow-aggregator</code> (Pipeline: Aggregator Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins Pipeline 기능을 제공하는 여러 플러그인들의 집합체다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 사용하여 파이프라인을 정의하고 실행할 수 있도록 하는 기반을 마련한다.</li>
      <li><strong>중요성</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 기반의 CI/CD 파이프라인을 구축하는 데 필수적인 플러그인으로, 복잡한 빌드, 테스트, 배포 워크플로우를 코드로 정의할 수 있게 한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">blueocean</code> (Blue Ocean Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins 파이프라인의 실행 과정을 시각적으로 보여주는 현대적이고 사용자 친화적인 UI 플러그인. 파이프라인의 각 단계와 상태를 한눈에 파악하고, 문제 발생 시 디버깅(debugging)을 용이하게 한다.</li>
      <li><strong>중요성</strong>: 파이프라인의 가시성을 높여 개발자와 운영자가 CI/CD 프로세스를 더 쉽게 이해하고 관리할 수 있도록 돕는다.</li>
    </ul>
  </li>
</ul>

<h3 id="jcasc">JCasC</h3>
<h4 id="개념-1">개념</h4>
<p>Jenkins Configuration as Code (JCasC)는 Jenkins의 설정을 YAML 파일과 같은 코드로 정의하고 관리하는 방법론이다. 전통적으로 Jenkins 설정은 웹 UI를 통해 수동으로 이루어졌으며, 이는 설정의 일관성을 유지하기 어렵고, 변경 이력을 추적하기 힘들며, 새로운 Jenkins 인스턴스를 구축할 때마다 동일한 작업을 반복해야 하는 비효율성을 초래했다. JCasC는 이러한 문제점을 해결하고, Jenkins 설정을 소프트웨어 개발의 다른 부분과 마찬가지로 코드로서 관리할 수 있도록 했다.</p>

<h4 id="jcasc의-이유와-장점">JCasC의 이유와 장점</h4>
<ul>
  <li><strong>재현성 (Reproducibility)</strong>: 모든 Jenkins 설정이 코드 파일에 명시되어 있으므로, 언제든지 동일한 Jenkins 환경을 정확하게 재구축할 수 있다. 이는 개발, 테스트, 프로덕션 환경 간의 일관성을 보장한다.</li>
  <li><strong>버전 관리 (Version Control)</strong>: 설정 파일이 Git과 같은 버전 관리 시스템에 저장되므로, 설정 변경 이력을 추적하고, 필요한 경우 이전 버전으로 쉽게 롤백할 수 있다. 이는 설정 변경으로 인한 문제를 해결하는 데 큰 도움이된다.</li>
  <li><strong>자동화 (Automation)</strong>: Jenkins 인스턴스를 프로비저닝(provisioning)하고 설정하는 과정을 자동화할 수 있다. 이는 특히 클라우드 환경에서 Jenkins를 동적으로 생성하고 관리할 때 매우 유용하다.</li>
  <li><strong>협업 강화 (Enhanced Collaboration)</strong>: 여러 개발자나 DevOps 엔지니어가 Jenkins 설정을 함께 검토하고 수정할 수 있으며, 코드 리뷰(code review)를 통해 설정 변경의 투명성과 품질을 높일 수 있다.</li>
  <li><strong>오류 감소 (Reduced Errors)</strong>: 수동 설정 과정에서 발생할 수 있는 인적 오류를 줄이고, 일관된 방식으로 설정을 적용할 수 있다.</li>
  <li><strong>문서화 (Documentation)</strong>: 설정 파일 자체가 Jenkins 환경에 대한 명확하고 최신 상태의 문서 역할을 한다.</li>
</ul>

<h4 id="jcasc-로-설정할-수-있는-주요-기능">JCasC 로 설정할 수 있는 주요 기능</h4>

<p>JCasC를 사용하면 Jenkins의 거의 모든 설정을 YAML 파일로 정의하고 적용할 수 있다.</p>

<ul>
  <li><strong>전역 설정 (Global Settings)</strong>:
    <ul>
      <li>시스템 메시지 (System Message)</li>
      <li>보안 설정 (Security Realm, Authorization Strategy)</li>
      <li>플러그인 관리 (Plugin Manager)</li>
      <li>UI 설정 (Theme, Appearance)</li>
    </ul>
  </li>
  <li><strong>도구 설정 (Tool Configurations)</strong>:
    <ul>
      <li>JDK, Maven, Git 등 빌드에 필요한 도구들의 설치 경로 및 설정</li>
    </ul>
  </li>
  <li><strong>노드 설정 (Node Configurations)</strong>:
    <ul>
      <li>Jenkins 에이전트 (Agent) 노드 추가, 레이블(Label) 설정, 연결 방식 등</li>
    </ul>
  </li>
  <li><strong>작업(Job) 관련 설정</strong>:
    <ul>
      <li>기본 작업 템플릿, 스케줄링 관련 설정 등 (개별 Job 설정은 주로 Jenkinsfile로 관리)</li>
    </ul>
  </li>
  <li><strong>연동 서비스 설정</strong>:
    <ul>
      <li>SCM (Source Code Management) 연동 설정</li>
      <li>알림 서비스 (Discord, Slack 등) 연동 설정</li>
    </ul>
  </li>
</ul>

<p><strong>JCasC 설정 예시 (YAML)</strong></p>

<p>아래는 JCasC를 사용하여 몇 가지 일반적인 설정을 구성하는 예시다. 실제 설정은 Jenkins 버전 및 설치된 플러그인에 따라 달라질 수 있다.</p>

<p><strong>예시 1: 시스템 메시지 및 기본 Executor 설정</strong></p>

<p>이 예시는 Jenkins의 시스템 메시지를 설정하고, 기본 빌드 실행기(Executor)의 수를 지정합니다. 이는 이전 분석 보고서에서 언급된 내용과 관련이 있습니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">systemMessage</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">Welcome to Jenkins! This instance is configured via Jenkins Configuration as Code.</span>
    <span class="s">For any issues, please contact the DevOps team.</span>
  <span class="na">numExecutors</span><span class="pi">:</span> <span class="m">5</span> <span class="c1"># 기본 Executor 수를 5개로 설정</span>
</code></pre></div></div>

<p><strong>예시 2: Git 도구 설정</strong></p>

<p>Jenkins에서 사용할 Git 실행 파일의 경로를 지정하는 예시입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">tool</span><span class="pi">:</span>
  <span class="na">git</span><span class="pi">:</span>
    <span class="na">installations</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Default</span><span class="nv"> </span><span class="s">Git"</span>
        <span class="na">home</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/usr/bin/git"</span> <span class="c1"># 시스템에 설치된 Git 경로</span>
</code></pre></div></div>

<p><strong>예시 3: Jenkins 에이전트 노드 설정</strong></p>

<p>새로운 빌드 에이전트 노드를 추가하고 레이블을 지정하는 예시입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">slaves</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">my-agent-node"</span>
      <span class="na">remoteFS</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/home/jenkins/agent"</span>
      <span class="na">labels</span><span class="pi">:</span> <span class="s2">"</span><span class="s">docker</span><span class="nv"> </span><span class="s">linux"</span>
      <span class="na">mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">NORMAL"</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hudson.slaves.DumbSlave"</span>
      <span class="na">launcher</span><span class="pi">:</span>
        <span class="na">ssh</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s2">"</span><span class="s">your-agent-host.example.com"</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s2">"</span><span class="s">jenkins"</span>
          <span class="na">privateKey</span><span class="pi">:</span>
            <span class="na">credentialsId</span><span class="pi">:</span> <span class="s2">"</span><span class="s">jenkins-ssh-key"</span> <span class="c1"># Jenkins Credentials에 등록된 SSH 키 ID</span>
</code></pre></div></div>

<p><strong>예시 4: 보안 설정 (익명 접근 비활성화)</strong></p>

<p>익명 사용자의 Jenkins 접근을 비활성화하는 설정입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">securityRealm</span><span class="pi">:</span>
    <span class="c1"># Active Directory, LDAP 등 다른 보안 설정을 사용할 수도 있습니다.</span>
    <span class="c1"># 여기서는 Jenkins 자체 사용자 관리 (Jenkins's own user database)를 가정합니다.</span>
    <span class="na">jenkinsUsers</span><span class="pi">:</span> <span class="pi">[]</span> <span class="c1"># 사용자 DB를 사용하되, 초기에는 비어있음</span>
  <span class="na">authorizationStrategy</span><span class="pi">:</span>
    <span class="na">globalMatrix</span><span class="pi">:</span>
      <span class="c1"># 모든 권한을 가진 Admin 사용자에게만 접근 허용</span>
      <span class="na">permissions</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">Overall/Administer:anonymous"</span> <span class="c1"># 익명 사용자에게 관리자 권한 부여 방지</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">Overall/Administer:authenticated"</span> <span class="c1"># 인증된 사용자에게 관리자 권한 부여 방지 (필요에 따라 조정)</span>
</code></pre></div></div>

<p>이러한 YAML 설정 파일들을 <code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code>과 같은 경로에 저장하고 Jenkins에 적용하면, 해당 설정들이 자동으로 반영된다.</p>

<h4 id="jcasc-문법-및-구조">JCasC 문법 및 구조</h4>

<p>JCasC 설정 파일은 Jenkins의 내부 객체 모델을 YAML 형식으로 매핑한다. 기본적인 YAML 문법 규칙은 다음과 같다.</p>

<ul>
  <li><strong>키-값 쌍 (Key-Value Pairs)</strong>: <code class="language-plaintext highlighter-rouge">키: 값</code> 형태로 데이터를 표현한다. 콜론(<code class="language-plaintext highlighter-rouge">:</code>) 뒤에는 공백이 하나 이상 있어야 한다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">key</span><span class="pi">:</span> <span class="s">value</span>
</code></pre></div>    </div>
  </li>
  <li><strong>들여쓰기 (Indentation)</strong>: 들여쓰기를 사용하여 계층 구조를 나타낸다. 공백만 사용하며, 탭(tab)은 사용할 수 없다. 동일한 레벨의 항목은 동일한 들여쓰기를 가져야 한다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">parent</span><span class="pi">:</span>
  <span class="na">child_key</span><span class="pi">:</span> <span class="s">child_value</span>
</code></pre></div>    </div>
  </li>
  <li><strong>목록 (Lists)</strong>: 하이픈(<code class="language-plaintext highlighter-rouge">-</code>)으로 시작하는 항목들을 사용하여 목록을 표현합니다.
```yaml
fruits:
    <ul>
      <li>Apple</li>
      <li>Banana</li>
      <li>Orange
```</li>
    </ul>
  </li>
  <li><strong>주석 (Comments)</strong>: <code class="language-plaintext highlighter-rouge">#</code>으로 시작하는 줄은 주석으로 처리됩니다.</li>
</ul>

<p>JCasC 설정 파일의 복잡성은 Jenkins 환경 복잡성에 비례해서 증대되고, 그만큼 다 이해하고 작업하는 것은 난이도가 수직 상승하게 된다. 그러나 기본적인 문법과 설정 항목들이 어떻게 매핑되는지를 이해하면 효율적인 관리가 가능하다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/2-til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (2)" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/2-til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/2-til-jenkins.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h3 id="jenkins-파이프라인">Jenkins 파이프라인</h3>
<h4 id="개념">개념</h4>
<ul>
  <li>파이프라인은 소프트웨어의 빌드, 테스트, 배포 과정을 자동화하는 일련의 단계를 코드로 정의한 것이다.</li>
  <li>Jenkins Pipeline은 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>이라는 텍스트 파일에 정의되며, 이 파일은 프로젝트의 소스 코드 저장소에 함께 저장된다. 이를 통해 파이프라인 자체도 코드로서 관리(Pipeline as Code)되어, 소프트웨어 개발의 다른 부분과 마찬가지로 버전 관리, 코드 리뷰, 변경 이력 추적 등의 이점을 얻을 수 있다.</li>
</ul>

<h4 id="declarative-pipeline-vs-scripted-pipeline">Declarative Pipeline vs Scripted Pipeline</h4>
<ul>
  <li><strong>Declarative Pipeline (선언형 파이프라인)</strong>:
    <ul>
      <li><strong>특징</strong>: 구조화된 블록(<code class="language-plaintext highlighter-rouge">pipeline</code>, <code class="language-plaintext highlighter-rouge">agent</code>, <code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">stage</code>, <code class="language-plaintext highlighter-rouge">steps</code> 등)을 사용하여 파이프라인을 정의한다. 미리 정의된 구조와 키워드를 사용하여 파이프라인의 흐름을 명확하고 간결하게 선언하는 방식이다. Groovy 스크립팅에 대한 깊은 지식 없이도 쉽게 작성하고 이해할 수 있는 편이다.</li>
      <li><strong>장점</strong>: 가독성이 높고, 배우기 쉬우며, Jenkins UI에서 시각적으로 파이프라인을 쉽게 이해할 수 있다. 복잡한 로직보다는 표준화된 CI/CD 흐름에 적합하다.</li>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 Declarative Pipeline의 대표적인 예시다.</li>
    </ul>

    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Declarative Pipeline 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span> <span class="c1">// 에이전트를 지정</span>
    <span class="n">environment</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// 전역 환경을 설정 역할을 한다</span>
    <span class="n">stages</span> <span class="o">{</span> <span class="c1">// 각 단계를 지정한다</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// checkout</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// 이미지 빌드</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    <span class="n">post</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// 모든 절차가 종료 후 작업</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Scripted Pipeline (스크립트형 파이프라인)</strong>:
    <ul>
      <li><strong>특징</strong>: Groovy 스크립트 언어를 사용하여 파이프라인의 모든 로직을 직접 작성한다. <code class="language-plaintext highlighter-rouge">node</code> 블록 내에서 자유로운 Groovy 문법과 Jenkins DSL(Domain Specific Language)을 활용하여 복잡하고 동적인 파이프라인을 구현할 수 있다.</li>
      <li><strong>장점</strong>: 매우 유연하고 강력하며, 복잡한 조건부 로직, 루프, 예외 처리 등 고급 프로그래밍 기능을 활용할 수 있다. 특정 요구사항에 맞춰 파이프라인을 세밀하게 제어해야 할 때 유용하다.(실질 빌드 작업을 프로그래밍 하듯이 다 만드는 구조니깐)</li>
      <li><strong>단점</strong>: Groovy 언어에 대한 이해가 필요하며, 가독성이 Declarative Pipeline보다 낮을 수 있다.</li>
    </ul>
  </li>
</ul>

<p>현대 Jenkins Pipeline 개발에서는 Declarative Pipeline이 더 권장한다. 대부분의 CI/CD 요구사항을 충족하며, 유지보수가 용이하고 팀원 간의 협업에 더 적합하기 때문이다. Scripted Pipeline은 Declarative Pipeline으로 구현하기 어려운 특정 고급 시나리오에서 보조적으로 사용될 수 있다. (빌드 절차 과정에서 유동성이 필요한 작업이 포함된다면 특히나 스크립트형으로 작성이 실질 더 편할 수 있으니까)</p>

<h4 id="jenkinsfile-의-역할과-중요성">Jenkinsfile 의 역할과 중요성</h4>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>은 Jenkins Pipeline의 핵심이며, CI/CD 파이프라인의 모든 단계를 코드로 정의한 파일이다. 이 파일은 프로젝트의 소스 코드 저장소의 루트 디렉토리(또는 지정된 경로)에 위치하며, Jenkins는 이 파일을 읽고 파이프라인을 실행한다.</p>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 역할과 중요성은 다음과 같다.</p>

<ul>
  <li><strong>Pipeline as Code (코드형 파이프라인)</strong>: 파이프라인 정의가 코드화되어 Git과 같은 버전 관리 시스템에 저장하는게 낫다. 이는 파이프라인의 변경 이력을 추적하고, 코드 리뷰를 통해 품질을 관리하며, 필요한 경우 이전 버전으로 롤백할 수 있도록 한다.</li>
  <li><strong>재현 가능한 CI/CD 환경</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 하나만 있으면 어떤 Jenkins 인스턴스에서도 동일한 CI/CD 파이프라인을 구축하고 실행할 수 있다. 이는 환경 간의 일관성을 보장하고, 새로운 프로젝트 온보딩(onboarding)을 간소화한다.</li>
  <li><strong>개발자와 운영자의 협업</strong>: 개발자는 코드와 함께 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 관리하며, 운영자는 이 파일을 통해 배포 프로세스를 이해하고 개선할 수 있다. 이는 개발(Dev)과 운영(Ops) 간의 경계를 허물고 협업을 강화한다.</li>
  <li><strong>유연성과 확장성</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>은 Groovy 언어의 강력한 기능을 활용하여 복잡한 로직과 다양한 도구 통합을 지원한다. 이를 통해 프로젝트의 특정 요구사항에 맞춰 파이프라인을 유연하게 확장하고 커스터마이징(customizing)할 수 있다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 실제 프로젝트에서 코드 체크아웃, Docker 이미지 빌드, GHCR(GitHub Container Registry) 푸시, 그리고 Blue/Green 배포 전략을 포함한 서버 배포 단계를 명확하게 정의하고 있고, 이를 통해 수동 빌드와 배포의 과정을 읽고 모사한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (일부 발췌)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span>
    
    <span class="n">environment</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

    <span class="n">stages</span> <span class="o">{</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Deploy to Server'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
    <span class="o">}</span>
   
    <span class="n">post</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>은 CI/CD 파이프라인의 ‘설계도’이자 ‘실행 스크립트’로서, 현대 소프트웨어 개발에서 자동화된 배포 프로세스를 구축하는 데 필수적인 역할을 수행한다.</p>

<h3 id="pipeline-문법-및-구조-간단-정리">Pipeline 문법 및 구조 간단 정리</h3>

<p>Jenkins Declarative Pipeline은 구조화된 블록과 지시어(Directive)를 사용하여 CI/CD 파이프라인을 정의한다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>을 예시로 각 주요 블록과 지시어의 역할에 대해 설명한다.</p>

<h4 id="pipeline-블록"><code class="language-plaintext highlighter-rouge">pipeline</code> 블록</h4>

<p><code class="language-plaintext highlighter-rouge">pipeline</code> 블록은 Declarative Pipeline의 최상위 요소이며, 모든 파이프라인 정의를 감싸는 컨테이너다. 이 블록 내부에 <code class="language-plaintext highlighter-rouge">agent</code>, <code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">post</code> 등 파이프라인의 모든 구성 요소가 포함된다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 시작과 끝을 정의하며, 전체 파이프라인의 구조를 명시한다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 시작 부분은 <code class="language-plaintext highlighter-rouge">pipeline { ... }</code>으로 구성된다.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile</span>
<span class="n">pipeline</span> <span class="o">{</span> <span class="c1">// 문서 시작을 알리는 부분</span>
    <span class="n">agent</span> <span class="n">any</span>
    
    <span class="n">environment</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

    <span class="n">stages</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
   
    <span class="n">post</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="agent-지시어-directive"><code class="language-plaintext highlighter-rouge">agent</code> 지시어 (Directive)</h4>

<p><code class="language-plaintext highlighter-rouge">agent</code> 지시어는 파이프라인 또는 특정 <code class="language-plaintext highlighter-rouge">stage</code>가 실행될 Jenkins Agent(노드)를 지정한다. 이는 빌드 작업을 수행할 환경을 정의하는 데 사용된다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 각 단계가 실행될 물리적 또는 가상 환경을 선언한다.</li>
  <li><strong>유형</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">any</code>: 사용 가능한 모든 Agent에서 파이프라인을 실행한다.</li>
      <li><code class="language-plaintext highlighter-rouge">none</code>: 파이프라인 레벨에서는 Agent를 지정하지 않고, 각 <code class="language-plaintext highlighter-rouge">stage</code>에서 개별적으로 <code class="language-plaintext highlighter-rouge">agent</code>를 지정한다.</li>
      <li><code class="language-plaintext highlighter-rouge">label 'your-label'</code>: 특정 라벨이 지정된 Agent에서 실행 (예: <code class="language-plaintext highlighter-rouge">agent { label 'docker-node-with-host-docker' }</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">docker { image '...' }</code>: Docker 이미지를 사용하여 임시 컨테이너에서 <code class="language-plaintext highlighter-rouge">stage</code>를 실행</li>
    </ul>
  </li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">agent any</code>를 사용하여 파이프라인의 모든 단계가 사용 가능한 Agent에서 실행되도록 했다</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (agent 지시어 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span> <span class="c1">// 파이프라인의 모든 단계가 사용 가능한 Agent에서 실행됩니다.</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="environment-블록-환경-변수-관리"><code class="language-plaintext highlighter-rouge">environment</code> 블록 (환경 변수 관리)</h4>

<p><code class="language-plaintext highlighter-rouge">environment</code> 블록은 파이프라인 전체 또는 특정 <code class="language-plaintext highlighter-rouge">stage</code>에서 사용할 환경 변수를 정의한다. 이는 빌드 스크립트 내에서 재사용 가능한 값이나 민감한 정보를 안전하게 관리하는 데 유용한 역할을 한다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인 실행 중에 접근할 수 있는 환경 변수를 선언</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 GHCR 자격 증명 ID, GitHub 자격 증명 ID, SSH 자격 증명 ID, 배포 서버 정보, Discord 웹훅 URL, 이미지 이름, SSH 호스트 및 포트, 프로젝트 경로 등 다양한 환경 변수를 정의</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (environment 블록 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span>
    
    <span class="n">environment</span> <span class="o">{</span>
        <span class="n">GHCR_CREDS_ID</span> <span class="o">=</span> <span class="s1">'ghcr-creds'</span>
        <span class="n">GITHUB_CREDS_ID</span> <span class="o">=</span> <span class="s1">'github-creds'</span>
        <span class="n">TARGET_SSH_CREDS_ID</span> <span class="o">=</span> <span class="s1">'a5-localhost-jenkins'</span>

        <span class="n">TARGET_DEPLOY_SERVER</span> <span class="o">=</span> <span class="s1">'GEEKOM-A5-Server'</span>

        <span class="n">DISCORD_CREDS_ID</span> <span class="o">=</span> <span class="s1">'discord-webhook-url'</span>

        <span class="n">IMAGE_NAME</span> <span class="o">=</span> <span class="s1">'ghcr.io/paul2021-r/project-mini-frontend'</span>

        <span class="n">TARGET_HOST</span> <span class="o">=</span> <span class="n">credentials</span><span class="o">(</span><span class="s1">'ssh-host-creds'</span><span class="o">)</span> <span class="c1">// Jenkins Credentials에서 가져옴 =&gt; 보안을 위함</span>
        <span class="n">TARGET_PORT</span> <span class="o">=</span> <span class="n">credentials</span><span class="o">(</span><span class="s1">'ssh-port-creds'</span><span class="o">)</span> <span class="c1">// Jenkins Credentials에서 가져옴</span>
        <span class="n">TARGET_PROJECT_PATH</span> <span class="o">=</span> <span class="s1">'/home/hansol/workspace/project-mini-frontend'</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">credentials()</code> 함수는 Jenkins Credentials 플러그인을 통해 Jenkins에 저장된 자격 증명(예: 비밀번호, SSH 키)을 안전하게 가져와 환경 변수로 사용할 수 있도록 한다. 이렇게 한 이유는 스크립트로 노출 되어도 문제가 없는 영역과, 그렇지 않은 영역을 구분하기 위함이다.</p>

<h4 id="stages-및-stage-블록-파이프라인-단계-정의"><code class="language-plaintext highlighter-rouge">stages</code> 및 <code class="language-plaintext highlighter-rouge">stage</code> 블록 (파이프라인 단계 정의)</h4>

<p><code class="language-plaintext highlighter-rouge">stages</code> 블록은 파이프라인의 모든 <code class="language-plaintext highlighter-rouge">stage</code> 블록을 포함하는 컨테이너다. 각 <code class="language-plaintext highlighter-rouge">stage</code> 블록은 파이프라인의 논리적인 단계를 정의하며, 일반적으로 빌드, 테스트, 배포와 같은 주요 작업을 나타내고 또한 격리한다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 전체 흐름을 구성하는 개별적인 작업 단위를 정의</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 <code class="language-plaintext highlighter-rouge">Checkout</code>, <code class="language-plaintext highlighter-rouge">Build Image</code>, <code class="language-plaintext highlighter-rouge">Push to GHCR</code>, <code class="language-plaintext highlighter-rouge">Deploy to Server</code>와 같은 여러 <code class="language-plaintext highlighter-rouge">stage</code>를 정의하여 CI/CD 파이프라인의 각 단계를 명확히 구분</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (stages 및 stage 블록 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="n">stages</span> <span class="o">{</span>
    <span class="c1">// code pull</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"1. Get the latest code from GitHub"</span>
                <span class="n">git</span> <span class="nl">credentialsId:</span> <span class="n">GITHUB_CREDS_ID</span><span class="o">,</span> <span class="nl">url:</span> <span class="s1">'https://github.com/paul2021-r/project-mini-frontend.git'</span><span class="o">,</span> <span class="nl">branch:</span> <span class="s1">'main'</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// build image</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

        <span class="c1">// push image</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

        <span class="c1">// deploy to server</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Deploy to Server'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="steps-블록-단계별-실행-명령어"><code class="language-plaintext highlighter-rouge">steps</code> 블록 (단계별 실행 명령어)</h4>

<p>각 <code class="language-plaintext highlighter-rouge">stage</code> 블록 내에는 <code class="language-plaintext highlighter-rouge">steps</code> 블록이 포함되며, 이 블록은 해당 <code class="language-plaintext highlighter-rouge">stage</code>에서 실제로 실행될 하나 이상의 명령어를 정의한다. <code class="language-plaintext highlighter-rouge">steps</code> 블록 내에서는 쉘(shell) 명령어(<code class="language-plaintext highlighter-rouge">sh</code>), Groovy 스크립트(<code class="language-plaintext highlighter-rouge">script { ... }</code>), Jenkins 플러그인이 제공하는 DSL(Domain Specific Language) 등을 사용할 수 있다.</p>

<ul>
  <li><strong>역할</strong>: <code class="language-plaintext highlighter-rouge">stage</code> 내에서 수행될 구체적인 작업들을 순차적으로 실행한다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">Checkout</code> 단계에서는 <code class="language-plaintext highlighter-rouge">echo</code> 명령어로 메시지를 출력하고, <code class="language-plaintext highlighter-rouge">git</code> 명령어로 소스 코드를 가져온다.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (steps 블록 예시)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"1. Get the latest code from GitHub"</span>
                <span class="n">git</span> <span class="nl">credentialsId:</span> <span class="n">GITHUB_CREDS_ID</span><span class="o">,</span> <span class="nl">url:</span> <span class="s1">'https://github.com/paul2021-r/project-mini-frontend.git'</span><span class="o">,</span> <span class="nl">branch:</span> <span class="s1">'main'</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<h4 id="post-블록-빌드-후-처리"><code class="language-plaintext highlighter-rouge">post</code> 블록 (빌드 후 처리)</h4>

<p><code class="language-plaintext highlighter-rouge">post</code> 블록은 파이프라인 실행이 완료된 후(성공, 실패, 항상 등 조건에 따라) 특정 작업을 수행하도록 정의한다. 주로 알림 전송, 리소스 정리, 로그아웃 등의 후처리 작업에 사용된다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 최종 상태에 따라 실행될 작업을 정의</li>
  <li><strong>조건</strong>: <code class="language-plaintext highlighter-rouge">always</code>, <code class="language-plaintext highlighter-rouge">success</code>, <code class="language-plaintext highlighter-rouge">failure</code>, <code class="language-plaintext highlighter-rouge">unstable</code>, <code class="language-plaintext highlighter-rouge">changed</code> 등 다양한 조건에 따라 <code class="language-plaintext highlighter-rouge">post</code> 액션을 실행할 수 있다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 빌드 성공 시와 실패 시 Discord 알림을 보내고, 항상 GHCR에서 로그아웃하도록 <code class="language-plaintext highlighter-rouge">post</code> 블록을 사용.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (post 블록 예시)</span>
    <span class="n">post</span> <span class="o">{</span>
        <span class="n">success</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Deployment succeeded. Now send a discord notification."</span>
            <span class="n">script</span> <span class="o">{</span> <span class="cm">/* ... Discord 성공 알림 ... */</span> <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">failure</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Deployment failed! Now send a discord notification."</span>
            <span class="n">script</span> <span class="o">{</span> <span class="cm">/* ... Discord 실패 알림 ... */</span> <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">always</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Logout from GHCR"</span>
            <span class="n">sh</span> <span class="s2">"docker logout ghcr.io"</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="groovy-언어의-기본-문법-basic-groovy-syntax">Groovy 언어의 기본 문법 (Basic Groovy Syntax)</h3>

<p>Jenkins Pipeline은 Groovy 언어를 기반으로 한다. Groovy는 Java 플랫폼에서 실행되는 동적 언어로, Java와 유사한 문법을 가지면서도 스크립팅에 더 적합한 유연성을 제공한다. 이전에 정리를 한 적이 있으나, 까먹은 관계로(…) 무식하게 복습한 번 하고 간다. Jenkins Pipeline에서 Groovy의 기본 문법을 이해하는 것은 파이프라인을 효과적으로 작성하고 디버깅하는 데 필수적인 역할을 수행한다.</p>

<h4 id="변수-선언-및-사용-variable-declaration--usage">변수 선언 및 사용 (Variable Declaration &amp; Usage)</h4>

<p>Groovy에서 변수는 <code class="language-plaintext highlighter-rouge">def</code> 키워드를 사용하여 선언할 수 있으며, 타입을 명시하지 않아도 됩니다. 변수는 문자열, 숫자, 리스트, 맵 등 다양한 데이터 타입을 저장할 수 있습니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">def</code> 키워드</strong>: 변수를 선언할 때 사용합니다. 타입을 명시하지 않으면 Groovy가 자동으로 타입을 추론합니다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">myString</span> <span class="o">=</span> <span class="s2">"Hello, Jenkins!"</span>
<span class="kt">def</span> <span class="n">myNumber</span> <span class="o">=</span> <span class="mi">123</span>
<span class="kt">def</span> <span class="n">myList</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"apple"</span><span class="o">,</span> <span class="s2">"banana"</span><span class="o">]</span>
</code></pre></div>    </div>
  </li>
  <li><strong>타입 명시</strong>: 필요에 따라 타입을 명시할 수도 있습니다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">anotherString</span> <span class="o">=</span> <span class="s2">"Hello, Groovy!"</span>
<span class="kt">int</span> <span class="n">anotherNumber</span> <span class="o">=</span> <span class="mi">456</span>
</code></pre></div>    </div>
  </li>
  <li><strong>변수 사용</strong>: 선언된 변수는 스크립트 내에서 직접 참조하여 사용할 수 있습니다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span> <span class="s2">"${myString} The number is ${myNumber}"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">environment</code> 블록 내에서 환경 변수를 정의하거나, <code class="language-plaintext highlighter-rouge">script</code> 블록 내에서 <code class="language-plaintext highlighter-rouge">def</code> 키워드를 사용하여 로컬 변수를 선언하고 활용하는 것을 볼 수 있다. 당연히 스크립트 작성 시 전역용과, 지역용에 맞춰서 스코프가 있는 만큼 그에 맞춰 동작하도록 만드는게 중요.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (변수 선언 및 사용 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="n">environment</span> <span class="o">{</span>
        <span class="n">IMAGE_NAME</span> <span class="o">=</span> <span class="s1">'ghcr.io/paul2021-r/project-mini-frontend'</span> <span class="c1">// 환경 변수</span>
    <span class="o">}</span>
    <span class="n">stages</span> <span class="o">{</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">script</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> <span class="c1">// def를 사용한 로컬 변수 선언</span>
                    <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="조건문-conditional-statements">조건문 (Conditional Statements)</h4>

<p>Groovy는 <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else</code>와 같은 표준 조건문을 지원한다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">if-else</code> 구조</strong>: 조건이 참(true)일 때 특정 코드 블록을 실행하고, 거짓(false)일 때 다른 코드 블록을 실행.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">status</span> <span class="o">=</span> <span class="s2">"success"</span>
<span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">==</span> <span class="s2">"success"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">echo</span> <span class="s2">"Operation succeeded."</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">echo</span> <span class="s2">"Operation failed."</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>삼항 연산자</strong>: 간단한 조건에 따라 값을 할당할 때 유용
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"Pass"</span> <span class="o">:</span> <span class="s2">"Fail"</span>
<span class="n">echo</span> <span class="s2">"Result: ${result}"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>의 홀짝 여부를 판단하여 배포할 서비스를 결정하는 데 조건문을 활용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (조건문 예시)</span>
<span class="n">stage</span><span class="o">(</span><span class="s1">'Deploy to Server'</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">steps</span> <span class="o">{</span>
        <span class="n">script</span> <span class="o">{</span>
            <span class="c1">// 어떤 컨테이너를 업데이트 및 업스트림 대상을 지정</span>
            <span class="kt">def</span> <span class="n">deployService</span> <span class="o">=</span> <span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="na">BUILD_NUMBER</span><span class="o">.</span><span class="na">toInteger</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-green"</span> <span class="o">:</span> <span class="s2">"app-blue"</span> 
            <span class="kt">def</span> <span class="n">upstreamService</span> <span class="o">=</span> <span class="o">(</span><span class="n">deployService</span> <span class="o">==</span> <span class="s2">"app-green"</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-blue"</span> <span class="o">:</span> <span class="s2">"app-green"</span>
            <span class="c1">// ...</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">env.BUILD_NUMBER.toInteger() % 2 == 0</code>은 현재 빌드 번호가 짝수인지 홀수인지 확인하는 조건이다. 짝수이면 <code class="language-plaintext highlighter-rouge">app-green</code>을 <code class="language-plaintext highlighter-rouge">deployService</code>로, 홀수이면 <code class="language-plaintext highlighter-rouge">app-blue</code>를 <code class="language-plaintext highlighter-rouge">deployService</code>로 할당하게 했다. 이는 Blue/Green 배포 전략에서 트래픽을 전환할 대상을 동적으로 결정하는 핵심 로직으로, 더 복잡한 방식을 써볼까 했지만, 결과적으로 심플함, 예측 가능성 등을 고려하여 일단 프론트엔드서버는 간단한 방식을 차용하였다.</p>

<h3 id="jenkins-pipeline에서-groovy-활용-eg-script----블록">Jenkins Pipeline에서 Groovy 활용 (e.g., <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록)</h3>

<p>Declarative Pipeline은 구조화된 형태를 가지지만, 복잡한 로직이나 동적인 처리가 필요할 때는 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록을 사용하여 Groovy 스크립트를 직접 실행할 수 있다. 이 블록은 Declarative Pipeline 내에서 Scripted Pipeline의 유연성을 제공하는 ‘탈출구’ 역할을 한다.</p>

<h4 id="script----블록의-역할"><code class="language-plaintext highlighter-rouge">script { ... }</code> 블록의 역할</h4>

<ul>
  <li><strong>복잡한 로직 구현</strong>: Declarative Pipeline의 제한된 표현력으로는 어려운 복잡한 조건부 로직, 반복문, 예외 처리 등을 Groovy 스크립트로 직접 구현할 수 있다.</li>
  <li><strong>동적 처리</strong>: 빌드 번호, 환경 변수, 외부 API 호출 결과 등 동적인 값에 따라 파이프라인의 동작을 변경해야 할 때 유용.</li>
  <li><strong>Jenkins DSL 확장</strong>: Jenkins Pipeline이 제공하는 내장 DSL(Domain Specific Language) 외에, Groovy의 강력한 기능을 활용하여 사용자 정의 함수나 라이브러리를 호출할 수 있다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Build Image</code>, <code class="language-plaintext highlighter-rouge">Push to GHCR</code>, <code class="language-plaintext highlighter-rouge">Deploy to Server</code>, <code class="language-plaintext highlighter-rouge">post</code> 블록 내에서 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록이 광범위하게 사용했다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (script 블록 활용 예시)</span>
<span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">steps</span> <span class="o">{</span>
        <span class="n">echo</span> <span class="s2">"2. Build New Docker Image"</span>
        <span class="n">script</span> <span class="o">{</span>
            <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> <span class="c1">// 빌드할 이미지 명을 가변적으로 지정하도록 사용함.</span>
            <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span> 
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">steps</span> <span class="o">{</span>
        <span class="n">echo</span> <span class="s2">"3. Push the Docker Image to GHCR"</span>
        <span class="n">script</span> <span class="o">{</span>
            <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span>
            <span class="n">withCredentials</span><span class="o">([</span><span class="n">usernamePassword</span><span class="o">(</span><span class="nl">credentialsId:</span> <span class="n">GHCR_CREDS_ID</span><span class="o">,</span> <span class="nl">usernameVariable:</span> <span class="s1">'USER'</span><span class="o">,</span> <span class="nl">passwordVariable:</span> <span class="s1">'TOKEN'</span><span class="o">)])</span> <span class="o">{</span>
                <span class="n">sh</span> <span class="s2">"echo ${TOKEN} | docker login ghcr.io -u ${USER} --password-stdin"</span>
                <span class="n">sh</span> <span class="s2">"docker push ${imageTag}"</span>
            <span class="o">}</span> <span class="c1">// withCredentials 로 주요내용을 함께 가져가서 명령어에 적용시킨다. </span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록은 <code class="language-plaintext highlighter-rouge">imageTag</code> 변수를 선언하고, <code class="language-plaintext highlighter-rouge">sh</code> 명령어를 사용하여 Docker 빌드 및 푸시 작업을 수행하는 Groovy 코드를 포함한다. 특히 <code class="language-plaintext highlighter-rouge">withCredentials</code>와 같은 Jenkins DSL은 <code class="language-plaintext highlighter-rouge">script</code> 블록 내에서 더욱 유연하게 활용될 수 있다.</p>

<p>Jenkins Pipeline 스크립트 언어인 Groovy를 이해하고 활용하는 것은 복잡한 CI/CD 파이프라인을 구축하고 유지보수하는 데 필수적인 역량이다. Groovy의 기본 문법과 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록의 활용법을 숙지함으로써, Jenkins 파이프라인의 잠재력을 최대한 발휘할 수 있다.</p>

<h3 id="소스-코드-관리-source-code-management---scm">소스 코드 관리 (Source Code Management - SCM)</h3>

<p>CI/CD 파이프라인의 첫 번째이자 가장 기본적인 단계는 소스 코드를 관리하고 변경 사항을 감지하는 것이다. 소스 코드 관리(SCM) 시스템은 개발자들이 작성한 코드를 저장하고, 변경 이력을 추적하며, 여러 개발자 간의 협업을 지원하는 도구다. Jenkins는 다양한 SCM 시스템과 연동하여 코드 변경을 감지하고 파이프라인을 트리거(trigger)해준다. 이 프로젝트에서는 Git을 SCM을 기반으로 만들었다.</p>

<h4 id="git-연동-git-credentialsid-github_creds_id-url--branch-main">Git 연동 (<code class="language-plaintext highlighter-rouge">git credentialsId: GITHUB_CREDS_ID, url: '...', branch: 'main'</code>)</h4>

<p>Jenkins는 Git 플러그인을 통해 Git 저장소와 쉽게 연동할 수 있게 되어있다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 내에서 <code class="language-plaintext highlighter-rouge">git</code> 스텝(step)을 사용하여 특정 Git 저장소에서 소스 코드를 체크아웃(checkout)할 수 있고 특별히 요청하는 단계 없이 자연스럽게 해당 저장소에서 파일을 가져와준다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">git</code> 스텝</strong>: Jenkins Pipeline에서 Git 저장소에서 코드를 가져오는 데 사용되는 내장 스텝이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">credentialsId</code></strong>: Jenkins에 미리 등록된 자격 증명(Credentials)의 ID를 지정한다. 이 자격 증명은 비공개(private) 저장소에 접근하거나, 특정 작업을 수행할 권한이 필요할 때 사용된다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">GITHUB_CREDS_ID</code>를 사용하여 GitHub 저장소에 접근하도록 세팅했다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">url</code></strong>: 소스 코드를 가져올 Git 저장소의 URL을 지정한다. HTTPS 또는 SSH URL을 사용할 수 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">branch</code></strong>: 체크아웃할 브랜치(branch)를 지정한다. 일반적으로 <code class="language-plaintext highlighter-rouge">main</code> 또는 <code class="language-plaintext highlighter-rouge">master</code> 브랜치를 지정하여 최신 코드를 가져오도록 설정했다.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Checkout stage)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"1. Get the latest code from GitHub"</span>
                <span class="n">git</span> <span class="nl">credentialsId:</span> <span class="n">GITHUB_CREDS_ID</span><span class="o">,</span> <span class="nl">url:</span> <span class="s1">'https://github.com/paul2021-r/project-mini-frontend.git'</span><span class="o">,</span> <span class="nl">branch:</span> <span class="s1">'main'</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p>이 스텝은 <code class="language-plaintext highlighter-rouge">GITHUB_CREDS_ID</code>에 해당하는 자격 증명을 사용하여 <code class="language-plaintext highlighter-rouge">https://github.com/paul2021-r/project-mini-frontend.git</code> 저장소의 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에서 최신 코드를 Jenkins 작업 공간(workspace)으로 가져온다. <code class="language-plaintext highlighter-rouge">credentialsId</code>를 사용하는 것은 민감한 정보(예: GitHub Personal Access Token)를 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에 직접 노출하지 않고 안전하게 관리하는 구조다.</p>

<h4 id="git-pull-origin-main-git-checkout-main-명령의-이해"><code class="language-plaintext highlighter-rouge">git pull origin main</code>, <code class="language-plaintext highlighter-rouge">git checkout main</code> 명령의 이해</h4>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 단계 내에서 SSH를 통해 원격 서버에 접속한 후 <code class="language-plaintext highlighter-rouge">git pull origin main</code> 및 <code class="language-plaintext highlighter-rouge">git checkout main</code> 명령어를 실행한다. 이는 배포 서버 자체의 프로젝트 디렉토리에서 최신 코드를 유지하기 위한 목적으로 제공된다. 즉, 기존 젠킨스 빌드 서버는 workspace 에서 자동으로 최신화되지만, 시크릿을 제외한 환경 파일이나 설정 등, 깃을 통해 공유되는 영역을 위해, SSH 접속 후에도 최신화를 시키는 세심한 단계를 추가했다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">ssh</span> <span class="o">-</span><span class="n">o</span> <span class="n">StrictHostKeyChecking</span><span class="o">=</span><span class="n">no</span> <span class="o">-</span><span class="n">p</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PORT</span><span class="o">}</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_HOST</span><span class="o">}</span> <span class="err">'</span>
                                <span class="n">set</span> <span class="o">-</span><span class="n">ex</span>
                                
                                <span class="c1">// ...</span>

                                <span class="n">echo</span> <span class="s2">"--- Refresh main repository ---"</span>
                                <span class="n">cd</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PROJECT_PATH</span><span class="o">}</span>
                                <span class="n">git</span> <span class="n">pull</span> <span class="n">origin</span> <span class="n">main</span>
                                <span class="n">git</span> <span class="n">checkout</span> <span class="n">main</span>
                                
                                <span class="c1">// ...</span>
                                <span class="err">'</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">cd ${TARGET_PROJECT_PATH}</code></strong>: 먼저 배포 서버의 프로젝트 루트 디렉토리로 이동.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">git pull origin main</code></strong>: 원격 저장소(<code class="language-plaintext highlighter-rouge">origin</code>)의 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에서 최신 변경 사항을 가져와 현재 로컬 브랜치에 병합(merge)한다. 이는 배포 서버에 항상 최신 버전의 코드가 존재하도록 보장</li>
  <li><strong><code class="language-plaintext highlighter-rouge">git checkout main</code></strong>: 현재 작업 중인 브랜치를 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 전환한다. 이는 혹시 다른 브랜치에 머물러 있을 경우를 대비하여 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에서 작업을 수행하도록 명확히 하는 역할을 한다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (3)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/3-til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (3)" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/3-til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/3-til-jenkins.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h2 id="jenkins">Jenkins</h2>
<h3 id="docker-이미지-빌드-및-관리-docker-image-build--management">Docker 이미지 빌드 및 관리 (Docker Image Build &amp; Management)</h3>

<p>CI/CD 파이프라인에서 애플리케이션을 컨테이너화하는 것은 환경 일관성을 보장하고 배포를 간소화하는 핵심적인 단계다. Jenkins는 Docker CLI와 연동하여 Docker 이미지를 빌드하고, 컨테이너 레지스트리(Registry)에 푸시(push)하며, 배포 서버에서 이미지를 풀(pull)하는 일련의 과정을 자동화한다. 이 섹션에서는 <code class="language-plaintext highlighter-rouge">project-mini-frontend</code>의 <code class="language-plaintext highlighter-rouge">app/Dockerfile</code>과 <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>을 기반으로 Docker 이미지 빌드 및 관리의 주요 개념을 정리하였다.</p>

<h4 id="docker-build-명령어-및---build-arg-활용"><code class="language-plaintext highlighter-rouge">docker build</code> 명령어 및 <code class="language-plaintext highlighter-rouge">--build-arg</code> 활용</h4>

<p><code class="language-plaintext highlighter-rouge">docker build</code> 명령어는 <code class="language-plaintext highlighter-rouge">Dockerfile</code>에 정의된 지침에 따라 Docker 이미지를 생성한다. 이 과정에서 <code class="language-plaintext highlighter-rouge">--build-arg</code> 옵션을 사용하여 빌드 시점에 환경 변수를 주입할 수 있다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker build -t &lt;image_name&gt;:&lt;tag&gt; &lt;path_to_dockerfile_context&gt;</code></strong>: 이미지를 빌드하는 기본 명령어.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-t &lt;image_name&gt;:&lt;tag&gt;</code>: 빌드된 이미지에 이름과 태그를 부여한다. 태그는 이미지의 버전을 식별하는 데 사용된다.</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;path_to_dockerfile_context&gt;</code>: <code class="language-plaintext highlighter-rouge">Dockerfile</code>이 위치한 디렉토리의 경로를 지정합한다. Docker 빌드 컨텍스트(context)가 된다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">--build-arg &lt;VAR_NAME&gt;=&lt;value&gt;</code></strong>: <code class="language-plaintext highlighter-rouge">Dockerfile</code> 내에서 <code class="language-plaintext highlighter-rouge">ARG</code> 지시어로 선언된 변수에 값을 전달한다. 이는 빌드 시점에 동적으로 환경을 구성할 때 유용하다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Build Image</code> 단계에서는 <code class="language-plaintext highlighter-rouge">docker build</code> 명령어를 사용하여 Next.js 애플리케이션 이미지를 빌드한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Build Image stage)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"2. Build New Docker Image"</span>
                <span class="n">script</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> 
                    <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span> 
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">sh "docker build -t ${imageTag} ./app"</code> 명령은 <code class="language-plaintext highlighter-rouge">project-mini-frontend/app</code> 디렉토리를 빌드 컨텍스트로 사용하여 이미지를 빌드하고, <code class="language-plaintext highlighter-rouge">IMAGE_NAME</code>과 Jenkins의 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>를 조합한 태그를 부여한다. 만약 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 내에서 <code class="language-plaintext highlighter-rouge">ARG</code>를 통해 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_API_URL</code>과 같은 환경 변수를 받도록 설정되어 있다면, <code class="language-plaintext highlighter-rouge">sh "docker build -t ${imageTag} --build-arg NEXT_PUBLIC_API_URL=${env.API_URL} ./app"</code>와 같이 <code class="language-plaintext highlighter-rouge">--build-arg</code>를 추가하여 빌드 시점에 값을 주입해서 다이나믹한 대응이 가능하다.</p>

<h4 id="docker-이미지-태깅-전략-eg-latest-build_number">Docker 이미지 태깅 전략 (e.g., <code class="language-plaintext highlighter-rouge">latest</code>, <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>)</h4>

<p>Docker 이미지 태깅은 이미지의 버전을 관리하고 식별하는 데 매우 중요하다. 일관된 태깅 전략은 CI/CD 파이프라인의 안정성과 효율성을 높이기에 구조를 이해할 필요가 있다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">latest</code> 태그</strong>: 일반적으로 가장 최신 버전의 안정적인 이미지에 부여된다. 하지만 <code class="language-plaintext highlighter-rouge">latest</code> 태그는 항상 최신을 의미하므로, 특정 버전을 명확히 식별하기 어렵다는 단점이 있다. 프로덕션 환경에서는 <code class="language-plaintext highlighter-rouge">latest</code> 태그만 사용하는 것을 지양하고, 특정 버전 태그와 함께 사용하는 것이 권장된다.(아니면 편의성, 이식성을 위해 이미지를 두개로 tag를 나눠, latest 인 경우, 빌드넘버 두가지를 함께 병용하는 것도 괜찮다.)</li>
  <li><strong><code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code> 태그</strong>: Jenkins의 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>와 같이 CI/CD 시스템에서 생성되는 고유한 빌드 번호를 태그로 사용하는 것은 매우 효과적인 전략이다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>를 활용한 태깅 전략을 사용했다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (이미지 태깅 예시)</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> 
                    <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span> 
                    <span class="c1">// ...</span>
                    <span class="n">sh</span> <span class="s2">"docker push ${imageTag}"</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">ghcr.io/paul2021-r/project-mini-frontend:123</code>과 같이 빌드 번호가 포함된 태그를 사용함으로써, 어떤 빌드에서 생성된 이미지인지 명확하게 식별할 수 있다.</p>

<h4 id="github-container-registry-ghcr-사용법">GitHub Container Registry (GHCR) 사용법</h4>

<p>GitHub Container Registry (GHCR)는 GitHub에서 제공하는 Docker 이미지 저장소 서비스다. Docker Hub와 유사하게 Docker 이미지를 저장하고 공유할 수 있으며, GitHub 저장소와 긴밀하게 통합된다.</p>

<ul>
  <li><strong>장점</strong>: GitHub 저장소와 연동되어 접근 제어 및 권한 관리가 용이하며, GitHub Actions와 같은 CI/CD 도구와 함께 사용하기 편리하다.</li>
  <li><strong>사용 이유</strong>: 다른 서비스들은 무료로 제공해주긴 해도 제한사항이 있고, default 값이 아니라는 점만 제외하면 모든 기능이 동일하다. EKS 와 같은 AWS 의 상용 서비스도 고려는 했지만, 굳이 비용을 들일 필요가 없기 때문에, 가장 널널하게 쓰기좋은 GHCR 을 적용했다.</li>
  <li><strong>사용법</strong>: <code class="language-plaintext highlighter-rouge">docker login</code>, <code class="language-plaintext highlighter-rouge">docker push</code>, <code class="language-plaintext highlighter-rouge">docker pull</code> 명령어를 사용하여 GHCR에 이미지를 푸시하고 풀할 수 있다. 인증은 GitHub Personal Access Token(PAT)을 통해 이루어진다. 단, PAT 발급 시 package 에 대한 write 권한을 제공해야 한다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Push to GHCR</code> 단계는 GHCR 사용법을 보여준다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Push to GHCR stage)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"3. Push the Docker Image to GHCR"</span>
                <span class="n">script</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span>
                    <span class="n">withCredentials</span><span class="o">([</span><span class="n">usernamePassword</span><span class="o">(</span><span class="nl">credentialsId:</span> <span class="n">GHCR_CREDS_ID</span><span class="o">,</span> <span class="nl">usernameVariable:</span> <span class="s1">'USER'</span><span class="o">,</span> <span class="nl">passwordVariable:</span> <span class="s1">'TOKEN'</span><span class="o">)])</span> <span class="o">{</span>
                        <span class="n">sh</span> <span class="s2">"echo ${TOKEN} | docker login ghcr.io -u ${USER} --password-stdin"</span>
                        <span class="n">sh</span> <span class="s2">"docker push ${imageTag}"</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">withCredentials</code> 블록을 사용하여 Jenkins에 저장된 <code class="language-plaintext highlighter-rouge">GHCR_CREDS_ID</code> 자격 증명(GitHub 사용자 이름과 PAT)을 <code class="language-plaintext highlighter-rouge">USER</code>와 <code class="language-plaintext highlighter-rouge">TOKEN</code> 환경 변수로 주입한다. 이 정보를 사용하여 <code class="language-plaintext highlighter-rouge">docker login ghcr.io</code> 명령으로 GHCR에 로그인한 후, <code class="language-plaintext highlighter-rouge">docker push ${imageTag}</code> 명령으로 빌드된 이미지를 GHCR에 푸시한다.</p>

<h4 id="docker-login-docker-push-docker-pull-docker-logout-명령어"><code class="language-plaintext highlighter-rouge">docker login</code>, <code class="language-plaintext highlighter-rouge">docker push</code>, <code class="language-plaintext highlighter-rouge">docker pull</code>, <code class="language-plaintext highlighter-rouge">docker logout</code> 명령어</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker login &lt;registry_url&gt;</code></strong>: Docker 레지스트리에 로그인한다. 사용자 이름과 비밀번호(또는 PAT)를 입력하며, url을 기준으로 사용하는 서비스 주체 플랫폼을 결정할 수 있다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">echo ${TOKEN} | docker login ghcr.io -u ${USER} --password-stdin</code>와 같이 표준 입력을 통해 비밀번호를 전달하여 자동화된 로그인 과정을 구현한다.(보안이 약하다고 하여, 대안이 되는 다른 방법도 있다지만, 아직 구현에 성공하진 못했다.)</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker push &lt;image_name&gt;:&lt;tag&gt;</code></strong>: 로컬에 빌드된 Docker 이미지를 원격 레지스트리에 업로드(푸시)한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker pull &lt;image_name&gt;:&lt;tag&gt;</code></strong>: 원격 레지스트리에서 Docker 이미지를 로컬로 다운로드(풀)한다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 단계에서 배포 서버가 GHCR로부터 이미지를 풀하는 데 사용된다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                            <span class="n">echo</span> <span class="s2">"--- (1/4) Pull the new image : ${imageTag} ---"</span>
                            <span class="n">docker</span> <span class="n">pull</span> <span class="n">$</span><span class="o">{</span><span class="n">imageTag</span><span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker logout &lt;registry_url&gt;</code></strong>: Docker 레지스트리에서 로그아웃합니다. 보안을 위해 파이프라인의 <code class="language-plaintext highlighter-rouge">post</code> 블록에서 항상 로그아웃하는 것이 권장되고, 그렇게 적용해두었다. 이로써 빌드 하나의 사이클에서 모든 내용이 종결되고 빌드 프로세스는 격리된다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (post block)</span>
    <span class="n">always</span> <span class="o">{</span>
        <span class="n">echo</span> <span class="s2">"Logout from GHCR"</span>
        <span class="n">sh</span> <span class="s2">"docker logout ghcr.io"</span>
    <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="docker-out-of-docker-dood-패턴-docker-out-of-docker-pattern">Docker-out-of-Docker (DooD) 패턴 (Docker-out-of-Docker Pattern)</h3>

<p>Docker-out-of-Docker (DooD) 패턴은 Docker 컨테이너 내부에서 Docker 명령어를 실행하여 호스트(Host)의 Docker 데몬(Daemon)과 상호작용하는 전략이다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트는 Jenkins 컨테이너 내부에서 호스트의 Docker 데몬을 제어하기 위해 DooD 패턴을 활용하고 있다.</p>

<h4 id="jenkins-컨테이너에서-호스트-docker-데몬-제어-원리">Jenkins 컨테이너에서 호스트 Docker 데몬 제어 원리</h4>

<p>일반적으로 Docker 컨테이너는 호스트 시스템과 격리된 환경에서 실행된다. 하지만 DooD 패턴을 사용하면 컨테이너 내부에서 호스트의 Docker 데몬에 접근하여 Docker 명령어를 실행할 수 있다.</p>

<ol>
  <li><strong>Docker 소켓 마운트</strong>: 호스트의 Docker 데몬은 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code>이라는 유닉스 소켓(Unix socket)을 통해 외부와 통신한다. DooD 패턴은 Jenkins 컨테이너를 실행할 때 이 호스트의 <code class="language-plaintext highlighter-rouge">docker.sock</code> 파일을 컨테이너 내부로 마운트한다.
    <ul>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-jenkins/docker-compose.yml</code>의 <code class="language-plaintext highlighter-rouge">volumes</code> 설정
```yaml
        <h1 id="project-mini-jenkinsdocker-composeyml-일부">project-mini-jenkins/docker-compose.yml (일부)</h1>
        <p>services:
  jenkins:</p>
        <h1>…</h1>
        <p>volumes:</p>
        <ul>
          <li>./jenkins_home:/var/jenkins_home</li>
          <li>/var/run/docker.sock:/var/run/docker.sock # 이 부분이 핵심</li>
          <li>/usr/bin/docker:/usr/bin/docker</li>
          <li>/usr/bin/docker-compose:/usr/bin/docker-compose
            <h1 id="-1">…</h1>
            <p>```
위 설정은 호스트의 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code>을 Jenkins 컨테이너의 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> 경로로 마운트한다. 이로써 Jenkins 컨테이너 내부의 Docker CLI는 호스트의 Docker 데몬과 통신할 수 있게 된 것이다.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Docker CLI 설치</strong>: Jenkins 컨테이너 내부에 Docker CLI가 설치되어 있어야 한다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>은 <code class="language-plaintext highlighter-rouge">apt-get install -y docker-ce-cli</code> 명령을 통해 Docker CLI를 설치하여 제어 도구들을 컨테이너 내부에 소지하게 되는 것이다.
    <ul>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>의 Docker CLI 설치 부분
        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># project-mini-jenkins/jenkins/Dockerfile (일부)</span>
<span class="c"># ...</span>
<span class="c"># 4. 패키지 목록 다시 업데이트 및 Docker CLI 설치 (서버 데몬 제외)</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> docker-ce-cli
<span class="c"># ...</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>권한 설정</strong>: Jenkins 컨테이너 내부에서 Docker 명령어를 실행하는 사용자(일반적으로 <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자)가 호스트의 <code class="language-plaintext highlighter-rouge">docker.sock</code>에 접근할 수 있는 권한을 가져야 한다. 이는 해당 사용자를 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 추가함으로써 해결된다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>은 <code class="language-plaintext highlighter-rouge">usermod -aG docker jenkins</code> 명령을 통해 이 권한을 부여한다.
    <ul>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>의 권한 설정 부분
        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># project-mini-jenkins/jenkins/Dockerfile (일부)</span>
<span class="c"># ...</span>
<span class="c"># DooD 구조를 위함. Docker 그룹에 jenkins 유저 추가</span>
<span class="k">ARG</span><span class="s"> DOCKER_GID=1001</span>
<span class="k">RUN </span>groupadd <span class="nt">-g</span> <span class="k">${</span><span class="nv">DOCKER_GID</span><span class="k">}</span> docker
<span class="k">RUN </span>usermod <span class="nt">-aG</span> docker jenkins
<span class="c"># ...</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h4 id="jenkins-사용자를-docker-그룹에-추가하는-이유"><code class="language-plaintext highlighter-rouge">jenkins</code> 사용자를 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 추가하는 이유</h4>

<p>리눅스(Linux) 시스템에서 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> 파일은 일반적으로 <code class="language-plaintext highlighter-rouge">root</code> 사용자 또는 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 속한 사용자만 접근할 수 있도록 권한이 설정되어 있ㅊ다. Jenkins 컨테이너 내부에서 <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자가 Docker 명령어를 실행하려면 이 소켓 파일에 대한 접근 권한이 필요하다.</p>

<p><code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>에서 <code class="language-plaintext highlighter-rouge">usermod -aG docker jenkins</code> 명령을 통해 <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자를 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 추가하는 것은 바로 이 접근 권한을 부여하기 위함이다. <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자가 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 속하게 되면, <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> 파일에 대한 읽기/쓰기 권한을 얻게 되어 호스트의 Docker 데몬과 통신할 수 있게 된다.</p>

<h3 id="bluegreen-배포-개념-concept-of-bluegreen-deployment">Blue/Green 배포 개념 (Concept of Blue/Green Deployment)</h3>

<p>Blue/Green 배포는 무중단 배포(Zero-Downtime Deployment)를 실현하기 위한 효과적인 전략 중 하나다. 이 방식은 프로덕션 환경에 두 개의 동일한 환경을 구축하고, 한 번에 하나의 환경만 활성화하여 사용자 트래픽을 처리한다. 일반적으로 ‘Blue’ 환경과 ‘Green’ 환경으로 명명되며, 한 환경이 현재 운영 중인(Active) 상태일 때 다른 환경은 새로운 버전의 애플리케이션을 배포하고 테스트하는 데 사용된다.</p>

<h4 id="무중단-배포-zero-downtime-deployment의-중요성">무중단 배포 (Zero-Downtime Deployment)의 중요성</h4>

<p>무중단 배포는 서비스 중단 없이 새로운 버전의 애플리케이션을 배포하는 것을 의미한다. 이는 현대 비즈니스 환경에서 다음과 같은 이유로 매우 중요합니다.</p>

<ul>
  <li><strong>사용자 경험 유지</strong>: 서비스 중단은 사용자에게 부정적인 경험을 제공하고, 이는 고객 이탈로 이어질 수 있다. 무중단 배포는 사용자가 서비스 중단을 인지하지 못하도록 하여 긍정적인 사용자 경험을 유지한다.</li>
  <li><strong>비즈니스 연속성 보장</strong>: 24시간 365일 운영되어야 하는 서비스의 경우, 배포로 인한 짧은 중단조차도 큰 비즈니스 손실로 이어질 수 있다. 무중단 배포는 이러한 비즈니스 연속성을 보장한다.</li>
  <li><strong>경쟁력 확보</strong>: 빠르게 변화하는 시장에서 새로운 기능을 신속하게 배포하고 사용자 피드백을 반영하는 능력은 기업의 경쟁력을 좌우한다. 무중단 배포는 이러한 빠른 릴리스 주기를 가능하게 한다.</li>
  <li><strong>안정성 향상</strong>: 배포 과정에서 발생할 수 있는 위험을 최소화하고, 문제가 발생하더라도 신속하게 이전 버전으로 롤백할 수 있는 안전망을 제공하여 서비스의 전반적인 안정성을 향상시킨다.</li>
</ul>

<h4 id="bluegreen-환경-구성-원리">Blue/Green 환경 구성 원리</h4>

<p>Blue/Green 배포는 다음과 같은 원리로 구성된다.</p>

<ol>
  <li><strong>두 개의 동일한 환경</strong>: ‘Blue’와 ‘Green’이라는 두 개의 완전히 동일한 프로덕션 환경을 준비한다. 이 두 환경은 하드웨어, 소프트웨어, 네트워크 구성 등 모든 면에서 동일해야한다. 이번 프로젝트의 경우, 가능한 실무를 모사하고, 목표로하는 AI서비스를 위해 프론트드는 다소 작게 준비하였기에, 한 호스트 서버에 작게 분할하여 집어넣는 것을 모색했다.</li>
  <li><strong>트래픽 라우팅 (Traffic Routing)</strong>: 사용자 트래픽은 로드 밸런서(Load Balancer) 또는 리버스 프록시(Reverse Proxy)를 통해 현재 활성화된 환경으로 라우팅된다. <code class="language-plaintext highlighter-rouge">project-mini-frontend</code> 프로젝트에서는 Nginx가 이 역할을 수행하게된다.</li>
  <li><strong>새로운 버전 배포</strong>: 현재 비활성화된 환경(예: Green)에 새로운 버전의 애플리케이션을 배포하고, 필요한 테스트를 수행할 수 있게 한다. 단, 지금은 로컬 개발환경이 존재하여, 그러한 접근을 만들진 않았음. 그러나 Ngnix 의 가상 서버 기능을 도입하여, 접근 가능한 도메인 URL 단위로 접근하도록 할 것이다.</li>
  <li><strong>트래픽 전환</strong>: 새로운 버전의 애플리케이션이 안정적으로 동작하는 것이 확인되면, 로드 밸런서/리버스 프록시의 설정을 변경하여 사용자 트래픽을 Blue 환경에서 Green 환경으로 전환한다. 이 전환은 매우 빠르게 이루어지므로 사용자 입장에서는 서비스 중단을 느끼지 못하며, stateless 서버이므로 트래픽의 전환이 아무 문제가 없다.</li>
  <li><strong>이전 환경 유지 또는 폐기</strong>: 트래픽 전환 후, 이전 버전이 실행되던 환경(예: Blue)은 잠시 동안 유지하여 문제가 발생할 경우 즉시 롤백할 수 있도록 한다. 안정성이 확인되면 이전 환경은 폐기하거나 다음 배포를 위한 대기 환경으로 재활용될 수 있다. 이 부분에 대해도 현재는 롤백을 위한 백업처럼 되어있고, 테스트를 위해선 수동 최신화가 필요하다. 하만, 향후 서비스의 문제 없을 시 이용 가능한 예비 서버의 업데이트 배포 방식도 작업으로추가할 예정이다.</li>
</ol>

<h3 id="jenkinsfile-내-bluegreen-로직-분석-project-mini-frontendjenkinsfile-참고"><code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 내 Blue/Green 로직 분석 (<code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code> 참고)</h3>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 Blue/Green 배포 전략을 Jenkins 파이프라인 내에서 직접 구현해보았다. 특히 <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 단계에서 이 로직이 핵심적으로 동작한다.</p>

<h4 id="build_number를-이용한-배포-서비스-결정-deployservice-upstreamservice"><code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>를 이용한 배포 서비스 결정 (<code class="language-plaintext highlighter-rouge">deployService</code>, <code class="language-plaintext highlighter-rouge">upstreamService</code>)</h4>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                    <span class="c1">// 어떤 컨테이너를 업데이트 및 업스트림 대상을 지정</span>
                    <span class="kt">def</span> <span class="n">deployService</span> <span class="o">=</span> <span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="na">BUILD_NUMBER</span><span class="o">.</span><span class="na">toInteger</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-green"</span> <span class="o">:</span> <span class="s2">"app-blue"</span> 
                    <span class="kt">def</span> <span class="n">upstreamService</span> <span class="o">=</span> <span class="o">(</span><span class="n">deployService</span> <span class="o">==</span> <span class="s2">"app-green"</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-blue"</span> <span class="o">:</span> <span class="s2">"app-green"</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">deployService</code>: 현재 빌드된 새로운 버전의 애플리케이션이 배포될 대상 서비스(컨테이너)의 이름을 결정한다. <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>가 짝수이면 <code class="language-plaintext highlighter-rouge">app-green</code>, 홀수이면 <code class="language-plaintext highlighter-rouge">app-blue</code>로 결정된다.</li>
  <li><code class="language-plaintext highlighter-rouge">upstreamService</code>: 현재 사용자 트래픽을 처리하고 있는 이전 버전의 애플리케이션 서비스 이름이다. <code class="language-plaintext highlighter-rouge">deployService</code>와 반대되는 서비스로 설정된다.</li>
</ul>

<h4 id="docker-compose-up--d---no-deps---force-recreate-명령의-역할"><code class="language-plaintext highlighter-rouge">docker compose up -d --no-deps --force-recreate</code> 명령의 역할</h4>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">cd</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PROJECT_PATH</span><span class="o">}</span>
                                <span class="c1">// ...</span>
                                <span class="n">docker</span> <span class="n">compose</span> <span class="o">--</span><span class="n">env</span><span class="o">-</span><span class="n">file</span> <span class="n">init</span><span class="o">.</span><span class="na">env</span> <span class="n">up</span> <span class="o">-</span><span class="n">d</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">deps</span> <span class="o">--</span><span class="n">force</span><span class="o">-</span><span class="n">recreate</span> <span class="n">$</span><span class="o">{</span><span class="n">deployService</span><span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker compose up -d</code></strong>: Docker Compose 파일에 정의된 서비스를 백그라운드(<code class="language-plaintext highlighter-rouge">-d</code>)에서 실행 및 업데이트 역할</li>
  <li><strong><code class="language-plaintext highlighter-rouge">--env-file init.env</code></strong>: <code class="language-plaintext highlighter-rouge">init.env</code> 파일에 정의된 환경 변수(예: <code class="language-plaintext highlighter-rouge">APP_BLUE_IMAGE</code>, <code class="language-plaintext highlighter-rouge">APP_GREEN_IMAGE</code>)를 Docker Compose 명령에 적용한다. 이 변수들은 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 이미지 이름을 동적으로 설정하는 데 사용된다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># project-mini-frontend/docker-compose.yml (일부)</span>
<span class="na">app-blue</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">${APP_BLUE_IMAGE}</span>
  <span class="c1"># ...</span>
<span class="na">app-green</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">${APP_GREEN_IMAGE}</span>
  <span class="c1"># ...</span>
</code></pre></div>    </div>
    <p>Jenkins 파이프라인은 <code class="language-plaintext highlighter-rouge">init.env</code> 파일을 업데이트하여 <code class="language-plaintext highlighter-rouge">APP_BLUE_IMAGE</code> 또는 <code class="language-plaintext highlighter-rouge">APP_GREEN_IMAGE</code> 변수가 새로 빌드된 이미지 태그를 가리키도록 할 수 있다. (현재 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">init.env</code>를 직접 수정하는 로직은 없지만, 이러한 방식으로 연동될 수 있다.)</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">--no-deps</code></strong>: 지정된 서비스(<code class="language-plaintext highlighter-rouge">deployService</code>)만 업데이트하고, 해당 서비스가 의존하는 다른 서비스(예: Nginx)는 다시 시작하지 않도록 하는 설정. 불필요한 서비스 중단을 방지하여 무중단 배포에 기여한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">--force-recreate</code></strong>: 서비스 컨테이너를 강제로 다시 생성합니다. 이는 새로운 이미지로 컨테이너를 업데이트할 때 필수적이다. 레이어가 중복되는 걸로 인식하여, 실제 변경 사항이 제대로 바뀌지 않는 것을 막기 위함이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">${deployService}</code></strong>: <code class="language-plaintext highlighter-rouge">app-blue</code> 또는 <code class="language-plaintext highlighter-rouge">app-green</code> 중 현재 배포 대상이 되는 서비스 이름이다.</li>
</ul>

<h4 id="sed-명령어를-이용한-nginx-설정-동적-변경-nginxnginxconf-업데이트"><code class="language-plaintext highlighter-rouge">sed</code> 명령어를 이용한 Nginx 설정 동적 변경 (<code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code> 업데이트)</h4>

<p>새로운 버전의 애플리케이션이 성공적으로 배포되면, Nginx 리버스 프록시의 설정을 변경하여 사용자 트래픽을 새로운 환경으로 전환해야 하고 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">sed</code> 명령어를 사용하여 <code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code> 파일을 동적으로 수정하고 있다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">echo</span> <span class="s2">"--- (3/4) Switch Nginx Configuration to change traffic ---"</span>
                                <span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="s2">"s|server ${upstreamService}:3000;|server ${deployService}:3000;|"</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PROJECT_PATH</span><span class="o">}</span><span class="s">/nginx/</span><span class="n">nginx</span><span class="o">.</span><span class="na">conf</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">sed -i</code></strong>: <code class="language-plaintext highlighter-rouge">sed</code> 명령어는 텍스트 스트림 편집기(Stream Editor)로, 파일의 내용을 변경하는 데 사용된다. <code class="language-plaintext highlighter-rouge">-i</code> 옵션은 변경 사항을 원본 파일에 직접 적용(in-place)하도록 하는 옵션이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">"s|server ${upstreamService}:3000;|server ${deployService}:3000;|"</code></strong>: <code class="language-plaintext highlighter-rouge">s</code>는 ‘substitute’를 의미하며, 특정 패턴을 찾아 다른 문자열로 대체한다. 여기서는 <code class="language-plaintext highlighter-rouge">server ${upstreamService}:3000;</code> 패턴을 찾아 <code class="language-plaintext highlighter-rouge">server ${deployService}:3000;</code>으로 변경한다. 즉, Nginx가 현재 트래픽을 보내고 있는 이전 서비스(<code class="language-plaintext highlighter-rouge">upstreamService</code>)를 새로운 서비스(<code class="language-plaintext highlighter-rouge">deployService</code>)로 변경하도록 설정 파일의 해당 URL 구문만 수정하는 역할을 한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">${TARGET_PROJECT_PATH}/nginx/nginx.conf</code></strong>: 수정할 Nginx 설정 파일의 경로</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code> 예시</strong>:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># project-mini-frontend/nginx/nginx.conf (일부)</span>
<span class="k">upstream</span> <span class="s">nextjs_app</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="nf">app-blue</span><span class="p">:</span><span class="mi">3000</span><span class="p">;</span> <span class="c1"># 이 부분이 동적으로 변경됩니다.</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="c1"># ...</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://nextjs_app</span><span class="p">;</span>
        <span class="c1"># ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="docker-compose-exec-nginx-nginx--s-reload를-통한-nginx-재로드"><code class="language-plaintext highlighter-rouge">docker compose exec nginx nginx -s reload</code>를 통한 Nginx 재로드</h4>

<p><code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일이 수정된 후, Nginx가 변경된 설정을 적용하도록 재로드해야 한다. 이때 Nginx 서비스를 중단하지 않고 설정을 재로드하는 것이 무중단 배포의 핵심이 된다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">echo</span> <span class="s2">"--- (4/4) Reload Nginx Configuration ---"</span>
                                <span class="n">docker</span> <span class="n">compose</span> <span class="o">--</span><span class="n">env</span><span class="o">-</span><span class="n">file</span> <span class="n">init</span><span class="o">.</span><span class="na">env</span> <span class="o">-</span><span class="n">f</span> <span class="n">docker</span><span class="o">-</span><span class="n">compose</span><span class="o">.</span><span class="na">yml</span> <span class="n">exec</span> <span class="o">-</span><span class="n">T</span> <span class="n">nginx</span> <span class="n">nginx</span> <span class="o">-</span><span class="n">s</span> <span class="n">reload</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker compose exec nginx</code></strong>: <code class="language-plaintext highlighter-rouge">nginx</code> 서비스 컨테이너 내부에서 명령어를 실행한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">nginx -s reload</code></strong>: Nginx에게 현재 실행 중인 서비스를 중단하지 않고 설정 파일을 다시 읽어들이도록 지시한다. 이는 새로운 연결은 변경된 설정으로 처리하고, 기존 연결은 현재 설정으로 계속 처리하도록 하여 서비스 중단 없이 설정을 적용할 수 있게 만든다.</li>
</ul>

<p>이 과정을 통해 사용자 트래픽은 새로운 버전의 애플리케이션이 실행되는 환경으로 즉시 전환되며, 이전 버전의 애플리케이션은 여전히 실행 중인 상태로 유지된다. 이는 문제가 발생할 경우 빠른 롤백을 가능하게 하는 안전망 역할을 한다.</p>

<h3 id="롤백-전략-rollback-strategy">롤백 전략 (Rollback Strategy)</h3>

<p>Blue/Green 배포는 롤백이 매우 용이하다는 강력한 장점을 가지기에 무중단 배포의 여러 전략 중 이번 프로젝트의 CICD 의 핵심이라고 할 수 있다. 새로운 버전 배포 후 심각한 문제가 발견될 경우, 즉시 이전 버전으로 트래픽을 되돌릴 수 있다.</p>

<h4 id="bluegreen-배포에서의-롤백-용이성">Blue/Green 배포에서의 롤백 용이성</h4>

<ul>
  <li><strong>즉각적인 전환</strong>: 새로운 환경(Green)으로 트래픽을 전환한 후 문제가 발생하면, Nginx 설정을 다시 변경하여 이전 환경(Blue)으로 트래픽을 즉시 되돌릴 수 있다. 이 과정은 <code class="language-plaintext highlighter-rouge">sed</code> 명령어를 반대로 실행하거나, conf 를 직접 수정 후 Nginx를 재로드하는 것만으로 가능해진다.</li>
  <li><strong>이전 환경 유지</strong>: 이전 버전의 애플리케이션이 실행되던 환경은 트래픽 전환 후에도 현재는 유지되도록 해두었다. 이는 롤백 시 별도의 배포 과정 없이 즉시 서비스를 복구할 수 있도록 한다.</li>
</ul>

<h4 id="명시적인-롤백-단계-또는-스크립트의-필요성">명시적인 롤백 단계 또는 스크립트의 필요성</h4>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은, 현재는 명시적인 롤백 단계를 포함하고 있지 않다. 프로젝트의 진행, 기존 Jenkins 의 작업을 그대로 활용해서 만들면 되기 때문이다. 향후에 적용이 될 예정이다.</p>

<ul>
  <li><strong>자동 롤백</strong>: <code class="language-plaintext highlighter-rouge">post { failure { ... } }</code> 블록 내에서 배포 실패 시 자동으로 Nginx 설정을 이전 상태로 되돌리고 Nginx를 재로드하는 스크립트를 추가할 수 있다.</li>
  <li><strong>수동 롤백 스크립트</strong>: Jenkins Job으로 별도의 롤백 스크립트를 생성하여, 특정 빌드 번호로 Nginx 트래픽을 전환할 수 있도록 할 수 있다. 이는 긴급 상황 발생 시 운영자가 빠르게 대응할 수 있도록 한다.</li>
</ul>

<h3 id="discord-알림-discord-notification">Discord 알림 (Discord Notification)</h3>

<p>CI/CD 파이프라인에서 빌드 및 배포 과정의 성공 또는 실패 여부를 실시간으로 파악하는 것은 매우 중요하기에 현재는 아주 기본적인 로깅 체계를 구축했다. Jenkins는 다양한 알림 채널을 지원하지만, 현재 개발 중에 가장 많이 사용하는 Discord 를 활용한 실시간 알림 체계를 구축했고, <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 빌드 결과에 따라 Discord 채널에 알림을 보내는 기능이 동작한다.</p>

<h4 id="curl--x-post--h-content-type-applicationjson---data-message-discord_url-명령어-분석"><code class="language-plaintext highlighter-rouge">curl -X POST -H 'Content-Type: application/json' --data '${message}' ${DISCORD_URL}</code> 명령어 분석</h4>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">post</code> 블록 내에서 <code class="language-plaintext highlighter-rouge">curl</code> 명령어를 사용하여 Discord 웹훅(Webhook)으로 알림 메시지를 전송한다. 이 명령어는 HTTP POST 요청을 통해 JSON 형식의 데이터를 Discord 웹훅 URL로 보낸다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (post success 블록 일부)</span>
        <span class="n">success</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Deployment succeeded. Now send a discord notification."</span>
            <span class="n">script</span> <span class="o">{</span>
                <span class="n">withCredentials</span><span class="o">([</span><span class="n">string</span><span class="o">(</span><span class="nl">credentialsId:</span> <span class="n">DISCORD_CREDS_ID</span><span class="o">,</span> <span class="nl">variable:</span> <span class="s1">'DISCORD_URL'</span><span class="o">)])</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">message</span> <span class="o">=</span> <span class="s2">"{\"content\": \"🚀 Build Process is successfully finished : **[${env.JOB_NAME}]** - **#${env.BUILD_NUMBER}**\"}"</span>

                    <span class="n">sh</span> <span class="s2">"curl -X POST -H 'Content-Type: application/json' --data '${message}' ${DISCORD_URL}"</span>
                <span class="o">}</span>

            <span class="o">}</span>

        <span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">curl -X POST</code></strong>: HTTP POST 메서드를 사용하여 요청을 보낸다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">-H 'Content-Type: application/json'</code></strong>: 요청 헤더(Header)에 <code class="language-plaintext highlighter-rouge">Content-Type</code>을 <code class="language-plaintext highlighter-rouge">application/json</code>으로 지정하여, 보내는 데이터가 JSON 형식임을 명시.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">--data '${message}'</code></strong>: 요청 본문(Body)에 전송할 데이터를 지정한다. 여기서는 <code class="language-plaintext highlighter-rouge">message</code> 변수에 저장된 JSON 문자열을 보낸다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">${DISCORD_URL}</code></strong>: Discord 웹훅 URL입니다. 이 URL은 Jenkins Credentials에 <code class="language-plaintext highlighter-rouge">Secret text</code> 타입으로 저장된 <code class="language-plaintext highlighter-rouge">DISCORD_CREDS_ID</code> 자격 증명을 <code class="language-plaintext highlighter-rouge">withCredentials</code> 블록을 통해 <code class="language-plaintext highlighter-rouge">DISCORD_URL</code> 환경 변수로 주입받아 사용한다. 이는 웹훅 URL과 같은 민감한 정보가 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에 직접 노출되는 것을 방지하여 보안을 강화하는 역할이다.</li>
</ul>

<h4 id="향후-목표">향후 목표</h4>

<p>Jenkins 의 빌드 과정에 대한 report 를 포함, 빌드 과정에서 문제가 발생하지 않고, 하더라도 빠른 대응이 되기 위해 메시지를 단순히 discord로 보내는 것만으로는 한계가 있다. 이에 전문적인 로깅 툴을 연결, 그 툴에 메시지를 보내는 기능을 단계별로 넣어서, 수행하는 작업이나, 향후 들어갈 테스트 등의 항목의 결과들을 공유하도록 수정해볼 생각이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - NextJS 무중단 배포 적용</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/23/til-jenkins.html" rel="alternate" type="text/html" title="TIL - NextJS 무중단 배포 적용" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/23/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/23/til-jenkins.html"><![CDATA[<h2 id="25-10-23-jenkins-무중단-배포-적용">25-10-23 Jenkins 무중단 배포 적용</h2>

<h3 id="1-오늘의-목표">1. 오늘의 목표</h3>

<p>기존에 수동으로 배포되던 Next.js 애플리케이션(<code class="language-plaintext highlighter-rouge">project-mini-frontend</code>)을 위해, 독립적으로 운영되는 Jenkins 서버를 활용하여 GitHub <code class="language-plaintext highlighter-rouge">main</code> 브랜치 변경 시 자동으로 빌드, GHCR 푸시, 타겟 서버 SSH 접속 및 Blue/Green 무중단 배포를 수행하는 CI/CD 파이프라인을 완성하는 것이 목표였다.</p>

<hr />
<h3 id="jenkins-무중단-배포-파이프라인-구축-절차">Jenkins 무중단 배포 파이프라인 구축 절차</h3>
<p><strong>1단계: 젠킨스 환경 최종 준비 (도구 챙기기)</strong></p>
<ul>
  <li><strong>목표:</strong> 젠킨스 컨테이너가 배포에 필요한 ‘도구’(<code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">git</code>, <code class="language-plaintext highlighter-rouge">docker</code>)를 모두 갖추고, ‘비밀번호’(<code class="language-plaintext highlighter-rouge">Credentials</code>)를 발급받도록 합니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">jenkins/Dockerfile</code>에 <code class="language-plaintext highlighter-rouge">openssh-client</code> 설치 코드 추가 및 젠킨스 재시작
        <ul>
          <li>설치: <code class="language-plaintext highlighter-rouge">RUN apt-get update &amp;&amp; apt-get install -y openssh-client</code></li>
          <li>빌드 및 실행(터미널에서) : <code class="language-plaintext highlighter-rouge">docker exec jenkins-server ssh</code> &gt; 입력 시 ssh 정상 설치 되면 매뉴얼이 뜸</li>
        </ul>
      </li>
      <li>젠킨스 Credential 등록 (GitHub PAT, GHCR PAT)
        <ul>
          <li><strong>1. GitHub 리포지토리 접근용 (Git Checkout)</strong>
            <ul>
              <li><strong>Kind:</strong> <code class="language-plaintext highlighter-rouge">Username with password</code></li>
              <li><strong>Username:</strong> (본인의 GitHub ID)</li>
              <li><strong>Password:</strong> (GitHub PAT - <code class="language-plaintext highlighter-rouge">repo</code> 스코프 권한 필요)</li>
              <li><strong>ID:</strong> <code class="language-plaintext highlighter-rouge">github-creds</code> (또는 식별 가능한 이름)</li>
            </ul>
          </li>
          <li><strong>2. GHCR 이미지 푸시용 (Docker Push)</strong>
            <ul>
              <li><strong>Kind:</strong> <code class="language-plaintext highlighter-rouge">Username with password</code></li>
              <li><strong>Username:</strong> (본인의 GitHub ID)</li>
              <li><strong>Password:</strong> (GitHub PAT - <code class="language-plaintext highlighter-rouge">write:packages</code> 스코프 권한 필요)</li>
              <li><strong>ID:</strong> <code class="language-plaintext highlighter-rouge">ghcr-creds</code> (또는 식별 가능한 이름)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>호스트 서버 <code class="language-plaintext highlighter-rouge">sshd</code> 서비스 실행 상태 최종 확인</li>
    </ol>
  </li>
</ul>

<p><strong>2단계: <code class="language-plaintext highlighter-rouge">project-mini-frontend</code> 리포지토리 설정 (명령서 작성)</strong></p>
<ul>
  <li><strong>목표:</strong> Next.js 리포지토리에 젠킨스가 수행할 모든 작업을 정의한 ‘명령서’(<code class="language-plaintext highlighter-rouge">Jenkinsfile</code>)를 추가하고, GitHub가 젠킨스를 호출할 ‘연락망’(Webhook)을 설정합니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Jenkinsfile</code> (파이프라인 스크립트) 신규 작성</li>
      <li>GitHub 리포지토리 Webhook 설정 (젠킨스 URL 연동)</li>
    </ol>
  </li>
  <li><strong>작업하면서 궁금했던 사항 정리</strong>
    <ul>
      <li>env 변수에 쓸수  있는 유용한 내장 환경 변수들
        <ul>
          <li><code class="language-plaintext highlighter-rouge">env.BUILD_NUMBER</code>: 현재 빌드의 순차 번호 (예: “57”)</li>
          <li><code class="language-plaintext highlighter-rouge">env.JOB_NAME</code>: 현재 실행 중인 젠킨스 잡(Job)의 이름</li>
          <li><code class="language-plaintext highlighter-rouge">env.BUILD_URL</code>: 현재 빌드 로그를 볼 수 있는 젠킨스의 URL (실패 알림에 필수)</li>
          <li><code class="language-plaintext highlighter-rouge">env.BRANCH_NAME</code>: 빌드를 트리거한 브랜치 이름 (예: “main”)</li>
          <li><code class="language-plaintext highlighter-rouge">env.GIT_COMMIT</code>: 빌드에 사용된 Git 커밋 해시(ID)</li>
          <li><code class="language-plaintext highlighter-rouge">env.WORKSPACE</code>: 젠킨스 에이전트가 코드를 Checkout 받은 경로</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ssh -o StrictHostKeyChecking=no</code> 란?
        <ul>
          <li>SSH 접속시 일반적으로 설정하는 것 질문 절차가 있는데, 젠킨스는 여기서 yes 라고 입력 안됨. 파이프라인 멈춤게 됨. 이에 그 질문을 강제로 무시하고, 무조건 신뢰하여 자동화 시키는 역할을 함.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>3단계: 젠킨스 파이프라인(Job) 생성 (프로젝트 연결)</strong></p>
<ul>
  <li><strong>목표:</strong> 젠킨스 UI에서 “이 GitHub 리포지토리의 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 읽어서 실행해”라고 설정하는 새 작업을 만듭니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li>젠킨스 대시보드에서 “New Item” &gt; “Pipeline” 생성</li>
      <li>“Pipeline script from SCM” 옵션으로 GitHub 리포지토리 및 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 경로 연결</li>
    </ol>
  </li>
  <li>Jenkins Credential 등록 (GitHub PAT <code class="language-plaintext highlighter-rouge">github-creds</code>, GHCR PAT <code class="language-plaintext highlighter-rouge">ghcr-creds</code>, SSH Private Key <code class="language-plaintext highlighter-rouge">a5-localhost-jenkins</code>).</li>
  <li><strong>Blue/Green 전환 로직 (<code class="language-plaintext highlighter-rouge">Deploy to Server</code> SSH 스크립트):</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">set -ex</code>: 명령어 추적 및 오류 시 즉시 종료 설정.</li>
      <li><code class="language-plaintext highlighter-rouge">docker login ghcr.io ...</code>: 타겟 서버에서 GHCR 로그인.</li>
      <li><code class="language-plaintext highlighter-rouge">docker pull [imageTag]</code>: 새 이미지 다운로드.</li>
      <li><code class="language-plaintext highlighter-rouge">cd [TARGET_PROJECT_PATH]</code>: 프로젝트 폴더 이동.</li>
      <li><code class="language-plaintext highlighter-rouge">docker compose --env-file .env.[deployService] up -d --no-deps --force-recreate [deployService]</code>: 임시 <code class="language-plaintext highlighter-rouge">.env</code> 파일을 사용하여 대기조 컨테이너 강제 재생성.</li>
      <li><code class="language-plaintext highlighter-rouge">sed -i "s|...|..." [nginx.conf 경로]</code>: Nginx 설정 파일의 <code class="language-plaintext highlighter-rouge">upstream</code> 변경.</li>
      <li><code class="language-plaintext highlighter-rouge">docker compose --env-file init.env exec -T nginx nginx -s reload</code>: Nginx 리로드 (기본 <code class="language-plaintext highlighter-rouge">init.env</code> 참조).</li>
      <li><code class="language-plaintext highlighter-rouge">docker logout ghcr.io</code>: 타겟 서버 로그아웃.</li>
    </ol>
  </li>
</ul>

<p><strong>4단계: 최초 빌드 실행 및 트러블슈팅</strong></p>
<ul>
  <li><strong>목표:</strong> <code class="language-plaintext highlighter-rouge">main</code> 브랜치에 코드를 푸시(Push)하여 1~3단계의 모든 설정이 올바르게 작동하는지 확인하고, 첫 배포를 성공시킵니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에 푸시하여 Webhook 트리거 실행 (또는 “Build Now” 수동 클릭)</li>
      <li>젠킨스 “Blue Ocean” UI에서 빌드 과정 실시간 모니터링</li>
      <li>오류 발생 시(예: 권한 문제, 경로 오류) 로그 확인 및 수정</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="진행-시-메모">진행 시 메모</h3>

<h4 id="jenkins-서버-쪽-작업">Jenkins 서버 쪽 작업</h4>
<ul>
  <li>jenkins 서버 내에서가 아닌 host 서버에서 build 해야 함
    <ul>
      <li>Jenkins 의 Dockerfile에 이를 위한 패키지를 추가했다.</li>
      <li>컨트롤을 할 클라이언트, Docker 를 호스트에서 수행하도록 만들어야 했다. : DooD 가 필요했고, 이를 위한 내용을 Jenkins 의 Dockerfile 에 기록했다.
        <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">services</span><span class="pi">:</span>
<span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">context</span><span class="pi">:</span> <span class="s">jenkins</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">jenkins-server</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">12345:8080"</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./jenkins_home:/var/jenkins_home</span>
    <span class="c1"># Docker CLI 사용을 위해 호스트로 마운트</span>
    <span class="pi">-</span> <span class="s">/var/run/docker.sock:/var/run/docker.sock</span>
    <span class="pi">-</span> <span class="s">/usr/bin/docker:/usr/bin/docker</span>
    <span class="pi">-</span> <span class="s">/usr/bin/docker-compose:/usr/bin/docker-compose</span>
  <span class="c1"># user: root</span>
  <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">CASC_JENKINS_CONFIG=/var/jenkins_home/casc.yaml</span>
  <span class="na">entrypoint</span><span class="pi">:</span> <span class="pi">&gt;</span>
    <span class="s">bash -c "</span>
      <span class="s">cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;</span>
      <span class="s">/usr/bin/tini -- /usr/local/bin/jenkins.sh</span>
    <span class="s">"</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>이때 가장 편한 방법은 <code class="language-plaintext highlighter-rouge">DooD</code> 시 Jenkins 컨테이너 내부 User를 <code class="language-plaintext highlighter-rouge">Root</code> 로 설정해야 바로 젠킨스 서버 컨테이너가, Host 서버의 Docker 를 수정할 수 있음
    <ul>
      <li>이는 보안의 위협이 됨. 이에 UID 와 GID 를 수정해줌으로써 권한 문제 없이 호스트를 제어 하도록 만들어 주었다.
        <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># 전략</span>
  <span class="c"># DooD 구조를 위함. Docker 그룹에 jenkins 유저 추가</span>
  ARG DOCKER_GID=1001
  RUN groupadd -g ${DOCKER_GID} docker
  RUN usermod -aG docker jenkins
  <span class="c"># 후략</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="nextjs-서버">NextJS 서버</h4>
<ul>
  <li>NextJS 이미지를 app-blue, app-green 으로 스위칭 되며 동작하게 만드는게 핵심이었고, docker-compose.yml 이를 위한 변수를 읽기 위해 <code class="language-plaintext highlighter-rouge">init.env</code> 파일을 설정하였다.</li>
  <li>Jenkinsfile 의 경우 <code class="language-plaintext highlighter-rouge">environment</code>, <code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">post</code> 로 간단한 구조다. 이때 핵심은 환경은 변수와 전역으로 필요한 것들만 지정해주었다.
    <ul>
      <li>stages 에는 각 스테이지들이 설정되고 스테이지들에서 유의사항은 다음과 같다.
        <ul>
          <li>Jenkins 는 workspace 라는 공간에서 설정에 따라 github을 설정하면 자동으로 바라보는 브랜치의 최신 상태를 다운로드 받는다.</li>
          <li>그리고 그 상단을 기준으로 하면, 이미 파일은 올라가있기 때문에 <code class="language-plaintext highlighter-rouge">Build Image</code> 스테이지에서는 빌드를 빠르게 가능하다.</li>
          <li>Stages는 아래와 같은 단계를 소유한다
            <ul>
              <li>Checkout</li>
              <li>Build Image</li>
              <li>Push to GHCR</li>
              <li>Deploy to GHCR</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>post 는 사후 단계로 향후에는 여러 로깅이나, 이런 것들이 가능하나, 현재는 웹 훅을 통한 알림을 추가했다. 
<img src="/assets/images/posts/2025-10/2025-10-23-052.png" alt="" />
        <blockquote>
          <p>알림은 아주 잘 온다. 향후엔 디테일하게 붙이는 방법이나, 모듈화를 고민해보자..</p>
        </blockquote>
      </li>
      <li>참고로 logging은 깔끔하게 보기 위하여 <code class="language-plaintext highlighter-rouge">블루오션</code> 플러그인을 활용했다
<img src="/assets/images/posts/2025-10/2025-10-23-053.png" alt="" />
        <blockquote>
          <p>처음엔 어떻게 쓰는지 몰라서 한참 기본 로그만 봤다…</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="주요-트러블슈팅-및-해결-과정-파이프라인-실행-중">주요 트러블슈팅 및 해결 과정 (파이프라인 실행 중)</h3>

<ol>
  <li><strong>Jenkinsfile 문법 오류 (<code class="language-plaintext highlighter-rouge">MultipleCompilationErrorsException</code>):</strong>
    <ul>
      <li><strong>원인:</strong> <code class="language-plaintext highlighter-rouge">stages</code> 블록 누락, <code class="language-plaintext highlighter-rouge">post</code> 블록 내 <code class="language-plaintext highlighter-rouge">script</code> 누락.</li>
      <li><strong>해결:</strong> 파이프라인 구조 수정.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sshagent</code> DSL 찾기 실패 (<code class="language-plaintext highlighter-rouge">NoSuchMethodError</code>):</strong>
    <ul>
      <li><strong>원인:</strong> “SSH Agent” 플러그인 미설치.</li>
      <li><strong>해결:</strong> 젠킨스 플러그인 관리자에서 설치.</li>
    </ul>
  </li>
  <li><strong>GHCR 푸시 실패 (<code class="language-plaintext highlighter-rouge">denied</code>, <code class="language-plaintext highlighter-rouge">insufficient_scope</code>):</strong>
    <ul>
      <li><strong>원인:</strong> 젠킨스 Credential의 PAT 정보 오류 또는 스코프 부족(<code class="language-plaintext highlighter-rouge">repo</code> 누락), <code class="language-plaintext highlighter-rouge">docker build</code> 시 이미지 태그 주소 누락 등 복합적 요인.</li>
      <li><strong>해결:</strong> Credential 재확인 했으나 문제 없었음. 핵심은 보안에 취약하다며 AI 가 추천한 방식으로 수정했을 때 문제 발생. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">docker login</code> 방식 수정 (<code class="language-plaintext highlighter-rouge">echo | docker login --password-stdin</code>) 원래 형태로 수정하여 파이프를 통해 credential 전달로 해결 완료.</li>
    </ul>
  </li>
  <li><strong>타겟 서버 <code class="language-plaintext highlighter-rouge">docker pull</code> 실패 (<code class="language-plaintext highlighter-rouge">unauthorized</code>):</strong>
    <ul>
      <li><strong>원인:</strong> SSH로 접속한 타겟 서버(<code class="language-plaintext highlighter-rouge">hansol</code> 유저)가 GHCR에 로그인되어 있지 않음.</li>
      <li><strong>해결:</strong> <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 스테이지 SSH 스크립트 내부에 <code class="language-plaintext highlighter-rouge">docker login ghcr.io ...</code> 명령어 추가. 너무 기본적인 거였는데… 호스트에선 보안, 그리고 클리어한 상태 유지를 위해 로직 내부에 login / logout 을 넣어줬어야 했다.</li>
    </ul>
  </li>
  <li><strong>Blue/Green 컨테이너 미교체 (<code class="language-plaintext highlighter-rouge">up-to-date</code>):</strong>
    <ul>
      <li><strong>원인:</strong> <code class="language-plaintext highlighter-rouge">docker compose up</code> 실행 시 <code class="language-plaintext highlighter-rouge">--env-file</code>로 전달된 새 이미지 태그를 인식하지 못하는 건지, 아니면 레이어가 바뀌지 않는 건지 동작하지 않았다.</li>
      <li><strong>해결:</strong> <code class="language-plaintext highlighter-rouge">docker compose up</code> 명령어에 <code class="language-plaintext highlighter-rouge">--force-recreate</code> 플래그 추가하여 무조건 교체가 되도록 하였음. 그리고 정확한 타게팅을 위해, 환경 변수가 필요했고 이에 <code class="language-plaintext highlighter-rouge">docker compose exec</code> 명령어에 <code class="language-plaintext highlighter-rouge">--env-file init.env</code> 옵션 추가로 환경변수를 명시해줌으로써 완전히 해결되었다.</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="배운-점-key-learnings">배운 점 (Key Learnings)</h3>

<ul>
  <li>젠킨스 파이프라인 문법 및 구조 (<code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">environment</code>, <code class="language-plaintext highlighter-rouge">Credentials</code>, <code class="language-plaintext highlighter-rouge">post</code>)를 제대로 공부했다. 아직 외운게 아니고 AI 를 통해 맡겨서 하면서, 뭔지 파악한 거라 향후엔 제대로 문서를 보든 해야 할 것 같다.</li>
  <li>SSH 기반 원격 서버 자동화 시 <code class="language-plaintext highlighter-rouge">sshagent</code>와 <code class="language-plaintext highlighter-rouge">StrictHostKeyChecking=no</code> 옵션, 명령어 실패 처리(<code class="language-plaintext highlighter-rouge">set -ex</code>)의 중요성.. 이라고 하지만 실상 필요한거면 당연히 안 들어있다고 생각했어야 한다. 🤣</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose</code> 명령어 실행 시 환경 변수 처리 방식 (<code class="language-plaintext highlighter-rouge">--env-file</code>, 기본 <code class="language-plaintext highlighter-rouge">.env</code>) 및 <code class="language-plaintext highlighter-rouge">--force-recreate</code> 플래그의 유용성.. 이라고 AI 가 정리해줬지만, 실질 이제는 –force-recreate 가 필요 없을지도..?</li>
  <li>Blue/Green 배포 시 <code class="language-plaintext highlighter-rouge">sed</code>를 이용한 Nginx <code class="language-plaintext highlighter-rouge">upstream</code> 동적 변경 및 <code class="language-plaintext highlighter-rouge">nginx -s reload</code>를 통한 무중단 트래픽 전환 방법은 되고 나니 너무 훌륭하고 짜릿하다…😍</li>
  <li>GHCR 인증 및 이미지 태그 지정 방식의 정확성 필요.</li>
  <li>CI/CD 파이프라인 구축 시 단계별 로그 확인(<code class="language-plaintext highlighter-rouge">docker logs</code>, <code class="language-plaintext highlighter-rouge">ssh -v</code>, Jenkins Console Output)을 통한 체계적인 트러블슈팅 방법. 아직 완벽하지도 않고, 보니 단계별로 명확한 로그가 남지 않는 다는 건 아쉽다. SSH 기반과 로그를 더 많이 기록하게 하는 방법이나 블루오션 플러그인 활용법 정리가 필요해 보인다.</li>
  <li>GitHub Webhook 연동을 위해서는 Jenkins 서버의 HTTPS 노출이 필요하며, 이는 <strong>향후 과제</strong>로 남겨두었다. 우선 프론트엔드 작업들 하면서 감 익히고 난 후엔 수행해볼 예정</li>
</ul>

<p><img src="/assets/images/posts/2025-10/2025-10-23-054.png" alt="" /></p>
<blockquote>
  <p>캬 … 먼저 배포부터 만들어버렸다… AI 덕이긴 한데 많이 늘었구나 나도…</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-23 Jenkins 무중단 배포 적용]]></summary></entry><entry><title type="html">TIL - Jenkins 서버 배포 및 무중단 배포 준비 프로세스</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/21/til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 서버 배포 및 무중단 배포 준비 프로세스" /><published>2025-10-21T00:00:00+00:00</published><updated>2025-10-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/21/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/21/til-jenkins.html"><![CDATA[<h2 id="2025년-10월-21일-젠킨스jenkins-서버-구축-및-무중단-배포-아키텍처-설계">2025년 10월 21일: 젠킨스(Jenkins) 서버 구축 및 무중단 배포 아키텍처 설계</h2>

<h3 id="1-오늘의-목표">1. 오늘의 목표</h3>

<p>‘실무형 CI/CD 파이프라인’ 구축의 첫 단계로, JCasC(Jenkins Configuration as Code)를 활용해 젠킨스 서버를 독립적으로 설치하고, SSH 기반의 Blue/Green 무중단 배포 아키텍처를 설계 및 확정했다.</p>

<h3 id="2-핵심-아키텍처-설계">2. 핵심 아키텍처 설계</h3>

<p>젠킨스 서버의 독립성과 이식성을 최우선으로 하며, 실제 상용 서비스의 빌드/배포 환경을 정확히 모사하는 것을 목표로 한다.</p>

<h4 id="1-핵심-원칙">1. 핵심 원칙</h4>

<ul>
  <li><strong>젠킨스 독립성 (이식성):</strong> <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code>라는 별도 리포지토리에서 <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">casc.yaml</code> 등으로 젠킨스 서버 자체를 코드화(Codefied)하여 관리한다. 이는 백업 및 재설정을 매우 용이하게 한다.</li>
  <li><strong>실무 환경 모사 (역할 분리):</strong>
    <ul>
      <li><strong>빌드 서버 (Jenkins):</strong> 젠킨스 컨테이너가 이 역할을 맡는다.</li>
      <li><strong>타겟 서버 (Host):</strong> 젠킨스가 설치된 호스트 머신(<code class="language-plaintext highlighter-rouge">localhost</code>)이 이 역할을 맡는다.</li>
    </ul>
  </li>
  <li><strong>배포 방식 (SSH):</strong> 빌드 서버는 <strong>DooD 방식을 사용하지 않고</strong>, 오직 <strong>SSH</strong>를 통해서만 타겟 서버에 접속하여 배포 명령(<code class="language-plaintext highlighter-rouge">docker pull</code>, <code class="language-plaintext highlighter-rouge">docker compose up</code>, <code class="language-plaintext highlighter-rouge">nginx reload</code> 등)을 전달한다.</li>
</ul>

<h4 id="2-자동화-프로세스">2. 자동화 프로세스</h4>

<ol>
  <li><strong>Trigger:</strong> GitHub <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 PR이 병합되면 Webhook을 통해 젠킨스가 이를 감지한다.</li>
  <li><strong>Build:</strong> 젠킨스가 <code class="language-plaintext highlighter-rouge">project-mini-frontend</code>의 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 사용해 새 이미지를 클린 빌드한다.</li>
  <li><strong>Push:</strong> 젠킨스가 빌드된 이미지를 **GHCR(GitHub Container Registry)**로 푸시한다.</li>
  <li><strong>Deploy (via SSH):</strong> 젠킨스가 Credential에 등록된 SSH 키를 사용해 타겟 서버(<code class="language-plaintext highlighter-rouge">localhost</code>)에 접속한다.</li>
  <li><strong>Target Server Actions:</strong> SSH 세션 내에서 다음의 셸 스크립트가 순차적으로 실행된다:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (예시) 젠킨스가 SSH를 통해 실행할 명령어들</span>
docker pull ghcr.io/hansol/project-mini-frontend:build-123
docker compose up <span class="nt">-d</span> <span class="nt">--no-deps</span> app-green
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/server app-blue:3000;/server app-green:3000;/'</span> /path/to/nginx.conf
docker compose <span class="nb">exec </span>nginx nginx <span class="nt">-s</span> reload
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="3-이미지-및-롤백-전략">3. 이미지 및 롤백 전략</h4>

<ul>
  <li><strong>이미지 명명:</strong> 젠킨스가 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code> (빌드 번호), <code class="language-plaintext highlighter-rouge">GIT_COMMIT</code> (커밋 해시) 등 강력한 메타데이터를 이미 관리하므로, 이미지 태그는 <code class="language-plaintext highlighter-rouge">ghcr.io/hansol/repo:${env.BUILD_NUMBER}</code>처럼 젠킨스의 <strong>빌드 번호</strong>를 사용하는 것이 가장 효율적이다.</li>
  <li><strong>롤백 전략:</strong> <code class="language-plaintext highlighter-rouge">docker image</code>를 이용한 롤백이 아닌, Git에서 <code class="language-plaintext highlighter-rouge">revert</code> 커밋을 푸시하여 새로운 파이프라인을 트리거하는 <strong>‘Roll-Forward’</strong> 방식을 채택한다. 이는 배포의 유일한 진입점을 CI/CD 파이프라인으로 통일시켜 안정성을 높인다.</li>
</ul>

<hr />

<h3 id="3-젠킨스-서버-설치-과정">3. 젠킨스 서버 설치 과정</h3>

<p>독립된 <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트를 통해 젠킨스 서버를 컨테이너로 실행했다.</p>

<h4 id="1-jcasc-템플릿-구성">1. JCasC 템플릿 구성</h4>

<p><code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 폴더를 다음과 같이 구성하여 젠킨스 서버 자체를 코드로 관리했다.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">docker-compose.yml</code> (서비스 정의)</strong></p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">jenkins</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">jenkins</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">jenkins-server</span>
    <span class="na">ports</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">12345:8080"</span><span class="pi">]</span> <span class="c1"># 8080 대신 12345 포트 사용</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./jenkins_home:/var/jenkins_home</span> <span class="c1"># Bind Mount</span>
    <span class="na">entrypoint</span><span class="pi">:</span> <span class="pi">&gt;</span> <span class="c1"># casc.yaml을 jenkins_home으로 복사</span>
      <span class="s">bash -c "</span>
        <span class="s">cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;</span>
        <span class="s">/usr/bin/tini -- /usr/local/bin/jenkins.sh</span>
      <span class="s">"</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">jenkins_home</span><span class="pi">:</span> <span class="pi">{}</span> <span class="c1"># Bind Mount를 사용하기로 했으므로 이 부분은 삭제됨</span>
</code></pre></div>    </div>

    <p><em>최종적으로 <code class="language-plaintext highlighter-rouge">volumes: [jenkins_home: {}]</code>는 삭제하고, <code class="language-plaintext highlighter-rouge">volumes: [./jenkins_home:/var/jenkins_home]</code>로 수정하여 Bind Mount를 사용하기로 결정했다.</em></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">jenkins/Dockerfile</code> (커스텀 이미지)</strong></p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> jenkins/jenkins:lts-jdk21</span>
<span class="k">USER</span><span class="s"> root</span>
<span class="k">COPY</span><span class="s"> plugins.txt /usr/share/jenkins/ref/plugins.txt</span>
<span class="k">RUN </span>jenkins-plugin-cli <span class="nt">--plugin-file</span> /usr/share/jenkins/ref/plugins.txt
<span class="k">COPY</span><span class="s"> casc.yaml /usr/share/jenkins/ref/casc.yaml</span>
<span class="k">USER</span><span class="s"> jenkins</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">jenkins/plugins.txt</code> (플러그인 목록)</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>configuration-as-code
git
workflow-aggregator
blueocean
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code> (젠킨스 설정)</strong></p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">systemMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Welcome</span><span class="nv"> </span><span class="s">to</span><span class="nv"> </span><span class="s">My</span><span class="nv"> </span><span class="s">Jenkins</span><span class="nv"> </span><span class="s">Server!</span><span class="nv"> </span><span class="s">This</span><span class="nv"> </span><span class="s">instance</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">managed</span><span class="nv"> </span><span class="s">by</span><span class="nv"> </span><span class="s">Code.</span><span class="nv"> </span><span class="s">🚀"</span>
  <span class="na">numExecutors</span><span class="pi">:</span> <span class="m">2</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-bind-mount와-uid-1000-권한-분석">2. Bind Mount와 UID 1000 권한 분석</h4>

<p><code class="language-plaintext highlighter-rouge">Dockerfile</code>로 빌드된 젠킨스 컨테이너는 보안을 위해 <code class="language-plaintext highlighter-rouge">root</code>가 아닌 UID <code class="language-plaintext highlighter-rouge">1000</code>번(<code class="language-plaintext highlighter-rouge">jenkins</code> 유저)으로 실행된다. <code class="language-plaintext highlighter-rouge">volumes: [./jenkins_home:/var/jenkins_home]</code> (Bind Mount) 사용 시, 호스트 폴더의 소유자 UID와 컨테이너 유저의 UID가 다르면 ‘Permission denied’ 오류가 발생한다.</p>

<ul>
  <li><strong>일반적인 해결책:</strong> 호스트에서 <code class="language-plaintext highlighter-rouge">sudo chown -R 1000:1000 jenkins_home</code> 명령어로 소유권을 강제로 맞춰야 한다.</li>
  <li><strong>나의 상황 (오늘의 발견):</strong> 내 호스트 서버(Ubuntu 22.04)의 <code class="language-plaintext highlighter-rouge">hansol</code> 계정 ID를 확인해보니, 젠킨스 컨테이너와 동일한 <code class="language-plaintext highlighter-rouge">1000</code>번이었다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">id </span>hansol
<span class="c"># uid=1000(hansol) gid=1000(hansol) groups=1000(hansol)...</span>
</code></pre></div>    </div>
  </li>
  <li><strong>결론:</strong> 나의 <code class="language-plaintext highlighter-rouge">hansol</code> 계정은 우분투 설치 시 생성된 첫 번째 표준 계정 ID(<code class="language-plaintext highlighter-rouge">1000</code>)를 사용하고 있어, 젠킨스 컨테이너의 UID(<code class="language-plaintext highlighter-rouge">1000</code>)와 완벽하게 일치한다. 이로 인해 나는 ‘Permission denied’ 문제가 원천적으로 발생하지 않는 이상적인 상태이며, 별도의 <code class="language-plaintext highlighter-rouge">chown</code> 명령어가 필요 없음을 확인했다.</li>
</ul>

<h4 id="3-젠킨스-실행-및-설정-마법사">3. 젠킨스 실행 및 설정 마법사</h4>

<ol>
  <li>프로젝트 폴더에 <code class="language-plaintext highlighter-rouge">jenkins_home</code> 디렉터리를 생성했다. (나의 경우 <code class="language-plaintext highlighter-rouge">chown</code>은 불필요했다.)
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>jenkins_home
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker compose up --build -d</code> 명령어로 젠킨스 빌드 및 실행.</li>
  <li><code class="language-plaintext highlighter-rouge">docker logs jenkins-server</code>로 초기 관리자 비밀번호 확인.</li>
  <li><code class="language-plaintext highlighter-rouge">http://paulryu9309.ddns.net:12345</code> (서버 IP와 변경된 포트)로 접속하여 설정 마법사(플러그인 설치, 관리자 계정 생성)를 완료했다.</li>
  <li>젠킨스 대시보드에서 <code class="language-plaintext highlighter-rouge">casc.yaml</code>에 정의한 “Welcome to My Jenkins Server!…” 환영 메시지를 확인하며 JCasC 적용을 최종 검증했다.</li>
</ol>

<h4 id="4-ssh-credential-등록-핵심-준비">4. SSH Credential 등록 (핵심 준비)</h4>

<p>젠킨스가 타겟 서버(<code class="language-plaintext highlighter-rouge">localhost</code>)에 접속할 수 있도록 <code class="language-plaintext highlighter-rouge">ssh-keygen</code>을 통해 젠킨스 전용 키 페어(<code class="language-plaintext highlighter-rouge">jenkins_key</code>, <code class="language-plaintext highlighter-rouge">jenkins_key.pub</code>)를 생성했다.</p>

<ol>
  <li><strong>서버(호스트)에 ‘자물쇠’ 설치:</strong> 생성한 공개키(<code class="language-plaintext highlighter-rouge">jenkins_key.pub</code>)의 내용을 <code class="language-plaintext highlighter-rouge">cat</code>을 이용해 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 파일에 추가했다.</li>
  <li><strong>젠킨스에 ‘열쇠’ 등록:</strong> 젠킨스 UI의 [Manage Jenkins] &gt; [Credentials]에서 <code class="language-plaintext highlighter-rouge">Kind</code>를 <code class="language-plaintext highlighter-rouge">SSH Username with Private Key</code>로 선택하고, <code class="language-plaintext highlighter-rouge">Username</code>에 <code class="language-plaintext highlighter-rouge">hansol</code>, <code class="language-plaintext highlighter-rouge">Private Key</code>에 개인키(<code class="language-plaintext highlighter-rouge">jenkins_key</code>)의 내용을 복사하여 글로벌 Credential을 성공적으로 등록했다.</li>
</ol>

<p><img src="/assets/images/posts/2025-10/2025-10-21-051.png" alt="" /></p>
<blockquote>
  <p>WSL 만 아니었으면 무중단까지 간건데… 아쉽다…</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 21일: 젠킨스(Jenkins) 서버 구축 및 무중단 배포 아키텍처 설계]]></summary></entry></feed>