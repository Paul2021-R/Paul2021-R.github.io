<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-05-17T13:51:32+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">브라우저의 진화, 플랫폼의 지각변동이 올까?</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/11/Agentic-browser-fellou.html" rel="alternate" type="text/html" title="브라우저의 진화, 플랫폼의 지각변동이 올까?" /><published>2025-05-11T00:00:00+00:00</published><updated>2025-05-11T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/11/Agentic-browser-fellou</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/11/Agentic-browser-fellou.html"><![CDATA[<h2 id="브라우저의-진화-fellou-의-등장">브라우저의 진화, Fellou 의 등장</h2>

<p><code class="language-plaintext highlighter-rouge">Fellou 브라우저 이미지 01</code></p>

<p>웹 브라우저는 오랫동안 인터넷의 게이트웨이(gateway) 역할을 해. 사용자는 검색하고, 스크롤하고, 클릭하면서 필요한 정보를 얻는 수동적인 경험에 익숙해져 있다.</p>

<p>그러나 AI 기술의 급진전으로 이제 브라우저 자체가 능동적인 조력자로 진화하는 변곡점에 와있다. 브라우저 자체가 능동적인 조력자로 진화하는 변곡점이, 이번에 등장한 Fellou 라는 AI 브라우저 이다. 그리고 이 브라우저의 등장은 변화의 시작이자, 그 가능성을 제대로 보여주려고 하고 있다. ‘사용자를 대신해 생각하고 행동하는’ 이라는 새로운 패러다임은, 과연 AI 가 인간의 어느 영역까지 침투할 수 있는지를 시험해 볼 수 있는 아주 좋은 대목이리라 생각된다.</p>

<p>본 내용은 AI 를 기반으로 Fellou 브라우저가 공개한 기술적 구조, 그리고 핵심 기능들을 살펴보며, 기존 브라우저와의 차이점, 플랫폼의 관점에서 어떤 의미를 가지며, 향후에 대한 나의 소해를 적어보려고 한다.</p>

<h2 id="fellou-브라우저의-해체">Fellou 브라우저의 해체</h2>

<p>Fellou 는 지능형 에이전트, 혹은 에이전틱 구조를 접목시킨 브라우저이자, 워크플로우 자동화라는 기능을 유기적으로 결합한 꽤나 혁신적인, ‘세계 최초 Agentic 브라우저’로 본인들을 소개 한다. 별도의 확장이나 플러그인 없이 브라우저 자체에 AI 기능이 내장되고, 시스템과 통합되어 사용자의 자연어로 의도만 표현되면 브라우저가 기존의 ‘뷰’만을 수행하던 브라우저와는 그 궤를 달리 하는 정보의 편집과 재구성을 해준다는 의미를 가지고 있다. Fellou 의 핵심 기술과 기능은 크게 3가지로 요약된다.</p>

<ol>
  <li>Deep Action Search : Fellou 의 자체적인 심화 검색 기능으로, 키워드 검색을 넘어 2,500개 이상의 데이터 포인트를 한꺼번에 파고들어 지능적인 해답을 찾아낸다. 이는 전통적인 검색보다 한층 깊이 있고, OpenAI 의 고급 검색도구인 DeepResearch 보다 뛰어난 성능을 보인다고 한다. 구글이 LLM 의 등장, Apple의 AI 관련 된 노선 변경도, 사실 검색이라는 기능과 LLM 의 시너지가 어떤지에 좌지우지 되었던 걸 생각하면, 거기서 더 진일보한 ‘다중 차원’, ‘의도를 포함한’ 통합적 검색이 가능해지고, 이는 한 마디로 정의 한다면 ‘의도를 읽은 검색’에 한 차원 더 깊게 들어간다는 점을 의미한다.</li>
  <li>Deep Action Workflow : 내장된 AI들을 활용하여 ‘자연어’를 해석하고, 이를 통해 자동화 워크플로우를 수행해주는 기능이다. 이는 MCP 를 통해 AI가 ‘실행’을 할 수 있게 된 것처럼, 검색할 내용, 뭔가 원하는 것을 행동해주길 원할 때, 그 행동을 해석하고 스스로 수행한다. 
‘최근 3개의 이메일을 확인하고 업무 관련 메일엔 ‘확인했습니다. 조치하겠습니다’ 라고 보내고, 이를 리스트업 해줘’</li>
  <li>Proactive Intelligence :</li>
</ol>

<h2 id="참고-문헌">참고 문헌</h2>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[Fellou: The Agentic AI Browser That Browses for You by Avinash A</td>
          <td>May, 2025</td>
          <td>Medium](https://medium.com/@avinash2060/fellou-the-agentic-ai-browser-that-browses-for-you-a13f7de07e5f)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><a href="https://aiagent.marktechpost.com/post/meet-fellou-an-agentic-ai-browser-that-can-think-and-act-for-you">Meet Fellou: An Agentic AI Browser That Can Think and Act for You</a></li>
  <li><a href="https://www.linkedin.com/posts/amaeteumanah_i-need-this-injected-into-every-soul-crushing-activity-7326546507199893504-gYeB/">I need this injected into every soul-crushing workflow I’ve ever endured.… - Amaete</a></li>
  <li><a href="https://www.npr.org/2024/11/20/g-s1-35111/after-a-court-win-the-justice-department-is-trying-to-make-google-sell-its-chrome-browser">The Justice Department is trying to make Google sell off its Chrome browser : NPR</a></li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><summary type="html"><![CDATA[브라우저의 진화, Fellou 의 등장]]></summary></entry><entry><title type="html">docker는 흔들리고 있을까?</title><link href="http://localhost:4000/backend/2025/05/06/alternative-for-docker.html" rel="alternate" type="text/html" title="docker는 흔들리고 있을까?" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/06/alternative-for-docker</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/06/alternative-for-docker.html"><![CDATA[<h2 id="도커-왕좌를-지키지-못하는-이유-컨테이너-생태계의-지각변동">도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동</h2>

<p><img src="/assets/images/posts/2025-05/docker-wallpaper.jpeg" alt="" /></p>

<p>수년간 <strong>컨테이너 생태계의 중심에는 도커가 있었다</strong>. 사실 도커는 ‘대명사’가 되긴 했지만 원래 그 기술의 근간은 ‘컨테이너’라는 기술이다.</p>

<p>리눅스 기반 OS 에서 제공하는 기술로 <strong>컨테이너</strong>는 시스템의 나머지 부분으로부터 격리된 하나 이상의 프로세스 집합을 의미한다.</p>

<p>이러한 프로세스를 실행하는 데 필요한 모든 파일과 필수 라이브러리, 종속성이 개별 이미지 내에 함께 패키징된다. 한 마디로 정리하면, Host 에 해당하는 영역에서 공통적인 걸 가져오고, 실제 독립적인 시스템 구현을 위해 필요한 부분은 ‘레이어’ 라는 이름으로 별도로 이미지 내부에 장착시켜서 호스트와는 별개의 시스템이 마치 구동되는 듯 보이게 만들어준다.</p>

<p>컨테이너는 가상 머신과 달리 <strong>가상 머신보다 적은 리소스를 사용</strong>하면서도 애플리케이션 격리를 유지할 수 있다. 또한, 표준 인터페이스를 갖추고 있어 대규모 애플리케이션(여러 컨테이너)의 일부로 더 쉽게 관리될 수 있으며, 여러 클라우드에 걸쳐 오케스트레이션될 수 있다. 궁극적으로 컨테이너는 <strong>애플리케이션 개발, 배포, 관리 방식에서 이식성과 일관성을 유지시키며 발전</strong>시킨 기술이라고 볼 수 있다. 그리고 이러한 컨테이너를 활용하여 시스테메틱한 관리체계를 정립한 도커는 컨테이너의 대명사처럼 여겨졌다.</p>

<p>하지만 이제는 도커만의 독주 무대가 아니게 되어감을 종종 느끼게 된다. 도커는 여전히 인기가 있지만, 점점 더 많은 기업과 개발자들이 다른 대안으로 눈을 돌리고 있다는 점은 고려해볼만한 논지가 아닐까 한다. 이는 도커가 선택지에서 제외되었다는 것이 아닌 성능, 보안, 유연성, 비용 등 주요 측면에서 도커가 뒤처지거나, 대안이 있다 혹은 대안을 찾아야 한다는 인식이 확산되고 있는 것이다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0001.png" alt="" /></p>

<h3 id="도커가-가지는-현안들">도커가 가지는 현안들</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0002.png" alt="" /></p>

<ol>
  <li>
    <p><strong>라이선스 및 비용 구조 변경</strong></p>

    <p>가장 중요한 전환점 중 하나는 <strong>도커 데스크톱의 라이선스와 비용 구조 변경</strong>이다. 도커는 일정 규모 이상의 조직에 유료 멤버십을 요구하기로 결정했으며, 이전까지 무료로 사용하던 도구에 대해 기업들이 갑자기 비용을 지불해야 하는 상황이 발생했다.</p>

    <p>이러한 부분은 비용에 민감한 팀들이 <strong>도커에 대한 의존도를 진지하게 재평가</strong>하도록 만들게 된다. 오픈 소스 도구로 전환하고자 하는 이들이 대안을 모색하는 계기가 되었다.</p>
  </li>
  <li>
    <p><strong>성능 문제</strong></p>

    <p>도커는 리눅스에서는 뛰어난 성능을 가집니다. 물론, 이는 컨테이너라는 기술 자체의 본질적으로 리눅스 시스템 구조와 밀접한 연관성을 갖고 있다.</p>

    <p>하지만 문제는 이러한 편리함을 윈도우나 Mac 에서 사용하고자 하면서 여러 이슈가 발생하게 된다. 도커는 기본적으로 Host로 사용할 영역을 각각 WSL2, HyperKit 을 활용하는데, 이를 기반으로 하는 도커 데스크톱은 리눅스 컨테이너를 에뮬레이트하기 위해 가상 머신을 사용하기 때문에, 이로 인한 불가피한 <strong>성능 저하, 과도한 메모리와 CPU 사용 등의 문제가 발생</strong>할 수 있다.</p>

    <p>고질적인 윈도우 WSL Vmmem 이슈, 파일 시스템의 비정상적인 느림, IO 성능 저하, CPU 오버헤드 문제 등등… 알려진 문제들, 불편함은 이미 충분히 지적되고 있고, 이에 대한 개선은 수년째 언급 되고 있는 실정이다.</p>

    <p>특히나 무거운 빌드나 복잡한 멀티 컨테이너 구성에서는 문제가 더욱 심각해진다. 수겹의 레이어를 만들어야 하고, 그걸 위한 이미지들은 기존보다 훨씬 많은 양의 가상화를 위한 리소스를 필요로 한다.</p>

    <p>반면, 핀치(Finch)에서 사용하는 리마(Lima) 같은 신기술은 맥 개발자를 위해 최적화된 가상화 환경을 제공하여 도커 데스크톱의 복잡성 없이 성능을 개선합니다. 맥 성능을 극대화하는 것이 대체 런타임을 고려하는 또 하나의 이유다.</p>
  </li>
  <li>
    <p><strong>보안 문제</strong></p>

    <p>도커의 아키텍처는 켜보면 바로 알 수 있는 특징이 있다. 내부의 구동에서 <strong>루트 권한으로 실행되는 데몬에 의존</strong>하고 있다는 점이다. 그러나 이러한 점이 바로 보안의 문제냐? 라고 하면 그렇지는 않다고 생각한다. 오히려 개발 친화적이고, Host 로의 입구 관문이 존재하는 데, 각 내부에 더 많고, 두꺼운 보안은 불필요한 요소일 수 있다.</p>

    <p>하지만 이로 인해 운영 환경에서 <strong>보안 위협 노출이 넓어질 수 있다</strong>. 이러한 점에서 도커는 보안 기능을 추가했지만, 보안을 중시하는 조직들은 애초부터 보안을 고려해 설계된 대안들을 선호하는 경우가 생길 수 밖에 없다.</p>
  </li>
  <li>
    <p><strong>모노리틱 접근 방식</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0003.png" alt="" /></p>

    <p>클러스터링을 위한 스웜(Swarm)과 이미지 레지스트리를 위한 도커 허브(Docker Hub)가 밀접하게 결합된 도커의 모노리틱 구조는 적응하고 난 사용자에게는 매우 편리하게 느껴질 수 있다. 모든 것이 물 흐르듯, 일사천리로 움직이게 되고 이러한 구조는 설정과 이식에서 우수한 성능을 보여준다.</p>

    <p>하지만 <strong>현대 클라우드 네이티브 환경에서는 오히려 제약</strong>으로 다가오게 될 수 있다. 오늘날의 트렌드는 <strong>특화되고 모듈화된 도구들로의 전환</strong>이다. 오케스트레이션은 쿠버네티스(Kubernetes)가 완전히 지배하고 있으며, 패키징은 헬름(Helm)이 담당하고, 컨테이너드(containerd)와 같은 전용 컨테이너 런타임은 컨테이너 관리에만 집중해준다. 즉, 각 역할에 맞는 수준의 관리를 하고 통제가 가능하다는 것은, 전체의 조율과 모듈화에 오히려 도움이 되지, 도커의 통합적 관리는, 오히려 <strong>복잡성을 증가</strong>시킬 수 있다.</p>
  </li>
  <li>
    <p><strong>밴더 종속성 우려</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0005.png" alt="" /></p>

    <p>개발자들은 도커의 특정 도구에 지나치게 의존하는 것에 신중해지고 있다. 도커 파일 문법은 널리 사용되지만, OCI 이미지 및 런타임 요구 사항처럼 공개 표준에 의해 관리되는 것이 아니다. 개발자들은 <strong>단일 툴체인에 묶이는 것을 피하고 싶어 하며</strong>, 특히 공개 표준이 더 큰 유연성과 장기적인 안정성을 보장해 줄 수 있다는 주장은 언제나 그렇지만 지속적으로 강조된다. <strong>다양한 도구와 플랫폼 간의 호환성 보장, 이식성, 밴더 중립성 확보가 더욱 중요</strong>해졌고 그렇지 못한 대상에 대해선 기피하는 것이 어느 기업이나, 개발자들의 공통된 영역이리라.</p>
  </li>
</ol>

<h3 id="도커의-대안들-새로운-플레이어들의-등장">도커의 대안들: 새로운 플레이어들의 등장</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0004.png" alt="" /></p>

<p>이러한 배경 속에서 여러 컨테이너 런타임들이 인기를 얻고 있으며, 이들은 현대적인 컨테이너 네이티브 환경의 핵심 가치인 모듈화, 성능, 개방성을 반영하고 있다. 주목할 만한 대안들은 다음과 같다.</p>

<ul>
  <li><strong>Podman</strong>: 레드햇(Red Hat)에서 개발한 포드만은 <strong>안전하고 데몬이 없는 대체재</strong>로 평가받는다. 도커와 달리 중앙 데몬에 의존하지 않으며, <strong>루트 권한 없이 컨테이너를 실행할 수 있는 루트리스 환경을 적극 지원</strong> 한다. 명령어 인터페이스도 도커와 매우 유사하여 보안을 중시하는 팀이 쉽게 전환할 수 있다.</li>
  <li><strong>containerd</strong>: 원래는 도커의 일부였지만 분리되어 현재는 CNCF가 관리하는 독립 프로젝트다. 특히 <strong>쿠버네티스 1.24에서 도커에 대한 직접 지원이 중단된 이후</strong>로, <strong>컨테이너드는 대부분의 쿠버네티스 배포판에서 기본 컨테이너 런타임으로 사용</strong>되고 있다. AWS, 구글 클라우드, 애저와 같은 주요 클라우드 제공 업체들도 자체 관리형 쿠버네티스 서비스에서 컨테이너드를 기반으로 사용한다. 컨테이너 관리에 단일 목적을 가지고 있어 <strong>경량화되고 확장 가능</strong>하다는 특징이 가장 크다.</li>
  <li><strong>CRI-O</strong>: CRI-O 역시 CNCF에서 관리하며, <strong>쿠버네티스를 위해 특별히 설계</strong>되었다. 컨테이너 런타임 인터페이스(CRI)를 엄격히 준수하며, 불필요한 요소를 제거한 간결하고 목적에 맞는 환경을 유지해준다. 오직 쿠버네티스 워크로드만을 지원하기 때문에 보안 측면에서도 이점을 제공한다. 레드햇 오픈 시프트의 기본 런타임이며, 최소주의와 규정 준수를 중시하는 팀들에게 선호된다.</li>
  <li><strong>Lima 및 Finch</strong>: 맥OS 성능 문제를 해결하기 위한 도구들이다. <strong>Lima는 맥OS에서 컨테이너 빌드를 위한 리눅스 가상 머신을 구성</strong>해 주는 도구로 성능에 최적화된 환경을 제공한다. <strong>Finch는 AWS가 후원하는 프로젝트</strong>로 리마와 컨테이너드/너드컨트롤(nerdctl)을 기반으로 하여 <strong>도커 데스크톱을 대체할 수 있는 고성능 도구를 제공</strong>한다. <strong>라이선스 제약 없이 사용할 수 있다는 점</strong>이 큰 장점이며, 맥OS 개발자들 사이에서 <strong>네이티브에 가까운 성능</strong>을 제공하는 대안으로 빠르게 선호되고 있다.</li>
</ul>

<h3 id="컨테이너-생태계의-미래">컨테이너 생태계의 미래</h3>

<p>컨테이너 생태계 전반의 분위기는 현재 지속적으로 <strong>모듈화와 전문화로의 전환</strong>을 반영하고 있다. 그러한 상황에서 도커의 아쉬운 부분을 이야기 해봤으나, 사실 지속적인 개선이 이루어지고 있다. 2025년 1월에 쓰여진 글로, <a href="https://www.paolomainardi.com/posts/docker-performance-macos-2025/">Docker on MacOS is still slow?</a>라는 이 글만 보더라도 2년 전 분석에 비하면 Docker 의 File Synchronization 기능으로 성능 저하는 최소화 가능하며, 아직 베타지만 Docker VMM 등 대안, 대첵 등도 거론된다는 점에서 MacOS 가상화 환경과 native linux 성능 간 격차 개선을 통해 컨테이너 생태계와 Docker가 여전히 개발자들의 선택을 받게 될 것이라는 점은 확실해 보인다.</p>

<p>도커는 사라지는 것이 아니라 변화하고 있는 것이다. 그러나 컨테이너라는 기술을 기반으로 하는 영역은 현재 <strong>개방형 표준, 경량화된 런타임, 클라우드 네이티브 원칙을 중심으로 빠르게 진화</strong>하고 있다. 도커가 이제는 컨테이너의 절대적인 중심은 아닐 수 있지만, 여전히 중요한 역할을 수행할 것이다. 우리가 목격하고 있는 것은 도커가 만들어낸 생태계의 성숙이며, 이를 통해 개발자들은 더 다양한 선택지를 갖게 되었다는 점이다.</p>

<p>미래는 <strong>모듈형 구조를 갖고 설계 단계부터 개방성을 지향하며, 기본적으로 안전하고 다양한 워크플로우에 유연하게 대응할 수 있는 도구들을 선호</strong>하는 것은 자연스러운 흐름일 것이고, 이 흐름을 읽고 대비하는 필요는 있어 보인다고 생각이 든다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="Container" /><category term="Docker" /><summary type="html"><![CDATA[도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동]]></summary></entry><entry><title type="html">@types/~ 의존성을 설치하면 얻는 것</title><link href="http://localhost:4000/backend/2025/05/03/Type-library.html" rel="alternate" type="text/html" title="@types/~ 의존성을 설치하면 얻는 것" /><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/03/Type-library</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/03/Type-library.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>요 최근 MSA 서버 구현 공부를 다시 하고 있다. 영어 강의고, 상당히 난감한 번역의 자막이라 열은 받지만… 그럼에도 구조적 설계를 배울 수 있어서 좋다.</p>

<p>그러는 와중에 여전히 모르는게 많은 응애 개발자 답게, 모르는 라이브러리의 설치에 대한 내용이 남아 이렇게 적어본다.</p>

<h2 id="typebcrypt-가-뭐시여">@type/bcrypt 가 뭐시여..?</h2>
<p>MSA auth 구현을 하던 도중, 강사가 개발환경에서 좋다고 하여 설치를 했고, 그러나 개발환경..? 굳이 구분이 필요한가 라고 생각을 했었는데… 그게 아니었다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">@types/</code> 라이브러리들은 TypeScript 개발 환경에서 매우 중요한 역할을 합니다. 이 라이브러리들은 주로 <code class="language-plaintext highlighter-rouge">-D</code> 플래그(또는 <code class="language-plaintext highlighter-rouge">--save-dev</code>)를 사용하여 개발 의존성으로 설치됩니다. <em>- Claude 3.7</em></p>
</blockquote>

<p>해당 패키지들이 괜히 구분된게 아니라고, 실질적으로 나름의 역할하는 거였구나. 새삼 깨닫게 되었다. 😅</p>

<h3 id="types-라이브러리의-역할은">@types/ 라이브러리의 역할은</h3>

<ol>
  <li>
    <p><strong>타입 정의 제공</strong>: JavaScript로 작성된 라이브러리에 대한 TypeScript 타입 정의를 제공한다. JavaScript는 원래 타입이 없는 언어이기 때문에, TypeScript에서 이러한 라이브러리를 사용할 때 타입 정보가 필요하고 없을 경우 당연히 TypeConflict 로 고생할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 시 코드 자동완성과 IntelliSense</strong>: 개발 도구(VS Code 등)에서 코드 자동완성, 파라미터 힌트, 메서드 시그니처 등의 도움말을 제공한다. 따라서 편의성 향상에 매우 도움이 된다.</p>
  </li>
  <li>
    <p><strong>타입 체크</strong>: TypeScript 컴파일러가 코드의 타입 오류를 찾아내는 데 사용된다. 이는 런타임 전에 많은 버그를 발견하는 데 도움이 되어 안정성에 도움이 된다.</p>
  </li>
  <li>
    <p><strong>문서화</strong>: 라이브러리의 API가 어떻게 사용되어야 하는지에 대한 문서 역할도 한다. 타입 정의를 통해 함수의 매개변수, 반환 값 등의 정보를 확인할 수 있다.</p>
  </li>
</ol>

<h3 id="예시">예시</h3>

<p>예를 들어, Express.js를 TypeScript 프로젝트에서 사용하려면:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>express          <span class="c"># 실제 라이브러리 설치</span>
npm <span class="nb">install</span> <span class="nt">-D</span> @types/express <span class="c"># TypeScript 타입 정의 설치</span>
</code></pre></div></div>

<p>이렇게 하면 다음과 같은 TypeScript 코드를 작성할 수 있습니다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">@types/express</code>는 <code class="language-plaintext highlighter-rouge">req</code>와 <code class="language-plaintext highlighter-rouge">res</code> 객체의 타입, 그리고 <code class="language-plaintext highlighter-rouge">express()</code> 함수의 반환 타입 등을 제공한다.</p>

<h2 id="알아둬야-하는-핵심-포인트">알아둬야 하는 핵심 포인트</h2>

<ol>
  <li>
    <p><strong>개발 의존성으로 설치할 것</strong>: <code class="language-plaintext highlighter-rouge">-D</code> 플래그를 사용하여 개발 의존성으로 설치하는 이유는 이 타입 정의가 런타임에 필요하지 않고 개발 및 컴파일 시에만 필요하기 때문.</p>
  </li>
  <li>
    <p><strong>라이브러리 버전 일치</strong>: <code class="language-plaintext highlighter-rouge">@types/</code> 패키지의 버전은 가능한 한 실제 라이브러리 버전과 일치해야 한다.</p>
  </li>
  <li>
    <p><strong>DefinitelyTyped</strong>: 대부분의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지는 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 프로젝트에서 관리됩니다. 이는 커뮤니티가 관리하는 타입 정의 저장소다.</p>
  </li>
  <li>
    <p><strong>내장 타입</strong>: 일부 라이브러리는 자체적으로 타입 정의를 포함하고 있어서 별도의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지가 필요하지 않기도 하다. 예를 들어, React 16.8 이후 버전은 자체 타입 정의를 포함하고 있다.</p>
  </li>
</ol>

<h2 id="yarn으로-types-패키지-설치하기">Yarn으로 @types/ 패키지 설치하기</h2>
<p>학습 시에는 pnpm 을 사용하였으나, 현재 회사의 의존성으로 yarn 을 사용 중이다. yarn 에선 다음과 같이 사용해서 type 을 다운받으면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 라이브러리 설치</span>
yarn add express

<span class="c"># 타입 정의를 개발 의존성으로 설치</span>
yarn add <span class="nt">--dev</span> @types/express
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 단축 </span>
yarn add <span class="nt">-D</span> @types/express
</code></pre></div></div>

<h2 id="yarn에서-packagejson-의존성-구분">Yarn에서 package.json 의존성 구분</h2>

<p>npm과 마찬가지로 Yarn도 <code class="language-plaintext highlighter-rouge">package.json</code> 파일에서 의존성을 다음과 같이 구분합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.1"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"devDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"@types/express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.13"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="타입-지원-여부-확인-방법">타입 지원 여부 확인 방법</h2>

<p>이렇듯 유용하기도 하고, 있는지 확인해 보면 좋은 <code class="language-plaintext highlighter-rouge">@type/~</code>는 각 라이브러리 마다 존재하는지 확인해서 필요시 설치하면 되고, 있는지 여부는 아래와 같은 방법을 활용하자.</p>

<ol>
  <li>패키지 설치 후 직접 확인</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 간단한 테스트 파일 작성</span>
<span class="k">import</span> <span class="o">*</span> <span class="kd">as </span><span class="kr">package</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">package-name</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>이 코드를 작성했을 때:</p>
<ul>
  <li>타입 오류가 없다면, 라이브러리가 이미 타입을 내장하고 있습니다.</li>
  <li>“Could not find a declaration file for module ‘package-name’” 오류가 발생한다면, 타입 정의가 없다고 보면 됨</li>
</ul>

<ol>
  <li>패키지 문서 확인</li>
</ol>

<p>대부분의 패키지는 README나 공식 문서에 TypeScript 지원 여부를 명시하니 확인 할 것</p>
<ul>
  <li>“Written in TypeScript” 또는 “TypeScript support included”와 같은 문구</li>
  <li>설치 안내에 <code class="language-plaintext highlighter-rouge">@types/package-name</code> 설치 지침이 포함되어 있는지 확인</li>
</ul>

<ol>
  <li>패키지 소스 확인</li>
</ol>

<p>패키지의 <code class="language-plaintext highlighter-rouge">package.json</code> 파일을 확인합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"package-name"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"types"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">       </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typings"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typescript"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"definition"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ol>
  <li>NPM 페이지 확인</li>
</ol>

<p>NPM 웹사이트에서 패키지 페이지를 확인하세요. 패키지 파일 목록에 <code class="language-plaintext highlighter-rouge">.d.ts</code> 파일이 있으면 타입을 제공한다.</p>

<ol>
  <li>DefinitelyTyped 검색</li>
</ol>

<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped GitHub 저장소</a> 또는 <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a>에서 <code class="language-plaintext highlighter-rouge">@types/package-name</code>이 있는지 확인한다.</p>

<ol>
  <li>자동화된 도구 사용</li>
</ol>

<h4 id="typescript-auto-importer-확장-프로그램">TypeScript-Auto-Importer 확장 프로그램</h4>

<p>VS Code의 <code class="language-plaintext highlighter-rouge">TypeScript-Auto-Importer</code>와 같은 확장 프로그램은 사용 가능한 타입 정의를 자동으로 감지한다.</p>

<h4 id="npx-typescript-check-esm-사용"><code class="language-plaintext highlighter-rouge">npx typescript-check-esm</code> 사용</h4>

<p>이 도구는 프로젝트 의존성의 TypeScript 호환성을 검사한다.</p>

<h4 id="typed-npm-registry-사용"><code class="language-plaintext highlighter-rouge">typed-npm-registry</code> 사용</h4>

<p>이 웹사이트에서 패키지 이름을 검색하여 타입 지원 여부를 확인 가능: https://www.typedregistry.com/</p>

<h3 id="실용적인-워크플로우">실용적인 워크플로우</h3>

<ol>
  <li>먼저 기본 패키지만 설치 함: <code class="language-plaintext highlighter-rouge">yarn add package-name</code></li>
  <li>코드에서 임포트해보고 오류가 발생하는지 확인</li>
  <li>오류가 발생하면 <code class="language-plaintext highlighter-rouge">@types</code> 패키지 존재 여부를 확인:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn info @types/package-name
<span class="c"># 또는</span>
npm view @types/package-name
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@types</code> 패키지가 존재하면 설치: <code class="language-plaintext highlighter-rouge">yarn add -D @types/package-name</code></li>
</ol>

<h2 id="마치며">마치며</h2>
<p>확실히 사용해보니, 없을 때 보다 공식 설명이 더 풍부한 경우가 많고, 객체, 타입에 대한 설명이 상세 해지는 걸 보니, 개발 시 무언가 추가 시 신경 써서 넣어두거나, 기본적으로 갖춰 둔 템플릿을 활용하면 좋을 것 같다.</p>

<p>이런 거 보면 아직 짬이 덜 찬 느낌이 든다. 🫥</p>

<p>개발의 길은 멀고, 아주 멀고, 아주 멀다. 😖</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="TypeScript" /><category term="Backend" /><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">클린 코드를 위한 룰</title><link href="http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming.html" rel="alternate" type="text/html" title="클린 코드를 위한 룰" /><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming</id><content type="html" xml:base="http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming.html"><![CDATA[<h2 id="-클린-코드-황금-6원칙-스터디-정리"><strong>🧠 클린 코드 황금 6원칙 스터디 정리</strong></h2>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0002.png" alt="" /></p>

<blockquote>
  <p>링크드인에서 개발과 관련한 이미지를 한 장봤다. 새롭게 개편한 블로그를 위한 글도 써야 하고, ‘오랜만에 정리 해 봐야겠구나’ 라는 생각이 들었다. 왜냐면 이제 개발을 시작한지 4년? 팀 개발을 해나가면 나갈 수록 더 중요한게 어디에 있는가에 대한 답변이 항상 거의 여기서 나오고 있다고 스스로도 느끼는데, 정작 정확하게 이해하고 있냐? 라고 하면 그렇지는 않다… 가 있기 때문이다. 🤔</p>
</blockquote>

<h3 id="1️⃣-soc-seperation-of-concerns--관심사는-분리해라">1️⃣ <strong>SOC (Seperation of Concerns) : 관심사는 분리해라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0003.png" alt="" />
어떤 비즈니스 로직을 구현 하는 과정에서, 다양한 것, 다양한 ‘관심’이 필요 시 된다. DTO로 들어오는 대상에 대해 무결성을 검증 해야 하고, 룰은 지켰으나 데이터는 온전한지도 확인 해야 하며,  그렇게 들어온 데이터는 비즈니스 로직이 정한 룰이나, 다양한 절차를 거쳐 결과적으로 요청을 한 클라이언트에게 전달되다.</p>

<p>따라서 다양한 요소들이나, 로직, 기능이 서로를 바라보게 될 수 밖에 없고, 보통 그런 구조가 설계되기 시작하면 거미줄처럼 얼키고 설켜 복잡한 형태를 이루게 된다.</p>

<p>문제는 그런 구조를 가지면 하나를 바꿔도 그 안에서 모든 것들이 영향을 미치게 되어 버린다는 점이다. 거기다 아무리 대단한 사람이 함께 참여하더라도 수천, 수만줄의 코드의 협업 속에서 그런 일이 일어난다면? 그걸 어떻게 발견하겠는가? 사소한 문제가 얼마나 커질 수 있는가를 여기서 알 수 있는 것이다. 물론, 이는 단적이고 극단적인 예시일 것이고 이 외에도 관심사의 혼재는 아주 큰 문제들을 많이 가진다.</p>

<p>따라서 많은 이들이 Seperation Of Concerns(관심사의 분리) 라는 가치를 이야기 하며, 이것이 필요한 이유를 크게 3가지 정도로 축약하여 이야기 한다.</p>

<ul>
  <li><strong>단일 책임 원칙을 지키기 위해</strong></li>
  <li><strong>유지 보수 과정에서 문제를 빠르게 좁혀야 한다.</strong></li>
  <li><strong>코드 재사용성을 극대화 하기 위해</strong></li>
</ul>

<p>예시를 그래도 간략하게 들어보자면… (feat. ChatGPT)</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Controller - 요청 처리만</span>
<span class="p">@</span><span class="nd">Post</span><span class="p">(</span><span class="dl">'</span><span class="s1">login</span><span class="dl">'</span><span class="p">)</span>
<span class="nf">login</span><span class="p">(@</span><span class="nd">Body</span><span class="p">()</span> <span class="nx">loginDto</span><span class="p">:</span> <span class="nx">LoginDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 여기서 무슨 일이 일어나든 </span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">login</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Service - 비즈니스 로직</span>
<span class="k">async</span> <span class="nf">login</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">:</span> <span class="nx">LoginDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">validateUser</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">);</span>
  <span class="c1">// 여기서 무슨 일이 일어나든 로직은 구분되어 있다 </span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">authService</span><span class="p">.</span><span class="nf">issueToken</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2️⃣-dyc-document-your-code--코드를-문서화하라">2️⃣ <strong>DYC (Document Your Code) : 코드를 문서화하라</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0004.png" alt="" /></p>

<p>팀 플레이를 진행하던, 혼자서 코드를 짜던 한 가지 중요한 지점은 사람은 ‘컴퓨터’ 가 아니라는 점이다. 컴퓨터도 데이터를 소실되니 마니 하는 마당에, 사람의 머리가 알 수 있고 기억할 수 있는 용량은 반드시 한계가 있다. 작업을 하던 과정이 급하고, 촉박하거나 하지 않더라도 개발을 하다보면 시간이 지나면서  ‘뇌 내 풍화(?)’를 겪게 된다.</p>

<p>그럴 때면 드디어 객관적으로 내 코드를 볼 수 있게 되고, 그 코드를 보며 자괴감도 분노도, 실망도 느끼게 되는게 마치 인생같다는(?) 이상한 소리를 할 수 있다. 왜 이렇게 했더라, 이 부분이 왜 필요했지 등등.. 그러다 보면 몇 달만에 다시 보고, 그 부분을 수정해야 할 때 그저 쉽게 코드 몇줄 추가 했음에도 에러가 생기는 일 등… 다양한 방해물이 생기고 나면, 그제야 우리는 깨닫게 된다.</p>

<p>‘아 메모 해 둘걸’</p>

<p>하고 말이다.</p>

<p>문서화가 중요한 것은 다음과 같은 이유라고 보면 된다.</p>

<ul>
  <li><strong>협업자가 코드를 빠르게 이해할 수 있으려면 필요하다.</strong></li>
  <li><strong>시간이 지난 뒤 ‘나’의 이해를 돕기 위해 필요하다.</strong></li>
</ul>

<p>뭐 예시는 필요하진 않을 것이다. 심지어 요즘은 LLM 을 활용하여 자동 문서화도 기가 막히게 잘 되고 있으니, 이 부분은 확실하게 도입하고 습관을 들이는 것이 좋아 보인다.</p>

<p>Cursor를 활용해도 좋을 것이고 Vsc 에 Continue 를 활용해도 좋다고 느껴진다.</p>

<h3 id="3️⃣-dry-dont-repeat-yourself--중복을-피하라">3️⃣ <strong>DRY (Don’t Repeat Yourself) : 중복을 피하라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0005.png" alt="" />
이번에는 좀 극단적인 예시를 들어 보면 좋을 것 같다.</p>

<blockquote>
  <p>결제 로직을 만들게 되었다고 치자. 전처리 과정에서 데이터들에 대한 정리, 특히나 암호화된 데이터를 decode 해서 실제 결제 이벤트를 받아내야 한다. 그 뒤 자세한 로직들이 나온다. 그런데 작업을 하다보니 이 decode 의 과정이 코드가 너무 길어, 블록으로 떼어 내서 다시 메서드화 시키기 너무 귀찮다..!</p>

  <p>결제 이벤트는 총 4개. 마음은 아팠지만, 기간이 얼마 남지 않았다는 생각에 어쩔 수 없이 결단을 내려 ctrl + c를 4회 진행하게 되는데…</p>

  <p>몇 달이 흘러, 결제 개선이 가능한 시점이 되었다. 결제 이벤트 하나만 추가로 개선하면 되는 것이었음에도, 무언가 이상하다. 무엇이 문제 였을까?</p>
</blockquote>

<p>같은 코드가 같은 내용임에도 불구하고 다양한 로직에 사용되는 경우는 은근히 흔하게 있다. 암호화와 복호화 과정이라는 대표적인 예시도 있지만, 그 밖에도 처리해야 하는 데이터의 가공 영역은 특히나 그런 경우가 많다.</p>

<p>하지만 문제는 예를 들어 이럴 수 있다. A 라는 로직이 있고 이것이 4번 쓰였는데, A를 고친다는 생각에 A’를 만들었지만, 막상 내가 그때 A를 4번 복붙 해야 한다는 걸 까먹을 수도 있고 실제로 그런 경우로 사고가 나는 경우가 정말 많다.</p>

<p>따라서 꼭 기억할 것은 같은 코드, 같은 규칙이라면 하나를 작성하고 그것을 통해 항상 정확하게 처리하는 것이 필요하다. 이를 통해 버그 발생 확률을 낮추고, 수정과 리펙토링 과정을 쉽고 정확하게 만들어주며, 오히려 이런 설계가 되었을 때 향후 코드 확장성이 높아지는 것은 당연히 덤이니까.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이런 단순한 코드라도 만들어두면, 재사용할 때 검색 한번으로 찾아서 쓸 수 있고, </span>
<span class="c1">// 향후 조건이 여러개로 늘어나도 1번의 수정이면 끝난다</span>
<span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="4️⃣-kiss-keep-it-simple-stupid--단순하게-유지하라">4️⃣ <strong>KISS (Keep It Simple, Stupid) : 단순하게 유지하라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0007.png" alt="" /></p>

<p>백엔드 개발자로 입문하게 되어, 첫 해 작업을 할 때 항상 생각했던 것은, 단단한 구조, 안정적인 성능, 이를 위한 수학적이거나 계산적인 로직으로 단단한 기능으로 구현하는게 좋지 않을까! 라는 호기로움이었다.</p>

<p>하지만 6개월 정도 했었을까? 그런 코드가 ‘잘 동작’은 하지만 ‘쓸모 없다’ 는 것은 너무나 빨리 알게 된 사실이었다.</p>

<p>개발의 과정은 완벽이 없다. 기능은 그대로지만 방향성은 달라지게되고, 사업의 형태, 비즈니스의 방향성의 고려로 기능은 수시로 바뀔 수 있다.</p>

<p>뿐만 아니라 새로운 사람이 들어오거나, 코드를 만드는 입장과 리뷰, 관리 하는 입장이 다른 경우도 있다. 무엇이 되었든 그런 상황이 되면 우리는 코드를 봐야하고, 그 코드를 이해하고 문제가 없는지를 확인하는 작업들이 필요 시 된다.</p>

<p>그런데 여기서 나만 아는, 혹은 나 혼자 이해할만한 로직을 활용한다는 것은 심각한 비효율성을 낳는다.</p>

<p>리펙토링을 이후에 할 때도 어려워지고, 누군가 읽고 해석해서 향후 관리를 해 나가는 것도 어렵다. 특히나 디버깅이나 테스트 과정 역시 어려울 수 밖에 없는 경우가 많다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">levels</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">90</span><span class="p">];</span>

  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">thresholds</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="nx">thresholds</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">idx</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">levels</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>둘은 동일한 결과를 만든다. 사실, 의도만 이해할 수 있다면 아래의 코드는 비교가 많아질 때 O(log n)의 복잡도로 이진탐색을 진행하기에, chatGPT 도 ‘압도적으로’ 성능이 좋다고 말할 정도로 성능면에선 좋다.</p>

<p>하지만 만약 구조가 바뀌거나 조건이 바뀐다고 할 때, 그리고 이 코드를 처음 보고 이해해야 하는 사람 입장이라면? 이런 부분들이 지속적으로 나온다면? 내 고집으로 만들어서 넣어 두고 충격적인 결말을 마주하게 될 지도 모를 것이다.</p>
<h3 id="5️⃣-tdd-test-driven-development--테스트-주도-개발">5️⃣ <strong>TDD (Test Driven Development) : 테스트 주도 개발</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0006.png" alt="" /></p>

<p>TDD는 일종의 로망(?) 처럼 느껴지고, 마치 판타지 처럼 여겨지는 경우가 좀 있다. 현실에 적용하기엔 어렵고, 번거롭고, 복잡하다는 것.</p>

<p>이러한 점이, 거를 타선이 없다는 것은 격하게 공감한다(?)</p>

<p>하지만 생각을 조금만 바꿔봐도 요즘은 훨씬 TDD 를 구현하고 준비하는 것이 어렵지 않은 시대가 되었다. 예를 들어 refernece 로 쓰이는 DTO 를 설정하고, AI 를 활용하여 예시가 되는 에러 케이스를 만들고, 그 경우의 수에 맞춰 만들어 달라고 해줄 수 있다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0001.png" alt="" /></p>

<p>실패를 먼저 고려하고, 그에 대한 대응을 정리해둔다면 로직에서 핸들링할 에러를 빼먹지 않을 수 있으며, 훨씬 명확한 협업, 클라이언트를 배려한 협업이 가능하다는 점에서 반드시 100% 완벽한 TDD 가 아니더라도 충분히 LLM 을 활용한 효율적인 방법이 적용 가능한 것이다.</p>

<p>특히나, 이렇게 준비되고, 이에 대한 Jest 테스트 같은 것들이 준비 된다면? 아마 말 하지 않아도 알 것이다. <code class="language-plaintext highlighter-rouge">버그는 잡히며</code>, <code class="language-plaintext highlighter-rouge">리펙토링을 해도 문제 없는지를 거의 즉각적으로 알 수 있고</code>, 결정적으로 성능 향상과 같이 <code class="language-plaintext highlighter-rouge">지표가 필요한 영역의 기능</code>이라면 손쉽게 테스트를 통해 리펙토링 포인트를 파악할 수 있다.</p>

<h3 id="6️⃣-yagni-you-arent-gonna-need-it--필요할-때만-만들기">6️⃣ <strong>YAGNI (You Aren’t Gonna Need It) : 필요할 때만 만들기</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0008.png" alt="" /></p>

<p>개발을 하는 것은 약간 장인정신(?)을 가지게 만든다. 내가 만드는 그것이 좀 더 멋지거나, 좀 더 성능이 좋거나, 뭐가 되었든 그 개발 분야가 뭐가 되었든 나름의 ‘미학’을 쫓는 것을 종종 보게 된다.</p>

<p>이것이 취미 일 땐 아름다울지 모른다.</p>

<p>취미 일 땐 입이 벌어지는 센스를 느낄 수 있는 것이 오히려 멋지고, 훌륭하며, 재미있다.</p>

<p>하지만 이것이 일이고, 비즈니스라면 말이 달라진다. 당장 필요한 기능, 시장이 원하는 기능, 괜찮은 아이디어를 빨리 구현하는 것이 이젠 너무 중요하고, 비즈니스에서 그 가치는 이미 십수년도 전, 아니 수백년 전부터 먼저 가져가는 사람이 임자였다.</p>

<p>개발 속도를 늦추는 오버 엔지니어링이 되어 버리게 된다면, 오히려 이후 유지 보수에도, 그리고 리소스의 낭비로 타이밍을 놓칠 수도 있다. 그리고 그것을 개발자도 경영자도, 상품을 소비할 소비자에게도 결코 좋을 리는 없다. 개발자는 회사 내지는 조직에서 함께 일하고 있고, 내가 맥을 쓰고, 커피를 마시면서, 일에 집중할 수 있게 해주는 건 내가 만든 그것을 쓰는 사람들의 돈으로 이루어진다는 사실을 잊고 살면, ‘잘 만들어도 욕을 먹는’ 케이스가 아주 드물지 않다는 것을 몸소 느낄 수 있을 것이다.</p>

<h2 id="-결론">📖 결론</h2>
<p>이 원치들에 대해 다양하게 적는건 시간 관계상 피하려고 한다. 이미 뭐 자료는 많으니… 😅</p>

<p>하지만 이 전체를 고민하고, 경험하고, 인정하게 되면 어느새 드는 하나의 생각은 다음처럼 정리 된다.</p>

<ul>
  <li>복잡한 시스템이 만들어지는 것을 막고</li>
  <li>코드를 읽기 쉽게 만들며</li>
  <li>유지 보수 가능하면서도</li>
  <li>팀 전체가 빠르게 개선할 수 있도록 하는 것.</li>
</ul>

<p>결국 이게 되면 그 어떤 소프트웨어도 유기적으로 살아 숨쉬듯 자기 복제와 자기 진화를 이루고, 목표 시 되는 프로덕트의 퀄리티를 맞추며, 인정받는 개인이자 팀이 될 수 있다.</p>

<p>오랜만에 링크드인에서 그저 짤로 본 것이지만, 정리를 하는 과정에서 CTO를 통해 얻어온 많은 경험들 그리고 백엔드 개발자로 1년 간 유지 보수, 코드를 짜오면서 얻은 많은 것들을 새삼 정리하는 감각을 느꼈다. 왜 실수가 많았고, 어디서 아쉬웠는지 새삼스럽게 느껴진 시간이었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="etc" /><category term="cleanCode" /><category term="prgramming" /><summary type="html"><![CDATA[🧠 클린 코드 황금 6원칙 스터디 정리]]></summary></entry><entry><title type="html">AI 로 어디까지 가능할까?</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game.html" rel="alternate" type="text/html" title="AI 로 어디까지 가능할까?" /><published>2025-04-12T00:00:00+00:00</published><updated>2025-04-12T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game.html"><![CDATA[<h2 id="ai-어디까지-가능할까-게임-만들-수-있을까">AI 어디까지 가능할까? 게임 만들 수 있을까?</h2>
<p>이런 영상을 보았다</p>

<p><a href="https://www.youtube.com/watch?v=NSXsTq6zg_s"><img src="https://img.youtube.com/vi/NSXsTq6zg_s/0.jpg" alt="5090사서..." /></a></p>

<p>엄밀히 말하면 5090을 가진 어마무시한 분의 이야기… 지금 살 수 있는 사람이 몇이나 될까하는 글카로 벤치에 AI까지 돌리는 내용인데.. 나에게는 다소 다르게 보였다.</p>

<h2 id="ai-로-어디까지-가능할까">AI 로 어디까지 가능할까?</h2>

<p>현재 stable diffusion 이나 Audacity + TortoiseTTS 등.. 오픈소스 AI 툴은 이미 성숙한 수준까지 올라온 상태이다.</p>

<p>뿐만 아니라 그러한 원초의 로우 툴에서 비롯되어, 웹 기반으로 서비스를 시작한 NovelAI, ComfyUI(이건 약간 중간 성격이긴 한데..), soundraw Ai 등… 이미 편리한 서비스들로 구체화 되었고, 좀더 알아보니 네이버나, 기타 굉장한 AI 스타트업들의 개발. 이제는 진짜 아무리 생각해도 AI가 핵심이고, 극강의 효율성이 필요하다는 점을 느낄 수 있었다. 이러한 점을 생각하니 이런 생각에 귀결 되었다.</p>

<blockquote>
  <p>이 정도면 혼자 게임도 만들 수 있지 않을까?</p>
</blockquote>

<p>게임, 게임성을 갖추는 것은 대단히 어렵고, 인간의 창조 영역에서도 특히나 혼자선 어려운 분야이다. 특히나 종합적인 컨텐츠로 연출, 그래픽스, 모션, 세부 분야로 파고 들면 생각보다 고려할 것들이 너무 많은 영역일 것이다.</p>

<p>하지만 생각해보면 꼭 종합적이어서 재밌거나 한건 아니다.</p>

<p>사람은 스토리를 먹고 사는 동물이다.</p>

<p>또한 사람은 본질적으로 <code class="language-plaintext highlighter-rouge">부족</code>할 때 비로소 <code class="language-plaintext highlighter-rouge">동기</code>를 얻는다.</p>

<p>그런 점이 가장 극대화 되는 장르들이 보통 퍼즐이나 비주얼 노벨류. 그리고 놀랍게도 현재 모바일 시장에서 여전히 흥행 강세이고, 수명이 유지되는 게임들도 결국 그런 부분에서 받춰져서 팬덤이 형성된 류가 꽤나 있다는 것을 알 수 있다.</p>

<p><img src="https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/2396980/capsule_616x353.jpg?t=1726036301" alt="" />
페이트 스테이 나이트는 내 시절 최고의 판타지 물이었고</p>

<p><img src="https://i.namu.wiki/i/ES0zVAPjU7o89_R-0Hywfus4caJ9LYFpF2zqLHQ0YTUuakUNw5LRY-MFHKKZmxoMiMdzor32OJc3moeQkySnCA.webp" alt="" />
그에 이어 나온 페이트 그랜드 오더는 소니를 먹여살리는 일등 공신 중 하나로 현재 수년째 그 인기를 이어가고 있는 프랜차이즈가 되었으며,</p>

<p><img src="https://i.namu.wiki/i/pvrIEFOSpzhHxbnEqMMSViO9_BnBoaHZs9hMbO32P27hV7hOv14nEQbJpPr3wpYelqgFxqk78z7C2dyPa2NeBg.webp" alt="" />
국내 성공작으로 게임성에선 뭐라고 욕을 먹어도 스토리에서 성공적인 블루 아카이브,</p>

<p><img src="https://cdn.getnews.co.kr/news/photo/202405/676535_395705_4552.png" alt="" />
빵댕이 게임이라고 하지만, 팬들에겐 그 이상이라는 평을 받는 니케</p>

<p>이런 류들이 런칭 이후 지속적인 사랑을 받고, 그 지속적인 사랑으로 얻은 캐시카우가 새로운 능력이나 도전을 이뤄내는 것을 생각해본다면… 과연 AI 를 활용하고, 핵심이 되는 부분 비주얼과 스토리에 대해서만 얼마나 좋은 스토리, 좋은 내용을 양질로 끌고 오냐만 결정 난다면 이건 굉장한 One Man Army 로 뭔가를 할 수 있는 게 아닐까?</p>

<h2 id="필요한-도구들은-뭐가-있을까">필요한 도구들은 뭐가 있을까?</h2>
<p>지금까지 확인 해보았을 때, 필요한 영역은 다음과 같다.</p>

<h3 id="게임의-툴-">게임의 툴 :</h3>
<p>게임의 툴로는 렌파이, Game Maker, Unity 를 생각해볼 수 있다. 툴의 난이도는 Unity 쪽이 가장 어렵지만, 활용성이나 장기적으론 Unity 가 가장 우수하다. 하지만 렌파이나 Game Maker는 쉽고, 오픈소스라는 가장 큰 장점을 갖고 있다.</p>

<p>비용의 처리나, 복잡성, 간단함을 승부로 할 것이라면 개인적으론 GameMaker 가 가장 현실적인 중간 답안이 아닐까? 다른 엔진도 여럿 추천 받았지만, 결국 2D 게임을 만든다고 할 때, 가장 적절한 수준은 어디인가에서 다플랫폼을 지원하고, 커뮤니티 수준등을 보면 결국 GameMaker로 갈 수 밖에 없을 것 같다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0003.png" alt="" /></p>

<p>거기다 이젠 영어만 있는 것들이 못 쓸 정도가 아니라는 점을 너무나 잘 알고 있다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0004.png" alt="" /></p>

<p>노트북LM 을 활용하여, 영어로 된 튜토리얼을 넣고, 학습 시켜 배워야할 영역만 체크하고, 영상도 볼 필요 없이 튜토리얼 대로 만든다… 진짜 지금 내가 사는 시대는 아무리 생각해도 말이 안된다(…)</p>

<h3 id="그림-">그림 :</h3>
<p>위에서도 언급한 Raw 한 툴을 활용하는 것도 가능하고, 거기서 좀더 개선된 것들이나 플러그인 등도 있다. 만약 쓰게 된다면 Stable Diffusion 을 사용할 것 같은데, 이는 오픈소스로 개방된 모델들을 활용할 수 있고, 무엇보다 오픈소스라는 점이 가장 중요하기 때문이다. 현재 끌리는 건 미드저니, NovelAI 와 같이 이미 좀더 편리하게 쓰도록 구성된 것들이 있는 것은 사실이지만, 혼자서 할 수 있는가? 로컬에서 이용 가능한가? 라는 점에서 테스트먼트를 한다면 stable diffusion을 우선 써보는게 낫다는 생각이 든다.</p>

<p>다만, 이걸 위해서 필요한 것은 역시 무드, 그리고 캐릭터를 별도로 가져갈 수 있냐는 점. 이 부분은 stable diffusion을 제대로 설치하여 사용해봐야 알 수 있을 것으로 보인다. 아직 아무것도 안하고 써보는 것이다보니(도커에 설치만 해봄 ㅋㅋ..) 뭐라고 이렇다 말하긴 애매하다.</p>

<p>한가지 현재 상황에서 대단히 중요한 부분은 과연 상용으로 쓸 수 있는가? 에 대한 부분이리라 생각된다. 상용 라이센스를 가지는 것들로만 구성을 해야 하므로, 이에 대한 고민 연구가 필요하며 법적인 부분에 대한 조언은 받아봄직 하긴 하다.</p>

<p>어쨌든, 이러라고 산 4080super 가 제 역할을 다해주길 기대한다…(<del>3년 내에 2천은 벌어야 한다…</del>)</p>

<h3 id="bgm--효과음-">BGM / 효과음 :</h3>
<p>사실 AI 가 거의 필요없다고 생각한다. 이런건 무료 에셋으로 가보자.</p>

<h3 id="음성-">음성 :</h3>
<p>이게 가장 큰 문제일 수 있을 것 같다. 비주얼 노벨에서 성우는 생각보다 중요하고, 현재 리메이크된 유명 게임들도 인게임 보이스를 넣어서 리메이크 하는 걸 보면, 확실하 예전 감성으로만 접근할 수 없긴 하다. 그래서 찾아보니…</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0001.png" alt="" /></p>

<p>세상에… AI 는 이미 여기도 이미 해결이 되어 있었다.</p>

<p>그 와중에 개인적으로 사용해본 결과 굉장히 독보적인 곳을 발견했는데, 그곳이 바로 이곳</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0002.png" alt="" /></p>

<p>SUPERTONE 이라는 곳으로, 목소리 수준이나, 비용, 어떤 면에서도 로컬보단 월등히 낫다는 생각이 들었다. 특히 한국어 성우 학습이 정말 괜찮다.</p>

<h2 id="일단-해보자">일단 해보자</h2>
<p><img src="https://i.namu.wiki/i/H0zMZ4htL9ypyfJ0LXQrcTcC6f7dZBBh1KedrpMXNnEiXaAIzyBTAOgFReXNwgw6JWjtlr4Agc6_kEMckjFUeLQpFzEJiCxurXkxzaA3azZbR_6oMHND5511MI4fQyhP9BcG1zVgKX7GrKgka6uT1A.webp" alt="" /></p>

<p>AI 를 공부하고, 개발자로 뭔가 해보려고 하였다. 개발을 배우는 것도 중요하고 그래서 현재 회사에서 나름데로 정말 노력에 노력을 더하고 있지만, 취미로 무언가 만들기 위해선 역시 재미가 필요하다. 그리고 필요한 건 ‘가볍지만 제대로’ 할 수 있는 도구 들.</p>

<p>어차피 배워 나가고 살아 나가다보니 친구도 없고, 시간은 많다.</p>

<p>내가 좋아하는 건 판타지와 SF, 그리고 씹덕.</p>

<p>개발자로 이것저것 배운 것들이 접목될 수 있는데, 심지어 팀이 아니어도 할 수 있다? 지금 나에게 필요한건 어쩌면 이런 도전을 해보는게 아닐까 싶다.</p>

<p>가즈아.</p>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><category term="게임" /><summary type="html"><![CDATA[AI 어디까지 가능할까? 게임 만들 수 있을까? 이런 영상을 보았다]]></summary></entry><entry><title type="html">기술 블로그를 다시 시작하면서</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start.html" rel="alternate" type="text/html" title="기술 블로그를 다시 시작하면서" /><published>2025-04-07T00:00:00+00:00</published><updated>2025-04-07T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start.html"><![CDATA[<h2 id="기술-블로그를-개편하면서">기술 블로그를 개편하면서</h2>
<p>기존의 개발자가 되기 전의 블로그를 써보겠다고 나름 노력했습니다. 
아카이브란 이름을 걸고, 기술 블로그를 만드는데 이것 저것 노력해봤던 그 흔적들.</p>

<p>하지만 취업을 하고나서 보니 부족한 것도 많고, 아쉬운 점도 많았습니다.
원래는 원대한 계획을 세우고, 직접 만들어보겠다! 이런 마인드도 있었지만…</p>

<p>일은 정신 없고, 내가 배우고 즐거워하는 것들을 씹어 삼키는 것만으로도 바쁘다 보니,
개인적인 일까지 겹치며서 시간을 확보하기는 커녕 하루 살아 하루 회복하는 일상…. 😫</p>

<p>하지만 조금 천천히 갈 순 있어도 멈추기는 싫었기에, 쇠뿔도 당긴 김에 빼라는 말 처럼 전체를 정리하고 다시 시작할 공간으로 정리를 단행했습니다.
(<del>정리라는 이름의 강제 초기화</del>)</p>

<p>기존의 글들도 다시 정리하여 마이그레이션을 할 것이고, 새롭게 배우던 것들도 좀더 깔끔하게, 좀더 쉽게 정리하는게 핵심입니다. 
그리고 이렇게 글로 내 생각을, 내 삶을 남겨, 나라는 존재의 능력치도, 동시에 내 가치도 함께 성장시키는 것이 이 공간에서 시작하려 합니다.</p>

<h2 id="앞으로">앞으로</h2>
<p>AI의 발전은 하루 걸러 하루 달라지고, 새로워지고, 진보합니다. 
백엔드적 경험은 무언가 하나 만들 때마다 성장을 하는 듯 하지만, 부족함을 놓치는 것들이 끊임없이 나오고 그것들을 못 챙겼다는 것은 상당한 아쉬움으로 남습니다.</p>

<p>그렇기에 목표는 명확합니다.</p>

<p>AI 는 아직 ‘따라잡을’ 수는 없어도, 따라가려고 노력은 할 것이며,</p>

<p>배운 것들 중 괜찮은 것들을 정리하여 이곳에 적고, 특히나 그것이 남들이 읽기 좋은 글의 형태로 남기려고 합니다.</p>

<p>이유는 간단합니다. 
쉬운 글로 남기려고 노력할 때, 비로소 어려운 것을 나 스스로도 이해하고, 동시에 누군가에게도 도움이 될 수도 있기 때문입니다. 
생각해보면 그 주제가 결국 개발이라는 점에서 차이가 있는 것은 아닌가- 라는 것도 한 편으로 생각해볼 지점이겠지만… 😂</p>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><summary type="html"><![CDATA[기술 블로그를 개편하면서 기존의 개발자가 되기 전의 블로그를 써보겠다고 나름 노력했습니다. 아카이브란 이름을 걸고, 기술 블로그를 만드는데 이것 저것 노력해봤던 그 흔적들.]]></summary></entry></feed>