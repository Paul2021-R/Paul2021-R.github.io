<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-09-04T04:12:23+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">Docker - What is Docker?</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/04/docker-001.html" rel="alternate" type="text/html" title="Docker - What is Docker?" /><published>2025-09-04T00:00:00+00:00</published><updated>2025-09-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/04/docker-001</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/04/docker-001.html"><![CDATA[<h2 id="docker란-무엇인가">Docker란 무엇인가?</h2>

<p>Docker는 애플리케이션을 개발, 배포, 실행하기 위한 개방형 플랫폼이다. Docker를 사용하면 애플리케이션을 인프라로부터 분리하여 소프트웨어를 신속하게 제공할 수 있다. Docker를 통해 인프라를 애플리케이션 관리와 동일한 방식으로 관리할 수 있다. Docker의 코드 배포, 테스트, 배포 방법론을 활용하면 코드 작성과 실제 운영 환경에서 실행 사이의 지연을 크게 줄일 수 있다.</p>

<hr />

<h2 id="docker-플랫폼">Docker 플랫폼</h2>

<p>Docker는 컨테이너라고 불리는 느슨하게 격리된 환경에 애플리케이션을 패키징하고 실행하는 기능을 제공한다. 격리 및 보안 기능을 통해 주어진 호스트에서 많은 컨테이너를 동시에 실행할 수 있다. 컨테이너는 가볍고 애플리케이션 실행에 필요한 모든 것을 포함하므로, 호스트에 설치된 것에 의존할 필요가 없다. 작업 중에 컨테이너를 공유할 수 있으며, 공유받는 모든 사람이 동일한 방식으로 작동하는 동일한 컨테이너를 얻게 됨을 확신할 수 있다.</p>

<p>Docker는 컨테이너의 라이프사이클을 관리하기 위한 도구와 플랫폼을 제공한다:</p>

<ul>
  <li>컨테이너를 사용하여 애플리케이션과 그 지원 구성 요소를 개발한다.</li>
  <li>컨테이너는 애플리케이션을 배포하고 테스트하는 단위가 된다.</li>
  <li>준비가 되면, 애플리케이션을 컨테이너 또는 오케스트레이션된 서비스로서 프로덕션 환경에 배포한다. 이는 프로덕션 환경이 로컬 데이터 센터, 클라우드 제공업체 또는 이 둘의 하이브리드인지 여부와 관계없이 동일하게 작동한다.</li>
</ul>

<hr />

<h2 id="docker의-용도">Docker의 용도</h2>

<h3 id="빠르고-일관된-애플리케이션-제공">빠르고 일관된 애플리케이션 제공</h3>

<p>Docker는 개발자들이 애플리케이션과 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화된 환경에서 작업할 수 있게 함으로써 개발 라이프사이클을 간소화한다. 컨테이너는 지속적 통합(CI) 및 지속적 배포(CD) 워크플로우에 매우 유용하다.</p>

<p>다음 예시 시나리오를 고려해 볼 수 있다:</p>

<ul>
  <li>개발자들은 로컬에서 코드를 작성하고 Docker 컨테이너를 사용하여 동료들과 작업을 공유한다.</li>
  <li>그들은 Docker를 사용하여 애플리케이션을 테스트 환경으로 푸시하고 자동화된 테스트와 수동 테스트를 실행한다.</li>
  <li>개발자들이 버그를 발견하면, 개발 환경에서 수정하고 테스트 및 검증을 위해 테스트 환경에 다시 배포할 수 있다.</li>
  <li>테스트가 완료되면, 수정 사항을 고객에게 전달하는 것은 업데이트된 이미지를 프로덕션 환경으로 푸시하는 것만큼 간단하다.</li>
</ul>

<h3 id="반응성-높은-배포-및-확장">반응성 높은 배포 및 확장</h3>

<p>Docker의 컨테이너 기반 플랫폼은 매우 이식성이 높은 워크로드를 가능하게 한다. Docker 컨테이너는 개발자의 로컬 노트북, 데이터 센터의 물리적 또는 가상 머신, 클라우드 제공업체 또는 혼합된 환경에서 실행될 수 있다.</p>

<p>Docker의 이식성과 가벼운 특성 덕분에 비즈니스 요구에 따라 거의 실시간으로 애플리케이션과 서비스를 확장하거나 축소하는 등 워크로드를 동적으로 쉽게 관리할 수 있다.</p>

<h3 id="동일한-하드웨어에서-더-많은-워크로드-실행">동일한 하드웨어에서 더 많은 워크로드 실행</h3>

<p>Docker는 가볍고 빠르다. 이는 하이퍼바이저 기반 가상 머신에 대한 실행 가능하고 비용 효율적인 대안을 제공하므로, 서버 용량을 더 많이 활용하여 비즈니스 목표를 달성할 수 있다. Docker는 고밀도 환경과 더 적은 리소스로 더 많은 작업을 수행해야 하는 중소 규모 배포에 완벽하다.</p>

<hr />

<h2 id="docker-아키텍처">Docker 아키텍처</h2>

<p>Docker는 클라이언트-서버 아키텍처를 사용한다. Docker 클라이언트는 Docker 컨테이너의 빌드, 실행, 배포와 같은 힘든 작업을 수행하는 Docker 데몬과 통신한다. Docker 클라이언트와 데몬은 동일한 시스템에서 실행될 수도 있고, Docker 클라이언트를 원격 Docker 데몬에 연결할 수도 있다. Docker 클라이언트와 데몬은 REST API, UNIX 소켓 또는 네트워크 인터페이스를 통해 통신한다. 또 다른 Docker 클라이언트로는 Docker Compose가 있는데, 이는 여러 컨테이너로 구성된 애플리케이션 작업을 가능하게 한다.</p>

<p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="" /></p>

<h3 id="docker-데몬">Docker 데몬</h3>

<p>Docker 데몬(<code class="language-plaintext highlighter-rouge">dockerd</code>)은 Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크, 볼륨과 같은 Docker 객체를 관리한다. 데몬은 다른 데몬과 통신하여 Docker 서비스를 관리할 수도 있다.</p>

<h3 id="docker-클라이언트">Docker 클라이언트</h3>

<p>Docker 클라이언트(<code class="language-plaintext highlighter-rouge">docker</code>)는 많은 Docker 사용자가 Docker와 상호 작용하는 주요 방법이다. <code class="language-plaintext highlighter-rouge">docker run</code>과 같은 명령을 사용하면 클라이언트는 이 명령들을 <code class="language-plaintext highlighter-rouge">dockerd</code>로 보내고, <code class="language-plaintext highlighter-rouge">dockerd</code>가 이를 실행한다. <code class="language-plaintext highlighter-rouge">docker</code> 명령어는 Docker API를 사용한다. Docker 클라이언트는 하나 이상의 데몬과 통신할 수 있다.</p>

<h3 id="docker-desktop">Docker Desktop</h3>

<p>Docker Desktop은 Mac, Windows 또는 Linux 환경에 쉽게 설치할 수 있는 애플리케이션으로, 컨테이너화된 애플리케이션과 마이크로서비스를 빌드하고 공유할 수 있게 해준다. Docker Desktop에는 Docker 데몬(<code class="language-plaintext highlighter-rouge">dockerd</code>), Docker 클라이언트(<code class="language-plaintext highlighter-rouge">docker</code>), Docker Compose, Docker Content Trust, Kubernetes 및 Credential Helper가 포함된다. 자세한 내용은 <a href="https://www.google.com/search?q=/manuals/desktop/_index.md">Docker Desktop</a>을 참조하라.</p>

<h3 id="docker-레지스트리">Docker 레지스트리</h3>

<p>Docker 레지스트리는 Docker 이미지를 저장한다. Docker Hub는 누구나 사용할 수 있는 공개 레지스트리이며, Docker는 기본적으로 Docker Hub에서 이미지를 찾는다. 자신만의 비공개 레지스트리를 운영할 수도 있다.</p>

<p><code class="language-plaintext highlighter-rouge">docker pull</code> 또는 <code class="language-plaintext highlighter-rouge">docker run</code> 명령을 사용하면 Docker는 구성된 레지스트리에서 필요한 이미지를 가져온다. <code class="language-plaintext highlighter-rouge">docker push</code> 명령을 사용하면 Docker는 이미지를 구성된 레지스트리로 푸시한다.</p>

<h3 id="docker-객체">Docker 객체</h3>

<p>Docker를 사용할 때 이미지, 컨테이너, 네트워크, 볼륨, 플러그인 및 기타 객체를 생성하고 사용하게 된다. 이 섹션은 이러한 객체 중 일부에 대한 간략한 개요이다.</p>

<h4 id="이미지">이미지</h4>

<p>이미지는 Docker 컨테이너를 생성하기 위한 지침이 담긴 읽기 전용 템플릿이다. 종종 이미지는 다른 이미지를 기반으로 하여 추가적인 사용자 정의를 더한 것이다. 예를 들어, <code class="language-plaintext highlighter-rouge">ubuntu</code> 이미지를 기반으로 하되 Apache 웹 서버와 당신의 애플리케이션을 설치하고, 애플리케이션 실행에 필요한 구성 세부 정보를 포함하는 이미지를 빌드할 수 있다.</p>

<p>자신만의 이미지를 생성하거나 다른 사람이 생성하여 레지스트리에 게시한 이미지만 사용할 수도 있다. 자신만의 이미지를 빌드하려면, 이미지를 생성하고 실행하는 데 필요한 단계를 정의하는 간단한 구문을 가진 Dockerfile을 생성한다. Dockerfile의 각 명령어는 이미지에 레이어를 생성한다. Dockerfile을 변경하고 이미지를 다시 빌드하면 변경된 레이어만 다시 빌드된다. 이것이 다른 가상화 기술에 비해 이미지가 매우 가볍고, 작고, 빠른 이유 중 하나이다.</p>

<h4 id="컨테이너">컨테이너</h4>

<p>컨테이너는 이미지의 실행 가능한 인스턴스이다. Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있다. 컨테이너를 하나 이상의 네트워크에 연결하거나, 스토리지를 연결하거나, 심지어 현재 상태를 기반으로 새 이미지를 생성할 수도 있다.</p>

<p>기본적으로 컨테이너는 다른 컨테이너 및 호스트 머신과 비교적 잘 격리되어 있다. 컨테이너의 네트워크, 스토리지 또는 기타 기본 하위 시스템이 다른 컨테이너나 호스트 머신으로부터 얼마나 격리될지 제어할 수 있다.</p>

<p>컨테이너는 이미지와 함께 생성 또는 시작 시 제공하는 모든 구성 옵션에 의해 정의된다. 컨테이너가 제거되면 영구 스토리지에 저장되지 않은 상태 변경 사항은 모두 사라진다.</p>

<h5 id="docker-run-명령어-예시"><code class="language-plaintext highlighter-rouge">docker run</code> 명령어 예시</h5>

<p>다음 명령어는 <code class="language-plaintext highlighter-rouge">ubuntu</code> 컨테이너를 실행하고, 로컬 명령줄 세션에 대화형으로 연결한 다음, <code class="language-plaintext highlighter-rouge">/bin/bash</code>를 실행한다.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">-i</span> <span class="nt">-t</span> ubuntu /bin/bash
</code></pre></div></div>

<p>이 명령을 실행하면 (기본 레지스트리 구성을 사용한다고 가정할 때) 다음 과정이 발생한다:</p>

<ol>
  <li>로컬에 <code class="language-plaintext highlighter-rouge">ubuntu</code> 이미지가 없다면, Docker는 마치 <code class="language-plaintext highlighter-rouge">docker pull ubuntu</code>를 수동으로 실행한 것처럼 구성된 레지스트리에서 이미지를 가져온다.</li>
  <li>Docker는 마치 <code class="language-plaintext highlighter-rouge">docker container create</code> 명령을 수동으로 실행한 것처럼 새 컨테이너를 생성한다.</li>
  <li>Docker는 컨테이너에 읽기-쓰기 파일 시스템을 최종 레이어로 할당한다. 이를 통해 실행 중인 컨테이너는 로컬 파일 시스템에서 파일 및 디렉터리를 생성하거나 수정할 수 있다.</li>
  <li>네트워킹 옵션을 지정하지 않았기 때문에 Docker는 컨테이너를 기본 네트워크에 연결하기 위한 네트워크 인터페이스를 생성한다. 여기에는 컨테이너에 IP 주소를 할당하는 것이 포함된다. 기본적으로 컨테이너는 호스트 머신의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있다.</li>
  <li>Docker는 컨테이너를 시작하고 <code class="language-plaintext highlighter-rouge">/bin/bash</code>를 실행한다. 컨테이너가 대화형으로 실행되고 터미널에 연결되어 있으므로(<code class="language-plaintext highlighter-rouge">-i</code> 및 <code class="language-plaintext highlighter-rouge">-t</code> 플래그 때문에), 키보드를 사용하여 입력을 제공할 수 있으며 Docker는 출력을 터미널에 기록한다.</li>
  <li><code class="language-plaintext highlighter-rouge">/bin/bash</code> 명령을 종료하기 위해 <code class="language-plaintext highlighter-rouge">exit</code>를 실행하면 컨테이너는 중지되지만 제거되지는 않는다. 다시 시작하거나 제거할 수 있다.</li>
</ol>

<hr />

<h2 id="기반-기술">기반 기술</h2>

<p>Docker는 <a href="https://golang.org/">Go 프로그래밍 언어</a>로 작성되었으며, 기능을 제공하기 위해 Linux 커널의 여러 기능을 활용한다. Docker는 컨테이너라고 하는 격리된 작업 공간을 제공하기 위해 <code class="language-plaintext highlighter-rouge">namespaces</code>라는 기술을 사용한다. 컨테이너를 실행하면 Docker는 해당 컨테이너에 대한 네임스페이스 집합을 생성한다.</p>

<p>이러한 네임스페이스는 격리 계층을 제공한다. 컨테이너의 각 측면은 별도의 네임스페이스에서 실행되며 그 접근은 해당 네임스페이스로 제한된다.</p>

<hr />

<h2 id="다음-단계">다음 단계</h2>

<ul>
  <li><a href="https://www.google.com/search?q=/get-started/get-docker.md">Docker 설치</a></li>
  <li><a href="https://www.google.com/search?q=/get-started/introduction/_index.md">Docker 시작하기</a></li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Docker" /><category term="CI" /><category term="CD" /><category term="Ops" /><summary type="html"><![CDATA[Docker란 무엇인가?]]></summary></entry><entry><title type="html">Kubernetes - Overview ~ Kubernetes Components</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/04/kubernetes-001.html" rel="alternate" type="text/html" title="Kubernetes - Overview ~ Kubernetes Components" /><published>2025-09-04T00:00:00+00:00</published><updated>2025-09-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/04/kubernetes-001</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/04/kubernetes-001.html"><![CDATA[<h2 id="kubernetes-개요">Kubernetes 개요</h2>

<p>이 페이지는 Kubernetes의 개요입니다.</p>

<p>Kubernetes라는 이름은 그리스어에서 유래되었으며, 조타수나 파일럿을 의미합니다. K8s라는 약어는 “K”와 “s” 사이의 8개 글자를 센 결과입니다. Google은 2014년에 Kubernetes 프로젝트를 오픈소스로 공개했습니다. Kubernetes는 <a href="https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/">프로덕션 워크로드를 대규모로 실행한 Google의 15년 이상의 경험</a>과 커뮤니티의 최고 아이디어 및 모범 사례를 결합합니다.</p>

<h3 id="kubernetes가-필요한-이유와-할-수-있는-일">Kubernetes가 필요한 이유와 할 수 있는 일</h3>

<p>컨테이너는 애플리케이션을 번들링하고 실행하는 좋은 방법입니다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 다운타임이 없도록 보장해야 합니다. 예를 들어, 컨테이너가 다운되면 다른 컨테이너가 시작되어야 합니다. 이러한 동작을 시스템이 처리해 준다면 더 쉽지 않을까요?</p>

<p>바로 이런 상황에서 Kubernetes가 도움이 됩니다! Kubernetes는 분산 시스템을 탄력적으로 실행할 수 있는 프레임워크를 제공합니다. 애플리케이션의 스케일링과 장애 조치를 처리하고, 배포 패턴을 제공하며, 그 외에도 많은 기능을 제공합니다. 예를 들어, Kubernetes는 시스템에 대한 카나리 배포를 쉽게 관리할 수 있습니다.</p>

<h4 id="kubernetes가-제공하는-기능">Kubernetes가 제공하는 기능:</h4>

<ul>
  <li>
    <p><strong>서비스 디스커버리와 로드 밸런싱</strong>: Kubernetes는 DNS 이름이나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있습니다. 컨테이너에 대한 트래픽이 높으면, Kubernetes는 네트워크 트래픽을 로드 밸런싱하고 분산하여 배포가 안정적으로 유지되도록 할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>스토리지 오케스트레이션</strong>: Kubernetes를 사용하면 로컬 스토리지, 퍼블릭 클라우드 제공업체 등 원하는 스토리지 시스템을 자동으로 마운트할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>자동화된 롤아웃과 롤백</strong>: Kubernetes를 사용하여 배포된 컨테이너의 원하는 상태를 설명할 수 있으며, 실제 상태를 제어된 속도로 원하는 상태로 변경할 수 있습니다. 예를 들어, Kubernetes가 배포용 새 컨테이너를 생성하고, 기존 컨테이너를 제거하며, 모든 리소스를 새 컨테이너로 채택하도록 자동화할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>자동 빈 패킹</strong>: 컨테이너화된 작업을 실행하는 데 사용할 수 있는 노드 클러스터를 Kubernetes에 제공합니다. 각 컨테이너에 필요한 CPU와 메모리(RAM) 양을 Kubernetes에 알려주면, Kubernetes가 리소스를 최대한 활용할 수 있도록 노드에 컨테이너를 배치할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>자가 치유</strong>: Kubernetes는 실패한 컨테이너를 재시작하고, 컨테이너를 교체하며, 사용자 정의 상태 확인에 응답하지 않는 컨테이너를 종료하고, 서비스할 준비가 될 때까지 클라이언트에 알리지 않습니다.</p>
  </li>
  <li>
    <p><strong>시크릿과 구성 관리</strong>: Kubernetes를 사용하면 비밀번호, OAuth 토큰, SSH 키와 같은 민감한 정보를 저장하고 관리할 수 있습니다. 컨테이너 이미지를 재빌드하지 않고도 시크릿과 애플리케이션 구성을 배포하고 업데이트할 수 있으며, 스택 구성에서 시크릿을 노출하지 않습니다.</p>
  </li>
  <li>
    <p><strong>배치 실행</strong>: 서비스 외에도, Kubernetes는 배치 및 CI 워크로드를 관리할 수 있으며, 원할 경우 실패한 컨테이너를 교체할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>수평 확장</strong>: 간단한 명령, UI 또는 CPU 사용량을 기반으로 자동으로 애플리케이션을 확장하거나 축소할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>IPv4/IPv6 듀얼 스택</strong>: Pod와 Service에 IPv4 및 IPv6 주소 할당</p>
  </li>
  <li>
    <p><strong>확장성을 위한 설계</strong>: 업스트림 소스 코드를 변경하지 않고도 Kubernetes 클러스터에 기능을 추가할 수 있습니다.</p>
  </li>
</ul>

<h3 id="kubernetes가-아닌-것">Kubernetes가 아닌 것</h3>

<p>Kubernetes는 기존의 모든 것을 포함하는 PaaS(Platform as a Service) 시스템이 아닙니다. Kubernetes는 하드웨어 수준이 아닌 컨테이너 수준에서 작동하므로, 배포, 스케일링, 로드 밸런싱과 같은 PaaS 제품에 공통적인 일반적으로 적용 가능한 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있게 합니다. 하지만 Kubernetes는 모놀리식이 아니며, 이러한 기본 솔루션은 선택 사항이고 플러그인 방식입니다. Kubernetes는 개발자 플랫폼을 구축하기 위한 빌딩 블록을 제공하지만, 중요한 부분에서는 사용자의 선택과 유연성을 보존합니다.</p>

<h4 id="kubernetes는">Kubernetes는:</h4>

<ul>
  <li>
    <p><strong>지원하는 애플리케이션 유형을 제한하지 않습니다</strong>: Kubernetes는 상태 없는 워크로드, 상태 있는 워크로드, 데이터 처리 워크로드를 포함하여 극도로 다양한 워크로드를 지원하는 것을 목표로 합니다. 애플리케이션이 컨테이너에서 실행될 수 있다면, Kubernetes에서 잘 실행되어야 합니다.</p>
  </li>
  <li>
    <p><strong>소스 코드를 배포하지 않고 애플리케이션을 빌드하지 않습니다</strong>: CI/CD(지속적 통합, 배포 및 배치) 워크플로는 조직 문화와 선호도뿐만 아니라 기술적 요구사항에 의해 결정됩니다.</p>
  </li>
  <li>
    <p><strong>미들웨어(예: 메시지 버스), 데이터 처리 프레임워크(예: Spark), 데이터베이스(예: MySQL), 캐시, 클러스터 스토리지 시스템(예: Ceph)과 같은 애플리케이션 수준 서비스를 내장 서비스로 제공하지 않습니다</strong>: 이러한 구성 요소는 Kubernetes에서 실행될 수 있으며, <a href="https://openservicebrokerapi.org/">Open Service Broker</a>와 같은 포터블 메커니즘을 통해 Kubernetes에서 실행되는 애플리케이션에서 액세스할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>로깅, 모니터링 또는 알림 솔루션을 지시하지 않습니다</strong>: 개념 증명으로서의 일부 통합과 메트릭을 수집하고 내보내는 메커니즘을 제공합니다.</p>
  </li>
  <li>
    <p><strong>구성 언어/시스템(예: Jsonnet)을 제공하거나 요구하지 않습니다</strong>: 임의 형태의 선언적 사양에 의해 대상이 될 수 있는 선언적 API를 제공합니다.</p>
  </li>
  <li>
    <p><strong>포괄적인 머신 구성, 유지 관리, 관리 또는 자가 치유 시스템을 제공하거나 채택하지 않습니다</strong>.</p>
  </li>
  <li>
    <p><strong>추가로, Kubernetes는 단순한 오케스트레이션 시스템이 아닙니다</strong>: 사실, 오케스트레이션의 필요성을 제거합니다. 오케스트레이션의 기술적 정의는 정의된 워크플로의 실행입니다: 먼저 A를 수행하고, 그 다음 B를, 그 다음 C를 수행합니다. 반대로, Kubernetes는 제공된 원하는 상태로 현재 상태를 지속적으로 추진하는 독립적이고 구성 가능한 제어 프로세스 집합으로 구성됩니다. A에서 C로 가는 방법은 중요하지 않습니다. 중앙 집중식 제어도 필요하지 않습니다. 이로 인해 사용하기 더 쉽고 더 강력하고, 견고하며, 탄력적이고 확장 가능한 시스템이 만들어집니다.</p>
  </li>
</ul>

<h3 id="kubernetes의-역사적-맥락">Kubernetes의 역사적 맥락</h3>

<p>시간을 거슬러 올라가서 Kubernetes가 왜 그렇게 유용한지 살펴보겠습니다.</p>

<h4 id="전통적-배포-시대">전통적 배포 시대:</h4>
<p>초기에 조직들은 물리 서버에서 애플리케이션을 실행했습니다. 물리 서버에서 애플리케이션의 리소스 경계를 정의할 방법이 없었고, 이로 인해 리소스 할당 문제가 발생했습니다. 예를 들어, 여러 애플리케이션이 물리 서버에서 실행되는 경우, 하나의 애플리케이션이 대부분의 리소스를 차지하여 다른 애플리케이션들의 성능이 저하되는 경우가 있을 수 있습니다. 이에 대한 해결책은 각 애플리케이션을 다른 물리 서버에서 실행하는 것이었습니다. 그러나 리소스가 충분히 활용되지 않았고, 조직이 많은 물리 서버를 유지하는 데 비용이 많이 들어 확장성이 없었습니다.</p>

<h4 id="가상화-배포-시대">가상화 배포 시대:</h4>
<p>해결책으로 가상화가 도입되었습니다. 단일 물리 서버의 CPU에서 여러 가상 머신(VM)을 실행할 수 있게 해줍니다. 가상화를 통해 애플리케이션을 VM 간에 격리할 수 있고, 한 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스할 수 없으므로 보안 수준을 제공합니다.</p>

<p>가상화를 통해 물리 서버의 리소스를 더 잘 활용할 수 있고, 애플리케이션을 쉽게 추가하거나 업데이트할 수 있어 더 나은 확장성을 제공하며, 하드웨어 비용을 줄이는 등 많은 이점이 있습니다. 가상화를 통해 물리 리소스 집합을 일회용 가상 머신 클러스터로 제시할 수 있습니다.</p>

<p>각 VM은 가상화된 하드웨어 위에서 자체 운영 체제를 포함한 모든 구성 요소를 실행하는 완전한 머신입니다.</p>

<h4 id="컨테이너-배포-시대">컨테이너 배포 시대:</h4>
<p>컨테이너는 VM과 유사하지만, 애플리케이션 간에 운영 체제(OS)를 공유하기 위해 격리 속성이 완화되었습니다. 따라서 컨테이너는 경량으로 간주됩니다. VM과 마찬가지로, 컨테이너는 자체 파일 시스템, CPU 공유, 메모리, 프로세스 공간 등을 가지고 있습니다. 기본 인프라에서 분리되어 있어서 클라우드와 OS 배포판 간에 이식 가능합니다.</p>

<p>컨테이너는 다음과 같은 추가적인 이점을 제공하기 때문에 인기가 높아졌습니다:</p>

<ul>
  <li>
    <p><strong>민첩한 애플리케이션 생성 및 배포</strong>: VM 이미지 사용에 비해 컨테이너 이미지 생성의 용이성과 효율성이 증가합니다.</p>
  </li>
  <li>
    <p><strong>지속적인 개발, 통합 및 배포</strong>: (이미지 불변성으로 인한) 빠르고 효율적인 롤백과 함께 신뢰할 수 있고 빈번한 컨테이너 이미지 빌드 및 배포를 제공합니다.</p>
  </li>
  <li>
    <p><strong>개발과 운영의 관심사 분리</strong>: 배포 시간이 아닌 빌드/릴리스 시간에 애플리케이션 컨테이너 이미지를 생성하여 애플리케이션을 인프라에서 분리합니다.</p>
  </li>
  <li>
    <p><strong>관찰 가능성</strong>: OS 수준 정보와 메트릭뿐만 아니라 애플리케이션 상태 및 기타 신호도 표시합니다.</p>
  </li>
  <li>
    <p><strong>개발, 테스트 및 프로덕션 환경의 일관성</strong>: 랩톱에서 실행되는 것과 클라우드에서 실행되는 것이 동일합니다.</p>
  </li>
  <li>
    <p><strong>클라우드 및 OS 배포 이식성</strong>: Ubuntu, RHEL, CoreOS, 온프레미스, 주요 퍼블릭 클라우드 및 기타 모든 곳에서 실행됩니다.</p>
  </li>
  <li>
    <p><strong>애플리케이션 중심 관리</strong>: 가상 하드웨어에서 OS를 실행하는 것에서 논리적 리소스를 사용하여 OS에서 애플리케이션을 실행하는 것으로 추상화 수준을 높입니다.</p>
  </li>
  <li>
    <p><strong>느슨하게 결합되고, 분산되며, 탄력적이고, 해방된 마이크로서비스</strong>: 애플리케이션이 더 작고 독립적인 조각으로 나뉘며 동적으로 배포 및 관리될 수 있습니다 – 하나의 큰 단일 목적 머신에서 실행되는 모놀리식 스택이 아닙니다.</p>
  </li>
  <li>
    <p><strong>리소스 격리</strong>: 예측 가능한 애플리케이션 성능.</p>
  </li>
  <li>
    <p><strong>리소스 활용</strong>: 높은 효율성과 밀도.</p>
  </li>
</ul>

<h2 id="kubernetes-구성-요소">Kubernetes 구성 요소</h2>

<p>이 페이지는 Kubernetes 클러스터를 구성하는 필수 구성 요소에 대한 고수준 개요를 제공합니다.</p>

<p><img src="/assets/images/posts/2025-09/2025-09-04-004.png" alt="" /></p>

<blockquote>
  <p>쿠버네티스 클러스터의 구성요소</p>
</blockquote>

<h3 id="kubernetes-클러스터의-구성-요소">Kubernetes 클러스터의 구성 요소</h3>

<h4 id="핵심-구성-요소">핵심 구성 요소</h4>

<p>Kubernetes 클러스터는 컨트롤 플레인과 하나 이상의 워커 노드로 구성됩니다. 주요 구성 요소에 대한 간략한 개요는 다음과 같습니다:</p>

<h3 id="컨트롤-플레인-구성-요소">컨트롤 플레인 구성 요소</h3>

<p>클러스터의 전체 상태를 관리합니다:</p>

<ul>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#kube-apiserver">kube-apiserver</a></strong> - Kubernetes HTTP API를 노출하는 핵심 구성 요소 서버입니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#etcd">etcd</a></strong> - 모든 API 서버 데이터를 위한 일관되고 고가용성을 갖춘 키-값 저장소입니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#kube-scheduler">kube-scheduler</a></strong> - 아직 노드에 바인딩되지 않은 Pod를 찾아서 각 Pod를 적절한 노드에 할당합니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#kube-controller-manager">kube-controller-manager</a></strong> - Kubernetes API 동작을 구현하기 위해 <a href="/docs/concepts/architecture/controller/">controllers</a>를 실행합니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#cloud-controller-manager">cloud-controller-manager</a></strong> (선택사항) - 기반 클라우드 제공업체와 통합합니다.</p>
  </li>
</ul>

<h3 id="노드-구성-요소">노드 구성 요소</h3>

<p>모든 노드에서 실행되어 실행 중인 파드를 유지하고 Kubernetes 런타임 환경을 제공합니다:</p>

<ul>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#kubelet">kubelet</a></strong> - 컨테이너를 포함한 Pod가 실행되도록 보장합니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#kube-proxy">kube-proxy</a></strong> (선택사항) - <a href="/docs/concepts/services-networking/service/">Services</a>를 구현하기 위해 노드에서 네트워크 규칙을 유지합니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#container-runtime">Container runtime</a></strong> - 컨테이너 실행을 담당하는 소프트웨어입니다. 자세한 내용은 <a href="/docs/setup/production-environment/container-runtimes/">Container Runtimes</a>를 참조하세요.</p>
  </li>
</ul>

<h3 id="추가-정보"><a href="#third-party-content-disclaimer">추가 정보</a></h3>

<p>클러스터에서 각 노드에 추가 소프트웨어가 필요할 수 있습니다. 예를 들어, Linux 노드에서 로컬 구성 요소를 감독하기 위해 <a href="https://systemd.io/">systemd</a>를 실행할 수도 있습니다.</p>

<h3 id="애드온">애드온</h3>

<p>애드온은 Kubernetes의 기능을 확장합니다. 몇 가지 중요한 예는 다음과 같습니다:</p>

<ul>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#dns">DNS</a></strong> - 클러스터 전체 DNS 해석을 위한 구성 요소입니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#web-ui-dashboard">Web UI</a></strong> (Dashboard) - 웹 인터페이스를 통한 클러스터 관리를 위한 구성 요소입니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#container-resource-monitoring">Container Resource Monitoring</a></strong> - 컨테이너 메트릭을 수집하고 저장하기 위한 구성 요소입니다.</p>
  </li>
  <li>
    <p><strong><a href="/docs/concepts/architecture/#cluster-level-logging">Cluster-level Logging</a></strong> - 컨테이너 로그를 중앙 로그 저장소에 저장하기 위한 구성 요소입니다.</p>
  </li>
</ul>

<h3 id="아키텍처의-유연성">아키텍처의 유연성</h3>

<p>Kubernetes는 이러한 구성 요소가 배포되고 관리되는 방식에서 유연성을 허용합니다. 아키텍처는 소규모 개발 환경부터 대규모 프로덕션 배포까지 다양한 요구사항에 맞게 조정될 수 있습니다.</p>

<p>각 구성 요소와 클러스터 아키텍처를 구성하는 다양한 방법에 대한 자세한 정보는 <a href="/docs/concepts/architecture/">클러스터 아키텍처</a> 페이지를 참조하세요.</p>

<h2 id="출처">출처</h2>

<p><a href="https://kubernetes.io/docs/concepts/overview/">Kubernetes 공식 문서</a></p>

<p><a href="https://kubernetes.io/docs/concepts/overview/components/">Kubernetes 공식 문서</a></p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Kubernetes" /><category term="CI" /><category term="CD" /><category term="Ops" /><summary type="html"><![CDATA[Kubernetes 개요]]></summary></entry><entry><title type="html">CS 학습 - 9월 1주차</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/03/cs.html" rel="alternate" type="text/html" title="CS 학습 - 9월 1주차" /><published>2025-09-03T00:00:00+00:00</published><updated>2025-09-03T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/03/cs</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/03/cs.html"><![CDATA[<h2 id="introduction">introduction</h2>

<p>CS 관련하여 부족한 부분들이 조금 있다고 생각했다. 
기술 면접을 준비하기 위해, 특히나 백엔드 특화 내용을 확실하게 정리하기 위해 하루에 30분 정도만 소비하기로 했다. 오전 첫 시작 시간을 위한 거라고 보면 될 듯 싶다.</p>

<p>외우는 것까지 되면 좋겠지만… 안되면 일단 기록이라도 제대로 해둬야 하니…</p>

<p>기본 내용은 꽤 괜찮은 글의 내용이 있어 <a href="https://mangkyu.tistory.com/88">여기</a>를 참고하고, 추가적으로 찾아 다니며 정리한 내용들을 기재하려고 한다.</p>

<h2 id="프로그래밍-공통">프로그래밍 공통</h2>

<h3 id="oop란">OOP란</h3>
<p>현실 세계의 구조, 동작, 추상적 개념을 프로그래밍에 옮겨와 특징과 기능으로 구현해내는 프로그래밍 기법으로, 코드 작성시 재 사용성, 변형 가능성 등을 높이는 특징을 가진다.</p>

<h3 id="oop-5가지-설계-원칙">OOP 5가지 설계 원칙</h3>
<ul>
  <li><strong>SRP(Single Responsibility Principle, 단일 책임 원칙)</strong>: 클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.</li>
  <li><strong>OCP(Open-Closed Principle, 개방 폐쇠 원칙)</strong>: 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.</li>
  <li><strong>LSP(Liskov Substitution Principle, 리스코프 치환 원칙)</strong>: 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 한다.</li>
  <li><strong>ISP(Interface Segregation Principle, 인터페이스 분리 원칙)</strong>: 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 한다.</li>
  <li><strong>DIP(Dependency Inversion Principle, 의존 역전 법칙)</strong>: 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해선 안된다.</li>
</ul>

<h3 id="절차-지향-프로그래밍-vs-객체-지향-프로그래밍">절차 지향 프로그래밍 vs 객체 지향 프로그래밍</h3>
<ul>
  <li>절차 지향
    <ol>
      <li>순차 처리 중시</li>
      <li>C 언어와 같은 언어가 대표적</li>
      <li>컴퓨터의 바이너리 처리와 유사하므로, 실행속도가 빠름</li>
      <li>코드 순서 변경 = 결과 바뀔 가능성 있음</li>
    </ol>
  </li>
  <li>객체 지향
    <ol>
      <li>실 세계를 객체화</li>
      <li>C++, Java, Python 등</li>
      <li>캡슐화, 상속, 다형성 기법 등으로 보다 추상화된 형태</li>
      <li>절차 지향보단 당연히 느릴 수 있음</li>
    </ol>
  </li>
</ul>

<h3 id="rest-api-와-restful-api">REST API 와 RESTful API</h3>
<ul>
  <li>REST 는 HTTP를 활용한 아키텍처 스타일이고, REST API 는 이를 기반한 API 이다. RESTful API 라고 함은, REST 의 원칙, 제약조건을 최대한 잘 따르며 설계한 API 를 의미, 즉 REST 는 개념 및 원칙이고 ful 이 붙으면 이를 구현한 결과물이라 볼 수 있다.</li>
  <li>REST 는 REpresentational State Transfer 의 약자로, 네트워크 상태가 전이되는 표현을 의미한다.</li>
  <li>REST 원칙
    <ul>
      <li>
        <p><strong>클라이언트-서버 디커플링</strong>. REST API 디자인에서 클라이언트와 서버 애플리케이션은 서로 간에 완전히 독립적이어야 한다. 클라이언트 애플리케이션이 알아야 하는 유일한 정보는 요청된 리소스의 URI이며, 이는 다른 방법으로 서버 애플리케이션과 상호작용할 수 없다. 이와 유사하게, 서버 애플리케이션은 HTTP를 통해 요청된 데이터에 전달하는 것 말고는 클라이언트 애플리케이션을 수정하지 않아야 한다.</p>
      </li>
      <li>
        <p><strong>Stateless</strong>. REST API는 stateless이다. 이는 각 요청에서 이의 처리에 필요한 모든 정보를 포함해야 함을 의미한다. 즉, REST API는 서버측 세션을 필요로 하지 않는다. 서버 애플리케이션은 클라이언트 요청과 관련된 데이터를 저장할 수 없다.</p>
      </li>
      <li>
        <p><strong>캐싱 가능성</strong>. 가능하면 리소스를 클라이언트 또는 서버측에서 캐싱할 수 있어야 한다. 또한 서버 응답에는 전달된 리소스에 대해 캐싱이 허용되는지 여부에 대한 정보도 포함되어야 한다. 이의 목적은 서버측의 확장성 증가와 함께 클라이언트측의 성능 향상을 동시에 얻는 것이다.</p>
      </li>
      <li>
        <p><strong>계층 구조 아키텍처</strong>. REST API에서는 호출과 응답이 서로 다른 계층을 통과한다. 경험에 따르면 클라이언트와 서버 애플리케이션이 서로 간에 직접 연결된다고 가정하지 않는 것이 좋다. 통신 루프에는 다수의 서로 다른 중개자가 있을 수 있다. REST API는 엔드 애플리케이션 또는 중개자와 통신하는지 여부를 클라이언트나 서버가 알 수 없도록 설계되어야 한다.</p>
      </li>
      <li>
        <p>코드 온디맨드(옵션). REST API는 일반적으로 정적 리소스를 전송하지만, 특정한 경우에는 응답에 실행 코드(예: Java 애플릿)를 포함할 수도 있다. 이 경우에 코드는 요청 시에만 실행되어야 한다.</p>
      </li>
      <li>
        <p>균일한 인터페이스. 요청이 어디에서 오는지와 무관하게, 동일한 리소스에 대한 모든 API 요청은 동일하게 보여야 한다. REST API는 사용자의 이름이나 이메일 주소 등의 동일한 데이터 조각이 오직 하나의 URI(Uniform Resource Identifier)에 속함을 보장해야 한다. 리소스가 너무 클 필요는 없지만, 이는 클라이언트가 필요로 하는 모든 정보를 포함해야 한다.</p>
      </li>
    </ul>
  </li>
  <li>REST 구성요소
    <ul>
      <li>
        <p><strong>자원(Resource) by URI</strong> : REST API 는 URI 를 통해 사용할 자원을 명시한다. 보통은 이떄 URI 에 명시되는 자원은 PK 와 같은 고유한 ID 값이다.</p>
      </li>
      <li>
        <p><strong>행위(Verb) by HTTP Method</strong> : REST API 는 HTTP Method (GET, POST, PUT, DELETE 등) 를 사용하여 URI 에 명시된 자원에 대해 어떠한 행위를 수행할 것인지를 명시한다.</p>
      </li>
      <li>
        <p><strong>표현(Representation of Resource)</strong> : REST API 에서 리소스는 다양한 형태(JSON, XML, TEXT, RSS 등)로 표현될 수 있다. 보통은 JSON 또는 XML 을 통해 데이터를 주고받는 것이 일반적이다.</p>
      </li>
      <li>
        <p><a href="https://developer.mozilla.org/ko/docs/Glossary/REST">참고자료</a></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="메모리-구조">메모리 구조</h3>
<p><img src="/assets/images/posts/2025-09/2025-09-03-001.png" alt="" /></p>
<ul>
  <li><strong>코드 영역</strong>: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부른다. 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 메모리로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 된다.</li>
  <li><strong>데이터 영역</strong>: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.</li>
  <li><strong>힙 영역</strong>: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 부른다. Java에서는 가비지 컬렉터가 자동으로 해제해준다. 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당된다.</li>
  <li><strong>스택 영역</strong>: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역이다. 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 한다. 스택 영역은 함수의 호출이 완료되면 소멸한다. 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당된다.</li>
</ul>

<h3 id="메모리-구조-심화---java-와-javascript">메모리 구조 심화 - Java 와 JavaScript</h3>
<ul>
  <li><strong>핵심 요약: 관리 주체와 방식의 차이</strong> : Java와 JavaScript는 둘 다 자동 메모리 관리(가비지 컬렉션)를 사용하지만, <strong>Java는 JVM(자바 가상 머신) 위에서 보다 체계적이고 개발자가 직접 관여할 수 있는 옵션이 많은 반면, JavaScript는 브라우저의 엔진에 의해 더 추상화되고 자동화된 방식으로 메모리를 관리</strong>한다.</li>
</ul>

<h4 id="java의-메모리-사용-방식"><strong>Java의 메모리 사용 방식</strong></h4>
<ul>
  <li>Java 애플리케이션은 <strong>JVM(Java Virtual Machine)</strong> 위에서 실행되며, JVM은 운영체제로부터 할당받은 메모리 영역(Runtime Data Area)을 용도에 따라 여러 부분으로 나누어 관리한다.</li>
  <li><strong>메서드(Method) 영역</strong>: 클래스, 변수, 메서드 등과 같은 클래스 정보가 저장된다. 이 영역은 모든 스레드가 공유한다.</li>
  <li><strong>힙(Heap) 영역</strong>: <code class="language-plaintext highlighter-rouge">new</code> 키워드로 생성된 객체와 배열이 저장되는 공간이다. 가비지 컬렉터(Garbage Collector)가 주로 활동하는 영역으로, 더 이상 참조되지 않는 객체를 찾아 메모리에서 해제한다.
    <ul>
      <li><strong>Young Generation</strong>: 새롭게 생성된 객체가 위치한다. 이곳에서 많은 객체들이 생성되고 빠르게 사라진다.</li>
      <li><strong>Old Generation</strong>: Young Generation 영역에서 오랫동안 살아남은 객체들이 이동하는 곳이다.</li>
    </ul>
  </li>
  <li><strong>스택(Stack) 영역</strong>: 메서드 호출 시 생성되는 지역 변수, 매개변수, 리턴 값 등이 저장된다. 메서드 호출이 끝나면 해당 스택 프레임은 자동으로 사라지므로 데이터도 함께 제거된다. 각 스레드마다 별도의 스택이 생성된다.</li>
</ul>

<h4 id="javascript의-메모리-사용-방식"><strong>JavaScript의 메모리 사용 방식</strong></h4>
<p>JavaScript는 주로 웹 브라우저의 JavaScript 엔진(예: Chrome의 V8)에 의해 메모리가 관리된다. Java와 유사하게 힙과 스택을 사용하지만, 개발자가 직접 제어할 수 있는 부분은 거의 없다.</p>
<ul>
  <li><strong>메모리 생명 주기</strong>: JavaScript의 메모리 관리는 할당, 사용, 해제의 3단계 생명 주기를 따른다.
    <ol>
      <li><strong>할당 (Allocation)</strong>: 변수 선언, 함수 정의, 객체 생성 시 엔진이 자동으로 메모리를 할당한다.</li>
      <li><strong>사용 (Use)</strong>: 할당된 메모리에 값을 읽고 쓰는 작업을 한다.</li>
      <li><strong>해제 (Release)</strong>: 더 이상 필요 없는 메모리는 가비지 컬렉터에 의해 자동으로 회수된다.</li>
    </ol>
  </li>
  <li><strong>메모리 공간</strong>:
    <ul>
      <li><strong>콜 스택(Call Stack)</strong>: 함수가 호출될 때마다 해당 함수의 실행 컨텍스트(함수 정보, 인자, 지역 변수 등)가 순서대로 쌓이는 곳이다. 원시 타입(Primitive types) 데이터가 이곳에 저장된다.</li>
      <li><strong>힙(Heap)</strong>: 객체, 배열, 함수와 같이 크기가 정해지지 않은 참조 타입(Reference types) 데이터가 저장되는 공간이다. 콜 스택에는 힙에 저장된 데이터의 주소(참조)만 저장된다.</li>
    </ul>
  </li>
  <li><strong>가비지 컬렉션</strong>: JavaScript 엔진은 ‘도달 가능성(reachability)’ 개념을 사용하여 더 이상 참조되지 않는 객체를 찾아 메모리에서 제거한다. 특정 객체에 접근할 수 있는 경로가 하나도 없으면 가비지 컬렉션의 대상이 된다.</li>
</ul>

<h4 id="주요-차이점-정리"><strong>주요 차이점 정리</strong></h4>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>Java</th>
      <th>JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**실행 환경**</td>
      <td>JVM (Java Virtual Machine)</td>
      <td>JavaScript 엔진 (e.g., V8, SpiderMonkey)</td>
    </tr>
    <tr>
      <td>**메모리 구조**</td>
      <td>메서드, 힙, 스택 등으로 명확하게 구분</td>
      <td>콜 스택, 힙으로 단순하게 구분</td>
    </tr>
    <tr>
      <td>**데이터 타입**</td>
      <td>원시 타입은 스택, 참조 타입은 힙에 저장</td>
      <td>원시 타입은 콜 스택, 참조 타입은 힙에 저장</td>
    </tr>
    <tr>
      <td>**개발자 제어**</td>
      <td>힙 크기 조절, GC 알고리즘 선택 등 일부 제어 가능</td>
      <td>메모리 관리에 거의 관여할 수 없음</td>
    </tr>
  </tbody>
</table>

<h4 id="jvm을-계속-쓰는-이유는">JVM을 계속 쓰는 이유는?</h4>
<p>초기 JVM은 코드를 한 줄씩 해석하는 인터프리터 방식의 비중이 높아 속도가 느리다는 평가를 받았지만, 오늘날의 JVM은 다음과 같은 기술들을 통해 높은 성능을 보여준다.</p>

<ol>
  <li><strong>고도로 발전된 JIT(Just-In-Time) 컴파일러</strong>
    <ul>
      <li><strong>프로파일링 기반 최적화</strong>: JVM은 단순히 코드를 기계어로 번역하는 것을 넘어, 애플리케이션이 실행되는 동안 <strong>코드의 어떤 부분이 자주 사용되는지(‘뜨거운’ 코드)를 지속적으로 분석</strong>한다.</li>
      <li><strong>적응형 최적화(Adaptive Optimization)</strong>: 자주 사용되는 코드는 더욱 공격적으로 최적화된 기계어로 재컴파일한다. 예를 들어, 처음에는 빠르게 컴파일하고(C1 컴파일러), 해당 코드가 계속해서 많이 쓰이면 시간을 더 들여 최고 수준으로 최적화한다(C2 컴파일러). 이런 동적인 최적화 방식 덕분에 시간이 지날수록 애플리케이션의 성능이 점차 향상된다.</li>
    </ul>
  </li>
  <li><strong>혁신적인 가비지 컬렉터(GC)의 발전</strong>
    <ul>
      <li>과거의 GC는 메모리를 정리하는 동안 애플리케이션 실행이 멈추는 <strong>‘Stop-the-world’</strong> 현상 때문에 성능 저하의 주된 원인이었다.</li>
      <li><strong>G1 GC (Garbage-First)</strong>: Java 9부터 기본 GC로 채택되었으며, 전체 힙(Heap) 영역을 작은 구역(Region)으로 나누어 관리한다. 이를 통해 짧은 멈춤 시간(Pause Time)을 예측 가능하게 유지하면서도 효율적으로 메모리를 정리한다.</li>
      <li><strong>ZGC 및 Shenandoah GC</strong>: 최신 Java 버전에 도입된 이 GC들은 <strong>멈춤 시간을 수 밀리초(ms) 단위로 극단적으로 줄이는 것</strong>을 목표로 한다. 수백 기가바이트(GB)에 달하는 거대한 메모리를 사용하는 시스템에서도 애플리케이션의 중단 없이 메모리를 정리할 수 있어, 대규모 서비스에서 매우 중요한다.</li>
    </ul>
  </li>
  <li><strong>JVM 자체의 내부 최적화</strong>
    <ul>
      <li><strong>이스케이프 분석(Escape Analysis)</strong>: 객체가 특정 메서드 안에서만 사용되고 외부로 벗어나지 않는다고 판단되면, 비싼 메모리 공간인 힙(Heap)이 아니라 훨씬 빠른 스택(Stack)에 객체를 할당한다. 이는 GC의 부담을 크게 줄여준다.</li>
      <li><strong>프로젝트 룸(Project Loom)</strong>: 최신 Java에 도입된 ‘가상 스레드(Virtual Threads)’ 기능이다. 기존 스레드보다 훨씬 가볍게 만들 수 있어, 적은 자원으로 수백만 개의 동시 작업을 처리할 수 있게 해준다. 이는 JVM 수준에서 동시성 처리 방식을 근본적으로 개선한 것이다.</li>
    </ul>
  </li>
</ol>

<h4 id="js-가-과거보다-빨라진-이유는">JS 가 과거보다 빨라진 이유는?</h4>
<p>기존의 JS의 철학, 그리고 이를 구동하는 엔진은 편리했으나 한계가 많았다. 비표준의 엉망인 상황에 성능까지 좋지 못했으나, V8 엔진은 다음과 같은 핵심 기술들을 통해 JavaScript의 성능을 크게 향상시킨다.</p>

<ol>
  <li><strong>JIT (Just-In-Time) 컴파일러 도입</strong>
    <ul>
      <li><strong>과거 방식</strong>: 코드를 한 줄씩 읽고 해석하는 <strong>인터프리터(Interpreter)</strong> 방식을 무조건적으로 사용해 속도가 느렸다.</li>
      <li><strong>V8 방식</strong>: JavaScript 코드를 실행 직전에 <strong>기계어(Machine Code)</strong>로 컴파일한다. 이는 사람이 이해하는 언어를 컴퓨터 CPU가 직접 이해하는 언어로 미리 번역해두는 것과 같아 실행 속도가 매우 빨라진다.</li>
    </ul>
  </li>
  <li><strong>최적화 컴파일러: 이그니션(Ignition)과 터보팬(TurboFan)</strong>
    <ul>
      <li>V8은 단순히 코드를 번역하는 것을 넘어, 2단계에 걸친 최적화 전략을 사용한다.</li>
      <li><strong>이그니션 (Ignition)</strong>: 먼저 코드를 빠르게 실행하기 위해 <strong>바이트코드(Bytecode)</strong>로 변환한다. 이는 시작 속도를 빠르게 만들어 준다.</li>
      <li><strong>터보팬 (TurboFan)</strong>: 코드가 실행되는 동안, 자주 사용되는 ‘뜨거운(hot)’ 부분을 감시한다. 그리고 이 부분을 <strong>매우 최적화된 기계어</strong>로 다시 컴파일하여, 반복적인 작업의 성능을 극대화한다.</li>
    </ul>
  </li>
  <li><strong>객체 속성 접근 속도 향상: 히든 클래스(Hidden Class)</strong>
    <ul>
      <li>JavaScript는 객체의 구조가 동적으로 바뀔 수 있어 속성 접근이 느릴 수 있다.</li>
      <li>V8은 비슷한 구조의 객체들을 내부적으로 <strong>같은 ‘히든 클래스(Hidden Class)’로 묶어 관리</strong>한다. 이를 통해 객체의 속성이 메모리의 어디에 위치하는지 미리 예측하고 빠르게 접근할 수 있게 된다.</li>
    </ul>
  </li>
  <li><strong>가비지 컬렉션(GC) 최적화</strong>
    <ul>
      <li>더 이상 사용하지 않는 메모리를 정리하는 가비지 컬렉션 과정이 프로그램의 실행을 잠시 멈추게 할 수 있다.</li>
      <li>V8은 이 멈춤 현상(stop-the-world)을 최소화하기 위해, <strong>여러 개의 스레드를 활용하여 병렬적</strong>으로 메모리를 정리하고, 세대별(Generational)로 나누어 효율적으로 관리하는 등 다양한 최적화 기법을 사용한다.</li>
    </ul>
  </li>
</ol>

<h3 id="docker-개요-정리">Docker 개요 정리</h3>

<p><strong>Docker</strong>는 애플리케이션을 <strong>‘컨테이너’</strong>라는 격리된 표준 단위로 패키징하여 개발, 배포, 실행하는 개방형 플랫폼이다. 컨테이너는 코드, 라이브러리 등 애플리케이션 실행에 필요한 모든 것을 포함하고 있어, 개발자의 PC부터 실제 운영 서버에 이르기까지 <strong>어떤 환경에서든 동일하게 동작하는 것을 보장한다.</strong> 이를 통해 “제 컴퓨터에서는 잘 되는데요?”와 같은 고질적인 문제를 해결하고, 소프트웨어를 빠르고 일관되게 전달하는 CI/CD(지속적 통합/배포) 과정을 효율적으로 만든다.</p>

<p>이러한 Docker는 사용자의 명령을 받는 <strong>클라이언트</strong>와 실제 컨테이너를 관리하는 <strong>데몬(서버)</strong>으로 구성된 구조로 동작한다. 개발자는 읽기 전용 템플릿인 <strong>‘이미지’</strong>를 바탕으로 실행 가능한 인스턴스인 <strong>‘컨테이너’</strong>를 생성하고 관리하게 된다. 이러한 방식은 기존의 가상 머신(VM)보다 훨씬 가볍고 빨라 서버 자원을 효율적으로 사용할 수 있게 하며, 높은 이식성으로 어떤 환경으로든 애플리케이션을 쉽게 이전하고 확장할 수 있는 장점을 제공한다.</p>

<p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="" /></p>

<blockquote>
  <p>하나 알 게 된거… 클라이언트 - 서버 구조니 데몬과 클라이언트를 조작하면 원격지에 데몬을 내 컴퓨터에서 조작하는 것도 가능해지는 구나..!</p>
</blockquote>

<h3 id="kubernetes-개요-정리">Kubernetes 개요 정리</h3>

<p>Kubernetes는 분산 시스템을 탄력적으로 운영할 수 있는 프레임워크를 제공한다. 컨테이너가 다운되면 자동으로 새 컨테이너를 시작하고, 트래픽이 증가하면 로드밸런싱을 수행하며, 애플리케이션의 스케일링과 장애 조치를 자동화한다. 주요 기능으로는 서비스 디스커버리, 스토리지 오케스트레이션, 자동 롤아웃/롤백, 자가 치유, 시크릿 관리, 수평 확장 등이 있어 개발자가 인프라 관리보다는 애플리케이션 개발에 집중할 수 있게 해준다.</p>

<p>Kubernetes는 기존 PaaS와 달리 특정 애플리케이션 타입을 제한하지 않으며, 소스 코드 배포나 빌드 기능은 제공하지 않는다. 대신 컨테이너 수준에서 작동하여 개발자에게 선택권과 유연성을 제공하는 빌딩 블록 역할을 한다. 물리 서버 → 가상화 → 컨테이너로 이어진 인프라 진화 과정에서, 컨테이너는 VM보다 경량이면서도 OS를 공유하여 리소스 효율성을 높이고, 개발부터 프로덕션까지 일관된 환경을 제공하는 현대적 배포 방식의 핵심이다.</p>

<p><img src="/assets/images/posts/2025-09/2025-09-04-004.png" alt="" /></p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><summary type="html"><![CDATA[introduction]]></summary></entry><entry><title type="html">코테 학습 - ‘택배 상자 꺼내기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/01/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘택배 상자 꺼내기’" /><published>2025-09-01T00:00:00+00:00</published><updated>2025-09-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/01/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/01/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/389478">원본 문제 보러가기</a></p>

<h2 id="2025년-9월-2일-문제-해결의-두-가지-접근법에-대한-고찰">2025년 9월 2일: 문제 해결의 두 가지 접근법에 대한 고찰</h2>

<p>오늘 프로그래머스 코딩 테스트 문제 하나를 붙잡고 꽤 오랜 시간 고민했다. ‘택배 상자 쌓기’ 문제였는데, 단순히 해결하는 것을 넘어 ‘어떻게 더 잘 해결할 수 있을까?’에 대한 깊은 생각에 잠기게 한 문제였다.</p>

<h3 id="첫-번째-접근-눈에-보이는-대로-직관적인-시뮬레이션">첫 번째 접근: 눈에 보이는 대로, 직관적인 시뮬레이션</h3>

<p>문제의 요구사항은 명확했다. 지그재그 방식으로 쌓이는 택배 상자들 중에서 특정 번호의 상자를 꺼내기 위해 위에 놓인 상자가 몇 개인지 세는 것이었다. 가장 먼저 떠오른 방법은 역시 ‘시뮬레이션’이었다.</p>

<ol>
  <li><strong>전체 구조 파악:</strong> 상자가 쌓일 공간을 2차원 배열로 구상했다.</li>
  <li><strong>규칙 적용:</strong> 문제에 명시된 규칙 그대로, 층(row)마다 방향을 바꿔가며 상자 번호를 채워 넣었다.</li>
  <li><strong>좌표 탐색 및 계산:</strong> 목표 상자의 좌표(x, y)를 찾고, 그 위층(y+1, y+2, …)의 같은 x 좌표에 상자가 있는지 확인하며 개수를 셌다.</li>
</ol>

<p>이 방식은 직관적이고 명쾌하다. 머릿속으로 그리는 과정을 코드로 그대로 옮기면 되니, 논리적 오류가 발생할 확률도 적었다. 문제의 제약 조건(n ≤ 100)이 크지 않았기에, 이 방법으로도 충분히 ‘정답’을 맞힐 수 있었다.</p>

<p>하지만 만약 상자가 100개가 아니라 100만 개, 1억 개가 된다면? 이 거대한 2차원 배열을 메모리에 올리는 것부터가 부담이 될 터였다. (물론 이 문제의 제약은 아니었지만, 언제나 최적화를 염두에 두는 습관을 들이고 싶었고, gemini 왈, 수학적 계산 식으로 수행이 가능하다는 말에 어떻게 하면 좋을지 고민했다.)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="c1"># 최초 설정
</span>    <span class="n">total_height</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">w</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">total_height</span> <span class="o">*</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">total_height</span> <span class="o">=</span> <span class="n">total_height</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># 시뮬레이션을 위한 박스 설정
</span>    <span class="n">box_pos</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">total_height</span><span class="p">)]</span>

    <span class="c1"># 층고에 따른 박스 번호 
</span>    <span class="n">delimiter_value</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># 타겟이 되는 박스 위치 측정을 위한 height, width 
</span>    <span class="n">target_height</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">target_width</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 주요 시뮬레이션(박스 적재 및 조건에 맞는 위치 발견 및 세부 설정
</span>    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">total_height</span><span class="p">):</span>    
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">box_pos</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">delimiter_value</span> <span class="o">+</span> <span class="n">x</span>
            <span class="c1"># 찾을 박스 위치 일 때 할 일
</span>            <span class="k">if</span> <span class="n">box_pos</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
                <span class="n">target_height</span> <span class="o">=</span> <span class="n">index</span>
                <span class="nf">if </span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">target_width</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">target_width</span> <span class="o">=</span> <span class="n">x</span> 
            <span class="c1"># 마지막 박스까지 마무리 시 루프 강제 종료
</span>            <span class="k">if</span> <span class="n">box_pos</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">delimiter_value</span> <span class="o">+=</span> <span class="n">w</span>

        <span class="c1"># 배열을 뒤집어야 하는 경우 탐색
</span>        <span class="nf">if </span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">box_pos</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="nf">reverse</span><span class="p">()</span>


    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">next_height</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">target_height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total_height</span><span class="p">):</span>
        <span class="c1"># 박스가 좌표상 존재하면 
</span>        <span class="k">if</span> <span class="n">box_pos</span><span class="p">[</span><span class="n">next_height</span><span class="p">][</span><span class="n">target_width</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">break</span>
    
    <span class="k">return</span> <span class="n">answer</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="두-번째-접근-패턴을-꿰뚫는-수학적-계산">두 번째 접근: 패턴을 꿰뚫는 수학적 계산</h3>

<p>고민의 지점에서, 나는 다른 접근법을 모색했다. 바로 ‘배열 없는 계산’이다.</p>

<p>핵심은 <strong>“어떤 상자 번호(k)가 주어지면, 그 상자의 좌표(x, y)를 즉시 계산해낼 수 있는가?”</strong> 였다. 상자가 쌓이는 규칙은 명확한 패턴을 가지고 있었고, 여기서 ‘단순화 시켜서’ 각 줄을 고려할 수 있고, 같은 위치 x 좌표를 가지는 상자를 계속 찾으면, 결국 원하는 상자를 꺼내기 위해 몇번 움직여야 하는지 알 수 있는 것이었다.</p>

<ul>
  <li><strong>y좌표 (층):</strong> <code class="language-plaintext highlighter-rouge">(k-1) // w</code> 로 간단히 계산할 수 있다.</li>
  <li><strong>x좌표 (칸):</strong> 층(y)이 짝수냐 홀수냐에 따라 계산 방식이 달라진다.
    <ul>
      <li>짝수 층: 왼쪽에서 오른쪽으로 가므로 <code class="language-plaintext highlighter-rouge">(k-1) % w</code></li>
      <li>홀수 층: 오른쪽에서 왼쪽으로 가므로 <code class="language-plaintext highlighter-rouge">w - 1 - ((k-1) % w)</code></li>
    </ul>
  </li>
</ul>

<p>이 좌표 계산 함수 <code class="language-plaintext highlighter-rouge">get_coords(k)</code>를 정의하고 나니, 문제는 훨씬 단순해졌다.</p>

<ol>
  <li>목표 상자(<code class="language-plaintext highlighter-rouge">num</code>)의 좌표 <code class="language-plaintext highlighter-rouge">(target_x, target_y)</code>를 구한다.</li>
  <li><code class="language-plaintext highlighter-rouge">num + 1</code>번 상자부터 <code class="language-plaintext highlighter-rouge">n</code>번 상자까지 루프를 돈다.</li>
  <li>각 상자의 x좌표를 계산해서 <code class="language-plaintext highlighter-rouge">target_x</code>와 같은지 확인하고, 같다면 카운트를 1 늘린다.</li>
</ol>

<p>이 방식은 불필요한 배열 생성을 완전히 제거하여 메모리 사용량을 극도로 줄였고, 전체 시뮬레이션 과정 없이 필요한 계산만 수행하므로 속도도 훨씬 빠르게 측정되었다(100 개 기준 두배정도 차이 났다)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">math</span>

<span class="k">def</span> <span class="nf">solution2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="c1"># gemini 추천 코드
</span>    
    <span class="c1"># 어떤 상자 번호(k)가 주어졌을 때, 그 상자의 (x, y) 좌표를 반환하는 함수
</span>    <span class="c1"># 이 함수가 배열을 생성하는 모든 로직을 대체합니다.
</span>    <span class="k">def</span> <span class="nf">get_coords</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
        <span class="c1"># 0부터 시작하는 인덱스로 변환
</span>        <span class="n">zero_based_k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="c1"># y 좌표 (행, 층) 계산
</span>        <span class="c1"># 0층, 1층, 2층...
</span>        <span class="n">y</span> <span class="o">=</span> <span class="n">zero_based_k</span> <span class="o">//</span> <span class="n">width</span>
        
        <span class="c1"># x 좌표 (열, 칸) 계산
</span>        <span class="c1"># 짝수 층(0, 2, ...)은 왼쪽에서 오른쪽으로 진행
</span>        <span class="k">if</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">zero_based_k</span> <span class="o">%</span> <span class="n">width</span>
        <span class="c1"># 홀수 층(1, 3, ...)은 오른쪽에서 왼쪽으로 진행
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">zero_based_k</span> <span class="o">%</span> <span class="n">width</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="c1"># 1. 목표 상자(num)의 좌표를 계산합니다.
</span>    <span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span> <span class="o">=</span> <span class="nf">get_coords</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    
    <span class="c1"># 2. 위에 쌓인 상자의 개수를 셀 변수를 초기화합니다.
</span>    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># 3. num 바로 다음 번호부터 마지막 번호(n)까지의 상자들을 확인합니다.
</span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># 각 상자(k)의 좌표를 계산합니다.
</span>        <span class="n">k_x</span><span class="p">,</span> <span class="n">k_y</span> <span class="o">=</span> <span class="nf">get_coords</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        
        <span class="c1"># 만약 k 상자의 x좌표가 목표 상자의 x좌표와 같다면,
</span>        <span class="c1"># (즉, 같은 열에 있다면)
</span>        <span class="c1"># 그것은 제거해야 할 상자입니다.
</span>        <span class="k">if</span> <span class="n">k_x</span> <span class="o">==</span> <span class="n">target_x</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="k">return</span> <span class="n">answer</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="정리">정리</h3>

<p>사실 처음 시작할 때부터 수학적 접근을 고려하지 않은 건 아니었다…만, 역시 문제는 어떻게 거기에 접근하면 되는가? 에 대한 이해도다.</p>

<p>두번째 개선 방안에서 핵심은 단순화였다.</p>

<p>좌표를 짤 거지만, 그때 몇번째 줄에 몇번째냐. 그리고 거기서 방향도 고려해야 한다. 이런 조건들에 사실 머리가 좀 하얘지긴 했었다.</p>

<p>그런데 개선 방향을 보니, 결국 위 아래가 중요한게 아니라, 그냥 현재 타겟이 되는 박스의 위치와 같은 x 좌표 위치만 있으면 되고, 최대 값까지 중에서도 그냥 한번만 루프를 돌면 된다는 점.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">AI Breakfast S2 Ep 3 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/08/18/00-AI-trend-with-google-s2-03.html" rel="alternate" type="text/html" title="AI Breakfast S2 Ep 3 생각정리" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/18/00-AI-trend-with-google-s2-03</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/18/00-AI-trend-with-google-s2-03.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=WTea4oBLPLQ"><img src="https://i.ytimg.com/vi/WTea4oBLPLQ/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<p>AI 에이전트 시대가 도래하고 있으며, 구글 클라우드의 AI 전문 고객 엔지니어와 제너러티브 AI 필드 솔루션 아키텍트 사이의 에이전트 개발의 실제적인 측면을 논하고 있다. 구글은 제미나이 2.0과 2.5를 통해 에이전트 시대를 준비하고 있으며, 에이전트 개발을 지원하는 방향으로 나아가고 있음을 보여주는 영상이었다.</p>

<p><strong>ADK (Agent Development Kit)의 필요성 및 특징</strong></p>

<ul>
  <li>에이전트 개발은 LM 기술 활용을 넘어 소프트웨어 엔지니어링 지식과 LM 관련 지식이 모두 필요하여 시작이 어렵다.</li>
  <li>시중에는 랭그래프(LangGraph)나 크루AI(CrewAI)와 같은 다양한 에이전트 개발 프레임워크가 있지만, 구글은 <strong>ADK를 개발</strong>하였다.</li>
  <li><strong>ADK의 목적</strong>은 에이전트 개발을 <strong>더 쉽게</strong> 만들고, 개발된 에이전트를 <strong>쉽게 프로덕션에 배포</strong>할 수 있도록 이밸류에이션, 세션 관리, 다른 서비스와의 연결 등 필요한 부분을 신경 써서 만드는 것이다.</li>
  <li><strong>기존 프레임워크와의 차이점</strong>으로, ADK는 <strong>사용 편의성</strong>이 높고, <strong>구글의 다른 서비스들과의 통합</strong>이 매우 쉽다. 또한 실제 <strong>프로덕션 환경을 위한 배포, CI/CD, 이밸류에이션 등</strong>의 고려가 잘 되어 있다.</li>
  <li>ADK는 고객의 요구사항을 셀즈포스에 반영하는 CRM 에이전트나 고객에게 제품을 추천하는 에이전트 등 <strong>다양하고 복합적인 전문 에이전트들을 이미 잘 만들어 놓은 예시</strong>를 제공하며, 이를 활용하여 개발을 시작할 수 있다. 튜토리얼을 통해 기존 기술로는 오래 걸렸을 작업을 매우 심플하게 구현하는 경험을 할 수 있다.</li>
  <li>ADK는 <strong>개발 시간을 획기적으로 단축</strong>시킨다. 예를 들어, RAG(Retrieval Augmented Generation) 기법을 활용한 프로젝트는 과거 몇 달이 걸렸으나, ADK를 사용하면 1~2주 만에 기존에 몇 달 걸렸을 만한 완성도로 개발이 가능하다. 문서 처리 프로젝트 또한 LLM과 에이전트를 결합하여 몇 개월, 심지어 1년 이상 걸리던 작업을 매우 빠르게 완성할 수 있다.</li>
  <li>ADK의 <strong>주요 기능</strong>은 다음과 같다:
    <ul>
      <li><strong>인스트럭션 기반의 작업 위임</strong>: 프롬프트만 입력하면 에이전트가 필요에 따라 서브 에이전트에게 작업을 위임하거나 특정 툴을 호출한다.</li>
      <li><strong>쉬운 검색 연동</strong>: 구글의 Vertex AI Search나 Vertex AI의 RAG 엔진을 쉽게 붙일 수 있어 검색 부분 구현이 매우 용이하다.</li>
      <li><strong>LLM 에이전트</strong>: 동적 추론을 통해 요청에 따라 전문화된 서브 에이전트에게 작업을 넘기는 것이 가능하다 (예: 수학 계산 에이전트가 소수점 계산은 더 똑똑한 에이전트에게 위임).</li>
      <li><strong>워크플로우 에이전트</strong>: 비즈니스 로직 처리를 위해 순차적, 병렬적, 루프 기반의 프로세스를 정의할 수 있다. 이는 LLM의 동적 추론만으로는 부족한 부분을 보완하여 에이전트의 안정적인 동작을 보장한다. 프로젝트에서는 LLM 에이전트와 워크플로우 에이전트를 혼합하여 설계하고 구현하는 경우가 많다.</li>
    </ul>
  </li>
</ul>

<p><strong>에이전트 개발의 평가 및 안정성</strong></p>

<ul>
  <li>에이전트 개발에서 <strong>평가는 가장 중요한 부분</strong> 중 하나이다.</li>
  <li>ADK는 <strong>세션 관리, 장기 기억(Long-term Memory), 이밸류에이션(Evaluation)</strong>과 같은 기능을 기본적으로 제공하여 개발자가 직접 구현해야 할 노력을 줄여준다.</li>
  <li><strong>에이전트 평가</strong>는 단순히 정답을 맞추는 것을 넘어, <strong>설계 의도대로 플로우를 따랐는지, 정확한 도구를 호출했는지</strong> 등을 확인하는 것이 중요하다.</li>
  <li>ADK는 특정 쿼리에 대해 에이전트가 따라야 할 경로(트랙토리)를 정해 놓고 이를 따르는지 평가하는 <strong>경로 트랙토리 평가</strong>를 지원한다.</li>
  <li>자연어 아웃풋 평가 시에는 로그 매트릭(Log Metric)이나 <strong>LLM을 심판(Judge)으로 활용하는 방식(LLM as a Judge)</strong>을 사용한다. LLM을 심판으로 활용하면 사람이 평가하는 것과 거의 차이 없는 정확도를 보이며, 특히 개발 단계에서 매우 유용하다.</li>
  <li>ADK Dev UI는 <strong>시각적인 디버깅</strong>을 제공한다. 요청 시 어떤 에이전트에게 위임되었는지, 어떤 툴을 사용했는지 등을 그래프 형태로 시각적으로 확인할 수 있으며, 트레이싱 정보도 제공하여 디버깅을 편리하게 한다. 또한 멀티모달(이미지, 비디오 처리) 및 스트리밍 처리도 지원한다.</li>
</ul>

<p><strong>에이전트 간 통신 표준: A2A (Agent-to-Agent)</strong></p>

<ul>
  <li>에이전트가 많아지면 <strong>서로 다른 에이전트 간의 인터페이스 문제</strong>가 발생할 수 있다.</li>
  <li>앤트로픽(Anthropic)이 발표한 <strong>MCP(Model Context Protocol)</strong>는 LLM의 한계를 보완하기 위해 외부 툴 사용을 쉽게 하는 개방형 프로토콜로 빠르게 확산되었다. 이는 기존 OpenAI의 펑션 콜링(Function Calling)이 GPT 생태계 내에서 폐쇄적으로 이루어진 것과 달리, 서버-클라이언트 개념을 차용하여 개발자에게 익숙하고 개방적이라는 점에서 큰 주목을 받았다.</li>
  <li>구글은 MCP의 부상 당시 외부의 우려에도 불구하고, MCP를 포괄하는 <strong>더 큰 생태계를 만드는 청사진</strong>을 가지고 <strong>A2A라는 개방형 프로토콜</strong>을 개발하고 있었다.</li>
  <li>A2A는 에이전트 간 소통을 위한 <strong>개방형 프로토콜</strong>로, 구글 독점 기술이 아니라 여러 회사와 협력하여 발표되었다. 이는 A2A가 MCP처럼 널리 퍼질 수 있는 가능성을 시사한다.</li>
</ul>

<p>결론적으로, ADK는 에이전트 개발을 쉽고 빠르며 프로덕션 수준으로 안정적으로 만들 수 있도록 지원하며, A2A는 에이전트 시대에 필수적인 에이전트 간 통신 표준이 될 것으로 기대된다.</p>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>말 그대로다.</p>

<p>AI 를 이제 슬슬 제대로 공부해야 하고, 배경지식에서 넘어서서 필요한 기술 스택을 배우고, 특히나 내가 중점적으로 생각하는 영역을 학습해야 할 때가 왔다고 생각한다.</p>

<p>그리고 그런 것들을 가능케 하는 도구들, 그 중에도 구글의 입장을 대변하는 것이 오늘 팟캐스트를 통해 들은 내용이다.</p>

<p>이러한 플랫폼으로 어떻게 고객을 먼저 잡는가, 그리고 거기서 개발이 얼마나 편리하게 될 수 있고, 개발 과정이 ‘예측 가능한가’의 강점을 어필할 수 있냐는 항상 AI 라는 혁신의 수면 아래에 잠잠하게 숨겨진 근본적인 한계치 였다.</p>

<p>ADK와 그 내부의 평가 절차, gui 화를 통해 조금이라도 쉽고, 명료하게 개발하며,  A2A 등의 존재를 통해 AI 를 적극 제어한다… 등 특히나 확률적인 답변이 정말 의도대로 동작하는가 라는 차원의 문제를 해결하기 위한 구글의 나름대로의 해결책이며, 특히나 모델이 제대로 이해했는가를 평가하기 위해선, 결국 ‘해야할 일을 수행할만한 수준의 AI’에다가, 그 AI의 상황 업무를 판단, AI가 적절했는가를 평가하는 것이 필요하다는, 현재의 구조의 최대의 맹점을 보여주고, 인정하며, 해결하는 구글의 나름의 방식을 제시한 것 같다.</p>

<p>ChatGPT 5 가 처음 나왓을 때, 샘 알트만은 라우팅 처리가 자연스러워서, 필요한 순간 적절한 사이즈의 모델로 답을 해주겠다. 모델을 고를 필요는 없다- 라고 말했었다. 이것이 OpenAI 식의 LLM 이 가지는 근본적인 문제의 대답이었다.</p>

<p>하지만 ChatGPT 는 여전히 그 통제가 사람들이 원하는 수준이 안되었고, 그 결과 사람들에게 내리는 답변의 질, 그리고양 어느 면에서도 납득을 시키지 못해, 결국 슬그머니 다시 기존의 방식으로 돌아갔었다.(아마도 언젠간 다시 라우팅을 시도하지 않을까?)</p>

<p>그만큼 이 일은 매우 까다롭고 어려운데, 결국 이러한 한계를 개선하려면 정확하고, 적절한 평가 체계가 준비되어 있어야 하며, 무엇보다 그 평가체계가 CICD 과정에 통합되어야 개발은 쉬워진다.</p>

<p>그리고 결정적으로 구글이나, OpenAI, 다른 경쟁자들의 이러한 플랫폼 경쟁, 개발 친화 경쟁은 뭘 의미할까?</p>

<p>궁극적으로 신뢰성 + 비용 개선 이 두가지가 핵심이 아닐까 생각해본다.</p>

<p>LLM은 훌륭한건 사실이다. 인프라도 점점 싸질거다. 하지만 여전히 비싸고, 여전히 그 한계와, 사용성 대비 ‘비즈니스’로 취급하기엔 다른 기업들 입장에서 쉽지는 않다는 게 현실이다. 성능면에서나, 자원면에서 적절하게 리소스 분배- 라는 차원으로 사람의 통제하에 있지 못한 면도 여전히 존재한다. 그러한 점에서 통제력을 키우고, 개발자의 의도대로 움직이며, 오히려 더 기계적이게 정확한 인풋에 대해 정확한 답을 내리기, 그리고 그 과정에서 리소스는 최소화하기 - AGI 를 지향하고 가면서도, 소버린 AI 와 같이 안보 차원에서도 적극적인 것에 함께 더불어서 기업이란 관점에서 본다면 ‘최적화’ 와 ‘비용개선’이라는 표면화 하기 어려운 영역에 대해 개선하고 싶은게 아닐까?</p>

<p>그렇기에 생각하건데, 필요한 건 DevOps 관점의 기술과, AI 기술 두가지의 융복합은 필수라고 생각한다.</p>

<p>AI 개발자들의 티오를 보더라도, 1티어를 제외한 나머지 AI 개발자는 사실상 갈 곳이 없다. 그렇다고 백엔드 개발만 해서도 요즘의 시장에서 먹히지 않는 것을 볼 수 있었다.</p>

<p>그런데 또 대담을 하다보면 AI 개발자가 백엔드지식을 이해하고 접근하시는 분도 분명 있지만, 그렇지 않은 분도 월등히 많다는 사실 또한 알 수 있었다.</p>

<p>AI 를 통해 내가 기본적으로 해야할 백엔드 역량을 매우 빠르고, 정확하게 접근할 수 있게 되었으니, 나의 능력을 어디에 쏟아야 할까? 결국 구글이 제시하듯, LLM 의 리소스를 잘 분배하거나, 평가를 통해 요구되는 사항에 최적화된 기능을 제공하고, 궁극적으로 비용 절감이나, 비용 만큼의 신뢰있는 서비스화 할 수 있는가? 그게 내가 생각하는 다음 내 인계점(Inflection Point)이 아닐까 생각한다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">memo - blog utterance setting 차이 정리</title><link href="http://0.0.0.0:4000/tools/2025/08/18/01-utterance-setting-issue.html" rel="alternate" type="text/html" title="memo - blog utterance setting 차이 정리" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/tools/2025/08/18/01-utterance-setting-issue</id><content type="html" xml:base="http://0.0.0.0:4000/tools/2025/08/18/01-utterance-setting-issue.html"><![CDATA[<h2 id="댓글-이상하다-뭐지">댓글 이상하다… 뭐지?</h2>

<p>댓글이 달렸다. 기술 블로그 운영할 때 정말 가뭄에 콩나듯, 아직 댓글이 많지는 않지만, 와주시는 것만으로도 감사한데…</p>

<p>문제는 이상하다..</p>

<p>알고보니 모든 댓글이 모든 글에 보인다..!</p>

<p>이상하여 분석하고 정리한 내용이다.</p>

<hr />

<h2 id="utterances-댓글-통합-문제-해결">Utterances 댓글 통합 문제 해결</h2>

<h3 id="원인-분석">원인 분석</h3>

<p>원인은 Jekyll 설정 파일(<code class="language-plaintext highlighter-rouge">_config.yml</code>)의 Utterances <code class="language-plaintext highlighter-rouge">issue_term</code> 설정에 있었다.</p>

<p>기존 설정은 <code class="language-plaintext highlighter-rouge">issue_term: "blog-comment:"</code>로 되어 있었는데, 이는 모든 페이지가 ‘blog-comment:’라는 단 하나의 GitHub Issue를 공유하도록 만든다. 따라서 어떤 글에서 댓글을 달아도 모두 같은 Issue에 저장되어 모든 글에 동일하게 표시되는 것이고 이렇게 되면 어느 글에 댓글을 단 건지 확실히 알기 어렵다 ㅠ..</p>

<p><img src="/assets/images/posts/2025-08/2025-08-18-002.png" alt="" /></p>
<blockquote>
  <p>설마 다른 글로 공유가 될 줄은 몰랐다.</p>
</blockquote>

<h3 id="해결-방안">해결 방안</h3>

<p>이 문제를 해결하기 위해 알아본 결과… gemini 왈 + 검색 결과, 해당 설정의 <code class="language-plaintext highlighter-rouge">issue_term</code> 값을 각 페이지의 고유한 URL 경로를 사용하도록 변경해야 한다.</p>

<ul>
  <li><strong>기존 설정:</strong> <code class="language-plaintext highlighter-rouge">issue_term: "blog-comment:"</code></li>
  <li><strong>변경할 설정:</strong> <code class="language-plaintext highlighter-rouge">issue_term: "pathname"</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">pathname</code>으로 설정하면, Utterances는 각 게시물의 고유 URL 경로(예: <code class="language-plaintext highlighter-rouge">/2025/08/18/post-A.html</code>)를 제목으로 하는 별도의 GitHub Issue를 생성하고 연결한다.</p>

<p><img src="/assets/images/posts/2025-08/2025-08-18-003.png" alt="" /></p>
<blockquote>
  <p>깔끔하게 해결 완료</p>
</blockquote>

<h3 id="나름-블로그-jekyll-공부-하고-했다는건데">나름 블로그 jekyll 공부 하고 했다는건데..</h3>

<p>아직 부족한게 넘 많다… 화려한 스펙이라고 할만하려면 더 능통해야하는데, 막상 다른 사람들 사이에서 보면 뭐 이리 모르는게 많은지! 🤣</p>]]></content><author><name>Paul2021-R</name></author><category term="tools" /><category term="생각정리" /><category term="학습" /><category term="blog" /><summary type="html"><![CDATA[댓글 이상하다… 뭐지?]]></summary></entry><entry><title type="html">나의 설명서를 정리는 했던가?</title><link href="http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/08/12/00-what-is-my-introduction.html" rel="alternate" type="text/html" title="나의 설명서를 정리는 했던가?" /><published>2025-08-12T00:00:00+00:00</published><updated>2025-08-12T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/08/12/00-what-is-my-introduction</id><content type="html" xml:base="http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/08/12/00-what-is-my-introduction.html"><![CDATA[<h2 id="나는-내-설명서를-갖고-있는가">나는 내 설명서를 갖고 있는가?</h2>

<p><a href="https://www.youtube.com/watch?v=d07JauBUt5g"><img src="https://i.ytimg.com/vi/d07JauBUt5g/hq720.jpg" alt="비디오 제목" /></a></p>

<p>김경일 교수님은 해당 유튜브 영상에서 다양한 심리적 문제와 대처 방안에 대해 통찰력 있는 내용의 강의를 자기 개발 차원에서, 숨 고르기 용으로 보았다. 그런데 생각보다 정말 괜찮은 내용들이 많았고, 그 생각들을 정리해두는게 나에게 정말 필요하겠구나 싶어 이렇게 정리해본 글이다.</p>

<h2 id="내-생각들">내 생각들</h2>

<h3 id="철학이-없는-사람이-무섭다">철학이 없는 사람이 무섭다</h3>

<p>확실히 나도 느낀 적이 있다. 자기 가치가 명확하지 않거나, 이익 추구형인 사람들을 종종 보게 되면, 그들의 입에서 나오는 이야기가 대단히 위험한 케이스. 내지는 소위 ‘가스라이팅’이 얼마나 심한지.</p>

<p>그리고 그런 이들의 이야기를 믿으면 안된다는 생각을 정말 심하게 했던, 내가 당했던 때들. 참 신기한게 그런 수단과 방법을 가리지 않는 이들의 이야기가 꼭 순간순간 솔깃 하게 들릴 때가 있던 건, 어쩌면 그때의 나는 여전히 가치 기준이 미흡하고, 관점의 흐릿함이 함께 있던게 아닌가, 그렇게 생각해본다.</p>

<p>특히나 나의 마음이 어떻게 안정을 찾아야 할지 모르던 청년, 20대의 시기, 그 시기는 결국 내가 어디가 부족한지를 이제 다시 한 번 보여준다 생각이 든다. 근거 없는 무서움, 근거 없는 불안감 속에서 나는 잘못된 이야기들, 잘못된 종교관, 특히나 마치 ‘이렇게만 하면 된다’ 라는 말이 얼마나 말이 안되는지를 깨닫게 되었을 때, 그때가 이런 내용에 드디어 공감할 수 있었던 게 아닌가 싶다.</p>

<h3 id="나르시즘-감정-배설-가스라이팅">나르시즘, 감정 배설, 가스라이팅</h3>

<p>교수님의 이야기 속에서도 특히나 안타까운 부분, 즉, ‘이용 당하는데’ 라는 제 3자의 시각을 인정하지 못하고, 그들의 이용을 다른 감정이나, 다른 표현으로 만들어 이해하려는 사람들. 그들에 대한 이야기를 할 때면 몇몇 스쳐지나가는 것을 느낄 수 있었다.</p>

<p>사랑이란 이름으로, 우정이란 이름으로, 동정이나 공감이란 이름으로, 사람에게 자신의 욕구에 맞춰 사람을 활용하는 행위는 그게 얼마나 지독한지, 얼마나 상대에게 나중에 후유증으로 남는지를 알 필요는 있지만… 문제는 역시 그걸 당하는 이들이 거기에 대해 참 신기하게도 저항하는 사람이 아니라, 이용 당하기 좋은 케이스의 사람이 또 그런 기묘한 관계가 된다는 것이, 참 안타까운 대목이 아닐까 싶다.</p>

<p>과거에 기독교 공동체에 있을 때도 그런 분이있었다. 상대를 웃기기 위해 자기 ‘밑’이라고 생각하는 이에 대해 무조건적인 광대 역할을 요구했고, 장난을 치면서 웃고 떠들게, 사람들 전체의 웃음을 유도하는 것 자체가 악의는 아니었지만, 그걸 당한 이들 중에 상처가 심한 이들도 발생했던 걸 떠올려 본다면, 여러 생각을 들게 하는 대목이었고, 요즘도 심심치 않게 보인다는 점에서 그런 행동이 얼마나 좋지 않은지 - 새삼 느끼게 되는 것이 있다.</p>

<h3 id="그러는-와중에-느끼는-바-진짜-성장-진짜-학습을-시킨다는-의미는">그러는 와중에 느끼는 바, 진짜 성장, 진짜 학습을 시킨다는 의미는</h3>

<p>그런 점에서 ‘나의 성장’ 동시에 누군가를 ‘성장시킨다’ 라는 의미에 대해, 특히 자녀 교육에 대하여서는 요즘 특히나 고민을 하게 만드는 영역인데, 정말 쉽지 않구나, 준비를 잘 해야하는 구나 라는 생각을 했다.</p>

<p>나의 어린 시절을 떠올리더라도, 가치가 성립 되기 전, 한 마디 한 마디, 감정 표현을 가능하게 만드냐 아니냐를 몰랐기에 했던 오해들을 생각해본다면… 진짜 잘 준비하고 많은 고민 속에서 이루어지는게 필요하지 않나 생각이 든다.</p>

<p>진짜 존중이 뭘까? 사람들과 만나고, 그들과 제대로 선한 영향력을 행사하고, 그러면서도 사회에서 내가, 조직이, 체계가 처한 현실에서 제대로 존중하고 존중 받는 것, 그게 행복할 텐데라고 고민하지만, 막상 그걸 위한 나만의 확고한 태도가 있냐? 하다못해 내 자식들, 내 가족을 나는 존중하나? 라는 생각에서 교수님의 이야기는 반드시 체화할 영역이라고 생각한다.</p>

<h3 id="결국-자신을-제어하는-방법은">결국 자신을 제어하는 방법은</h3>

<p>언제부터 나는 나의 관리를 잘했나?</p>

<p>사실 이 질문에 대해 이제는 좀 희미해진 기억을 갖고 있다. 공부, 역할, 임무, 나의 성장 과정에서 나는 생각해보면 그렇게 잘한다고 불리게 된 것이 썩 처음부터는 아니었다.</p>

<p>중학교 2학년 끝날 때 즈음, 조금 씩이었고, 대학교 때도 생각해보면 ‘완벽’은 아니었다.</p>

<p>그럼에도 한 가지 이야기 할 수있는 사실은, 대학생 때 이후, 나의 감정을 이해하고 나의 감정을 어떻게 조절할지 그것을 체득한 이래로 나의 학습도, 작업도, 그리고 무엇보다 계획을 실행하는 능력에서는 나름 자신감이 생긴 것을 느낄 수 있었다.</p>

<p>그런데 그럴 때 느꼈던, 그리고 내 스스로의 방법이 뭐냐! 라고 할 때 생각했던 문구가 바로 ‘자신 설명서’ 라는 것이었다. 호불호, 내가 효과적일 시간을 활용한다, 계획해서 수행한다, 그리고 거기서 그렇게 생각할 수 있는 이유는 ‘싫다’와 ‘좋다’를 확실하게 말하면서 결정하게 된 것. 그것이 내가 일을 판단하는 것이 남들보다 명확해졌던 이유이자, 결론에 따라 행동을 확실하게 하게 된 계기였다.</p>

<p>그리고 오늘 교수님의 이야기는 그런 나의 생각에 상당히 부합하면서도, 좀더 들어가야 함을 깨달았다. 작업 시작의 부담을 줄이는 방법을 사용하고, 가장 나의 최적 시간을 판단하고 고민한 뒤 그것에 기반해서 해야 한다.</p>

<p>그러려면 나에 대한 메타인지가 있어야 하는데, 이는 결국 시간표를 계획해보고, 계획 과정에서 ‘나란 놈’을 인지해서 어떻게 하면 ‘할 수 있는지’에 맞춰 나를 설계한다. 결국 말은 쉽지만 객관성이란 잣대 부터 위험한 잣대기도 하고, 그렇게 얻은 생체 데이터가 맞는지, 오히려 훈련이 필요한 부분도 있지 않을까? 그렇게 생각하면 머리가 아파오지만… 그럼에도 확실히 그것이 필요함은 느껴졌다.</p>

<p><img src="/assets/images/posts/2025-08/2025-08-12-002.png" alt="" /></p>
<blockquote>
  <p>ChatGPT 5 괜찮긴 하다..</p>
</blockquote>

<p>Gemini 는 시간 데이터로 판단이 불가능하다고 하여 요최근 다시 쓰기 시작한 ChatGPT 를 기준으로 대화 내역으로 나의 활동 상황, 특히나 내 대화를 기반으로 어떤 지적 활동을 몇시에 하는지 분석해보았다.</p>

<p>아주 단편적인 정보라 절대 ‘결과’나 ‘통찰’로 취급하면 안되지만 ChatGPT 왈,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) 오전에는 라이트한 일, 계획에 대한 결정 등을 주로 수행하고
2) 3시부터 개발이나 복잡한 실무적 이야기를 특히 많이 하는데, 그 때도 4시가 가장 피크를 이루며(지적 활동 극대화)
3) 오후에는 10시가 되면 희안하게 중대한 결정, 고민 등을 결정한다(결정활동 위주로 수행)
</code></pre></div></div>

<p>라고 이야기 했다.</p>

<p>결국 업무의 배치, 생산성, 미래에 목표를 이루기 위해선 이런 나의 특성을 이해한 계획, 이해한 목표와 실천의 연속이 결과를 낼 수 있으리라, 그렇게 생각하니 확실히 나의 계획이나 일정 진행 과정을 잘 기록하고 메타데이터화 하는게 필요하다는 사실에 확신을 얻을 수 있었다.</p>

<h3 id="인사이트-그리고-성장">인사이트 그리고 성장</h3>

<p>지식 인사이드라는 채널에서, 소통과 성장에 대해 이야기를 들을 때면 ‘똑똑해진 것 같은 기분’을 느껴, 이것도 중독인가 싶어 불안하긴 하지만(ㅋㅋㅋ)</p>

<p>그럼에도 영상을 곱씹어 보는 이유. 결국 다음 성장, AI 와 함께 하는 ‘인간’으로 어떤 것들을 갖춰야 나는 전문가가 될 수 있을까, 그것에 대한 답을 오늘 다소 얻은 것 같다.</p>

<p>나의 몸, 나의 마음을 제어하는 것, 그리고 그 중간에는 나의 정체성이 명확한게 핵심이며, 그렇게 되면 자신에 대한 제어도, 거짓말이나, ‘개소리’에 대한 판단도 할 수 있으며, 결론적으로 진짜 결정, 목표, 그리고 나아가서 삶에서 ‘일’을 성공적으로 해나갈 수 있으리라 생각해본다.</p>

<p>아직 감정도, 해야할 일들도 다 이해한 건 아니지만… 이런 시간과 기회, 고민할 상황을 얻어낸 것에 대단한 감사를 느낀다.</p>

<p>몸 아픈것도 해결 되었으니… 이젠 다이어트와 함께 AI + 그리고 백엔드 기술 연마에 힘써야겠다.</p>

<h2 id="영상-요약-내용">영상 요약 내용</h2>
<ul>
  <li><strong>성품의 변화와 얼굴의 드러남</strong>:
    <ul>
      <li>젊은 시절과 현재의 얼굴을 비교하면 사람의 성품을 상당 부분 파악할 수 있다고 본다. 이는 타고난 성격이 아니라 다듬어지는 성품과 관련이 있다. 40세가 넘으면 자신의 얼굴에 책임을 져야 한다는 말도 일리가 있다고 보았다. 특히 SNS 발달로 과장되거나 연출된 모습이 오히려 성품의 문제를 드러내는 함정이 될 수 있다고 경고했다.</li>
    </ul>
  </li>
  <li><strong>타인 파악 방법</strong>:
    <ul>
      <li>대화를 통해서는 상대방의 거짓을 알아내기 어렵다. 대화 시에는 목적이 있어 다른 가능성을 열어두지 않기 때문이다. 대신 <strong>목적 의식 없는 관찰</strong>이 사람을 파악하는 데 훨씬 유리하다고 강조했다. 말콤 글래드웰의 주장을 인용하며, 사업 파트너를 파악할 때 사업과 무관한 제3자를 데려가 관찰하게 하는 것이 도움이 된다고 설명했다.</li>
    </ul>
  </li>
  <li><strong>‘개소리(Bullshit)’의 심리</strong>:
    <ul>
      <li>진실이 아닌 것을 알면서 하는 거짓말보다, <strong>진심으로 헛소리(개소리)를 하는 사람에게 대응하는 것이 더 어렵다</strong>고 말한다. 거짓말은 팩트 체크에 무너지지만, 개소리는 진실에 관심이 없기 때문이다. 이는 사이비 종교를 믿는 것과 같은 심리적 방식이며, “내 마음이 중요한 거야”라고 주장하는 교주의 심리와 유사하다고 설명한다. 누구나 마음이 상하면 개소리를 할 수 있으며, 자신의 상한 마음이 중요하다는 점을 스스로 알아차리지 못할 때 이러한 현상이 발생한다고 보았다.</li>
    </ul>
  </li>
  <li><strong>개소리에 대한 저항 능력</strong>:
    <ul>
      <li>개소리를 하는 사람에게 직접 “헛소리”라고 바로잡아주면 오히려 화를 내기 때문에 통하지 않는다고 한다. 개소리에 흔들리지 않기 위해서는 어떤 사안이나 현상에 대한 <strong>자기 정의(self-definition)를 명확히 하는 것이 중요</strong>하다고 강조했다. 자기 정의가 없는 사람들은 ‘존재론적 착각’에 빠져 표피적인 특성에 쉽게 현혹되며, 이는 교육 수준이나 소득 수준과 무관하게 발생할 수 있다고 경고했다. 자신의 삶의 중요한 부분(돈, 집, 가족, 사랑, 성공 등)에 대해 끊임없이 정의를 내리고, 이를 타인과 공유하며 정교화하는 과정이 필요하다고 제안했다.</li>
    </ul>
  </li>
  <li><strong>나르시시스트 대처법</strong>:
    <ul>
      <li>나르시시즘은 자신이 잘난 것보다 <strong>남이 못나야 더 중요하다고 생각하는 특징</strong>을 가진다. 나르시시스트는 가까이하지 않는 것이 좋지만, 피할 수 없는 관계라면 다음과 같이 대처할 것을 조언한다:
        <ul>
          <li><strong>자신이 그 사람과 친하지 않음을 명시</strong>하여 악의적인 소문이 정당성을 얻지 못하게 해야 한다.</li>
          <li>리더의 경우, 나르시시스트를 <strong>절대 독대하지 말아야 하며</strong>, 실적이나 공을 칭찬할 때는 <strong>여러 사람 앞에서 칭찬</strong>해야 한다.</li>
          <li>조직의 상은 <strong>리더의 이름을 빼고 조직의 이름으로 수여</strong>해야 나르시시스트적 욕구를 자극하지 않고 상의 신뢰도와 생명력을 높일 수 있다고 설명한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>고민 상담을 빙자한 감정 배설자 대처</strong>:
    <ul>
      <li>필요에 의해 가해하고, 반대로 그걸 다시 자신을 위해 상대의 요청에 거절하지 못한다.
        <ul>
          <li><strong>전략적으로 타인을 옴짝달싹 못 하게 하려는 경우</strong>: 거의 소시오패스에 가까우므로 피해야 한다.</li>
          <li><strong>상담자를 대안으로 삼는 경우</strong>: 상대방의 이야기를 끊지 않고 들어주되, “<strong>아 그러니까 네 말은 이런 거구나</strong>“와 같이 <strong>요약 질문을 반복</strong>하여 상대방이 불편함을 느끼게 함으로써 이야기를 줄이도록 유도할 수 있다.</li>
          <li><strong>감정 배설의 도구로 삼는 경우</strong>: 불안형에 해당하며, 자신을 부정하고 타인을 긍정하는 경향이 있다. 이 경우, <strong>가벼운 욕설 사용</strong>이나 <strong>거리두기</strong>를 통해 자신이 함부로 배설할 대상이 아님을 알리고, 공유 면적을 줄여나가는 것이 중요하다고 보았다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>‘어른 아이(Adult Child)’ 대처법</strong>:
    <ul>
      <li>어른 아이는 성인이 되어서도 감정 조절이 어려운 사람들이다. 이는 성장 과정에서 부모가 아이의 감정을 대신 느끼거나 감정 표현을 아예 막았기 때문에 발생한다고 보았다. 부모는 아이가 자기 감정을 먼저 드러내게 하고, <strong>감정을 표현할 기회를 주되 적절한 감정의 크기를 가르쳐야 한다</strong>고 조언했다.</li>
      <li>어른 아이를 대처하는 방법으로는 <strong>물리적으로 떨어져서 이야기하기</strong>, <strong>말을 느리게 하여 화를 누그러뜨리기</strong>, 상대방의 격한 말을 “<strong>아, 그러니까 선생님 말씀은 그 거지 같은 놈들이 선생님한테 찾아와서 개 같은 짓을 하셨다는 얘기죠?</strong>“와 같이 <strong>거울처럼 따라 해 객관화</strong>시키는 방법을 추천한다.</li>
    </ul>
  </li>
  <li><strong>실패 수용과 ‘사후 확증 편향’ 극복</strong>:
    <ul>
      <li>작은 실수를 ‘인생 망했다’고 받아들이는 것은 과거의 상처가 한꺼번에 터지는 경우라고 본다. 타인의 실패에 대해 “내 그럴 줄 알았어”라고 말하는 것은 <strong>‘사후 확증 편향(hindsight bias)’</strong>을 유발하여 학습과 개선을 방해하고 회피하게 만든다고 경고했다. 성장을 위해서는 사소한 실수라도 흔쾌히 인정하고 솔직히 고백하는 문화가 필요하며, 이를 위해 <strong>자신만의 시그니처 행위나 멘트를 만들어 유쾌하게 실수를 인정하는 것</strong>이 도움이 된다고 제안했다.</li>
    </ul>
  </li>
  <li><strong>게으름에 대한 재해석 및 생산성 향상</strong>:
    <ul>
      <li>게으름은 천성이라기보다는 <strong>상황적 요인</strong>과 <strong>‘트리거(trigger)’ 부재</strong>로 인해 발생하는 경우가 많다고 보았다. 한국인의 뇌는 본래 근면 성실하므로, 자신을 게으르다고 생각한다면 상황 단서를 찾지 못하고 있을 가능성이 크다고 설명한다.
        <ul>
          <li><strong>생산성 높은 사람들의 특징</strong>: 자신이 <strong>언제, 무엇을, 어디서 잘하는지</strong>에 대한 상황 단서 데이터를 기록하고 활용한다.</li>
          <li><strong>작업 시작의 부담 극복</strong>: 큰 작업을 통째로 시작하려 하지 말고, <strong>가장 쉬운 첫 단계(예: “책만 펴자”, “연필만 올려놓자”)만 설정</strong>하여 부담을 줄이고 자연스럽게 다음 단계로 나아가게 유도해야 한다.</li>
          <li><strong>‘게임화’ 전략</strong>: 세밀하게 나눈 계획(예: 페이지 단위, 분 단위)을 통해 <strong>진도감</strong>을 느끼고 <strong>성취감</strong>을 얻는 것이 몰입에 도움이 된다고 설명한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>아침형/저녁형 인간과 업무 배치</strong>:
    <ul>
      <li>심리학적으로 아침형 인간과 저녁형 인간이 분명히 존재하며, 각자 <strong>지적인 능력이 최고조에 달하는 시간대가 다르다</strong>고 한다. 한국 사회는 이른 등교 및 출근 문화로 인해 저녁형 인간에게 불리한 면이 있다고 지적했다.
        <ul>
          <li><strong>자신의 최적 시간대 파악</strong>: 매일 밤 잠들기 전 자신의 말, 행동, 기분에 점수를 매기고 어제 몇 시에 자서 몇 시간 잤는지 6개월 정도 기록하면 자신에게 <strong>가장 활발한 ‘아침’이 언제인지</strong> 알 수 있다고 조언한다.</li>
          <li><strong>효율적인 하루 시간표</strong>:
            <ul>
              <li><strong>오전(뇌가 가장 각성된 시간)</strong>: 깊은 생각, 결정, 새로운 정보 처리 등 높은 집중력이 필요한 일을 배치해야 한다. 루틴한 일은 낭비라고 보았다.</li>
              <li><strong>오후(뇌가 지쳐 있는 시간)</strong>: 익숙하고 반복적이며 루틴한 일을 배치하는 것이 효율적이다. 지쳐 있을 때 자동화된 일을 잘하기 때문이다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>미래 목표 설정 및 직업 선택</strong>:
    <ul>
      <li>청년들이 지나치게 구체적인 미래 목표(예: “35세에 35평 아파트”)를 설정하여 좌절하는 경우가 많다고 보았다.
        <ul>
          <li><strong>동사형 목표 설정</strong>: 먼 미래의 목표일수록 <strong>명사나 숫자가 아닌 동사형(예: “나는 40살에 내가 원하는 곳에서 중심적인 위치가 될 거야”)으로 설정</strong>하여 유연성과 대안을 확보해야 한다고 강조했다.</li>
          <li><strong>적성은 ‘행위’에 있다</strong>: 직업이나 분야가 아닌 ‘어떤 행위’에 재능이 있는지를 찾아야 한다고 한다. 예를 들어, 김경일 교수님은 새로운 정보를 알려주는 것보다 과거의 성공과 실패 이유를 일깨워주는 ‘행위’에 특화되어 있다고 설명했다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>직업 만족도와 기업 문화</strong>:
    <ul>
      <li>많은 사람들이 자신이 회사에서 무엇을 왜 하는지 모르고 일에 재미를 느끼지 못하는 현실을 지적하며, <strong>기업 문화를 중요하게 봐야 한다</strong>고 강조한다.
        <ul>
          <li>기업은 돈이나 서열이 아닌 <strong>‘이런 문화가 있다’는 것을 정확하게 알려야 하며</strong>, ‘녹서(Green Paper)’와 같은 형태로 회사 내에서 주고받는 질문들을 공유하여 지원자가 문화를 짐작할 수 있도록 해야 한다고 제안했다.</li>
          <li>사람들이 직장이나 배우자를 선택할 때 <strong>감정을 약속하기보다 행동을 약속해야 한다</strong>고 니체의 말을 인용하며 강조한다. 감정은 변하면 수정 불가능하지만, 행동은 수정, 용서, 만회가 가능하기 때문이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>일에서 즐거움 찾기 (게임화)</strong>:
    <ul>
      <li>일, 공부, 훈련은 본래 뇌에서 즐겁게 인식하지 않는 ‘노동’이지만, <strong>‘게임’처럼 만들어 ‘몰입’하면 즐겁다고 착각</strong>할 수 있다고 말한다. 몰입을 통해 <strong>‘성장감’</strong>을 느끼는 것이 중요하며, 일이 재미없게 느껴지는 것은 전문가가 되어 더 이상 실력이 급격히 늘지 않는 정체기일 가능성이 크다고 보았다. 이럴 때에는 <strong>‘직무 변경’</strong>을 통해 새로운 성장을 도모하고 업무를 확장하는 것이 안전하고 효과적인 방법이라고 추천한다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="생각정리" /><category term="자기개발" /><category term="심리" /><summary type="html"><![CDATA[나는 내 설명서를 갖고 있는가?]]></summary></entry><entry><title type="html">AI Breakfast S2 Ep 2 생각정리</title><link href="http://0.0.0.0:4000/ai/2025/08/11/00-AI-trend-with-google-s2-02.html" rel="alternate" type="text/html" title="AI Breakfast S2 Ep 2 생각정리" /><published>2025-08-11T00:00:00+00:00</published><updated>2025-08-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/08/11/00-AI-trend-with-google-s2-02</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/08/11/00-AI-trend-with-google-s2-02.html"><![CDATA[<h2 id="영상-보기">영상 보기</h2>
<p><a href="https://www.youtube.com/watch?v=1ZO6C8itatI"><img src="https://i.ytimg.com/vi/1ZO6C8itatI/hq720.jpg" alt="비디오 제목" /></a></p>

<h2 id="요약">요약</h2>
<ul>
  <li><strong>생성형 AI 모델의 발전</strong>: 미디어를 생성하는 모델인 <strong>Veo (베오)가 어드밴스드 모델로 출시되어 동영상 품질을 크게 향상시켰다</strong>. 이전에는 텍스트로만 동영상을 제어하기 어려웠으나, 이제는 <strong>이미지를 기반으로 동영상을 제작하여 등장인물의 일관성을 유지할 수 있게 되었다</strong>. 또한, 이미지를 생성하는 <strong>Imagen (이마젠)</strong>이나 음악을 생성하는 <strong>Lyra (리라)</strong>와 같은 모델들은 몇 번의 프롬프트 엔지니어링만으로도 손쉽게 콘텐츠를 생산하여 <strong>기업의 생산성 향상 및 비용 절감에 기여한다</strong>.</li>
  <li><strong>AI의 일관성 및 신뢰도</strong>: AI 기술에서 <strong>일관성</strong>은 답변의 신뢰성을 보장하는 중요한 허들이다. 이는 <strong>할루시네이션(환각 현상)과도 연관</strong>되며, 텍스트 기반 모델(LLM)에 시드(seed) 정보를 넣어 <strong>동일한 질문에 유사하고 일관된 답변이 나오도록 모델 개발에 중점을 두고 있다</strong>.</li>
  <li><strong>개발 생산성 향상</strong>: <strong>Gemini Code Assistant (제미나이 코드 어시스턴트)</strong> 2.5 버전이 출시되어 개발자들의 생산성을 높이는 데 기여한다. 이 도구는 <strong>문서 작업을 대신 생성</strong>하고, <strong>에러를 잡는</strong> 데 유용하며, <strong>멀티턴 대화</strong>를 통해 질문에 대한 추가 질문을 할 수 있어 효율적이다. 궁극적으로 개발자들이 반복적인 코딩 작업보다는 <strong>소프트웨어 아키텍처 설계와 디자인에 집중</strong>할 수 있도록 돕는 것이 주된 목적이다.</li>
  <li><strong>AI의 역할 변화</strong>: AI는 인간을 대체하는 것이 아니라 <strong>어시스턴트로서 활용되어야 한다</strong>는 관점을 제시한다. 과거에는 AI가 불가능하다고 여겨졌던 <strong>그림 그리기, 사진 만들기, 코딩과 같은 창의적인 영역에 AI가 먼저 도전하고 있다</strong>.</li>
  <li><strong>워크스페이스 기능 강화</strong>: Google Workspace (구글 워크스페이스)에도 다양한 AI 기능이 추가되었다. 대표적으로 <strong>라이브 통역(Live Interpreter) 기능</strong>이 꿈같은 기능으로 언급되었으며, 이메일 작성, 문서 요약, 파일 위치 확인 등 <strong>사용자의 생산성을 향상시키는 디폴트 기능들이 대거 도입될 예정</strong>이다.</li>
  <li><strong>에이전트 시대의 도래</strong>: 2024년은 <strong>‘에이전트 시대(Agentic Year)’</strong>로 불린다. 초기 AI가 대고객 서비스에 주로 활용되려 했으나 AI 자체의 완벽하지 않음으로 인해 어려움이 있었으며, 현재는 <strong>기업 내부의 어시스턴트로서 에이전트 환경을 구축하는 데 집중</strong>하고 있다.</li>
  <li><strong>구글의 에이전트 생태계 구축 전략</strong>: 구글은 에이전트 생태계를 확장하기 위해 <strong>ADK (Agent Development Kit)</strong>와 <strong>A2A (Agent-to-Agent)</strong>를 <strong>오픈소스</strong>로 릴리즈하고 있다. 이는 구글이 TPU/GPU부터 소프트웨어까지 모든 것을 다루는 <strong>풀스택(Full-stack) 회사</strong>임에도 불구하고, 더 큰 생태계를 구축하기 위해 <strong>다양한 파트너와 협력하여 기술 표준화를 주도</strong>하려는 전략이다.
    <ul>
      <li><strong>ADK</strong>: 에이전트를 쉽게 만들고 실행할 수 있는 개발 도구이다. 에이전트가 무엇을 해야 할지에 대한 <strong>명령(프롬프트)에 따라 실행하며, 필요할 경우 툴을 활용</strong>한다.</li>
      <li><strong>A2A</strong>: <strong>에이전트 간의 통신 규약(프로토콜)을 표준화</strong>하는 기술로, 서로 다른 에이전트들이 원활하게 커뮤니케이션할 수 있도록 돕는다.</li>
    </ul>
  </li>
  <li><strong>MCP (Model-Component-Protocol)</strong>: MCP는 <strong>에이전트와 툴 간의 표준화된 통신 규약</strong>이다. 에이전트가 어떤 작업을 수행할 때 필요한 툴(예: 구글 서치)을 효율적으로 사용하고 관리할 수 있도록 지원하며, 이는 에이전트 생태계를 확장하고 표준화하는 데 중요한 역할을 한다.</li>
  <li><strong>Firebase Studio (파이어베이스 스튜디오)</strong>: 백엔드 개발 프레임워크인 파이어베이스의 새로운 기능으로, 일반 언어 프롬프트만으로 <strong>프로토타이핑을 빠르고 쉽게 생성</strong>할 수 있게 한다. 이는 개발 과정에서 <strong>커뮤니케이션을 가속화하고, 사전 문제점을 빠르게 파악하여 생산성을 높이는 데 매우 중요한 도구</strong>이다.</li>
  <li><strong>구글의 미래 비전</strong>: 구글은 현재를 “구글의 시간이 왔다”고 표현하며, 미래에는 <strong>AGI (일반 인공지능) 레벨에 가까운 AI 기술이 등장할 것</strong>으로 예측하고 있다. 이는 더욱 깊어진 추론 능력과 강화된 멀티모달리티, 그리고 더욱 강력해진 답변 일관성을 특징으로 할 것이다. 궁극적으로 다양한 비즈니스에 활용될 수 있는 AI 기술의 발전을 기대하고 있다.</li>
</ul>

<h2 id="내-생각-정리">내 생각 정리</h2>
<p>해당 팟캐스트를 통해 알 수 있는 사항, 사실 1편에서도 이야기 된 내용들이었긴 하지만… 
그럼에도 대단한 것들에 대해 다시 강조하는 내용, 보여주는 내용들은 확실히 훌륭하다고 생각했다.</p>

<p>ChatGPT 5가 발표 되었지만, 논란, 호불호가 있는 것에 비하면, 
Google 의 서비스는 일반 대중에게는 그다지 큰 놀라움이 아니고, 심지어 개발자들 조차 빠르게 인지하는 사람들은 AI에 진심인, 정말 얼마 안된다는 생각이 들긴 한다.</p>

<p>하지만 막상 써보고 느낀 감상은, 오히려 ChatGPT 보다 Google의 그것들이 정말 놀랄 만큼 미친 수준이고, 또 여전히 아쉬움이 있지만(특히 Google Code Assistance) 여전히 그 포텐셜이나 어떤 서비스를 구축하려고 하는가를 곰곰히 생각해보면 확실하게 ‘효과적’인 것들이며 플랫폼으로의 영향력을 얼마나 치밀하게 고민했는가를 느낄수 있었다. (실력도 실력이고)</p>

<p>이부분이 중요하다고 생각하는 것은 다음과 같은 일들 때문이다.</p>

<p><a href="https://zdnet.co.kr/view/?no=20250801175507">오픈 AI, 1년 매출 120 달러 속 적자 여전…</a></p>
<blockquote>
  <p>이건 사실 뭐 어쩔 수 없다고 본다</p>
</blockquote>

<p><a href="https://www.digitaltoday.co.kr/news/articleView.html?idxno=584197">AI 코딩 스타트업, 매출 급성장에도 수익성은 여전히 ‘글쎄’</a></p>
<blockquote>
  <p>오늘자 기사다</p>
</blockquote>

<p>물론 부정적인 이야기를 본다고 뭔가 결론이 나진 않을 것이다.
그리고 여전히 투자 열기나, 새로운 기대감, 그리고 변화하는 진폭의 크기가 너무 커서, 객관적 평가가 되긴 할까? 하는 의구심은 든다.</p>

<p>하지만 한가지 확실하게 알 수 있는 것은 AI는 과거의 다른 IT 트랜드 보다는 확실히 혁신적이지만, 그것이 시장의 성장과 기업의 성과, 그리고 매출이 시장의 반응성에서 정말 혁신으로 자리잡을 까, 세상의 판도를 뒤집는가, 기업이 여기에 모든 걸 투자할 이유가 되는가? 에 대한 답이 아직 아님을 보여준다.</p>

<p>그러다 보니 기업들은 생존을 위한 현실적 BM 이 필요해지고, 이런 점에서 개발자들의 역할과 역량, AI에 대한 어떤 생각을 갖고 있어야 할지는 생각해볼만한 영역이라고 고민이 된다.</p>

<p>과거 메타버스로 정부 투자 열심히 받아서, 결과적으로 살아있는 회사가 몇 군데인가? 를 바라본다면, 이러한 흐름 속에서 살아가는 한 사람으로서 보다 진중하게 이 상황을 적절하게 활용할 태도가 필요하다는 생각은 확고하게 든다.</p>

<p>특히나 이런 점은 그냥 단순하게 AI 자체를 잘 다루는 기술의 시대에서, AI를 얼마나 효과적이게 시스템에 녹여내고, 비용 절감, 수익 창출로 이끌어낼 것인가- 라는 차원에서 바라볼 이유이자, 이런 점을 무시한 투자와 고민은 튤립에 투자를 하던 때나, 메타버스에 투자하던 때와 유사한 결론이라는 사실을 다시 한 번 상기 시켜준다.</p>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="DevOps" /><category term="Google" /><category term="생각정리" /><summary type="html"><![CDATA[영상 보기]]></summary></entry><entry><title type="html">1년 간의 활동을 정리 하면서</title><link href="http://0.0.0.0:4000/backend/2025/08/11/01-Final-Report-For-My-task.html" rel="alternate" type="text/html" title="1년 간의 활동을 정리 하면서" /><published>2025-08-11T00:00:00+00:00</published><updated>2025-08-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/08/11/01-Final-Report-For-My-task</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/08/11/01-Final-Report-For-My-task.html"><![CDATA[<h2 id="api-서버-개발-1년-회고-안정성과-확장성을-향한-여정">API 서버 개발 1년 회고: 안정성과 확장성을 향한 여정</h2>

<p>지난 1년간 <code class="language-plaintext highlighter-rouge">A-api(가칭)</code> 프로젝트를 개발하고 개선하며 경험했던 여정을 회고하는 글을 드디어 작성한다. 더 빨리 적었어야 했겠지만… 아무래도 네이버 부스트 캠프라던가, 그 외에 정리 라던가, 사실 8월 쉬지도 못하고 작업 하고 있는 상황이라 ㅋㅋㅋ.. 약간의 변명 섞어 가지만, 이제는 좀 정리 해봐야 겠다 싶어 이렇게 남겨 본다.</p>

<p>이 글을 통해 1년 간의 메인 서버로 API 서버가 어떻게 구축되었고, 어떤 기능들이 추가되었으며, 안정성과 효율성을 위해 어떤 노력들이 있었는지 스스로 정리를 위한 글을 남겨보려고 한다. (기업 사용 명칭들은 모두 가칭으로 대체 된다.)</p>

<h3 id="1-프로젝트-개요-및-핵심-기술-스택">1. 프로젝트 개요 및 핵심 기술 스택</h3>

<p><code class="language-plaintext highlighter-rouge">A-api(가칭)</code> 프로젝트는 아동의 재활 및 치료 과정을 돕는 게임형 콘텐츠의 핵심 비즈니스 로직과 이에 관련된 데이터를 관리하고, 사용자 및 아동 정보를 처리하며, 결제(구독), 알림, 스케줄링 등 다양한 부가 기능을 제공하는 백엔드 애플리케이션이다.</p>

<p>주요 기술 스택은 다음과 같다:</p>
<ul>
  <li><strong>프레임워크</strong>: NestJS (TypeScript 기반)</li>
  <li><strong>데이터베이스</strong>: MongoDB (Prisma ORM 활용)</li>
  <li><strong>캐시/메시지 큐</strong>: Redis (캐싱 및 세션 관리), BullMQ (비동기 작업 큐)</li>
  <li><strong>인증</strong>: JWT 기반 인증</li>
  <li><strong>로깅</strong>: Winston (파일 및 DB 로깅), 자체 구현 로거</li>
  <li><strong>API 문서화</strong>: Swagger</li>
  <li><strong>배포/운영</strong>: Docker, Jenkins, Nginx, (GitHub Actions - 현재 버전에선 삭제)</li>
  <li><strong>기타</strong>: <code class="language-plaintext highlighter-rouge">axios</code>, <code class="language-plaintext highlighter-rouge">agenda</code>, <code class="language-plaintext highlighter-rouge">mixpanel</code>, <code class="language-plaintext highlighter-rouge">notionhq/client</code>, 인앱 결제 라이브러리 등</li>
</ul>

<p>최초 설계 시에는 MVC 구조를 기반으로 고려한 전형적인 모놀리스 식 서버 애플리케이션이었으며, 이후 3.0.0 이후 NestJS 공식 권장하는 모듈 기반 아키텍처를 적극적으로 활용하여 기능별로 책임과 관심사를 명확하게 분리한 견고한 구조로 최종 구현되었다.</p>

<h3 id="2-주요-기능-개발-및-개선-내역">2. 주요 기능 개발 및 개선 내역</h3>

<p>지난 1년간 A-api 서버의 핵심 기능들을 개발하고 개선하는 데 집중하였다. 게임의 기본 구현이 클라이언트에서 진행되다보니, 최대한 유저의 행적, 운동, 운동 스케쥴링 등에서 로그를 남기는 쪽이 핵심이 되었다.</p>

<ul>
  <li><strong>사용자 및 인증 시스템</strong>:
    <ul>
      <li>로컬(이메일/비밀번호) 및 소셜(Google, Apple) 로그인/회원가입 기본 골자를 기반으로 개선 작업을 수행했다.</li>
      <li>JWT 기반의 인증 시스템을 구축하여 API 접근을 안전하게 제어하고, 사용자 정보 및 탈퇴 처리 로직을 관리하였다.</li>
      <li>임상 시험이 이루어져(2024년 ~ 2025년), 이에 대응하고자 <code class="language-plaintext highlighter-rouge">UserAttribute</code> 모델을 통해 임상시험 참여자와 같은 특정 사용자에게 특별 권한이나 속성을 부여하는 기능을 추가하였다.</li>
      <li>이후 <code class="language-plaintext highlighter-rouge">UserAttribute</code>를 기반으로 사용자의 클라이언트 디바이스에 맞춰 최적 설정으로 게임 플레이 가능하도록 대응하였다.</li>
    </ul>
  </li>
  <li><strong>아동 및 치료 관리</strong>:
    <ul>
      <li>보호자 계정에 여러 자녀를 등록하고 관리할 수 있는 기능을 개발하였다.</li>
      <li>자녀의 재활 치료 게임 플레이 기록(<code class="language-plaintext highlighter-rouge">PlayRecord</code>), 치료 결과(<code class="language-plaintext highlighter-rouge">TherapyResult</code>), 일일 활동 로그(<code class="language-plaintext highlighter-rouge">DailyActivityLog</code>)를 상세히 저장하는 시스템을 구축하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">TherapySchedule</code>을 통해 개인별 맞춤 치료 스케줄을 관리하고, 특히나 <code class="language-plaintext highlighter-rouge">Agenda</code>를 활용하여 스케줄링된 작업을 처리하도록 하여 최대한 분산 처리 가능하도록 구축하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">TherapyHand</code>, <code class="language-plaintext highlighter-rouge">HandClassLabel</code> 등 재활 치료에 특화된 상세한 데이터 타입을 <code class="language-plaintext highlighter-rouge">Prisma</code> 스키마에 정의하여 전문적인 데이터 관리가 가능하도록 하였다.</li>
    </ul>
  </li>
  <li><strong>게임 콘텐츠 및 설정 관리</strong>:
    <ul>
      <li>치료에 사용되는 손동작(<code class="language-plaintext highlighter-rouge">Motion</code>) 데이터(가이드 영상, 설명 등)를 관리하는 기능을 구현하였다.</li>
      <li>메인 치료 게임 외에 미니게임(<code class="language-plaintext highlighter-rouge">MiniGameResult</code>)의 결과도 기록하고, <code class="language-plaintext highlighter-rouge">GameSettings</code> 모델을 통해 게임의 난이도, 패치노트 등 다양한 설정을 동적으로 관리할 수 있도록 하였다.</li>
      <li>미니 게임의 경우, 모듈 구조를 적극 활용하여 클라이언트가 미니 게임에 저장할 데이터를 직접 설정도 가능하고 최대한 백엔드 어플리케이션와 클라이언트 사이의 의존성이 필요시를 제외하면 최대한 의존성을 분리하도록 구조화하였다.</li>
    </ul>
  </li>
  <li><strong>결제 시스템 및 비즈니스 로직</strong>:
    <ul>
      <li>Apple App Store 및 Google Play Store 인앱 결제(구독)를 처리하고, 구독 상태를 관리하는 시스템을 구축하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">PaymentResult</code>, <code class="language-plaintext highlighter-rouge">PaymentHistory</code>, <code class="language-plaintext highlighter-rouge">Subscription</code> 모델을 통해 결제 및 구독 이력을 추적하고, 프로모션 코드(<code class="language-plaintext highlighter-rouge">Promotion</code>) 발급 및 관리 기능을 추가하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">TherapyTicket</code>을 통해 게임의 보상이 적절하게 제공될 수 있는 내부 시스템을 구현하였다.</li>
      <li>Google 의 <code class="language-plaintext highlighter-rouge">Pub/Sub</code> 과 Apple 의 <code class="language-plaintext highlighter-rouge">ServerNotification V2</code> 를 분석하여 이벤트들에 대응, 결제 사이클에 따라 서버에서 구독 상태의 완전한 관리가 가능하도록 구축하였다.</li>
    </ul>
  </li>
  <li><strong>알림 및 외부 연동</strong>:
    <ul>
      <li>NCP SENS를 통해 알림톡(회원가입, 치료 목표 달성 등)을 발송하는 기능을 구현하였다.</li>
      <li>Discord 웹훅을 이용하여 서버의 주요 이벤트(서버 시작, 에러 등)를 개발팀에 실시간으로 알리도록 하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">Mixpanel</code>을 사용하여 사용자 행동 데이터를 수집 및 분석하고, <code class="language-plaintext highlighter-rouge">Notion</code> API를 연동하여 내부 데이터를 동기화하거나 리포트를 생성하는 기능을 개발하였다.</li>
      <li>외부 연동 기능에서 외부 서비스의 상황과 조건에 따라, <code class="language-plaintext highlighter-rouge">Agenda</code>와 <code class="language-plaintext highlighter-rouge">BullMq</code>를 활용하여 로깅에 실패하지 않는 구조룰 구축해 냄.</li>
    </ul>
  </li>
  <li><strong>서버 안정성 및 성능 테스트</strong>:
    <ul>
      <li>파일 로깅, 표준 출력 로깅을 포함하여 Winston 을 라이브러리를 최적화하여, 월별 로깅 저장, 자동 로깅 압축 등 실 서비스에 최적화된 로깅을 구현하였다.</li>
      <li>더불어 비즈니스 로직에서 발생한 로깅 사항이나 외부 접속 시의 Req/Res 의 로깅 저장의 필요성 대두에 <code class="language-plaintext highlighter-rouge">Interceptor</code> 개념을 활용한 미들웨어를 구축하였으며, 인메모리 큐 기반으로 하여 로그 데이터 쌓기로 인해 발생 가능한 서버 부담을 최소화 하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">그레이스풀 셧다운</code> 을 도입, 리눅스 시스템의 긴급한 정지나 강제 종료 등 상황에서 시스템 콜에 의한 강제 서버 종료를 막을 수 있게 했다. 이를 통해 로그의 소실 없이 해야할 작업들을 온전히 마무리 되었을 때 종료 될 수 있는 형태로 구축하여 로그 소실을 최소화 시켰다.</li>
      <li>k6 를 도입 AWS 의 현재 서버 자원 상태에서 최대 얼마나 처리 가능한지, 필요한 응답을 얼마 안에 받을 수 있는지 등을 테스트하여 체계화 하였다.</li>
    </ul>
  </li>
</ul>

<h3 id="3-devops-및-인프라-개선">3. DevOps 및 인프라 개선</h3>

<p>안정적이고 효율적인 개발 및 배포 환경을 구축하기 위해 DevOps 프로세스 개선에 많은 노력을 기울였다.</p>

<ul>
  <li><strong>Jenkins CI/CD 파이프라인용 배포 스크립트 통합 및 개선</strong>:
    <ul>
      <li>최초에는 AWS App Runner 서비스를 활용한 완전 관리형 서비스를 통해 배포 및 실행됨.</li>
      <li>기존 방식의 문제점들로 인해 일반적인 EC2 인스턴스로 서버를 이전 ELB 를 활용한 간단한 로드벨런싱 서버 형태에서 점진적으로 개선하여 ASG(Auth Scaling Group) 기반의 이미지 푸시 및 배포 기능으로 구현 하였다.</li>
      <li>이후 무중단 배포 및 개발환경 개선을 위해 전 서버 구성목록을 컨테이너화하였다.</li>
      <li>무중단 배포를 위하여 개별 서비스 배포 스크립트(<code class="language-plaintext highlighter-rouge">tag_and_push_nestjs.sh</code>, <code class="language-plaintext highlighter-rouge">tag_and_push_nginx.sh</code>)를 구축, ECR 서비스를 활용하여 <code class="language-plaintext highlighter-rouge">target</code> 태깅을 통해 이미지를 자동 추적 및 배포 가능한 서버 형태로 구현하여 기존 형태에서 비용, 자동 배포, 무중단성 등 이점들을 극대화한 운영하도록 개선됨.</li>
      <li>모든 사용자 입력을 제거하고, 환경, 서비스별 버전, Target 태그 여부를 명령행 인자로 받아 처리하도록 설계하여 자동화에 적합하도록 변경하였다.</li>
      <li>스크립트들은 반복되는 이미지 푸시 로직을 <code class="language-plaintext highlighter-rouge">push_image</code> 함수로 모듈화하여 코드 재사용성과 가독성을 높였다.</li>
      <li>NestJS 버전은 설정 파일에서 동적으로 읽어오거나 직접 명시할 수 있도록 유연성을 추가하였고, 특정 서비스의 배포를 건너뛸 수 있는 <code class="language-plaintext highlighter-rouge">skip</code> 옵션을 추가하여 파이프라인의 선택적 실행을 가능하게 하였다.</li>
      <li><code class="language-plaintext highlighter-rouge">aws ecr put-image</code>를 사용하여 <code class="language-plaintext highlighter-rouge">target</code> 태그를 갱신하는 방식으로 기존 로직을 개선하여 효율적이고 원자적인 태그 관리가 가능하도록 하였다.</li>
      <li>package.json 을 적극 활용하여 패키지 매니징을 통한 빌드, 이미지 관리, 배포 등을 명령어로 가능케 만들었고, 이를 통해 서버 개발 및 배포 시간의 효율을 극대화 하였다.</li>
      <li>Husky 와 Lint 의 추가적인 도입 및 CodeRabbit AI 와 같은 서비스 도입을 통해 코드 품질을 끌어올려, 에러가 실 서비스로 최대한 넘어가지 안 도록 관리하였다.</li>
    </ul>
  </li>
</ul>

<p>이 외에도 Docker를 활용한 컨테이너화, Jenkins를 통한 CI/CD 파이프라인 구축, Nginx를 통한 정적 파일 서빙 및 리버스 프록시 역할 수행 등 전반적인 DevOps 환경을 개선하였다.</p>

<h3 id="5-버전별-주요-업데이트-내역">5. 버전별 주요 업데이트 내역</h3>

<p>지난 1년간 진행된 주요 기능 추가 및 개선 내역은 다음과 같다.</p>

<ul>
  <li><strong>API 2.2.1</strong>:
    <ul>
      <li><strong>성능 개선 (Throttler)</strong>: 인증 컨트롤러에 Rate Limiting을 적용하여 성능, 부정 요청을 제한하는 것으로 개선하였다.</li>
      <li><strong>테스트 계정 관리 API</strong>: 유저 계정에 다중 테스트 계정 삽입 및 삭제 API를 개발하였다.</li>
      <li><strong>사용자 및 자녀 컨트롤러/서비스 리팩토링</strong>: 자녀 삭제 로직을 개선하고, 유저 생성 과정 로직을 리팩토링하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.2.2</strong>:
    <ul>
      <li><strong>데이터 처리 개선</strong>: 데이터가 없는 경우 API에서 빈 배열을 전달하고, DTO를 <code class="language-plaintext highlighter-rouge">Partial</code>로 래핑하여 유연성을 높였다.</li>
      <li><strong>일일 로그 Public API 핫픽스 및 개선</strong>: 일일 로그 치료 결과 Public API 버그를 수정하고, Prisma <code class="language-plaintext highlighter-rouge">find</code> 메서드 및 MongoDB <code class="language-plaintext highlighter-rouge">relation</code> 활용을 개선하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.2.3</strong>:
    <ul>
      <li><strong>로깅 점검 및 개선</strong>: 스케줄링 모듈의 로거를 점검하고, 로깅 누락 문제에 대응하기 위해 로깅을 추가하고 에러 핸들링을 강화하였다.</li>
      <li><strong>자녀 등급 추가</strong>: <code class="language-plaintext highlighter-rouge">Child</code> 모델에 <code class="language-plaintext highlighter-rouge">grade</code> 필드를 추가하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.3.0</strong>:
    <ul>
      <li><strong>로깅 통합 및 리팩토링</strong>: 로깅 통합 작업을 완료하고, 파일 로거 및 Winston 설정을 개선하였다.</li>
      <li><strong>오늘 치료 결과 전송 기능 수정</strong>: 오늘 치료 결과를 확인할 수 있도록 기능을 수정하였다. <code class="language-plaintext highlighter-rouge">Agenda</code> 라이브러리를 도입하여 치료 기록의 수집과 서버 성능 최적화를 감안하여 개발함.</li>
      <li><strong>사용자 속성 및 임상 시험 기능 구현</strong>: 사용자 속성 및 임상 시험 관련 기능을 구현하였다. 임상 대상자에 맞춰 손 동작 등을 변경될 수 있는 기능을 Decorator 와 Interceptor 를 활용하여 개발하였다. 이를 통해 기존 비즈니스 로직을 그대로 사용 가능하도록 개발함.</li>
    </ul>
  </li>
  <li><strong>API 2.4.0</strong>:
    <ul>
      <li><strong>미니게임 관리 모듈</strong>: 미니게임 관리 시스템, 모듈형으로 구현하여 다양한 미니게임 추가를 코드 개발 없이 가능하도록 구현함.</li>
      <li><strong>게임 설정 분리</strong>: 게임 설정을 독립적인 모듈로 분리하였다. 미니게임과 연동되는 게임 설정 기능.</li>
    </ul>
  </li>
  <li><strong>API 2.5.0</strong>:
    <ul>
      <li><strong>아산 임상 시험 개정</strong>: 아산 임상 시험 관련 기능들의 개정 요청에 따라 작업을 진행하고, Prisma 모델링 및 치료 캘린더 컨트롤러 API를 업데이트하였다. 요청 사항에 따라 전체 기능 리 팩토링 완료 하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.6.0</strong>:
    <ul>
      <li><strong>자녀 진단 기록 추가</strong>: 새로운 진단 기록 기능 및 기본 관리 API 명세 작성을 완료하였다.</li>
      <li><strong>관리자 추가 보안 기능 구현</strong>: 관리자의 유저 비밀번호 초기화 등의 어드민 기능 구현을 완료 하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.7.0</strong>:
    <ul>
      <li><strong>일일 로깅 및 로그인 프로세스 리팩토링</strong>: 일일 로깅 및 로그인 프로세스 리팩토링을 진행하였다.</li>
      <li><strong>코드 컨벤션 통합</strong>: 코드 컨벤션 통합 작업을 진행하였다. 기존 레거시 코드들에 대한 컨벤션과 맞지 않은 개발 사항들 전체를 분석 및 정리하였다.</li>
      <li><strong>CI/CD 개선</strong>: <code class="language-plaintext highlighter-rouge">deploy-to-dev.yaml</code> 및 <code class="language-plaintext highlighter-rouge">gemgem-hosted-test.yaml</code> 파일을 만들어서 AWS App Runner 에서 GitHub Action의 방식으로 CI/CD를 개선하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.8.0</strong>:
    <ul>
      <li><strong>미국 SMS 인증</strong>: 외부 서비스를 활용하여 미국 SMS 인증 기능 개발을 진행하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.9.0</strong>:
    <ul>
      <li><strong>구독 시스템 구현</strong>: 구독 구글 및 애플의 스토어 및 결제 시스템 구현을 진행하였다. 전체 라이프 사이클 중 4개</li>
      <li><strong>로컬 회원가입 개선</strong>: 로컬 회원가입 시 이미 가입된 메일이면 가입 수단을 리턴하도록 변경하였다.</li>
      <li><strong>에러 핸들링 개선</strong>: 에러 핸들링 응답 바디 복구 및 iOS 취소 조건 추가를 진행하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.10.0</strong>:
    <ul>
      <li><strong>미니게임 결과 제한/잠금 리팩토링</strong>: 미니게임 결과 제한 및 잠금 관련 리팩토링을 진행하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.11.0</strong>:
    <ul>
      <li><strong>Notion CRM 기능 구현</strong>: Notion API를 활용하여 고객들의 정보를 비개발 구성원이 보기 좋게 동기화 기능 구현하였다.</li>
      <li><strong>새로운 미니게임 설정</strong>: 새로운 미니게임 설정 관련 작업을 진행하였다.</li>
      <li><strong>일반 사용자 손 스케줄링</strong>: 일반 사용자 손 스케줄링 기능을 추가하였다.</li>
      <li><strong>새로운 회원가입 로직</strong>: 새로운 회원가입 로직을 추가하였다.</li>
      <li><strong>외부 API 모듈화</strong>: 모든 외부 API 부분을 수정하고 모듈화하였다.</li>
    </ul>
  </li>
  <li><strong>API 2.12.0</strong>:
    <ul>
      <li><strong>치료 캘린더 수정</strong>: 치료 캘린더 관련 버그를 수정하였다.</li>
      <li><strong>출석 기능 업데이트</strong>: 출석 기능 관련 새로운 업데이트를 진행하였다.</li>
      <li><strong>회원 탈퇴 로직 리팩토링</strong>: 회원 탈퇴 로직 리팩토링을 진행하였다.</li>
      <li><strong>DI 구조 개선</strong>: DI(Dependency Injection) 구조 개선을 진행하였다.</li>
      <li><strong>Discord 개선</strong>: Discord 관련 개선을 진행하였다. 기존 디스코드 로깅의 간단한 시스템으로 인해 Rate Limitting 문제를 발견. 이에 따라 테스트 후 얼마나 로깅 소실 되는지 판단하고, 개선을 위한 구조 리펙토링 수행. 워커 스레드와 큐 기능을 활용, 지수 백오프 로직 등을 통해 99% 유지 상태로 구현 완료.</li>
      <li><strong>컴파일러 빌드 구조 수정</strong>: 컴파일러 빌드 구조를 SWC와 babel 컴파일러 사이에서 필요 상황에 따라 컴파일 방식을 선택하고, 빌드 속도 등을 개선함.</li>
    </ul>
  </li>
  <li><strong>API 3.0.0</strong>:
    <ul>
      <li><strong>주요 변경 및 버전 업그레이드 이유</strong>: API 3.0.0은 단순히 기존 기능의 개선을 넘어, <strong>레거시 코드에 대한 대대적 리펙토링 및 모듈 구성 변경, 새로운 결제 시스템(구독 인상 대응, 스토어 이벤트 핸들링)의 대대적인 도입, 새로운 게임 콘텐츠(미니게임, VideoPinkfong)의 추가, 그리고 핵심 사용자 기능(운동 리포트)의 구현</strong> 등 서비스의 핵심 비즈니스 로직과 사용자 경험에 큰 영향을 미치는 대규모 기능들이 통합된 버전이다. 또한, 이러한 대규모 변경 사항들을 안정적으로 서비스하기 위한 CI/CD 개선 및 여러 중요한 버그 수정이 동반되었다. 이러한 변화의 폭이 컸기 때문에 메이저 버전 업그레이드(2.x.x -&gt; 3.0.0)가 이루어졌다.</li>
      <li><strong>서버 구조 개선</strong>: 공통 모듈의 라이브러리화 이전에, <code class="language-plaintext highlighter-rouge">common</code> 모듈로 분리하여 DI 적절 구조로 리펙토링, <code class="language-plaintext highlighter-rouge">feature</code> 에 해당하는 기능들만 분리하고 순환의존성 문제 대거 개선.</li>
      <li><strong>새로운 스토어 이벤트 핸들링 및 구독 인상 대응</strong>: 구독 인상에 대한 핸들링 구현 및 새로운 스토어 이벤트 핸들링 기능이 완료되었다.</li>
      <li><strong>미니게임 추가 및 기존 게임 구조 변경</strong>: 미니게임(<code class="language-plaintext highlighter-rouge">brushing</code>, <code class="language-plaintext highlighter-rouge">cooking</code>), 영상 재생 게임이 추가되었고, UpStairs 복잡한 구조를 리펙토링하였다.</li>
      <li><strong>운동 리포트 기능 추가</strong>: 메인 화면 운동 리포트를 위한 기능이 추가되었다.</li>
      <li><strong>CI/CD 및 개발 환경 개편</strong>: Husky 와 같은 린팅 후킹을 통해 개발 시 놓치기 쉬운 영역, 코드 포멧팅을 휴먼 에러 케이스를 없도록 개선, 개발 환경의 Container 화 스크립트를 전체 구축하여 local, Dev, Staging, Prod 환경을 로컬에서 테스트 및 빌드 가능하도록 구축함. AWS 설정을 개선하여 무중단 배포가 가능하도록 구축 이후 Jenkins 를 기반으로한 CICD 파이프라이닝 구축.</li>
      <li><strong>린트 설정 동기화</strong>: 린트 설정 동기화 및 포맷팅 작업을 진행하였다.</li>
      <li><strong>Google 구독 취소 API</strong>: Google 구독을 업체에서 갱신 취소를 신청하는 API 기능을 탑재하였다.</li>
    </ul>
  </li>
</ul>

<h3 id="6-1년의-여정-그리고-아쉬운-점과-향후-학습개선-사항">6. 1년의 여정, 그리고 아쉬운 점과 향후 학습/개선 사항</h3>

<p>나의 1년간의 작업은 NestJS 기반의 백엔드 시스템을 안정적이고 확장 가능하게 구축하는 데 매우 큰 기여를 하였다. 특히, 체계적인 모듈화, 상세한 데이터 모델링, 그리고 DevOps 자동화에 대한 노력은 내가 무얼 해야 하고 Backend 개발이란게 무엇인지를 이해하는, 치열한 시간이었다고 평가한다.</p>

<p>하지만, AI의 비약적 발전 덕에, 그리고 그렇게 점점 더 업무 효율이 올라가면서, AI가 이 서버를 분석하면 어떤 부분에서 아쉬운 점과 향후 학습 및 개선을 통해 더욱 발전할 수 있는 영역이 있는지를 분석하였고, 이를 기반으로 다음 개발의 역량의 지표로 삼으려고 한다.</p>

<ul>
  <li><strong>문서 관리 프로세스 개선</strong>: 문서의 최신성을 유지하고 협업 과정에서 발생할 수 있는 문제를 방지하기 위한 명확한 문서 관리 프로세스(예: 문서 변경에 대한 코드 리뷰 강화, 자동화된 병합 도구 활용, 문서 버전 관리 전략 수립)의 필요성을 느꼈었다. 물론 테크 리더께서 온전히 나를 신뢰해주시고 덕분에 개발 요청 상황과 현 서버들의 상태를 기반으로 개선작업들을 할 수 있었지만, 결과적으로 다른 사람들과 함께 개발한 것이 아니라는 점, 이런 프로세스가 미리미리 준비되지 않았기 때문에 아쉽다고 느꼈다.</li>
  <li><strong>DB 로깅의 안정성 강화 및 로깅 시스템 강화</strong>: <code class="language-plaintext highlighter-rouge">LoggerMiddleware</code>가 기존의 로깅 방식이고, 새롭게 만든 <code class="language-plaintext highlighter-rouge">HttpLoggingInterceptor</code> 간의 역할 중복이 있었다. 특히나 프로덕션 수준에서 볼 때 로깅으로 서버에 시스템 부하를 최소화 시켜야 할 것이며, 에러 상황을 판단하기 위해서 파일 로그가 반드시 어딘가에 저장되도록 만들어야 할 텐데, ASG 로 인스턴스가 최신화가 되는 구조는 파일을 날려버리는 형태가 되다보니, 이를 고려하지 않은 설계는 대단히 초보적인 실수라고 보였다.(하다 못해 EC2 볼륨 설정을 바꿔도 충분하리라…)</li>
  <li><strong>민감 정보 마스킹 활성화</strong>: 보안 강화를 위해 로그에 민감한 정보가 기록되지 않도록 <code class="language-plaintext highlighter-rouge">maskSensitiveInfo()</code> 함수를 구현했었다. 하지만 로그들 전체를 분석하거나, 체계화 하는 과정을 거치지 못해, 활성화 시키지 못했다. 민감 정보를 잘 처리해내고, 로깅은 확실히 남기는 두 가지를 잘 다 이루었다면 좋았으리라 생각이 된다.</li>
  <li><strong>Nginx 역할 확장 고려</strong>: Nginx가 현재 정적 파일 서빙 및 로깅 역할을 한다고 명시되어 있는데, 향후 API Gateway 역할(인증, 라우팅, 속도 제한 등)을 확장하여 백엔드 서비스의 부하를 줄이고 보안을 강화하는 방안을 학습하고 적용하는 것을 고려할 수 있다.</li>
  <li><strong>보다 진보된 파이프라이닝</strong>: CICD 의 구현은 가능했으나, 다양한 기능으로 적절히 서버로 서빙되지 못한다는 점, 유저 활성화가 아쉬워 보다 넓은 스케일링에 도전해보지 못했다는 점은 다소 아쉬운 부분이다.</li>
  <li><strong>어드민 기능 구현의 부재</strong>: 백엔드 개발만이 전부가 아니라, 데이터의 취득, 데이터 가공, 데이터 사용 대상이 보다 쉽게 접근 가능한 구조화가 필요했으나, 그러한 개발은 시간상 하지 못했었다. 이러한 점은 이후 운영이란 차원에서 매우 아쉬움으로 남았다.</li>
</ul>

<h3 id="7-결론">7. 결론</h3>

<p>지난 1년간 A-api 서버 프로젝트를 개발하며 NestJS 기반의 견고한 백엔드 시스템을 구축하고, 다양한 핵심 기능들을 구현하였다. 특히 DevOps 프로세스 개선을 통해 개발 생산성과 배포 안정성을 높이는 데 기여하였으며, 로깅 시스템 분석 및 잠재적 오류 분석을 통해 시스템의 안정성과 품질을 향상시키기 위한 노력을 지속하였다. 그 결과들은 3.0 버전을 구현할 수 있었고, 테크 리더님에게도 상당한 호평을 받은 대단히 체계화된 구조라는 칭찬을 받았고, 이는 다음 단계로 가야하는 구나, 갈 수 있겠구나 하는 자긍심, 자부심도 될 수 잇었다고 생각한다.</p>

<p>여러 상황이 겹쳐 이제는 해당 업체를 나와 AI 라는 키워드 DevOps 라는 키워드를 더 집중하기 위해 노력하려고 하는데, 이러한 나의 노력이 다음 곳에서 다시 또 무언가로 나타내질 수 있기를 기원한다.</p>

<p>나란 존재 빠이팅…</p>

<p><img src="/assets/images/posts/2025-08/2025-08-11-003.png" alt="" />
<img src="/assets/images/posts/2025-08/2025-08-11-004.png" alt="" />
<img src="/assets/images/posts/2025-08/2025-08-11-005.png" alt="" /></p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="생각정리" /><category term="Backend" /><category term="NestJS" /><category term="TypeScript" /><summary type="html"><![CDATA[API 서버 개발 1년 회고: 안정성과 확장성을 향한 여정]]></summary></entry><entry><title type="html">Docker Build, 90초에서 2초로</title><link href="http://0.0.0.0:4000/backend/2025/08/11/02-From-90-To-2s.html" rel="alternate" type="text/html" title="Docker Build, 90초에서 2초로" /><published>2025-08-11T00:00:00+00:00</published><updated>2025-08-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/08/11/02-From-90-To-2s</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/08/11/02-From-90-To-2s.html"><![CDATA[<h2 id="90초에서-2초로-나의-docker-빌드-속도-최적화-분투기">90초에서 2초로: 나의 Docker 빌드 속도 최적화 분투기</h2>

<p>전체 서버 API 프로그램에 대해 정리를 하고, 작업했던걸 테스트 해보려고 Docker Compose로 프로젝트를 빌드하다 흥미로운 메시지를 발견했다.</p>

<blockquote>
  <p>Compose can now delegate builds to bake for better performance. To do so, set COMPOSE_BAKE=true.</p>
</blockquote>

<p>성능 개선이라는 말에 <code class="language-plaintext highlighter-rouge">COMPOSE_BAKE=true</code> 옵션을 바로 적용했다. 이는 약 2만 줄 규모의 NestJS API 서버의 빌드 시간은 항상 90초를 훌쩍 넘기며 어우 너무 길다고 느꼈었다. 그러니 기대도 해봤지만…  결과는 생각보다 실망스러웠다. 아주 약간의 개선은 있었지만, 기대했던 드라마틱한 변화는 없었다.</p>

<p>이 글은 그 실망스러운 결과에서 시작하여, 근본적인 원인을 파헤치고 마침내 빌드 시간을 2초 내외로 단축하기까지의 과정을 정리한 글이다.</p>

<h3 id="1-첫-시도와-실망-10의-미미한-개선">1. 첫 시도와 실망: 10%의 미미한 개선</h3>

<p><code class="language-plaintext highlighter-rouge">COMPOSE_BAKE=true</code> 옵션을 적용한 첫 빌드 시간은 약 88초였다. 기존 98초에 비하면 <strong>약 10% 빨라진 셈</strong>이니 효과가 없지는 않았다. 
이 옵션의 경우 새로운 빌드 기능인데, 빌드 시 이미지를 만드는 과정에서 병렬 처리를 통해 성능이 아주 좋아질 거라고 그렇게 이야기 했었다. 실제로 사용하는 현재 개발 기기는 M4 맥북 프로, 램도 24기가바이트 이니 분명 넉넉하고도 남을 상황이었고, 그러면 못해도 3-40 % 개선이 있을 수 있다고 예상했던 것인데…</p>

<p>무언가 더 근본적인 문제가 내 빌드 과정에 숨어있음을 직감했다.</p>

<p><code class="language-plaintext highlighter-rouge">Bake</code>라는 도구는 죄가 없었다. 문제는 내부에 있었다.</p>

<h3 id="2-근본-원인-추적-왜-내-빌드는-항상-느렸을까">2. 근본 원인 추적: 왜 내 빌드는 항상 느렸을까?</h3>

<p>결론적으로, 내 빌드 속도를 저해하던 범인은 세 가지였다.</p>

<ol>
  <li>
    <p><strong>잘못된 습관: ‘안전’을 맹신한 캐시 삭제</strong>
가장 큰 문제였다. 3.0.0 을 구성하면서 나는 빌드 시 클린 빌드가 되는 것이 가장 중요하다고 생각했다. ‘혹시 모를 충돌’이나 ‘깨끗한 빌드’를 명분으로, 매번 빌드 전에 <code class="language-plaintext highlighter-rouge">docker rmi</code> 명령어로 이전 이미지를 삭제하는 것을 package.json에서 수행하도록 자동화 했었다. 이것은 Docker의 가장 강력한 무기인 <strong>캐시(Cache)를 스스로 내다 버리는 행위</strong>였다.</p>
  </li>
  <li>
    <p><strong>비효율적인 Dockerfile: 잘못된 <code class="language-plaintext highlighter-rouge">COPY</code> 순서</strong>
두 번째 문제는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 내부에 있었다. 나는 습관적으로 소스 코드 전체를 복사(<code class="language-plaintext highlighter-rouge">COPY . .</code>)한 뒤에 의존성을 설치(<code class="language-plaintext highlighter-rouge">RUN yarn install</code>)했다. 이로 인해 소스 코드 단 하나만 수정해도 <code class="language-plaintext highlighter-rouge">yarn install</code> 캐시가 무효화되어 매번 수 분이 걸리는 의존성 설치를 반복하고 있었다.</p>
  </li>
  <li>
    <p><strong>나의 무지: <code class="language-plaintext highlighter-rouge">COMPOSE_BAKE</code>의 본질</strong>
<code class="language-plaintext highlighter-rouge">Bake</code>는 여러 빌드 작업을 <strong>병렬로 처리</strong>해주는 도구이지, 단일 작업 자체를 마법처럼 빠르게 만들어주는 도구가 아니었다. 내 빌드 시간의 대부분은 <code class="language-plaintext highlighter-rouge">yarn install</code>이라는 단일 네트워크 작업이 차지하고 있었으므로, <code class="language-plaintext highlighter-rouge">Bake</code>가 활약할 무대 자체가 없었던 것이다.</p>
  </li>
</ol>

<h3 id="3-전환점-문제-해결과-최적화-적용">3. 전환점: 문제 해결과 최적화 적용</h3>

<p>원인을 알았으니 해결은 명확했다. 각 문제를 해결하기 위해 적용한 구체적인 코드 변경 사항은 다음과 같다.</p>

<h4 id="해결-1-dockerfile-캐시-구조-최적화"><strong>해결 1: <code class="language-plaintext highlighter-rouge">Dockerfile</code> 캐시 구조 최적화</strong></h4>

<p><code class="language-plaintext highlighter-rouge">Dockerfile</code>의 빌더 스테이지에서 <code class="language-plaintext highlighter-rouge">COPY</code> 명령어의 순서를 조정하여 캐시 효율을 극대화했다.</p>

<ul>
  <li>
    <p><strong>수정 전:</strong></p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ❌ 문제 지점: 소스 코드를 의존성 설치 전에 복사</span>
<span class="k">COPY</span><span class="s"> src ./src/</span>
<span class="k">RUN </span>yarn <span class="nb">install</span> <span class="c"># 캐시가 거의 항상 무효화됨</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>수정 후:</strong></p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ✅ 개선 지점: 의존성 설치를 먼저 실행하여 캐시 레이어 생성</span>
<span class="k">RUN </span>yarn <span class="nb">install</span>
<span class="c"># ✅ 개선 지점: 자주 변경되는 소스 코드를 나중에 복사</span>
<span class="k">COPY</span><span class="s"> src ./src/</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="해결-2-파괴적인-빌드-스크립트-수정"><strong>해결 2: 파괴적인 빌드 스크립트 수정</strong></h4>

<p><code class="language-plaintext highlighter-rouge">unset</code> 명령어를 빌드 과정에서 완전히 분리하고, 캐시 사용 여부에 따라 스크립트 역할을 명확히 나누었다.</p>

<ul>
  <li>
    <p><strong>수정 전:</strong></p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w"> </span><span class="nl">"build:dev"</span><span class="p">:</span><span class="w"> </span><span class="s2">"yarn unset:dev &amp;&amp; docker compose ... build"</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>수정 후:</strong></p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"build:dev"</span><span class="p">:</span><span class="w"> </span><span class="s2">"docker compose ... build"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"build:dev:no-cache"</span><span class="p">:</span><span class="w"> </span><span class="s2">"docker compose ... build --no-cache"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="4-결과-98의-시간-단축-개발-경험의-혁명">4. 결과: 98%의 시간 단축, 개발 경험의 혁명</h3>

<p>모든 최적화를 적용한 결과는 역시나 훌륭했다.</p>

<ul>
  <li><strong>최적화 이전 (캐시 X, 비효율 구조):</strong> <strong>약 98초</strong></li>
  <li><strong>최적화 이후 (캐시 X, 효율 구조):</strong> <strong>약 88초</strong> (기존 대비 <strong>10%</strong> 향상)</li>
  <li><strong>최적화 이후 (캐시 O, 효율 구조):</strong> <strong>약 2초</strong> (최초 대비 <strong>98%</strong> 시간 단축)</li>
</ul>

<h4 id="지표로-만들어보면"><strong>지표로 만들어보면?</strong></h4>

<p>이 시간 기록을 기반으로, 평균 프로젝트에서 개발 과정에서 빌드 하는 횟수를 평균 낸 적이 있는데, 이를 기준으로 단축이 실제로 얼마나 큰 차이를 만드는지 프로젝트 규모에 따라 예상해보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능 규모</th>
      <th style="text-align: left">예상 빌드 횟수</th>
      <th style="text-align: left">최적화 전 누적 시간</th>
      <th style="text-align: left">최적화 후 누적 시간</th>
      <th style="text-align: left">**절약된 시간**</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**소형**</td>
      <td style="text-align: left">약 10회</td>
      <td style="text-align: left">약 16분</td>
      <td style="text-align: left">**약 20초**</td>
      <td style="text-align: left">**약 15분**</td>
    </tr>
    <tr>
      <td style="text-align: left">**중형**</td>
      <td style="text-align: left">약 100회</td>
      <td style="text-align: left">약 2시간 40분</td>
      <td style="text-align: left">**약 3분 20초**</td>
      <td style="text-align: left">**약 2시간 36분**</td>
    </tr>
    <tr>
      <td style="text-align: left">**대형**</td>
      <td style="text-align: left">약 250회</td>
      <td style="text-align: left">약 6시간 45분</td>
      <td style="text-align: left">**약 8분 20초**</td>
      <td style="text-align: left">**약 6시간 37분 (거의 하루)**</td>
    </tr>
  </tbody>
</table>

<p>결과적으로, <strong>대형 기능 하나를 개발할 때마다 거의 하루에 가까운 근무 시간을 절약</strong>할수 있게되었다. 이것은 단순한 시간 단축을 넘어, 잦은 빌드 대기로 인해 끊기던 개발의 리듬과 흐름(Flow)을 온전히 유지할 수 있게 만들었다.</p>

<h3 id="5-결론-내가-얻은-교훈들">5. 결론: 내가 얻은 교훈들</h3>

<p>이번 최적화 과정을 통해 몇 가지 중요한 교훈을 얻었다.</p>

<ol>
  <li><strong>도구를 의심하기 전에 나를 의심하라.</strong> <code class="language-plaintext highlighter-rouge">Bake</code>는 훌륭한 도구였지만, 내가 그 성능을 발휘할 환경을 만들어주지 못했다.</li>
  <li><strong>Docker의 기본, 캐시를 믿고 활용하라.</strong> <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 명령어 순서는 단순한 순서가 아닌, 캐시 전략 그 자체이다.</li>
  <li><strong>의도에 맞는 정확한 명령어를 사용하라.</strong> <code class="language-plaintext highlighter-rouge">docker rmi</code>와 <code class="language-plaintext highlighter-rouge">build --no-cache</code>는 비슷해 보이지만, 그 역할과 결과는 완전히 다르다.</li>
</ol>

<p>깨끗한 구조가 꼭 완벽한 개발 상황을 유지해주는 것은 아니었다. 안정성을 최우선으로 생각했지만, 반대로 그렇게 됨으로서 얼마나 많은 손해를 본건지… 다음번 CI/CD 를 수행한다면, 그때엔 이러한 점들의 고려가 필수라고 생각되고, 이러한 점에서 AI 나 동료들과의 검증 절차를 반드시 넣고 만들어보리라 생각을 할 수 있었다.</p>

<p>흠 재밌는 정리였다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="생각정리" /><category term="Backend" /><category term="NestJS" /><category term="TypeScript" /><summary type="html"><![CDATA[90초에서 2초로: 나의 Docker 빌드 속도 최적화 분투기]]></summary></entry></feed>