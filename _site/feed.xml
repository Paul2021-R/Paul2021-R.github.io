<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-06-29T16:41:38+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">Jenkins 를 위한 Groovy 스크립트 언어 정리</title><link href="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/29/groovy-language-with-jenkins.html" rel="alternate" type="text/html" title="Jenkins 를 위한 Groovy 스크립트 언어 정리" /><published>2025-06-29T00:00:00+00:00</published><updated>2025-06-29T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/29/groovy-language-with-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/29/groovy-language-with-jenkins.html"><![CDATA[<h1 id="jenkinsfile-작성-튜토리얼">Jenkinsfile 작성 튜토리얼</h1>

<p>본 내용은 Jenkins 파이프라인 구축 전에 이해도를 위하여 언어에 대한 간단한 가이드를 정리한 내용이다.</p>

<h2 id="들어가기-전에-1-왜-gui가-아닌-스크립트-형태로-써야-하는가">들어가기 전에 1: 왜 GUI가 아닌 스크립트 형태로 써야 하는가?</h2>

<p>Jenkins 는 강력한 플랫폼이다. 다양한 대체제가 나왔음에도 여전히 인정받는 CI/CD 를 위한 툴이며, 그 플러그인과 커뮤니티, 레퍼런스들의 존재들은 여전히 영향력 있는 툴이라는 점을 보여준다.</p>

<p>GUI로 설정 대신 스크립트로 작성해야 하는 이유는 다음과 같다.</p>

<ol>
  <li>버전 관리 용이, 협업 용이성 : GUI 로 설정을 수행하는 것은 스크립트 형태로 내보낼 수 있으나, 그 스크립트 자체는 Git 과 같은 버전 관리 시스템 통합하기 까다롭다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 은 프로젝트 소스 코드와 함께 저장하여 관리하여, <strong>파이프라인 변경 이력</strong>을 Git 으로 완벽히 추적할 수 있고, 이는 긴급 상황이나, 개선이 필요시 쉽게 작업이 가능하다.</li>
  <li>재현성(Reproducibility)과 환경 일관성 : Jenkinsfile 은 파이프라인의 모든 단계를 코드로 정의 내리며, 새로운 Jenkins 인스턴스를 설정하거나 다른 팀에 동일한 파이프라인을 제공시, 스크립트만 복사하면 된다. 이러한 점에서 GUI 보다 효과적이고, <strong>환경의 일관성</strong>을 증대시킬 수 있다.</li>
  <li>복잡하고 동적인 로직 구현 : GUI 방식은 미리 정의된 블록, 제한된 옵션을 활용해야 한다. 그러나 Groovy 언어 기반으로 스크립트를 하게 되면, 매우 유연하고 복잡한 로직을 구현할 수 있다. 이는 다양한 서비스 환경에 맞춤화한 파이프라인 구성이 가능하다는 점에서 매우 중요하다.</li>
  <li>개발 친화적 : 개발팀이 직접 CI/CD 파이프라인을 개선, 유지보수를 할 수 있는데, 이는 DevOps 문화의 핵심 요소다.</li>
  <li>오류 사전 감지 : Jenkinsfile은 문법 오류나 논리 오류를 Git 에 커밋하기 전에 Linter 등을 통해 미리 확인해보는 것이 가능하다.</li>
</ol>

<p>물론, 반대의견으로 GUI 로 만들어 스크립트로 보관을 이야기 하기도 한다. 
Jenkins에는 <code class="language-plaintext highlighter-rouge">Pipeline Syntax</code> 라는 기능으로 GUI 로 설정한 내용을 기반으로 Groovy 코드로 생성 및 보관이 가능하다. 하지만 다음과 같은 이유로 추천하진 않는다.</p>

<ol>
  <li>GUI 에서 제공하는 기능만 사용 가능 : 복잡한 조건, 반복, 동적인 데이터 처리는 결국 손이 감</li>
  <li>복사-붙여넣기 오버헤드 : GUI 에서 설정을 불러와 이를 Jenkinsfile에 넣어야 하는 추가 과정이 발생</li>
  <li>버전관리의 완전한 통합 부족 : Jenkinsfile 이라는 파일로 관리 되어야 할텐데, 그렇지 못함.</li>
</ol>

<h2 id="들어가기-전에-2-jenkinsfile을-프로젝트-내부에-보관해야-하는-이유는">들어가기 전에 2: Jenkinsfile을 프로젝트 내부에 보관해야 하는 이유는?</h2>
<ol>
  <li>버전관리: Git 저장소에 함께 관리될 수 있으니 애플리케이션 코드와 함께 관리가 가능하여 Git 을 활용한 완벽한 추적이 가능.</li>
  <li>재현성 및 환경 일관성: 어떤 환경, 어떤 Jenkins 서버세서든 프로젝트 코드만 Git으로 클론하면 Jenkinsfile 이 함께 따라와서, 동일한 CI/CD 파이프라인을 재현할 수 있다.</li>
  <li>개발자 협업: CI/CD 파이프라인 설정이 코드베이스에 포함되어 개발자들도 파이프라인에 대한 변경 사항을 코드리뷰로 기여할 수 있고, 이는 DevOps 문화 개발, 협업을 강화하는데 기여.</li>
  <li>프로젝트 종속성: 파이프라인은 해당 프로젝트의 빌드, 테스트, 배포 단계를 정의하는데, 각 프로젝트 요구사항에 맞춰 Jenkinsfile 을 개별적으로 관리하는게 효율적.</li>
  <li>새로운 Jenkins 서버 설정의 용이성: 향후 Jenkins 서버를 새로 구축하거나 재설정 시 각 프로젝트에 존재하니, 다시 연결만 해주면 모든 파이프라인의 설정이 자동 복구됨.</li>
</ol>

<h2 id="groovy-언어">Groovy 언어</h2>

<p>Groovy 언어는 Java와 매우 유사하면서도 더 간결하고 유연한 문법을 제공하는 스크립트 언어다. Jenkinsfile에서는 주로 데이터 처리, 조건문, 반복문, 함수 호출 등에 사용된다.</p>

<h3 id="groovy-언어-기본-튜토리얼-jenkinsfile을-위한-핵심">Groovy 언어 기본 튜토리얼 (Jenkinsfile을 위한 핵심)</h3>

<p>여기서는 Jenkinsfile을 작성하는 데 필요한 Groovy의 <strong>핵심적인 문법과 개념</strong>을 위주로 설명한다.</p>

<h4 id="1-변수-선언과-데이터-타입">1. 변수 선언과 데이터 타입</h4>

<p>Groovy는 변수 선언 시 <code class="language-plaintext highlighter-rouge">def</code> 키워드를 사용하거나, 명시적인 데이터 타입을 지정할 수 있다. 대부분의 경우 <code class="language-plaintext highlighter-rouge">def</code>를 사용하면 Groovy가 타입을 자동으로 추론한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">"Jenkins"</span> <span class="c1">// 문자열 (String)</span>
<span class="kt">def</span> <span class="n">version</span> <span class="o">=</span> <span class="mf">2.452</span>   <span class="c1">// 숫자 (정수 또는 실수)</span>
<span class="kt">def</span> <span class="n">isRunning</span> <span class="o">=</span> <span class="kc">true</span>  <span class="c1">// 불리언 (Boolean)</span>
<span class="kt">def</span> <span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"apple"</span><span class="o">,</span> <span class="s2">"banana"</span><span class="o">,</span> <span class="s2">"cherry"</span><span class="o">]</span> <span class="c1">// 리스트 (List)</span>
<span class="kt">def</span> <span class="n">map</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"key1"</span><span class="o">:</span> <span class="s2">"value1"</span><span class="o">,</span> <span class="s2">"key2"</span><span class="o">:</span> <span class="mi">123</span><span class="o">]</span> <span class="c1">// 맵 (Map)</span>
</code></pre></div></div>

<h4 id="2-문자열-strings">2. 문자열 (Strings)</h4>

<p>Groovy는 문자열 처리는 자바보다 유연하게 설계 되어 있다.</p>

<ul>
  <li><strong>따옴표:</strong> 작은따옴표 (<code class="language-plaintext highlighter-rouge">'...'</code>)는 일반 문자열, 큰따옴표 (<code class="language-plaintext highlighter-rouge">"..."</code>)는 문자열 내 변수 삽입(GString)이 가능한 문자열을 나타낸다.</li>
  <li><strong>GString (변수 삽입):</strong> 큰따옴표 안에 <code class="language-plaintext highlighter-rouge">${변수명}</code> 또는 <code class="language-plaintext highlighter-rouge">$변수명</code> 형태로 변수를 직접 삽입할 수 있다.</li>
</ul>

<!-- end list -->

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">buildNumber</span> <span class="o">=</span> <span class="mi">10</span>
<span class="kt">def</span> <span class="n">jobName</span> <span class="o">=</span> <span class="s2">"MyProject"</span>

<span class="n">println</span> <span class="s2">"Build number is ${buildNumber}"</span> <span class="c1">// 결과: Build number is 10</span>
<span class="n">println</span> <span class="s2">"Job name is $jobName"</span>         <span class="c1">// 결과: Job name is MyProject</span>
<span class="n">println</span> <span class="s1">'This is a simple string.'</span>    <span class="c1">// 변수 삽입 안 됨</span>

<span class="c1">// 여러 줄 문자열: """ 또는 '''를 사용</span>
<span class="kt">def</span> <span class="n">multiLineString</span> <span class="o">=</span> <span class="s2">"""
Hello,
This is a multi-line string.
Build: ${buildNumber}
"""</span>
<span class="n">println</span> <span class="n">multiLineString</span>
</code></pre></div></div>

<h4 id="3-리스트-lists">3. 리스트 (Lists)</h4>

<p>iterable 한 데이터 컬렉션 기능. <code class="language-plaintext highlighter-rouge">[]</code> 대괄호를 사용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">fruits</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"apple"</span><span class="o">,</span> <span class="s2">"banana"</span><span class="o">,</span> <span class="s2">"orange"</span><span class="o">]</span>

<span class="n">println</span> <span class="n">fruits</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>      <span class="c1">// 결과: apple (인덱스는 0부터 시작)</span>
<span class="n">println</span> <span class="n">fruits</span><span class="o">.</span><span class="na">size</span><span class="o">()</span>  <span class="c1">// 결과: 3 (리스트 크기)</span>
<span class="n">fruits</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s2">"grape"</span><span class="o">)</span>    <span class="c1">// 요소 추가</span>
<span class="n">println</span> <span class="n">fruits</span>         <span class="c1">// 결과: [apple, banana, orange, grape]</span>
</code></pre></div></div>

<h4 id="4-맵-maps">4. 맵 (Maps)</h4>

<p>키(key)와 값(value)의 쌍으로 이루어진 데이터 컬렉션이에요. <code class="language-plaintext highlighter-rouge">:</code> 또는 <code class="language-plaintext highlighter-rouge">=</code>를 사용하여 정의한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"Alice"</span><span class="o">,</span> <span class="s2">"age"</span><span class="o">:</span> <span class="mi">30</span><span class="o">,</span> <span class="s2">"city"</span><span class="o">:</span> <span class="s2">"Seoul"</span><span class="o">]</span>

<span class="n">println</span> <span class="n">userInfo</span><span class="o">[</span><span class="s2">"name"</span><span class="o">]</span>  <span class="c1">// 결과: Alice</span>
<span class="n">println</span> <span class="n">userInfo</span><span class="o">.</span><span class="na">age</span>      <span class="c1">// 결과: 30 (점(.) 표기법도 가능)</span>
<span class="n">userInfo</span><span class="o">.</span><span class="na">country</span> <span class="o">=</span> <span class="s2">"South Korea"</span> <span class="c1">// 새 키-값 쌍 추가</span>
<span class="n">println</span> <span class="n">userInfo</span>          <span class="c1">// 결과: [name:Alice, age:30, city:Seoul, country:South Korea]</span>
</code></pre></div></div>

<h4 id="5-조건문-ifelse">5. 조건문 (If/Else)</h4>

<p>Java와 동일하게 <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else</code>를 사용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">status</span> <span class="o">=</span> <span class="s2">"SUCCESS"</span>

<span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">==</span> <span class="s2">"SUCCESS"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"배포 성공!"</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">==</span> <span class="s2">"FAILURE"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"배포 실패!"</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"배포 상태 알 수 없음."</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="6-반복문-loops">6. 반복문 (Loops)</h4>

<p><code class="language-plaintext highlighter-rouge">for</code> 루프와 <code class="language-plaintext highlighter-rouge">each</code> 클로저(함수)를 주로 사용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">items</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"item1"</span><span class="o">,</span> <span class="s2">"item2"</span><span class="o">,</span> <span class="s2">"item3"</span><span class="o">]</span>

<span class="c1">// for 루프</span>
<span class="k">for</span> <span class="o">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"Processing: $item"</span>
<span class="o">}</span>

<span class="c1">// each 클로저 (더 Groovy스러운 방식)</span>
<span class="n">items</span><span class="o">.</span><span class="na">each</span> <span class="o">{</span> <span class="n">item</span> <span class="o">-&gt;</span>
    <span class="n">println</span> <span class="s2">"Processing with each: $item"</span>
<span class="o">}</span>

<span class="c1">// 인덱스와 함께 반복 (eachWithIndex)</span>
<span class="n">items</span><span class="o">.</span><span class="na">eachWithIndex</span> <span class="o">{</span> <span class="n">item</span><span class="o">,</span> <span class="n">index</span> <span class="o">-&gt;</span>
    <span class="n">println</span> <span class="s2">"Item ${index}: $item"</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="7-함수-methodsclosures">7. 함수 (Methods/Closures)</h4>

<p>Jenkinsfile에서는 주로 <code class="language-plaintext highlighter-rouge">script</code> 블록 내에서 Groovy 함수를 정의하거나, 클로저를 활용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일반적인 함수 정의</span>
<span class="kt">def</span> <span class="nf">greet</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s2">"Hello, ${name}!"</span>
<span class="o">}</span>

<span class="n">println</span> <span class="nf">greet</span><span class="o">(</span><span class="s2">"World"</span><span class="o">)</span> <span class="c1">// 결과: Hello, World!</span>

<span class="c1">// 클로저 (변수에 할당된 코드 블록)</span>
<span class="kt">def</span> <span class="n">sayHi</span> <span class="o">=</span> <span class="o">{</span> <span class="n">name</span> <span class="o">-&gt;</span>
    <span class="n">println</span> <span class="s2">"Hi, $name"</span>
<span class="o">}</span>

<span class="n">sayHi</span><span class="o">(</span><span class="s2">"Bob"</span><span class="o">)</span> <span class="c1">// 결과: Hi, Bob</span>
</code></pre></div></div>

<h4 id="8-try-catch-예외-처리">8. try-catch (예외 처리)</h4>

<p>스크립트 실행 중 발생하는 오류를 처리하여 파이프라인이 갑자기 중단되지 않도록 할 수 있음.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">def</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="s">/ 0 /</span><span class="o">/</span> <span class="mi">0</span><span class="err">으로</span> <span class="err">나누기</span> <span class="err">오류</span> <span class="err">발생</span>
    <span class="n">println</span> <span class="n">result</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"오류 발생: ${e.message}"</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">println</span> <span class="s2">"오류 발생 여부와 상관없이 항상 실행되는 부분."</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="9-외부-명령어-실행-shell-command">9. 외부 명령어 실행 (Shell Command)</h4>

<p>Jenkinsfile에서 가장 많이 사용하는 기능 중 하나로, <code class="language-plaintext highlighter-rouge">sh</code> (Shell) 명령어를 통해 리눅스/유닉스 쉘 명령어를 실행하는 것이 가능하다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sh</span> <span class="s1">'ls -al'</span> <span class="c1">// 파일 목록을 출력</span>
<span class="n">sh</span> <span class="s1">'echo "Hello from shell"'</span> <span class="c1">// 쉘에서 메시지 출력</span>

<span class="c1">// 여러 줄 명령</span>
<span class="n">sh</span> <span class="s2">"""
    echo "First line"
    echo "Second line"
"""</span>

<span class="c1">// 명령의 결과 받기</span>
<span class="kt">def</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sh</span><span class="o">(</span><span class="nl">script:</span> <span class="s1">'pwd'</span><span class="o">,</span> <span class="nl">returnStdout:</span> <span class="kc">true</span><span class="o">).</span><span class="na">trim</span><span class="o">()</span> <span class="c1">// 현재 작업 디렉토리 경로를 pwd 로 실행하고 받아서, trim 처리하여 작업 디렉토리를 저장한다.</span>
<span class="n">println</span> <span class="s2">"Current directory: $output"</span>

<span class="c1">// 명령의 성공/실패 여부만 확인</span>
<span class="kt">def</span> <span class="n">success</span> <span class="o">=</span> <span class="n">sh</span><span class="o">(</span><span class="nl">script:</span> <span class="s1">'exit 0'</span><span class="o">,</span> <span class="nl">returnStatus:</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// 성공하면 0 반환</span>
<span class="kt">def</span> <span class="n">failure</span> <span class="o">=</span> <span class="n">sh</span><span class="o">(</span><span class="nl">script:</span> <span class="s1">'exit 1'</span><span class="o">,</span> <span class="nl">returnStatus:</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// 실패하면 1 반환</span>
<span class="n">println</span> <span class="s2">"Success: $success, Failure: $failure"</span>
</code></pre></div></div>

<h4 id="10-jsonyaml-파싱">10. JSON/YAML 파싱</h4>

<p>AWS CLI 명령의 결과가 JSON 형태인 경우가 많다. 이를 Groovy에서 파싱하여 데이터에 접근하는 방법을 알아두면 유용하다. <code class="language-plaintext highlighter-rouge">readJSON</code>이나 <code class="language-plaintext highlighter-rouge">readYaml</code> 같은 Jenkins Pipeline Step이 이를 도와서 처리해준다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">jsonString</span> <span class="o">=</span> <span class="s1">'{"name": "test", "status": "success"}'</span> <span class="c1">// Json 을 읽어</span>
<span class="kt">def</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="n">readJSON</span><span class="o">(</span><span class="nl">text:</span> <span class="n">jsonString</span><span class="o">)</span> <span class="c1">//파싱 처리 =&gt; 객체화</span>

<span class="n">println</span> <span class="n">jsonData</span><span class="o">.</span><span class="na">name</span>   <span class="c1">// 결과: test</span>
<span class="n">println</span> <span class="n">jsonData</span><span class="o">.</span><span class="na">status</span> <span class="c1">// 결과: success</span>
</code></pre></div></div>

<hr />

<h2 id="groovy-학습-팁--알아두면-좋은-내용">Groovy 학습 팁 &amp; 알아두면 좋은 내용:</h2>

<ul>
  <li><strong>Jenkins Pipeline Syntax Snippet Generator:</strong> Jenkins 대시보드의 파이프라인 잡 설정 페이지에서 “Pipeline Syntax” 링크를 클릭하면 Snippet Generator를 사용할 수 있다. 여기서 원하는 Jenkins 스텝을 선택하고 설정을 채우면 해당 Groovy 코드를 자동으로 생성해 준다. 이것이 Groovy 문법을 익히는 데 가장 강력한 도구 중 하나다.</li>
  <li><strong>Java 지식 활용:</strong> Groovy는 Java와 매우 유사하므로, Java 경험이 있다면 빠르게 적응할 수 있다.</li>
  <li><strong>간결함 선호:</strong> Groovy는 Java보다 더 적은 코드로 동일한 작업을 수행할 수 있는 “Syntactic Sugar”가 많다. 간결한 표현을 선호하는 경향이 있다.</li>
  <li>Jenkins 를 위한 jenkins 파일의 구조를 이해하는 것이 실수를 줄이는데 중요하다.</li>
  <li>글로벌 변수의 경우 최초 설정을 하긴 하지만, 기본적으로 Secret 등에 대해 우선 가져오는 구조로 설정은 불가능하다. 각 단계별로만 되고, 이러한 경우 에러 핸들링은 Jenkins 가 알아서 해준다는 점 알아둘것.</li>
</ul>

<hr />

<h2 id="마치면서">마치면서</h2>

<p>젠킨스랑 같이 산지도 어언 7개월 차. Unity 클라이언트 프로젝트를 쓰는 바람에 익숙한 Github 방식을 버리게 되어 다소 아쉽지만, 뭐 어떤가, 대세 기술 하나 제대로 파는건 당연히 필요하고, 특히나 jenkins 는 최소 3년 ~ 5년차에게 요구되는 기술이라는데 제대로 배워둘 필요가 있다고 느꼈다(일단 재미도 있다)</p>

<p>엄두도 안 났었던 내용인데, Docker 를 비롯해 한 두달 바짝 DevOps를 위한 여러 기술들을 고심하고, API 서버에 도입을 하나씩 해 나가니 생각보다 별거 아니란 생각에, 역시 양파 까듯 생각했어야 하는 구나 란 생각을 다시 한 번 해보았다.(처음엔 뭐 그리 부담스럽게 생각했던 것인지…)</p>

<p>이제 한 발자국 남았다. Jenkins 배포를 위한 file 작업 중이니 조만간 마무리 지어야지….🤔</p>]]></content><author><name>Paul2021-R</name></author><category term="개발" /><category term="Backend" /><category term="DevOps" /><category term="Programming" /><category term="Groovy" /><category term="학습" /><summary type="html"><![CDATA[Jenkinsfile 작성 튜토리얼]]></summary></entry><entry><title type="html">서버 상태를 알려주는 서버리스 서버 만들기 v1</title><link href="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/28/EKS+LAMDA+CLOUDWATCH.html" rel="alternate" type="text/html" title="서버 상태를 알려주는 서버리스 서버 만들기 v1" /><published>2025-06-28T00:00:00+00:00</published><updated>2025-06-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/28/EKS+LAMDA+CLOUDWATCH</id><content type="html" xml:base="http://0.0.0.0:4000/%EA%B0%9C%EB%B0%9C/2025/06/28/EKS+LAMDA+CLOUDWATCH.html"><![CDATA[<h2 id="0-introduciton">0. Introduciton</h2>

<p>신규 프로젝트를 진행하는 과정에서 backend 개발자로서 Legacy 코드들의 대대적인 개선, 코드 품질 향상, 그러면서도 향후를 고려한 다양한 DevOps 적인 요청이 들어왔다.</p>

<p>아무래도 클라이언트 처럼 직접적인 개발이 필요한 입장에선 타이트한 일정 상황에서 구현이나, 현재의 목표에 중시해야 했지만, 백엔드라는 특성 상 테크리더의 요청으로 백엔드는 보다 안전하고, 보다 관리 용이성을 높이는 것 역시 추가로 필요하다는 것이 리더의 설명이자, 계획이었다.</p>

<p>그렇기에 나 역시 개발의 핵심 방향성을 잡고 한달의 달리기를 위한 목표 설정을 했었다. 내용은 다음과 같다.</p>

<ol>
  <li>배포와 개발 환경을 최대한 독립화하자.
    <ul>
      <li>Docker 이미지화 + ECR 을 활용하기 + 시작 템플릿을 활용하여 1 딸깍이면 신규 이미지를 불러오돌 구현하자</li>
      <li>Jenkins 를 활용한 무중단 배포를 최대 목표로 잡자.</li>
    </ul>
  </li>
  <li>배포, 개발의 과정에서, 기계적으로 코드 품질을 유지할 장치를 마련하자.
    <ul>
      <li>Husky 의 도입을 통해 git 이벤트를 추적해 특정 품질 최적화 기능을 구동시킨다.</li>
      <li>lint, lint-staged, tsc 컴파일러의 typechecking 등을 내부에 추가하기</li>
    </ul>
  </li>
  <li>코드 외적으로 Ops 관점에서 최대한 안정성을 확보하자.
    <ul>
      <li><strong>Cloud Watch 서비스를 보다 고도로 파악하고 적용하자, 특히 각 서버의 특성(AI, API) 이에 최적화된 헬스 체킹의 기반을 준비하자.</strong></li>
      <li><strong>국내에선 당장 문자로 인스턴스 상태 알림을 수신 가능하게 만들자</strong></li>
    </ul>
  </li>
</ol>

<p>말이 길어졌다. 사실 해당 프로젝트에 대해서도 정리가 필요하긴 할 것으로 보이지만, 그것은 또 다음 시간에… 사실 너무 바빠서 그 중간의 내용에 진행했던 내용을 다 적었다간, 논문이 되어버릴지도 모른다. 😂</p>

<h2 id="1-sms-어떻게-보내볼까">1. SMS 어떻게 보내볼까</h2>

<p>사실 요즘은 딸깍- 이라는 키워드를 활용하듯 B2B 서비스나, AWS 에서도 돈을 더 내고 고급 서비스를 써도 된다. 심지어 글로벌이라면 SNS 서비스를 활용하면 그냥 그걸로 끝날지도 모른다. 하물며 lamda 와 SNS API 를 활용하면 아마 그걸로 충분히 구현 될 수도 있다.(그러니 사실 따라하라고 추천하고 싶진 않다… 이 글의 목적도 엄밀히 말하면 서버리스 서비스와 AWS 의 서비스를 보다 내 스타일로 써보면 어디까지 되나? 가 궁금해서 일을 크게 키운거기도 하다.) 어쨌든, 그리하여 여러 고민을 해보았다.</p>

<ol>
  <li>기존 쓸 수 있는 서비스를 최대한 활용하고 싶다.</li>
  <li>비용이나, 헬스 체킹에 너무 시간을 쏟기는 싫다.</li>
  <li>배포 관리하기 귀찮다!</li>
  <li>서버리스 서비스를 한번 써보고 싶다..!</li>
  <li>대신 종속성은 최소화 하자</li>
</ol>

<p>요정도를 고려해보았다.그리하여 나온 구조는 다음과 같은 구조이다.</p>

<p><img src="/assets/images/posts/2025-06/2025-06-28-0001.png" alt="" /></p>

<h3 id="1-1-event-추적--proccessor-로-송신">1-1. Event 추적 ~ Proccessor 로 송신</h3>

<p>CloudWatch 는 기본적으로 모니터링할 대상을 바라본다. 특히 여기서 핵심은 각 서버마다 이벤트를 지정 시 Health 의 지표가 될 만한 핵심을 파악해야 한다는 점이다. 연산장치인 CPUUtilization 을 보는 지표도 있겠지만, 자사의 경우 유저의 일정한 수준의 처리 성능을 중요시 했고, 따라서 네트워크 사용량에 대한 구체적인 정보 쪽이 훨씬 서버 관리에 중요하였다.</p>

<p>여기서 중요한 포인트라고 생각되는 것은, 사실 SNS 를 쓰지 않아도 된다는 사실이다. SimpleNotificationService 를 통해 주제를 설정하지 않더라도, CloudWatch 는 직접 Lambda 를 호출하는 게 가능하다. 하지만 그렇게 하게 되면 CloudWatch 의 알람마다 Lambda 설정을 건드려야 할 필요가 발생하고 만다. 따라서 1:N 의 관계가 필요하다면, 반드시 중간 매개체로 N이 1과 바로 연결되지 않는 구조가 필요하기 때문에 SNS 의 존재가 꼭 중요하다 볼 수 있다.</p>

<p>그 뒤 Lambda 는 SNS 를 통해 일원화 되어 들어오는 이벤트들에 대해 내가 지정한 위치의 URL 로 보내면 되는데, 이때 주요한 내용으로 알아두면 하는 것은, ‘파이썬’ 기반으로 사용한다고 하더라도, 순정 상태에선 외부 라이브러리를 쓰지 못한다는 점이다(괜히 이점 때문에 AI 바이브 코딩 했다 왜 안되나 한참 찾았다.) 다행히, 수동으로 넣어줘도 되고, 간단한 통신 정도만 수행한다면 제일 좋은 건 내장 통신 라이브러리로 전달만 하는 것이다.</p>

<h3 id="1-2-수신-및-프로세싱--sms">1-2. 수신 및 프로세싱 ~ SMS</h3>

<p>Processor 라고 이름을 지은 이 서버의 목적은 Naver의 SENS API 에 맞게 전달해주는 역할이다. NaverCloud 라니! 라고 생각할 수도 있다. 하지만 어떻게 하겠는가, 회사에선 이걸 쓰고 있는데(…) 이미 실서비스에 사용 중이기도 했고, API 가 익숙하다는 점을 생각하니, 이부분 만큼은 빠르게 가기로 했다.</p>

<p>그리하여 API ~ SMS 는 처리 했고, 그 다음의 포인트는 역시 수신 받는 곳의 구현이었다.</p>

<p>NestJS 를 사용해도 되긴 했다. 왜냐면 이미 NestJS 서버는, 우리 회사 상용 서버 역시 3.0.0에 해당하는 수준으로 판을 올려놓은 상태였고, 해당 템플릿을 사용한다면 충분히 할만하지 않을까? 싶었다.</p>

<p>그러나 이미 써본 기술, 동시에 장황하게 설정된 기능들이나 관리 코드들을 그대로 가져오기엔 용도에 맞지 않는 다는 점은 분명해 보였다. 이에 이왕 현재 자사 서비스를 위해 사용 중인 FastAPI 를 써보면 좋겠다는 생각을 했고, 이왕 하는 김에 의존성의 관리는 Poetry 를 사용해보기로 했다.</p>

<p>써본 후기로는… Poetry 는 가상환경 커맨드 안쳐도 된다! 편하다! 와, FastAPI 는 우와 자동 Swagger 쩐다…! 😯 라는 느낌을 받았다. Pydantic을 통한 자동 데이터 유효성 검사, 그리고 /docs 경로에 자동으로 생성되는 API 문서는 Postman 없이도 즉시 테스트가 가능한 환상적인 개발 경험을 제공했다.</p>

<p>여기서 핵심은 API 를 수신하고, 각 이벤트에 맞춰 지정된 대상에게 전달하는 구조를 작성하는 것이었고, 그 뒤엔 이를 배포하는 걸 조금이라도 ‘편하게’ 하는 방법을 구현하는 것이었다.</p>

<p>이에 ECR(Elastic Container Registry)에 tag 를 활용하여 가장 최신으로 관리되는 것, 그리고 EC2를 활용하여 인스턴스로 관리하는 것이 아니라, 알아서 필요시 사용되기 + 스케일러블 하게 대응이 가능하게 만드는 것으로 하였다.</p>

<p>특히나 이렇게 구현 하면서 ECS(Elastic Container Service) 를 처음 써보게 되었는데, Task 라는 개념으로 Fargate 방식을 제공하는 ECS 를 사용했고, 초기 사용은 복잡했지만, ELB 와 기타 조합을 통해 알아서 이미지로 갱신되도록 만들었다. Task Definition, Service, 그리고 ALB Target Group과 Security Group 간의 네트워킹 설정은 처음 접하는 입장에서 많은 시행착오를 요구했다. 코어 0.25개에 0.5GB 의 메모리 사용은, 인스턴스처럼 항상 준비된 하드웨어요금이 나가는 것보다 계산 시 훨씬 경제적이었다. (물론 함정은 다른데 있다)</p>

<h2 id="2-그래서-이-구조의-장점과-단점은-뭘까">2. 그래서 이 구조의 장점과 단점은 뭘까</h2>

<p>전체적으로 작업이 끝나고 SMS 를 받아보니, 확실히 이메일 받을 때 보단 상태를 확인도 가능하고, 설정에 따라 주기적으로 헬스 체크도 가능해진다는 점은 매우 편리하였다. 바이브 코딩 + 각종 기술 맛보기 + AWS 서비스 구성을 배워 본다는 점에선 매우 영양가 있던 시간(?) 이라고 밖에 할 말이 없을 것 같은데, 그럼에도 구조를 짜고 내용을 바라보면 다소 아쉬움도 남았다. 😎</p>

<h3 id="2-1-장점-pros">2-1. 장점 (Pros)</h3>
<p>우선, 완벽하게 모듈화된 설계 구성은 예를 들어 lambda 하나로만 한다거나 하는 것 보다 훨씬 직관적이었다. 각 역할(이벤트 수신, 처리, 발송)이 명확했고, 문제가 발생했을 때 어느 지점의 문제인지 파악하기 용이했으며, 특히 각 영역의 수정이나 배포 등에서 매끄럽다고 생각한다.</p>

<p>데이터 편집은 FastAPI 서버를 건드리면 되고, 알람은 CloudWatch 경보를 추가하거나 세밀하게 만들어 주면 될 문제였다. lambda는 필요할 때만 활성화 되니 필요하지 않을 땐 사실상 없는 것이나 마찬가지. Fargate의 경우에도 그냥 켜둔 다면 0원에 수렴하기 때문에 가장 작은 EC2 인스턴스를 쓴다고 해도, 이미 프리티어는 넘어버린 자사 입장에선 훨씬 양호했다.</p>

<p>개인적인 면에서도 서버리스 + ECR + 도커 이미지로의 빌드 + 태깅을 통한 최신 이미지 추적의 형태는 개발 이후 복잡할 수 있는 배포 과정을 deploy.sh 스크립트 하나로 매우 깔끔하게 만들어주었다. Fargate 라는 서비스는 생각 이상으로 편리하다는 점, 직접 프로비저닝이나 관리 안해도 되는 점은 확실히 좋았다. 응용할 수 있는 방법은 특히나 많았고, 서비스의 특성에 따라 경제적인 서버 운용에 키 역할을 해줄 수 있겠구나 하는 생각을 할 수 있었다.</p>

<p>람다의 경우, 생각 이상으로 너무 편하다는 생각은 확실히 들었다. 데이터의 중간 인터셉터 역할을 하기엔 확실히 편리했고, 그냥 코드를 짜고 deploy 만 하는 순간 끝난다는 점은 ‘서버로 만들긴 애매한’ 무언가를 위한 상당히 좋은 툴이었다는 경험이(?) 추가 되었다고 볼 수 있을 것 같다 😁</p>

<p>또한 먼 이야기겠지만, 이벤트가 늘어나면 조건만 추가하면 자연스럽게 스케일러블 한 설계가 가능하고, 민감한 정보는 모두 컨테이너화 되어 있으니(특히 전달 받는 분들의 연락처 등), 이러한 점에서 알림 서비스로서 향후를 고려한 꽤 괜찮은 구성이 아닐까 싶다.</p>

<h3 id="2-2-단점-cons">2-2. 단점 (Cons)</h3>
<p>AWS 는 바보가 아니다. 이렇게 편리한 서비스 옵션들, 모듈들을 무료로 푸는 데는 나름의 악랄한 부분이 있지 않으면 안된다(…) <del>등가교환 법칙…</del></p>

<p>우선 핵심은 모듈화 하는 과정에서 Fargate 의 구성 난이도가 오히려 무지하게 높다는(!) 생각을 할 수 있었다. 해당 서비스의 의도와 구성에 대한 이해도가 없지만 AI 를 활용해서 그나마 해결했지, 이걸 모르는 사람이 혼자 해본다? 과연 될까 싶은게 솔직한 감상이었다(…)</p>

<p>뿐만 아니라, SMS 로 알림을 보내는 게 핵심인데, 그걸 위해 하루 정도 소요되는 시간을 들여 만든다는 것은, 어떤 점에선 최악의 시간 낭비일 수도 있지 않나 싶다. 서버 상태의 알림은 주의-경보 이정도만 해도 되는데, 그걸 위해 이렇게까지 투자하는 것은 어쩌면 라이브 서비스에서도 어느정도 운영을 했다고 생각하니까지, 초기 팀이나, 초기 서비스에 이렇게 알림에 하루 쓴다는건 그게 맞나? 싶은 생각을 할 수 있었다.</p>

<p>모듈화가 장점이지만, 동시에 차라리 이렇게 안만들고 통짜로 만들어도 되는거 아닌가? 생각도 문뜩 들었다.</p>

<p>마지막으로 가장 최악은, 비용에 대한 부분이다. SMS 쓴다고 돈을 써야 하는 부분을 제외하면 이번 작업 과정 전체는 충분히 경제적이었다. 0.25 개의 코어 활용, 0.5GB 메모리, 일반 인스턴스론 불가능할 수준으로 작은 수준이다보니, 역할조차 작으니 말이 안되게 작은 스펙이지만 충분히 잘 돌아갔다.</p>

<p>하지만, Fargate, Lambda 등은 문제가 아닌데, 이를 통신하기 위해 연결해야 하고, 그렇게 되는 과정에서 ELB(Elastic Load Balancer)를 비롯한 각종 네트워킹 서비스들의 비용은 당연히 부과 되는 것이었고, 그냥 단순히 Fargate 의 컨테이너가 돌리기만 한다면 좋았겠지만 그렇지 못하다보니 계산 시 한달에 3만원 ~ 많게는 4.5 만원까지도 나올 수 있다는 계산을 다 만들고 했다(…)</p>

<p>아니, 인스턴스 24시간 켜놓고 3-4만원 나오는게 맞추면, 이것저것 다할 수 있는데? <del>전형적인 조삼모사</del></p>

<p>… 여하튼 할 말은 많지만 V1 버전은 그리하여 마무리하고 나니 아쉬운 점, 특히 투머치 한 점을 보완해야 한다는 점을 깨달을 수 있었다</p>

<h2 id="3-결론">3. 결론</h2>

<p>요즘 키워드 DevOps, GitOps 가 특히 중요하다는데, 확실히 재미있는 영역이다. 그리고 더불어 AWS 와 같은 서비스에 대해 개념의 이해도 착실히 늘어가고 있다는 점에서 자신감이 붙는 포인트가 아닐까 싶다.</p>

<p>특히나 서버리스는 말로만 서버리스라고 했지, 막상 테스트 삼아 만들어 본 적은 없었는데, 만들면서 왜 필요한지 확실히 체감을 할 수 있었다. 서버라는 어떤 스테레오 타입 구축을 위한 노력 없이, 기능적 최소화, 자원 사용의 최소화라는 관점에선 꽤나 멋진 기능이고, 활용도가 상당하다는 점에서 괜찮다는 생각이 들었다.</p>

<p>다만, 역시나. 이렇게 편하면 괜한게 아닌것 처럼(…) 그 서비스 자체는 괜찮지만, 사실상 반 필수로 써야 하는 다른 서비스들에 대해 요금설계가 확실히 되어 있다는 점에서, “이럴 거면 그냥 EC2 연결하지 왜…?” 라는 말이 튀어나오게 되는게 사실이다(개발자 입장에선).</p>

<p>그리하여 바로 V2 형태로 개선을 했었는데, 그 내용도 조만간 정리해야 겠다.</p>]]></content><author><name>Paul2021-R</name></author><category term="개발" /><category term="Backend" /><category term="DevOps" /><category term="AWS" /><category term="Python" /><category term="AI" /><category term="NaverCloud" /><summary type="html"><![CDATA[0. Introduciton]]></summary></entry><entry><title type="html">NestJS 를 위한 NodeJS Deep Dive</title><link href="http://0.0.0.0:4000/backend/2025/06/04/deep-dive-node-js.html" rel="alternate" type="text/html" title="NestJS 를 위한 NodeJS Deep Dive" /><published>2025-06-04T00:00:00+00:00</published><updated>2025-06-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/06/04/deep-dive-node-js</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/06/04/deep-dive-node-js.html"><![CDATA[<h2 id="0-들어가면서">0. 들어가면서</h2>
<p>본 글은 어디까지나 NestJS 개발자로써 Node 기본기를 다지기 위해 원하는 식의 재구성이 포함됩니다. 혹시나 내용적으로 오류가 있으면 알려주시면 감사하겠습니다 😎</p>

<h2 id="1-why-node-and-then-nestjs">1. Why Node And then NestJS</h2>
<p>Node.js 의 이해도는 NestJS 개발자로 하여금 여러 이점을 갖춘다.</p>

<ul>
  <li><strong>디버깅 및 성능 튜닝</strong>: 이벤트 루프, V8 엔진, 메모리 관리와 같은 Node.js 내부 구조를 깊이 이해하면 NestJS 추상화를 통해서는 즉시 명확하지 않을 수 있는 성능 병목 현상, 메모리 누수 및 비동기 동작을 보다 효과적으로 디버깅할 수 있다.</li>
  <li><strong>Node.js 기능 직접 활용</strong>: NestJS는 많은 유틸리티를 제공하지만, 복잡한 파일 작업에는 fs 모듈, 특정 암호화 요구에는 crypto 모듈, CPU 집약적 작업에는 worker_threads 모듈과 같이 Node.js 핵심 모듈을 직접 사용해야 하거나 더 효율적인 시나리오가 있다.</li>
  <li><strong>정보에 입각한 아키텍처 결정</strong>: Node.js의 단일 스레드 특성, 논블로킹 I/O 및 모듈 시스템에 대한 지식은 특히 확장성 및 마이크로서비스 설계와 관련하여 NestJS 애플리케이션 내에서 더 나은 아키텍처 선택을 하는 데 도움이 된다.</li>
  <li><strong>향상된 보안 이해</strong>: 일반적인 Node.js 취약점을 이해하면 NestJS의 보안 기능(예: 입력 유효성 검사 파이프가 주입 공격을 방지하는 방법 이해)을 이해하고 올바르게 구현하는 데 도움이 된다.</li>
</ul>

<p>생각해보면 NestJS 는 그 철학의 근간이 되는 Angular 와 MVC 패턴의 유사성을 보여주는 Spring 프레임워크의 그것을 잘 버무려놓은 도구이다. 그 덕에 네트워크를 통한 서버 애플리케이션의 라이프사이클을 추상화하고, 그 순서에 대한 이해도가 없는 상태에서도 Node.js 기반으로 동작하며 기본 HTTP 요청을, 그 이해도가 낮음에도 구동하게 해주는 아주 훌륭한 도구일 것이다.</p>

<p>하지만 그러한 초반의 구조적인 도움은 빠른 개발, 유연한 대응이 가능하게 해주긴 하지만, 그 이상의 최적화, 그 이상의 개선이 필요할 때, Node.js 에 대한 이해도가 없다면 이는 좀더 고급의 기능들, 알수 없는 버그나 오버헤드의 최적화 차원에서의 성능이 뛰어난 코드, 안정성의 제고 등이 불가능하다.</p>

<h2 id="2-nodejs-의-runtime">2. Node.js 의 Runtime</h2>
<h3 id="2-1-v8-엔진">2-1. V8 엔진</h3>
<p><img src="/assets/images/posts/2025-06/2025-06-05-0002.png" alt="" /></p>
<blockquote>
  <p>처음 JS 를 배울 때가 생각난다..</p>
</blockquote>

<p>JavaScript는 그 이름처럼 Java의 명성을 따라, 웹 브라우저의 스크립팅 언어로 그 태초를 시작하였다. 하지만 그 사용성이나 웹의 가치가 증대됨에 따라, 해당 스크립트의 발전도 이루어져 갔으며, 그 과정에서 특히나 가속을 이룰 수 있던 것이 Google 의 Chromium의 V8 엔진을 사용하게 된 이후에서였다. 단순 인터프리팅 방식으로의 해석 및 동작 실행을 넘어서서, 기계 코드로의 컴파일을 겸하게 되고 고성능을 이룩하면서, JavaScript는 단순한 웹 스크립트 언어 그 이상의 가치를 갖게 된다.</p>

<p>특히, 그 와중에 나온 것이 바로 V8을 기반이며 웹 상이 아닌, 호스트 컴퓨터 기반에서도 구동이 가능한 런타임으로 Node가 등장하게 된 것이다.</p>

<h4 id="2-1-1-jitjust-in-time-컴파일-및-성능">2-1-1. JIT(Just-In-Time) 컴파일 및 성능</h4>
<p><img src="/assets/images/posts/2025-06/2025-06-05-0003.png" alt="" /></p>

<p>Node 는 v8 엔진 기반의 런타임이고 기본 인터프리팅 방식으로 JS 코드들을 수행한다. Ingnition 인터프리터에 의해 해석될 수 있고, 그런데 이 과정에서 반복적으로 동작이 필요한 코드들이 발생한다. 이러한 ‘핫 함수’(자주 실행되는 코드) 영역에 대해서는 TurboFan 컴파일러에 의해 기계코드로 컴파일이 이루어진다.</p>

<p>CS의 아주 기초적인 상식이지만, 사람의 언어에 가깝게 구성된 언어일 수록 컴퓨터는 이를 이해하는데 상당한 리소스를 쓸 수 밖에 없다. 이와 반대로 바이너리(기계코드)로 이루어진 코드가 되면, 이는 CPU 가 사용하는 이해 방식 그대로이니 그만큼 쉽게, 빠르게 처리될 것이다. 즉, 기존의 JS 코드들은 느리거나, 그 태생의 한계를 가지고 있다고 평가 되었지만 JIT 컴파일러의 등장은 Node.js 가 충분히 속도를 확보할 수 있는 비결이 되었으며, 따라서 JS 코드나 TS 코드를 작성시, 보다 깔끔하고 예측 가능한 코드를 작성시 V8이 더 효과적으로 최적화할 수 있다.</p>

<h4 id="2-1-2-가비지-컬렉션">2-1-2. 가비지 컬렉션</h4>
<p>V8은 GC 를 사용하여 메모리를 자동 관리해주고, 그렇기에 개발자가 이를 관리할 필요를 없애주었다. 여기에는 시간의 서순에 따라 관리되는 접근 방식을 갖춘다.</p>

<ul>
  <li>New Space (Young Generation): 새 객체가 할당되는 곳. 여기서는 수집이 빈번하고 빠르며, New Space를 두 개의 세미 스페이스로 나누는 “Scavenge” 알고리즘(복사 수집기)을 사용함. 대부분의 객체가 “젊을 때 죽기” 때문에 효율적이다.</li>
  <li>Old Space (Old Generation): 몇 번의 Scavenge 주기를 거친 객체는 Old Space로 승격되어 관리된다. 여기서는 수집 빈도가 낮지만 시간이 더 많이 소요되며, “Mark &amp; Sweep”(도달 가능한 객체를 표시하고 가비지를 제거) 및 “Mark &amp; Compact”(추가로 라이브 객체를 이동하여 조각화 줄임) 알고리즘을 사용하여 관리된다.</li>
</ul>

<p>특히나 NestJS 기준으로 설명하면 서비스, 전역 프로바이더는 오래 지속되는 객체로 Old Space에 남게 되는데, 문제는 잘못 관리되는 객체 수명 주기나 대규모 객체 할당이 발생하면 GC 일시중지를 증가시켜 애플리케이션의 응답 성능에 문제를 일으킬 수 있다.</p>

<h4 id="2-1-3-v8의-최적화-기술과-javascript-기반-언어-사용시-중요한-포인트">2-1-3. V8의 최적화 기술과 JavaScript 기반 언어 사용시 중요한 포인트</h4>
<ul>
  <li>
    <p>Hidden Class(Shapes): V8엔진은 JS 언어의 특징이라고도 볼 수 있는 객체 속성 접근을 최적화 하기위한 메모리 관리 기법으로 동일한 구조(동일한 순서로 동일한 속성)를 가진 객체는 히든 클래스를 공유한다.</p>

    <p>따라서 인스턴스 화 후에 속성이 추가되거나, 변경되는 코드가 작성되게 되면, 히든 클래스의 전환도 발생하게 되고, 상당한 성능 저하를 일으 킬 수 있다.</p>

    <p>이러한 구조는 JS, TS 언어의 프로토타입과도 밀접한 관련이 있을 수 있는데, 이러한 공유 공간을 통해, 유사한 속성들의 무질서한 메모리 할당에서 자유로울 수 있다.</p>
  </li>
  <li>
    <p>Inline Caching(ICs): 해당 기능은 속성 조회 결과를 캐싱해두는 역할에 대해서를 표현한다. V8 엔진이 히든 클랫, 속성의 오프셋을 기록하고, 동일한 기능 작업이 수행되면 V8은 캐시된 정보를 재 사용하여 접근 속도를 높일 수 있다.</p>

    <p>이러한 점에서 보면 다형성이나 거대 형성(너무 과도한 히든 클래스) IC 는 당연히 캐싱이 많이 되는 만큼 느리게 된다. 이러한 점에서 보면 NestJS 에서 요청 핸들러나, 서비스에서 객체의 모양을 일관되게 사용하면, 단형성 IC를 유지할 수 있고 성능에서 조금이라도 이득을 볼 수 있다.</p>
  </li>
</ul>

<p>이러한 V8의 최적화 기술, 언어적 특성을 볼 때, NestJS 사용자 역시 V8 친화적 코딩 패턴(일관된 객체 모양, 생성자 속성 초기화 원칙, 내부 속성의 변동 최소화 등)을 사용하는 것이 매우 중요하다.</p>

<h3 id="2-2-이벤트-루프-nodejs의-동시성-모델">2-2. 이벤트 루프: Node.js의 동시성 모델</h3>
<p><img src="/assets/images/posts/2025-06/2025-06-05-0004.png" alt="" /></p>

<p>Node.js 는 단일 스레드 이벤트 루프라는 개념으로 Non-blocking I/O 작업을 수행한다. 이를 통해 각 요청에 대하여 여러 스레드를 관리하는 오버헤드가 없이 많은 동시 연결을 효율적으로 처리할 수 있다.</p>

<h4 id="2-2-1-이벤트-루프의-단계">2-2-1. 이벤트 루프의 단계</h4>
<p>각 단계는 그 목적이 존재하며, 해당 단계에 들어서면 해당 단계에 처리해야할 것들에 대해서만 처리하고 넘어가는 구조를 통해 지속적으로 쌓여지는 여러 일들을 단계적 처리가 가능하게 구현되어 있다.</p>
<ul>
  <li>Timers: setTimeout() 및 setInterval()에 의해 스케줄된 콜백을 실행</li>
  <li>Pending Callbacks(또는 I/O Callbacks): 다음 루프 반복으로 지연된 I/O 콜백(예: 일부 시스템 오류)을 실행</li>
  <li>Idle, Prepare: 대기, 내부 전용 단계</li>
  <li>Poll: 새 I/O 이벤트를 검색하고 I/O 관련 콜백(닫기 콜백, 타이머 및 setImmediate()를 제외한 거의 모든 콜백)을 실행, setImmediate()에 의해 스케줄된 스크립트가 있거나 타이머가 준비되지 않은 경우 폴 큐가 비어 있으면 차단</li>
  <li>Check: setImmediate() 콜백을 실행</li>
  <li>Close Callbacks: 닫기 이벤트 콜백(예: socket.on(‘close’,…) )을 실행</li>
</ul>

<h4 id="2-2-2-processnexttick-setimmediate-및-실행-순서">2-2-2. process.nextTick(), setImmediate() 및 실행 순서</h4>
<ul>
  <li>process.nextTick(): 콜백은 이벤트 루프 자체의 일부는 아니지만 현재 작업이 완료된 직후, 이벤트 루프가 다음 단계로 진행되기 전에 실행, setImmediate()보다 우선 순위가 높음</li>
  <li>setImmediate(): 현재 폴 단계가 완료되고 다음 반복의 타이머 전에 스크립트를 실행하도록 스케줄링. 콜백은 “check” 단계에 배치된다.</li>
  <li>setTImeout(fn, O): 최소 0ms의 임계값이 경과한 후 스크립트를 실행하도록 스케줄링함. I/O 주기 외부에서 호출될 경우 setImmediate()에 대한 실행 순서는 예측할 수 없지만 I/O 주기 내에서는 일반적으로 setImmediate()가 더 빠릅니다.</li>
</ul>

<h4 id="2-2-3-nestjs-의-비동기-작업과-nodejs-의-관계">2-2-3. NestJS 의 비동기 작업과 Node.js 의 관계</h4>
<p>NestJS 는 Node의 비동기 작업의 구조와 시스템을 그대로 컨트롤러, 서비스에 적용하고 의존하고 있다. 그렇기에 이벤트 루프 개념의 이해, NestJS 의 큐 개념에 대한 이해 등을 기반으로 더 강력한 비동기적 처리 구조를 구현할 수도 있다. async/await, Promise의 올바른 사용법과 setImediate또는 nextTick을 언제 쓰면 될지를 이해하는 가는 작업 스케쥴링 최적화를 가능케 한다.</p>

<p>NestJS 는 기본 철학에서부터 비동기 작업을 권장한다. 단, 서비스 내에서 CPU 바운드 블로킹 코드를 작성하는 것도 가능한데, 이러한 형태의 가장 큰 단점은, 연산량이 많아지면 단일 스레드를 독점하고 이벤트 루프가 다른 보류중인 이벤트 처리를 못하게 되어, 요청에 대한 응답이 밀리게 된다는 점이다.</p>

<p>이러한 경우 워커 스레드와 같은 기술을 사용하여 오프로드해야 하는 등으로 일에 대한 선택적 스케쥴링도 필요할 수 있다. IO 에 대해서도 aync/await 정도만으로도 충분히 병목을 제어할 수 없는 경우도 있다. 따라서 NestJS 기술 스택을 사용하는 개발자는 단순히 I/O 바운드의 비동기성과 함께 CPU 바운드 작업에 대한 주의 역시 이해하고 워커 스레드와 같은 전략을 사용할 필요가 있다.</p>

<p><img src="/assets/images/posts/2025-06/2025-06-05-0005.png" alt="" /></p>

<h3 id="2-3-논블로킹-io-및-비동기-프로그래밍">2-3. 논블로킹 IO 및 비동기 프로그래밍</h3>
<p>Node.js의 표준 라이브러리에서 비동기 IO 를 기본 제공하며, JS 코드가 차단되는, 동기식 동작을 방지한다. IO 작업의 수행 시 스레드를 차단하기 대신에 응답이 돌아오면 하던 작업을 재게하는 식을 통해 수천개의 동시 연결을 단일 스레드에서 처리하는 것이 가능해진다.</p>

<h4 id="2-3-1-콜백-지옥과-promise로의-진화">2-3-1. 콜백 지옥과 Promise로의 진화</h4>
<ul>
  <li>초기 Node.js는 비동기 작업을 위해 콜백에 의존하고 있었다. 이러한 구조는 깊이 중첩되고 관리하기 어려운 코드들을 발생하였고, 따라서 개발의 생산성(가독성, 유지보수성)이 매우 제한적이었다. ES6이후 Promise의 도입은 매우 큰 변화를 가져왔다.</li>
</ul>

<h4 id="2-3-2-깔끔한-비동기-코드를-위한-asyncawait">2-3-2. 깔끔한 비동기 코드를 위한 async/await</h4>
<ul>
  <li>콜백 방식은 try/catch 불가능, 에러 전파가 불명확했으나, Promise 이후 .catch() 로 에러흐름을 명확히 분리했으며, async/await 로 더 자연스러운 동기식 표현이 가능하면서도 비동기로 동작이 구현 될 수 있게 되었다.</li>
</ul>

<h4 id="2-3-3-nestjs-가-비동기-패턴을-적용하는-방법">2-3-3. NestJS 가 비동기 패턴을 적용하는 방법</h4>
<ul>
  <li>JS 와 의 발전으로 Node.js 기반인 상태에서 NestJS 는 async/await 을 완전히 수용 한 단계 더 나아간 추상화를 통해 컨트롤러, 서비스, 프로바이더, 그리고 그 하부의 메서드나 핸들러들 모두 async 함수가 될 수 있고 Promise 를 반환한다. 이를 통해 응답을 받기전까지 언제든지 멈추고 다른 작업이 가능하도록 NestJS 는 구현된다.</li>
  <li>수명주기 이벤트: onModuleInit을 포함 각종 후크도 이벤트들로 지정되어 있고 async를 활용하여 비동기적으로 로직의 초기화를 수행할 수있고 이러한 점은 NestJS 개발자들에게 개발적 구성을 더욱 풍부하고 쉽게 할수 있도록 돕게 된다.</li>
</ul>

<h4 id="결론">결론</h4>
<ul>
  <li>NestJS 는 컨트롤러, 서비스, 가드, 인터셉터 및 파이프에서 async, await 을 광범위하게 사용이 가능하며, 이러한 구성요소는 Promise 를 반환한다. 매우 편리하고, 구성의 효율성이 발생하긴 하지만, 문제는 모든 비동기 부분에서 오류 처리를 부지런히 해야 한다. 이는 전역 필터 외에도 로컬에서의 오류 처리를 잘 해야 하고, 이러한 구성이 되어야 전역으로만 의존시 어디 위치에서 특정 오류가 발생하는지를 정확히 개발자가 취급하지 못할 수 있다는 위험을 인지해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">canActivate</code> 메서드의 경우 <code class="language-plaintext highlighter-rouge">Promise&lt;boolean&gt;</code> 을 반환할 수 있는데, 이는 해당 메소드나 로직 안에서 거부가 로컬로 처리 되지 않으면 콜백으로 전파 되며, 오류를 포착하도록 설계하는 것이 가능하다. 이러한 점에서 <code class="language-plaintext highlighter-rouge">Promise</code>의 체인 특성을 이해까지 한다면 비동기 오류의 적절한 처리가 가능해 질 것이다. 
// TODO:
    <h2 id="3-nodejs의-모듈-데이터-처리-및-io">3. Node.js의 모듈, 데이터 처리 및 IO</h2>
  </li>
  <li>
    <p>전통적으로 Node 진영에서는 CommonJS 라는 기반 모듈을 사용했으나 ECMAScript 모듈을 지원한다. TypeScript 기반인 NestJS 프로젝트는 일반적으로 소스 코드에서 ESM 구문을 사용하고, 이는 tsconfig.json 설정 및 Node.js 버전에 따라 CJS 로 트랜스파일이 되는 구조를 가진다.</p>
  </li>
  <li>주요 차이점 요약</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">특징</th>
      <th style="text-align: left">CommonJS(CJS)</th>
      <th style="text-align: left">ECMAScript(ESM)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">로드 시점</td>
      <td style="text-align: left">동기적, requre() 호출 시점에 파일을 즉시 불러오고 실행</td>
      <td style="text-align: left">비동기적, 모듈 로딩이 비동기적으로 처리되어 성능에 유리</td>
    </tr>
    <tr>
      <td style="text-align: center">구문</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">require()</code> / <code class="language-plaintext highlighter-rouge">module.exports</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">import</code> / <code class="language-plaintext highlighter-rouge">export</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">this</code>의 스코프</td>
      <td style="text-align: left">전역 객체 (<code class="language-plaintext highlighter-rouge">global</code>)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">undefined</code></td>
    </tr>
    <tr>
      <td style="text-align: center">실행 환경</td>
      <td style="text-align: left">주로 Node.js 환경</td>
      <td style="text-align: left">브라우저와 Node.js 환경 모두 지원</td>
    </tr>
    <tr>
      <td style="text-align: center">정적 분석</td>
      <td style="text-align: left">불가능, 코드를 실행해야 의존성 파악이 가능</td>
      <td style="text-align: left">가능, 코드 실행 전 <code class="language-plaintext highlighter-rouge">import</code> / <code class="language-plaintext highlighter-rouge">export</code> 구문 분석으로 의존성 파악 가능</td>
    </tr>
  </tbody>
</table>

<h3 id="31-모듈-시스템-commonjs-대-ecmascript-모듈esm">3.1 모듈 시스템: CommonJS 대 ECMAScript 모듈(ESM)</h3>
<h4 id="311-구문-및-로딩-메커니즘">3.1.1 구문 및 로딩 메커니즘</h4>
<p>CommonJS (CJS): 동기 모듈 로딩을 위해 require()를 사용하고 내보내기를 위해 module.exports 또는 exports를 사용한다.</p>

<p>ECMAScript 모듈 (ESM): import 및 export 문을 사용한다. ESM 로딩은 비동기적이며 정적 분석(트리 셰이킹)을 가능하게 만든다.   </p>

<h4 id="312-주요-차이점">3.1.2 주요 차이점</h4>
<ul>
  <li>로딩: 동기식과 비동기식</li>
  <li><code class="language-plaintext highlighter-rouge">__dirname</code>, <code class="language-plaintext highlighter-rouge">__filename</code> 지원 여부: CJS 에서 사용 가능하지만, ESM 에서는 직접 사용은 안된다. (단 <code class="language-plaintext highlighter-rouge">import.meta.url</code>, <code class="language-plaintext highlighter-rouge">path.dirname(fileURLToPath(import.meta.url))</code>를 사용, Node.js v20.11.0+에서 제공한다.)</li>
  <li>최상위 await: ESM 에서만 사용 가능</li>
  <li>JSON 모듈 가져오기: CJS 는 직접 require 활용하여 허용. ESM은 import 사용</li>
  <li>파일 확장자: CJS 는 종종 .js 를 생략 가능. 단, ESM 은 명시적 파일 확장자 사용.</li>
</ul>

<h4 id="313-nestjs-프로젝트의-고려사항">3.1.3 NestJS 프로젝트의 고려사항</h4>
<ul>
  <li>NestJS 에서 핵심은 TS 로 작성되고 ESM 구문을 사용하지만, 기본적으로 두 모듈 시스템이 탑재 되어 있으니, tsconfig.json 을 통해 어떤 식으로 트랜스파일링 되어 출력 모듈을 결정 지을 수 있다. (반대로 따라서 __dirname 과 같은 것들의 동작 방식은 트랜스파일링과 tsconfig.json의 관계를 모르면 혼란의 원인이 될 수 있다.)</li>
  <li>결과적으로 tsc를 통해 JS로 트랜스파일이 되고, 여기서도 <code class="language-plaintext highlighter-rouge">module</code> 옵션에 따라 형식이 결정된다는 점을 알면 된다.</li>
  <li>현재는 이러한 트랜스파일을 통해 기존의 레거시와의 호환이 유지 되고 있지만, ESM 전용 패키지 또는 최상위 await 과 같은 기능을 사용시 문제에 직면할 수 있고, ESM 으로의 적극적인 전환 도중에 있기 때문에 NestJS 사용에서 ESM을 사용하는 것, 그 구조를 이해하는 것이 중요하다.</li>
</ul>

<h3 id="32-스트림-효율적인-데이터-처리">3.2 스트림: 효율적인 데이터 처리</h3>
<ul>
  <li>Node.js에서 특히 대용량 IO 의 효율적 처리를 위한 기본 수단. 데이터를 한번에 메모리에 모두 로드하지 않고, 청크 단위를 사용하여 처리한다.</li>
</ul>

<h4 id="321-스트림-유형">3.2.1 스트림 유형</h4>
<ul>
  <li>Readable: 데이터 읽기용 (예: fs.createReadStream()).</li>
  <li>Writable: 데이터 쓰기용 (예: fs.createWriteStream(), http.ServerResponse).</li>
  <li>Duplex: 읽기 및 쓰기 모두 가능 (예: 네트워크 소켓).</li>
  <li>Transform: 출력이 입력에서 계산되는 Duplex 스트림 유형 (예: 압축, 암호화).</li>
</ul>

<h4 id="322-pipe-메서드-및-역압backpressure">3.2.2 <code class="language-plaintext highlighter-rouge">pipe()</code> 메서드 및 역압(Backpressure)</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">readable.pipe(writable)</code>은 읽기 가능한 스트림을 쓰기 가능한 스트림에 연결하는 일반적인 패턴으로, 데이터 흐름을 자동화하고 역압을 처리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">역압</code>은 쓰기 가능한 스트림이 데이터를 충분히 빠르게 처리할 수 없는 경우 읽기 가능한 스트림에 일시 중지를 신호하는 메커니즘으로, 메모리 과부하를 방지용이다. 쓰기 가능한 스트림이 다시 준비되면(비워지면) 읽기 가능한 스트림이 다시 시작된다.</li>
</ul>

<h4 id="323-nestjs에서의-사용사례-대용량-파일-업로드-다운로드-실시간-데이터-처리">3.2.3 NestJS에서의 사용사례: 대용량 파일 업로드/ 다운로드, 실시간 데이터 처리</h4>
<ul>
  <li>파일 업로드: NestJS에서 파일 업로드를 처리할 때(예: <code class="language-plaintext highlighter-rouge">@nestjs/platform-express</code>와 <code class="language-plaintext highlighter-rouge">Multer</code> 사용 또는 사용자 지정 솔루션), 들어오는 파일 데이터는 스트림이다. 이 스트림을 직접 처리하면(예: 클라우드 저장소 또는 파일 시스템으로 파이핑) 전체 파일을 버퍼링하는 것보다 메모리 효율적이다.   </li>
  <li>파일 다운로드: 대용량 파일을 제공하기 위해 NestJS 컨트롤러는 <code class="language-plaintext highlighter-rouge">StreamableFile</code>을 반환하거나 읽기 가능한 스트림(예: <code class="language-plaintext highlighter-rouge">fs.createReadStream</code>()에서)을 HTTP 응답 객체(쓰기 가능한 스트림)로 직접 파이핑할 수 있다.</li>
  <li>실시간 데이터: 웹 소켓 또는 메시지 큐와 같은 소스에서 실시간 데이터를 처리하는 데 스트림이 포함될 수 있다.</li>
</ul>

<h4 id="324-nestjs-유틸리티-streamablefile">3.2.4 NestJS 유틸리티: `StreamableFile</h4>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">StreamableFile</code> :   
 <code class="language-plaintext highlighter-rouge">@nestjs/common</code>에서 제공하는 클래스로, 파일을 응답으로 스트리밍하는 것을 단순화한다. Buffer 또는 Readable 스트림을 사용할 수 있다. NestJS는 이를 응답으로 파이핑하는 것을 처리한다.</p>

    <p>예: return new StreamableFile(buffer); 또는 return new StreamableFile(fs.createReadStream(‘path/to/file’));   </p>
  </li>
  <li>
    <p>서버 전송 이벤트 (SSE) :  
 NestJS는 클라이언트에 실시간 업데이트를 푸시하기 위한 SSE를 지원한다.  SSE 핸들러는 RxJS <code class="language-plaintext highlighter-rouge">Observable을</code> 반환하며, NestJS는 이를 이벤트 스트림으로 조정한다. 이는 이 특정 사용 사례에 대한 원시 스트림 처리보다 높은 수준의 추상화다.</p>
  </li>
</ul>

<h3 id="33-버퍼-바이너리-데이터-처리">3.3 버퍼: 바이너리 데이터 처리</h3>
<h3 id="34-fs-모듈파일-시스템-모듈">3.4 fs 모듈(파일 시스템 모듈):</h3>

<h2 id="4-성능-확장과-최적화">4. 성능, 확장과 최적화</h2>
<h3 id="41-nodejs의-메모리-관리">4.1 Node.js의 메모리 관리</h3>
<h3 id="42-cpu-집약적-작업을-위한-워커-스레드">4.2 CPU 집약적 작업을 위한 워커 스레드</h3>
<h3 id="43nestjs-특징-성능-최적화">4.3NestJS 특징 성능 최적화</h3>

<h2 id="5-오류-처리-및-디버깅-전략">5. 오류 처리 및 디버깅 전략</h2>
<h3 id="51-nodejs-의-강력한-오류-처리">5.1 Node.js 의 강력한 오류 처리</h3>
<h3 id="52-nestjs-예외-필터">5.2 NestJS 예외 필터</h3>
<h3 id="53-nodejs-및-nestjs-애플리케이션-디버깅">5.3 Node.js 및 NestJS 애플리케이션 디버깅</h3>

<h2 id="6-nodejs-보안-고려-사항">6. Node.js 보안 고려 사항</h2>
<h3 id="61-일반적인-nodejs-보안-취약점-owasp-관점">6.1 일반적인 Node.js 보안 취약점 (OWASP 관점)</h3>
<h3 id="62-nestjs-보안-기능-및-모범-사례">6.2 NestJS 보안 기능 및 모범 사례</h3>

<h2 id="7-배포-및-프로세스-관리">7. 배포 및 프로세스 관리</h2>
<h3 id="7-1-nodejs-애플리케이션-배포의-기본">7-1. Node.js 애플리케이션 배포의 기본</h3>
<ul>
  <li>프로덕션 빌드: NestJS 애플리케이션은 일반적으로 TS 파일로 작성된다. 그렇기에 실제 프로덕션 환경에서 배포되기 전에는 JS 파일로 컴파일(트랜스파일) 되어야 하며, 이때 개발 환경의 내용이 배제된 내용들이 dist 디렉터리에 컴파일된 파일들이 생성된다. 이러한 파일들은 node main.js 로 구동 시작점에서 부트스트래핑 된다.</li>
  <li>애플리케이션 실행(node dist/main.js): 완성된 빌드는 진입점을 통해 애플리케이션이 시작될 수 있다.</li>
  <li>환경변수(NODE_ENV=production): 프로덕션 환경에서 애플리케이션을 실행하면, 구동되는 OS 는 환경변수 설정이 되어 있어야 합니다. 이는 단순 구분 목적이 아닌 일부 라이브러리등에서는 이 변수를 기반으로 성능, 기능 등의 차이가 있어 다른 동작이 발생할 수 있습니다(로깅, 최적화 등의 수준에서).</li>
</ul>

<h3 id="7-2-nestjs-애플리케이션을-위한-프로세스-관리자-pm2">7-2. NestJS 애플리케이션을 위한 프로세스 관리자 PM2</h3>
<p><img src="/assets/images/posts/2025-06/2025-06-05-0001.png" alt="" /></p>
<ul>
  <li>PM2: Node를 사용하는 서비스, 혹은 그렇지 않은 서비스들도 활용할 수 있는 정말 만능의 툴. 프로세스 관리, 모니터링, 로깅, 자동 재시작 등 서비스 사용에 있어 관리가 필요하면, 일단 써보면 되는 툴(<del>무안단물</del>)</li>
  <li>PM2의 역할: 애플리케이션의 예기치 않은 충돌에 자동 재시작으로 다운 타임을 최소화, CPU 및 메모리 사용량 등을 관리하여 모니터링 해주는 UI 등을 제공해준다.</li>
  <li>다중 CPU 코어 활용을 위한 ‘클러스터 모드’: Node.js 는 원리상 단일 스레드 구조지만, PM2의 클러스터 모드(기본 fork 모드라고 부름)를 활성화 하면 다중 코어를 활용할 수 있고, 코드의 특별한 수정 없이 애플리케이션의 성능, 안정성을 크게 향상 시키는게 가능하다. exec_mode:”cluster” 및 “instances”: “max”(혹은 특정 수)로 ecosystem.config.js 파일에 설정하여 활성화 해주면 된다.</li>
  <li>Graceful Shutdown: 프로덕션 환경에서는 애플리케이션의 종료 전에 나머지 쿼리를 처리하는 등으로 데이터 소실을 일으키지 않을 수 있는가가 매우 중요하다(데이터베이스, 메시지 큐 등). 서버 자체에서도 SIGNAL 에 대한 처리를 통해 시스템의 문제에 대응하여 갑작스러운 종료를 대비할 수 있긴 하지만, 이에 대해 PM2를 활용하면 해당 구성을 구현하지 않아도, 기본적으로 SIGNAL 에 대한 보호 및 Graceful 한 종료를 만들어 준다.</li>
  <li>ecosystem.config.js 의 예시 :
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ecosystem.config.js [124, 125, 127, 129]</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">apps</span> <span class="p">:</span>
<span class="p">};</span>
</code></pre></div>    </div>
    <p>ecosystem.config.js 를 활용함으로써 서버 하드웨어의 재부팅이나, 각종 에러가 발생하더라도 해당 config를 기반으로 production 환경의 node 애플리케이션을 자동으로 복구, 이 역시 다운타임을 최소화하거나, 설정 최적화를 자동으로 적용하는 역할을 한다.</p>
  </li>
  <li>그러나 단점들:
    <ul>
      <li>클러스터 모드 사용은 단순한 CPU 활용률 증대를 넘어서 Node 프로세스를 여러개 복제하여 사용하는 구조지만, stateless 하지 못한 저장 구조를 갖추는 서비스의 경우 클러스터 모드 시 에러를 유발할 수 있다는 점에서 클러스터 모드 적용에 매우 신중이 생각해야 한다.</li>
      <li>뿐만 아니라 외부 서비스 등을 사용한다거나, PM2 클러스터 모드로 고가용성을 노린다면 애플리케이션의 상태관리 전략을 고려해봐야 한다.</li>
      <li>또한 Production 수준의 서비스를 위해 기껏 dist 폴더만을 서버 인스턴스에 설치한다고할 때, PM2는 이를 감싸는 구조이므로 자체 모니터링, 로깅 기능들이 포함되어 오버헤드를 야기한다.</li>
      <li>다른 CICD 를 위한 도구들에 비해선 복잡한 서비스 의존성 처리 등이 어렵다는 점에서 단점이 될 수 있음.</li>
      <li>특히나 리눅스 환경에서의 이용성은 나쁘지 않음. 그러나 윈도우 기반에선 어려움이 있고, docker 나 kubernetes 와 중복되는 기능들로 DevOps 환경에서 크게 쓸모가 없고, 그 편의성에 비해 요 최근에 주목을 받지 못하고 있다.</li>
      <li>결과적으로 간단한 서비스 서버 애플리케이션을 위해 거창한 docker나 kubernetes 가 필요없으면 써봄직한 프로그램이지만, 대용량 처리를 비롯 다양한 바운더리가 존재할 경우 사용이 오히려 제약을 느릴 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="7-3-docker-를-사용한-컨테이너화">7-3. Docker 를 사용한 컨테이너화</h3>
<ul>
  <li>Docker: 리눅스의 컨테이너 기반으로 구성된 프로그램으로 호스톼 상관 없이 Docker는 에플레키션 으로 감싸서, 호스트 컴퓨터에서의 애플리케이션의 종속성을 패키징, 개발, 테스트 및 프로덕션 환경 전반을 걸친 일관성을 제공해준다.</li>
  <li>기본 Dockerfile 구조 예시
    <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1단계: 애플리케이션 빌드</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:18-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="k">WORKDIR</span><span class="s"> /usr/src/app</span>
<span class="k">COPY</span><span class="s"> package*.json./</span>
<span class="k">RUN </span>npm <span class="nb">install</span>
<span class="k">COPY</span><span class="s">..</span>
<span class="k">RUN </span>npm run build

<span class="c"># 2단계: 프로덕션 이미지 생성</span>
<span class="k">FROM</span><span class="s"> node:18-alpine</span>
<span class="k">WORKDIR</span><span class="s"> /usr/src/app</span>
<span class="k">COPY</span><span class="s"> --from=builder /usr/src/app/dist./dist</span>
<span class="k">COPY</span><span class="s"> --from=builder /usr/src/app/node_modules./node_modules</span>
<span class="k">COPY</span><span class="s"> --from=builder /usr/src/app/package*.json./</span>
<span class="k">EXPOSE</span><span class="s"> 3000</span>
<span class="k">CMD</span><span class="s"> ["node", "dist/main.js"]</span>
</code></pre></div>    </div>
  </li>
  <li>Docker는 이러한 기본적인 빌드 레퍼런스에서 시작하여 Docker compose, 이러한 이미지를 활용하는 kubernetes 까지 뻗어 나갈 수 있으며, 특히나 이 구조에 대한 이해도를 알게 된다면 CICD 의 핵심인 CD 파이프라이닝에 대해 적용도 가능해진다.(Jenkins, GitHub Actions 등)</li>
</ul>

<h2 id="8-마치며">8. 마치며</h2>
<p>Node.js 에 대한 깊이 있는 이해는 단순하게 이론적 지식 증대의 의미를 가지진 않는다. Nestjs 프레임워크의 추상화 계층의 아래 단계의 실제 상황을 파악하는 구체적인 이미지를 보여준다. 애플리케이션의 성능을 미세 조정하고, 복잡한 문제를 효과적으로 개선, 보안의 강화나 정보에 입각한 구체적인 아키텍쳐 결정이 가능한데 Node.js 의 이해도는 NestJS 개발의 그 다음을 위해 반드시 필요한 학습의 과정이라고 볼 수 있다.</p>

<p>V8 엔진의 내부 작동 방식, 이벤트 루프의 미묘한 동작, 비동기 프로그래밍에 대한 숙달과 다양한 모듈의 이해. 스트림이나 버퍼를 활용한 효율적인 데이터 처리 및 메모리 관리 기술, 워커 스레드를 활용한 연산 처리 등 NestJS 애플리케이션의 고난도 기능 구현을 위해 필수적인 요소들의 근간에는 Node.js가 있음을 다시 한번 강조할 수 있다.</p>

<p>Node.js 의 오류 처리 메커니즘의 이해, NestJS의 예외 필터의 결합 방법, 다양한 디버깅 도구 및 기술의 효과적인 접목, 보안에 대한 모범 살졔 적용등은 프로덕션 환경에서의 안정적이고 안전한 애플리케이션을 보장하는데 매우 중요한 부분이라 평할 수 있겠다. 간단한 배포에 대한 기본 내용들인 PM2, 도커의 활용은 기본적인 빌드 프로세스의 이해도와, 개발의 라이프사이클의 기초를 다질 수 있는 포인트라고 볼 수 있겠다.(당연히 현실 라이브 서비스는 이보다 더 복잡하다는 점은 당연하게도 알아야 할 것이다.)</p>

<h2 id="00-참고문헌--ai-학습-및-정보-출처-확인용">00. 참고문헌 : AI 학습 및 정보 출처 확인용</h2>
<details>
<summary>여기를 클릭하면 참고문헌 리스트가 열립니다</summary>

<ol>
<li><a href="https://docs.nestjs.com/v5/">Documentation - NestJS - A progressive Node.js web framework</a></li>
<li><a href="https://jelvix.com/blog/nestjs-vs-express">Comparing NestJS &amp; Express.js: Which Framework is the Best - Jelvix</a></li>
<li><a href="https://www.pullrequest.com/blog/nestjs-vs-express-a-comparative-analysis-for-secure-and-efficient-web-development/">NestJS vs Express: A Comparative Analysis for Secure and Efficient Web Development</a></li>
<li><a href="https://nodejs.org/en/learn/getting-started/introduction-to-nodejs">Node.js — Introduction to Node.js</a></li>
<li><a href="https://slashdev.io/nl/-guide-to-building-secure-backends-in-nestjs-in-2024">Guide To Building Secure Backends In NestJS In 2024 - Slashdev</a></li>
<li><a href="https://www.packtpub.com/en-in/product/scalable-application-development-with-nestjs-9781835468609/chapter/chapter-1-overview-of-nestjs-2/section/the-ecosystem-of-nestjs-ch02lvl1sec07">The ecosystem of NestJS - Packt+ - Advance your knowledge in tech</a></li>
<li><a href="https://dev.to/rayenmabrouk/why-nestjs-is-the-new-gold-standard-for-node-backend-development-lm">Why NestJS Is The New Gold Standard For Node Backend ...</a></li>
<li><a href="https://www.presidio.com/getting-started-with-nestjs/">Getting started with NestJS - Presidio</a></li>
<li><a href="https://dev.to/leolanese/nestjs-performance-2kcb">NestJS Performance - DEV Community</a></li>
<li><a href="https://dev.to/geampiere/how-to-profile-a-nestjs-application-483n">How to Profile a NestJS Application - DEV Community</a></li>
<li><a href="https://dev.to/geampiere/what-is-the-stream-api-in-nodejs-and-how-can-we-use-it-in-nestjs-4n70">What Is the Stream API in Node.js and How Can We Use It in NestJS? - DEV Community</a></li>
<li><a href="https://last9.io/blog/understanding-worker-threads-in-node-js/">Node.js Worker Threads Explained (Without the Headache) - Last9</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-handle-cpu-intensive-loads-in-node-js/">How to Handle CPU Intensive Loads In Node JS ? - GeeksforGeeks</a></li>
<li><a href="https://betterstack.com/community/guides/scaling-nodejs/nodejs-streams/">Understanding Node.js Streams: A Comprehensive Guide - Better Stack Community</a></li>
<li><a href="https://www.dennisokeeffe.com/blog/2024-07-04-nodejs-buffers-explained">Node.js Buffers Explained - Dennis O'Keeffe</a></li>
<li><a href="https://www.geeksforgeeks.org/node-js-fs-createreadstream-method/">Node.js fs.createReadStream() Method - GeeksforGeeks</a></li>
<li><a href="https://www.geeksforgeeks.org/node-js-fs-createwritestream-method/">Node.js fs.createWriteStream() Method - GeeksforGeeks</a></li>
<li><a href="https://node-js.tistory.com/27">Node.js란? Node.js 특징 정리(이벤트 기반, 논 블로킹 I/O 모델)</a></li>
<li><a href="https://dev.to/leapcell/inside-the-nodejs-event-loop-a-deep-dive-152d">Inside the Node.js Event Loop: A Deep Dive - DEV Community</a></li>
<li><a href="https://www.nodejs-security.com/blog/owasp-nodejs-best-practices-guide">OWASP Node.js Best Practices Guide - Node.js Secure Coding</a></li>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html">Nodejs Security - OWASP Cheat Sheet Series</a></li>
<li><a href="https://snyk.io/articles/nodejs-security-best-practice/">Top 10 Node.js Security Best Practices for 2023 - Risks &amp; Prevention ...</a></li>
<li><a href="https://www.devcentrehouse.eu/blogs/nestjs-dtos-pipes-scalable-backend-apps/">Using DTOs and Validation Pipes in NestJS - Dev Centre House ...</a></li>
<li><a href="https://docs.nestjs.com/controllers">Controllers - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://docs.nestjs.com/middleware">Middleware - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://docs.nestjs.com/pipes">Pipes - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://www.geeksforgeeks.org/explain-v8-engine-in-node-js/">Explain V8 engine in Node.js - GeeksforGeeks</a></li>
<li><a href="https://rahulvijayvergiya.hashnode.dev/under-the-hood-of-nodejs-exploring-the-v8-javascript-engine">Under the Hood of Node.js: Exploring the V8 JavaScript Engine</a></li>
<li><a href="https://nodejs.org/en/learn/getting-started/the-v8-javascript-engine">The V8 JavaScript Engine - Node.js</a></li>
<li><a href="https://dev.to/omriluz1/v8-engine-optimization-techniques-1bcd">V8 Engine Optimization Techniques - DEV Community</a></li>
<li><a href="https://blog.platformatic.dev/optimizing-nodejs-performance-v8-memory-management-and-gc-tuning">Boost Node.js with V8 GC Optimization - Platformatic Blog</a></li>
<li><a href="https://digitalerena.com/node-js-topic31/">Understanding Memory Management in Node.js - DigitalErena</a></li>
<li><a href="https://www.ness.com/understand-how-to-reduce-memory-usage-of-promises-in-node-js/">Understand how to reduce memory usage of Promises in Node.js ...</a></li>
<li><a href="https://dev.to/omriluz1/hidden-classes-and-inline-caches-in-v8-43dd">Hidden Classes and Inline Caches in V8 - DEV Community</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/js-v8-engine">The V8 Engine and JavaScript Optimization Tips - DigitalOcean</a></li>
<li><a href="https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick">Node.js — The Node.js Event Loop</a></li>
<li><a href="https://nodejs.org/en/learn/asynchronous-work/overview-of-blocking-vs-non-blocking">Node.js — Overview of Blocking vs Non-Blocking</a></li>
<li><a href="https://docs.nestjs.com/fundamentals/async-providers">Documentation - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://blog.postman.com/understanding-async-await-in-node-js/">Understanding Async/Await in Node.js - Postman Blog</a></li>
<li><a href="https://docs.nestjs.com/fundamentals/lifecycle-events">Lifecycle events - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://docs.nestjs.com/microservices/basics">Microservices - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://packmind.com/simplify-promises-async-await/">Simplify your promises with async/await: four examples - Packmind</a></li>
<li><a href="https://sematext.com/blog/node-js-error-handling/">Node.js Error Handling Best Practices: Hands-on Experience Tips</a></li>
<li><a href="https://dev.to/ngtrthvu3007/nestjs-request-lifecycle-2jhe">NestJS: Request Lifecycle - DEV Community</a></li>
<li><a href="https://betterstack.com/community/guides/scaling-nodejs/error-handling-nestjs/">NestJS Error Handling Patterns - Better Stack Community</a></li>
<li><a href="https://docs.nestjs.com/faq/request-lifecycle">Request lifecycle - FAQ - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://codesignal.com/learn/courses/securing-and-testing-your-mvc-nestjs-app/lessons/session-based-authentication-with-passportjs-in-nestjs">Session-Based Authentication with Passport.js in NestJS - CodeSignal Learn</a></li>
<li><a href="https://www.geeksforgeeks.org/exception-filters-in-nestjs-handling-exceptions-gracefully/">Exception Filters in NestJS: Handling exceptions gracefully ...</a></li>
<li><a href="https://codesignal.com/learn/courses/adding-enterprise-features-to-your-mvc-nestjs-app/lessons/error-handling-in-nestjs">Error Handling in NestJS - CodeSignal Learn</a></li>
<li><a href="https://docs.nestjs.com/exception-filters">Exception filters - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://betterstack.com/community/guides/scaling-nodejs/commonjs-vs-esm/">CommonJS vs. ES Modules - Better Stack Community</a></li>
<li><a href="https://blog.appsignal.com/2024/12/11/a-deep-dive-into-commonjs-and-es-modules-in-nodejs.html">A Deep Dive Into CommonJS and ES Modules in Node.js ...</a></li>
<li><a href="https://docs.nestjs.com/cli/scripts">Scripts - CLI - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://dev.to/zenstok/how-to-create-and-download-files-of-unlimited-size-in-nodejsnestjs-48al">How to Create and Download Files of Unlimited Size in node.js ...</a></li>
<li><a href="https://moldstud.com/articles/p-nodejs-streams-and-buffers-the-ultimate-guide-for-developers">Mastering Node.js Streams and Buffers for Developers - MoldStud</a></li>
<li><a href="https://nodejs.org/en/learn/modules/how-to-use-streams">Node.js — How to use Streams</a></li>
<li><a href="https://docs.sheetjs.com/docs/demos/net/server/nestjs">Sheets in NestJS - SheetJS Community Edition</a></li>
<li><a href="https://github.com/nestjs/nest/blob/master/packages/common/file-stream/streamable-file.ts">nest/packages/common/file-stream/streamable-file.ts at master · nestjs/nest - GitHub</a></li>
<li><a href="https://docs.nestjs.com/techniques/server-sent-events">Server-Sent Events - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://indicoder.tkssharma.com/blog/understand-nodejs-stream-and-buffers">Understand Node JS Stream and Buffers - Tarun Sharma - @indiTechCoder</a></li>
<li><a href="https://dev.to/sfundomhlungu/buffers-in-nodejs-what-they-do-why-you-should-care-46p1">Buffers in Node.js: What They Do &amp; Why You Should Care - DEV Community</a></li>
<li><a href="https://www.geeksforgeeks.org/what-are-buffers-in-node-js/">What are Buffers in Node.js - GeeksforGeeks</a></li>
<li><a href="https://indicoder.tkssharma.com/blog/understand-nodejs-stream-and-buffers">Understand Node JS Stream and Buffers - Tarun Sharma - @indiTechCoder</a> </li>
<li><a href="https://gist.github.com/jonilsonds9/efc228e34a298fa461d378f48ef67836">Uploading binary file (buffer) using NestJS - Discover gists GitHub Gist</a></li>
<li><a href="https://www.geeksforgeeks.org/node-js-file-system/">Node.js File System - GeeksforGeeks</a></li>
<li><a href="https://accuweb.cloud/resource/articles/how-to-work-with-files-using-the-fs-module-in-node-js">How To Work with Files using the fs Module in Node.js? - AccuWeb.Cloud</a></li>
<li><a href="https://docs.nestjs.com/techniques/configuration">Configuration - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://matcha.fyi/how-to-fix-memory-leaks-in-javascript-with-examples/">How to Fix Memory Leaks in JavaScript (With Examples) - matcha.fyi</a></li>
<li><a href="https://sematext.com/blog/nodejs-memory-leaks/">Debugging Node.js Memory Leaks: How to Detect, Solve or Avoid Them in Applications</a></li>
<li><a href="https://dev.to/geampiere/how-to-manage-memory-and-avoid-leaks-in-nestjs-applications-3geh">How to Manage Memory and Avoid Leaks in NestJS Applications - DEV Community</a></li>
<li><a href="https://www.netguru.com/blog/node-js-memory-leaks">Nodejs Memory Leak: How to Debug And Avoid Them? - Netguru</a></li>
<li><a href="https://www.hashstudioz.com/blog/unmasking-the-silent-killer-of-node-js-performance-mastering-the-art-of-memory-leak-debugging/">Unmasking the Silent Killer of Node.js Performance: Mastering the Art of Memory Leak Debugging - HashStudioz Technologies</a></li>
<li><a href="https://docs.nestjs.com/recipes/async-local-storage">Async Local Storage - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://docs.nestjs.com/modules">Modules - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://www.nicholasadamou.com/notes/worker-threads-in-nodejs">Worker Threads in Node.js: The Secret to High Performance Backends - Nicholas Adamou</a></li>
<li><a href="https://nodejs.org/download/release/v13.1.0/docs/api/worker_threads.html">Worker Threads - Node.js v13.1.0 Documentation</a></li>
<li><a href="https://github.com/chjj/bthreads">chjj/bthreads: worker threads for javascript - GitHub</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer - JavaScript - MDN</a></li>
<li><a href="https://www.nicholasadamou.com/notes/worker-threads-in-nodejs">Worker Threads in Node.js: The Secret to High Performance Backends - Nicholas Adamou</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics">Atomics - JavaScript - MDN</a></li>
<li><a href="https://www.brilworks.com/blog/optimize-your-nest-js-app-performance/">Optimize Your Nest.js App Performance with These Practices - Brilworks</a></li>
<li><a href="https://www.growthaccelerationpartners.com/blog/lab-notes-looking-at-nestjs-framework-for-web-apps-overview-performance-thoughts">Insights- Growth Acceleration Partners</a></li>
<li><a href="https://docs.nestjs.com/techniques/validation">Validation - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://www.tritondatacenter.com/node-js/production/design/errors">Error Handling in Node.js - Triton DataCenter</a></li>
<li><a href="https://dev.to/ruben_alapont/error-handling-in-nodejs-streams-best-practices-dhb">Error Handling in Node.js Streams: Best Practices - DEV Community</a></li>
<li><a href="https://nodejs.org/api/events.html">Events - Node.js v24.1.0 Documentation</a></li>
<li><a href="https://dev.to/hanzla-baig/debugging-javascript-like-a-pro-mastering-browser-devtools-nodejs-85g">Debugging JavaScript Like a Pro: Mastering Browser DevTools ...</a></li>
<li><a href="https://nodejs.org/en/learn/getting-started/debugging">Node.js — Debugging Node.js</a></li>
<li><a href="https://docs.nestjs.com/devtools/overview">Devtools - Overview - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://www.youtube.com/watch?v=bV-DHjmwuZ0">Debug Node.js apps with Chrome DevTools (and TypeScript) - YouTube</a></li>
<li><a href="https://nodejs.org/api/debugger.html">Debugger - Node.js v24.1.0 Documentation</a></li>
<li><a href="https://stackoverflow.com/questions/49504765/debugging-nest-js-application-with-vscode">typescript - Debugging nest.js application with vscode - Stack Overflow</a></li>
<li><a href="https://moldstud.com/articles/p-creating-effective-logging-interceptors-in-nestjs-to-track-request-lifecycles">Creating Logging Interceptors in NestJS for Request Tracking ...</a></li>
<li><a href="https://www.hyperdx.io/blog/node-js-logging-best-practices">Node.js Logging Best Practices - HyperDX Blog</a></li>
<li><a href="https://betterstack.com/community/guides/logging/how-to-install-setup-and-use-pino-to-log-node-js-applications/">A Complete Guide to Pino Logging in Node.js - Better Stack Community</a></li>
<li><a href="https://dev.to/saint_vandora/cross-site-scripting-xss-attacks-in-nodejs-understanding-preventing-and-mitigating-risks-4b2p">Cross-Site Scripting (XSS) Attacks in Node.js: Understanding ...</a></li>
<li><a href="https://www.contrastsecurity.com/glossary/insecure-deserialization">What is Insecure Deserialization? - Contrast Security</a></li>
<li><a href="https://docs.cobalt.io/bestpractices/insecure-deserialization/">Insecure Deserialization – - Cobalt</a></li>
<li><a href="https://docs.nestjs.com/techniques/serialization">Serialization - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://www.contrastsecurity.com/glossary/npm">What is npm? - Best Practices and How to Fix Security Vulnerabilities</a></li>
<li><a href="https://moldstud.com/articles/p-top-nestjs-security-best-practices-comprehensive-faq-for-developers">Best Practices for Securing NestJS Applications - MoldStud</a></li>
<li><a href="https://codesignal.com/learn/courses/securing-your-nestjs-app/lessons/securing-endpoints-with-jwt-guards">Securing Endpoints with JWT Guards - CodeSignal Learn</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/understanding-guards-in-nestjs">Understanding Guards in NestJS - DigitalOcean</a></li>
<li><a href="https://www.passportjs.org/packages/passport-nest/">passport-nest</a></li>
<li><a href="https://www.youtube.com/watch?v=S8Cjx5ua2JU&amp;pp=0gcJCdgAo7VqN5tD">NestJS Authentication + Refresh Token With Passport.js - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=BfDHPOiHlqU">NestJS JWT Authentication – Secure Your API Like a Pro! - YouTube</a></li>
<li><a href="https://docs.nestjs.com/security/authentication">Documentation - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://codesignal.com/learn/courses/securing-your-nestjs-app/lessons/session-based-authentication-with-passportjs-in-nestjs">Session-Based Authentication with Passport.js in NestJS - CodeSignal Learn</a></li>
<li><a href="https://www.npmjs.com/package/%40tekuconcept%2Fnestjs-csrf">@tekuconcept/nestjs-csrf - npm</a></li>
<li><a href="https://snyk.io/blog/how-to-protect-node-js-apps-from-csrf-attacks/">How to protect Node.js apps from CSRF attacks - Snyk</a></li>
<li><a href="https://docs.nestjs.com/security/csrf">CSRF - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://ru-nestjs-docs.netlify.app/techniques/security">Security - Documentation - NestJS - A progressive Node.js framework - Netlify</a></li>
<li><a href="https://docs.nestjs.com/security/helmet">Helmet - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://github.com/gasangw/NestJS-Interview-Questions-And-Answers">gasangw/NestJS-Interview-Questions-And-Answers - GitHub</a></li>
<li><a href="https://docs.nestjs.com/security/best-practices">docs.nestjs.com</a></li>
<li><a href="https://moldstud.com/articles/p-effective-strategies-to-shield-your-nestjs-application-from-sql-injection-vulnerabilities">How to Protect Your NestJS Application from SQL Injection Attacks ...</a></li>
<li><a href="https://zerothreat.ai/blog/securing-nodejs-web-app-from-sql-injection-attacks">How to Stop SQL Injection Attacks in Node JS Web App? - ZeroThreat</a></li>
<li><a href="https://dev.to/ubaydah/managing-dependencies-in-nodejs-an-overview-of-npm-and-yarn-2g9n">Managing Dependencies in Node.js: An Overview of NPM and Yarn - DEV Community</a></li>
<li><a href="https://github.com/brocoders/nestjs-boilerplate/pull/1836">Switch from npm to Yarn for Better Dependency Management by ...</a></li>
<li><a href="https://docs.nestjs.com/cli/overview">Overview - CLI - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://www.npmjs.com/package/%40jescrich%2Fnestjs-workflow">@jescrich/nestjs-workflow - NPM</a></li>
<li><a href="https://www.imaginarycloud.com/blog/npm-vs-yarn-which-is-better">Yarn vs NPM: Which package manager should I use? - Imaginary Cloud</a></li>
<li><a href="https://docs.nestjs.com/deployment">Deployment - NestJS - A progressive Node.js framework</a></li>
<li><a href="https://dev.to/mochafreddo/managing-nextjs-and-nestjs-applications-in-production-with-pm2-3j25">Managing Next.js and NestJS Applications in Production with PM2 ...</a></li>
<li><a href="https://www.npmjs.com/package/%40nestjs-mod%2Fpm2">@nestjs-mod/pm2 - npm</a></li>
<li><a href="https://github.com/vishalm/node-pm2-cluster-example">vishalm/node-pm2-cluster-example: This repository ... - GitHub</a></li>
<li><a href="https://pm2.keymetrics.io/docs/usage/application-declaration/">Ecosystem File - PM2</a></li>
<li><a href="https://pm2.keymetrics.io/docs/usage/cluster-mode/">Cluster Mode - PM2</a></li>
<li><a href="https://pm2.io/docs/runtime/best-practices/graceful-shutdown/">Graceful Shutdown - Best Practices - PM2 Documentation - PM2</a></li>
<li><a href="https://blog.logrocket.com/node-js-24-new/">Node.js 24 is here: What's new and what to expect - LogRocket Blog</a></li>
<li><a href="https://nodesource.com/blog/Node.js-version-24">Node.js 24 Is Here: What You Need to Know - NodeSource</a></li>
<li><a href="https://nodejs.org/en/blog/release/v24.0.0">Node.js — Node v24.0.0 (Current)</a></li>
<li><a href="https://www.bacancytechnology.com/blog/nodejs-24">Node.js 24: Latest Enhancements and Updates - Bacancy Technology</a></li>
<li><a href="https://dev.to/tak089/a-roadmap-to-evolve-from-beginner-to-expert-in-nestjs-and-nextjs-development-15ml">A Roadmap to Evolve from Beginner to Expert in NestJS and Next.js ...</a></li>
<li><a href="https://www.ccbp.in/blog/articles/node-js-roadmap">Node.js Roadmap for 2025: A Complete Guide - NxtWave</a></li>
<li><a href="https://community.nasscom.in/communities/mobile-web-development/nodejs-development-powering-future-real-time-applications">NodeJS Development: Powering the Future of Real-Time Applications - nasscom</a></li>
<li><a href="https://www.google.com/search?q=https://dev.to/dharmvachhani/the-future-of-nodejs-development-trends-challenges-and-opportunities-42oh%23:~:text%3DThe%2520NodeJS%2520ecosystem%2520will%2520continue,development%2520more%2520efficient%2520and%2520robust.">dev.to</a></li>
<li><a href="https://dev.to/dharmvachhani/the-future-of-nodejs-development-trends-challenges-and-opportunities-42oh">The Future of NodeJS Development: Trends, Challenges, and ...</a></li>
<li><a href="https://nodejs.org/en/blog/vulnerability/may-2025-security-releases">Node.js — Wednesday, May 14, 2025 Security Releases</a></li>
<li><a href="https://seclists.org/oss-sec/2025/q2/112">oss-sec: Re: Fwd: Node.js security updates for all active release lines, May 2025</a></li>
</ol>

</details>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="Backend" /><category term="Node" /><category term="NestJS" /><category term="JavaScript" /><category term="TypeScript" /><category term="Programming" /><summary type="html"><![CDATA[0. 들어가면서 본 글은 어디까지나 NestJS 개발자로써 Node 기본기를 다지기 위해 원하는 식의 재구성이 포함됩니다. 혹시나 내용적으로 오류가 있으면 알려주시면 감사하겠습니다 😎]]></summary></entry><entry><title type="html">NestJS 컴파일러 성능 비교 - tsc vs SWC</title><link href="http://0.0.0.0:4000/backend/2025/06/01/compiler-comparson.html" rel="alternate" type="text/html" title="NestJS 컴파일러 성능 비교 - tsc vs SWC" /><published>2025-06-01T00:00:00+00:00</published><updated>2025-06-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/06/01/compiler-comparson</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/06/01/compiler-comparson.html"><![CDATA[<h2 id="introduce">introduce</h2>
<p>Node 계열 프레임워크에서 TypeScript 언어 방식으로 개발을 하게 되면, 잘 알듯 JavaScript 로의 변환의 과정이 반드시 필요하다. 타입 체크를 비롯한 TypeScript의 강력한 기능으로 한 번 더 래핑된 상태라, JS 로의 변환 과정은 필수인 것이다.</p>

<h3 id="tsc-기본-컴파일러">tsc 기본 컴파일러</h3>
<p>TypeScript 컴파일러는 ms 에서 강력한 정적 분석과 엄격한 타입을 관리한다는 철학을 기반으로 만들어져 있다. 매우 큰 커뮤니티를 통해 안정성, 신뢰성, 쉽게 이용 가능하다는 기본적인 특징들은 이미 충분히 라이브서비스에 쓸만하다고 볼 수 있다. 그런 점에서 NestJS 프로젝트를 시작하면 시작과 동시에 기본 값으로 설정 되어 있는 것은 이러한 부분을 증명해주는 것이리라.</p>

<p>하지만 라이브 서비스로 쓰다보면 약간 답답함을 경험하게 될 것이다. 비교적 충분히 빠르긴 하지만, 프로젝트가 커지면 성능 병목은 어쩔 수 없이 필요하게 되고, 특히나 다중 타입 등이 많아질 수록, 포괄적인 검사는 엄청난 병목으로 다가온다. 제네릭스 타입이나, 타입의 수단계를 거친 복잡한 타입의 인스턴스화는 개발경험, CI 속도에 영향을 느끼게 된다.</p>

<p>특히나 AWS 에서 개발 환경이 존재하는 경우에도 문제가 있다. 감시모드를 켜게 되면 tsc 는 초기에는 메모리가 낮은 편이지만, 파일 변경으로 재 컴파일 트리거가 발동하면 메모리 사용량이 급격히 증가하게 된다. 피크 수준이 200 ~ 300mb 수준을 차지하게 되는데, 문제는 리소스가 부족한 서버를 갖고 있거나, 리소스에 맞춰진 수준의 dev 서버를 구동한다고 하면 피크 메모리 점유율로 인해 AWS 인스턴스가 멈추는 경우가 발생하게 된다.</p>

<h3 id="nestjs-의-swcspeedy-web-compiler">NestJS 의 SWC(Speedy Web Compiler)</h3>

<p>이러한 점들을 경험하고 나면 살짝 불편함을 느끼게 되고, 검색을 하게 된다. 그러다보면 마치 군대에서 ‘사제’를 찾듯이(?) 사제 컴파일러가 그렇게 좋다더라~ 하는 소문을 듣게 되고, 나름의 대안을 찾아 보게된다. 그 중에 하나가 <code class="language-plaintext highlighter-rouge">SWC</code> 라는 컴파일러. 러스트 기반이자, 트랜스파일링 프로세스를 최적화 시켜 Babel 의 직접적인 대체제라는 평가를 가진 컴파일러이다.</p>

<p><img src="/assets/images/posts/2025-06/2025-06-03-0001.png" alt="SWC로고" /><br /></p>

<p><a href="https://swc.rs/">공식 사이트</a><br /></p>

<p><a href="https://github.com/swc-project/swc?tab=readme-ov-file">공식 깃허브</a></p>

<p>SWC는 NestJS v10에서 공식으로 통합이 도입되었고, <code class="language-plaintext highlighter-rouge">@swc/cli</code>, <code class="language-plaintext highlighter-rouge">@swc/core</code> 패키지를 통해 사용이 가능하다. <code class="language-plaintext highlighter-rouge">nest-cli.json</code> 에서 컴파일러 옵션의 builder 를 swc 로 넣어주면 SWC 컴파일러를 사용할 수 있다.</p>

<p>이러한 SWC 의 근본적인 목적은 Babel(tsc)의 기본적인 타입 검사를 수행하지 않고, 고속변환에 포커스를 맞추고 있다는 점이다. 그럼에도 왜 써야 하는가? 라고 하면 다음과 같이 정리 할 수 있다.</p>

<ul>
  <li>
    <p>기본적으로 SWC의 벤치 내용은 <a href="https://swc.rs/docs/benchmarks">여기</a>를 참조하면 기본적으로 제공해주는 것을 알 수 있다. 프로젝트마다 다를 순 있지만, 기본적으로 평균 20배 내외의 성능을 나타낸다는 결과를 보여주었다.</p>

    <p>실제로 사내 메인 서비스의 NestJS 서버의 경우 단순 빌드 작업만 수행한다고 할 때, 기본 컴파일러 상태에서 총 4930ms가 수행되었으나, SWC 적용할 경우 2700ms 가 소요되었다. 약 82% 성능 향상을 보는 것이다(뒤에서 언급하기도 하겠지만, 현재는 SWC, TSC 의 병행 구조이다보니 파일 복사 과정이 포함되어 있고, 해당 부분을 공통으로 제외하면 훨씬 높은 성능을 보여주는 것이다).</p>
  </li>
  <li>
    <p>1번과 함께 HMR(Hot Module Replacement)가 이루어져서, 대단히 생산적인 워크 플로우를 짤 수 있다. 시간이 중요한 상황에서 이러한 즉각적인 피드백은 개발의 반복 속도, 테스팅 속도 등을 줄여주니, 그만큼 생산성에 직결된다고 볼 수 있다.</p>
  </li>
</ul>

<h2 id="swc-사용-후기는-그래서">SWC 사용 후기는 그래서?</h2>

<h3 id="빌드시간-비교">빌드시간 비교</h3>
<p>공식자료들을 기반으로 정리해 보면, 약 6000 줄의 코드 구성의 소규모 NestJS 프로젝트는 tsc의 경우 약 5.2 초의 빌드가, SWC 의 경우 0.38초가 걸렸다. 이러한 수치는 트랜스파일링 단계의 속도 향상에 대한 내용이 주를 이루며, 타입 검사는 해당하지 않는다.</p>

<p>공식 내용을 정리한 표를 보면 더욱 이 차이는 명백해진다.</p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>1 코어, 동기</th>
      <th>4 Promise</th>
      <th>100 Promise</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>swc (es3)</td>
      <td>616 ops/sec</td>
      <td>1704 ops/sec</td>
      <td>2199 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2015)</td>
      <td>677 ops/sec</td>
      <td>1688 ops/sec</td>
      <td>1911 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2016)</td>
      <td>1963 ops/sec</td>
      <td>3948 ops/sec</td>
      <td>5580 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2017)</td>
      <td>1971 ops/sec</td>
      <td>3948 ops/sec</td>
      <td>6259 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2018)</td>
      <td>2555 ops/sec</td>
      <td>4884 ops/sec</td>
      <td>8108 ops/sec</td>
    </tr>
    <tr>
      <td>swc-optimize (es3)</td>
      <td>645 ops/sec</td>
      <td>1716 ops/sec</td>
      <td>1860 ops/sec</td>
    </tr>
    <tr>
      <td>babel (es5)</td>
      <td>34.05 ops/sec</td>
      <td>27.28 ops/sec</td>
      <td>32 ops/sec</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>단위: <strong>ops/sec (operations per second)</strong><br />
참고: 수치가 높을수록 더 빠름</p>
</blockquote>

<p>더불어 자원이 풍부하지 않은 회사도 있을 수 있으므로(…) 메모리 소비도 분석하면 다음과같은 패턴이 보여진다. 아래 수치는 외부 오버헤드 최소화를 위하여, <code class="language-plaintext highlighter-rouge">node_modules</code>에서 직접 명령어를 실행 했을 때 수치다.</p>

<table>
  <thead>
    <tr>
      <th>컴파일러/설정</th>
      <th>시작 시 메모리</th>
      <th>파일 변경 시 메모리</th>
      <th>1분 비활성 후 메모리</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>tsc</td>
      <td>~50</td>
      <td>~200</td>
      <td>~60</td>
    </tr>
    <tr>
      <td>tsc (without –noCheck)</td>
      <td>~200</td>
      <td>~300</td>
      <td>~65</td>
    </tr>
    <tr>
      <td>SWC</td>
      <td>~310</td>
      <td>변화 없음</td>
      <td>변화 없음</td>
    </tr>
    <tr>
      <td>SWC (with –workers 1)</td>
      <td>~195</td>
      <td>변화 없음</td>
      <td>변화 없음</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>참고: <code class="language-plaintext highlighter-rouge">변화 없음</code>은 감지 가능한 메모리 증감이 없음을 의미함</p>
</blockquote>

<p>tsc 는 일반적으로 낮은 기본 메모리 사용량을 보여준다. 그러나 피크 시의 경우 상당한 변화량을 가지는데, 여기서 좀 특이한 경험을 했었다.</p>

<p><a href="https://g-db.tistory.com/entry/AWS-EC2-%EB%A8%B9%ED%86%B5-%EB%A9%88%EC%B6%A4-%ED%98%84%EC%83%81-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95">AWS EC2 먹통, 멈춤 현상 해결방법</a>, 이 글이 아마 가장 명확한 이유일 것으로 보이는데,… AWS는 인스턴스의 다른 리소스보다 메모리에 민감한 것으로 보여진다. 특히나 순간적으로 치솟는 경우 AWS 인스턴스 자체가 멈추는 경우가 있고, 이 때는 AWS 의 CloudWatch 가 먹통이 되는 데, 이로인해 모니터링도 에러라고 핸들링을 못하고, SSH 접속도 안되고, 재부팅도 빠르게 이루어지지 않는다. 서버가 타임아웃하는 문제가 발생하는 것이다. 정말 열 받는 부분인데(…) 한술 더 떠 개발들 위하여 사용하는 VSC IDE 의 SSH 접속 도 메모리를 매우 많이 먹는 다는 점이다.</p>

<p>이 두 가지 조건이 합쳐지고, tsc 로 HMR 를 수행하게 되면 서버는 정말 랜덤 확률로 터지고, 터진 뒤에도 터졌는지를 전혀 모르는 (…) 상황이 발생할 수 있다. 계속 값을 바꾸면서, 세팅에 따른 백엔드의 서빙 특성을 조사하거나 해야 할 때는 1변경 1리붓을 경험할 수 도 있다.(리소스가 적으면 어쩔 수 없다…)</p>

<p>이를 개선하기 위해 스왑 메모리 등을 설정하는 방법도 있지만, 특성 상 이러한 임시 대비책을 사용하면 안되는 서버도 있기 때문에, 이러한 방법 만으론 온전하게 해결되었다고 보기도 좀 문제가 있다.</p>

<p>따라서 dev 환경 등엣 SWC를 적용하고 –watch 모드를 켠 상태로 접속하여 사용 및 코드 수정 -&gt; 빌드 -&gt; 다시 테스트 이 환경을 히먄 tsc 로 컴파일을 할 때보다 월등히 안정적인 작업, 빠른 변경이 가능해진다.</p>

<h3 id="개발-환경의-최적화는-좋다-하지만">개발 환경의 최적화는 좋다.. 하지만</h3>

<p>tsc 는 오래 걸리며, 메모리가 피크 되는 순간마다 인스턴스는 죽을 걱정(?)을 해야 할 수 있다. 제일 문제는 수 초 씩 걸리는 과정이 은근히 하고 있던 작업의 맥을 끊거나 흐름을 끊는 역할을 한다는 점이고, 이는 집중하여 개발하는 과정을 도와주기 보단 버퍼를 자꾸 일으키는 방해 요소가 된다. <del>그러라고 성능 좋은 로컬 환경이 필요한 거다</del></p>

<p>SWC의 도입은 이러한 점에서 충분히 훌륭하다. 이러한 파격적인 성능, 개발 시의 안정성을 제공해주는 것은 좋았지만, 한가지 결정적인 문제는 계속 언급되는 ‘타입 체크’ 의 부재이다.</p>

<p><img src="/assets/images/posts/2025-06/2025-06-02-0001.png" alt="" /></p>
<blockquote>
  <p>동일한 브랜치에서 tsc 컴파일러로 빌드를 했을 때</p>
</blockquote>

<p><img src="/assets/images/posts/2025-06/2025-06-02-0002.png" alt="" /></p>
<blockquote>
  <p>동일한 브랜치에서 SWC 컴파일러로 빌드를 했을 때</p>
</blockquote>

<p>타입체크는 TypeScript의 근본이다. JS의 막무가내 스럽고, 당혹스러울 정도의 ‘강력함’을 정리하고 다듬어서, 에러를 최소화 시키기 위한 패러다임이 TypeScript이다. 아무리 욕을 먹거나, TS를 배제하려고 해도 여전히 TypeScript가 배제되지 않는 것은 JS가 가진 한계를 매우 유용하게 보완해주기 때문이다.</p>

<p>그런데 SWC는 이를 가볍게 무시해준다. 같은 환경이지만, 수 많은 타입 에러를 무시해버린다. 심지어 그런 문제를 갖고 있는 데도 구동되고 일정하게 서벅 ‘실행된다’. 이건 매우 큰 문제였다. dev 환경에서 SWC 를 기반으로 작업을 하고 테스트 할 때는 전혀 문제가 아닌 기능들이, 막상 production 환경에 올려놓고 보면 다른데서 터지거나 하는 일이 발생하고 그제서야 서버가 뻗을 수 있다. 왜냐면 타입이 제대로 지정이 안되거나 버그가 있지만, 내가 작업하던 곳, 내지는 SWC 상태에서는 어떻게든 돌려버리는 것이다.</p>

<p>몇 번이나 CTO에게 이 부분을 지적받고 난 이후, SWC 없이 작업하기 너무 싫다고 생각은 하지만, 동시에 내가 만능이 아닌 이상 TypeError에 대한 두려움, 확신이 없는 상태로 괜찮은가? 라고 생각했다. 그렇기에 반드시 검사 내지는 tsc 를 활용한 완벽한 타입 체킹이 필요하다고 생각했다. (참고로 SWC도 설정을 켜서 할 수 있으나, 완벽하지 않다.)</p>

<h2 id="그렇기에">그렇기에..</h2>

<p>SWC 는 개발하기에 매우 편안한 환경을 구현해준다. 하지만 결정적으로 급박하게 개발하는 과정이라고 해도, 빨라서 편하다고 해도, Type 에러 발생, 라이브 서버 폭발이라는 사태는 정말 막아야 한다. 나름대로의 대안이 필요했다. 따라서 초기에는 이를 위한 해결 방법을 고안했다.</p>

<h3 id="초기다-알지-못할-때">초기(다 알지 못할 때)</h3>
<p>tsc / SWC 를 컨버팅하는 script를 제작, 해당 스크립트를 package.json 에서 동작하도록 설정하였었다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c">#9 설정 파일 교체 함수</span>
update_config_files<span class="o">(){</span>
    <span class="nb">echo</span> <span class="s2">"Updating configuration files..."</span>
    <span class="k">if</span> <span class="o">!</span> <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$BUILDER_CONFIG_FILE</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$NEST_CLI_FILE</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span>error_handler <span class="s2">"Failed to update </span><span class="nv">$NEST_CLI_FILE</span><span class="s2">"</span>
    <span class="k">fi
    if</span> <span class="o">!</span> <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$TSCONFIG_CONFIG_FILE</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$TSCONFIG_FILE</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span>error_handler <span class="s2">"Failed to update </span><span class="nv">$TSCONFIG_FILE</span><span class="s2">"</span>
    <span class="k">fi

    </span><span class="nb">echo</span> <span class="s2">"Successfully updated </span><span class="nv">$NEST_CLI_FILE</span><span class="s2"> and </span><span class="nv">$TSCONFIG_FILE</span><span class="s2"> with </span><span class="nv">$BUILDER_TYPE</span><span class="s2"> Compiler."</span>
<span class="o">}</span>

<span class="nb">.</span>
<span class="nb">.</span>
<span class="nb">.</span>


<span class="c"># 11 메인 로직 </span>
main<span class="o">()</span> <span class="o">{</span>
    <span class="c"># 로깅 설정</span>
    setup_logging

    <span class="c"># 로깅 설정 후 원래의 에러 핸들러 설정</span>
    <span class="nb">trap</span> <span class="s1">'error_handler "Line ${LINENO}: $BASH_COMMAND" '</span> ERR
    
    validate_input <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    </span>check_files
    create_backup
    update_config_files
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    </span>cleanup_backup

    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    case</span> <span class="s2">"</span><span class="nv">$BUILDER_TYPE</span><span class="s2">"</span> <span class="k">in</span>
        <span class="s2">"swc"</span><span class="p">)</span>
            <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="nb">echo</span> <span class="s2">"✨ SWC compiler does not need to clear cache"</span>
            <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="p">;;</span>
        <span class="s2">"origin"</span><span class="p">)</span>
            yarn cache clean <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Warning: yarn cache clean failed, ignoring."</span>
            <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
            </span><span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="nb">echo</span> <span class="s2">"✨ Clear Yarn Cache"</span>
            <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
    <span class="nb">sleep </span>1
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi

    if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
    <span class="nb">echo</span> <span class="s2">"✨ Compiler is switched </span><span class="nv">$BUILDER_TYPE</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi</span>
<span class="o">}</span>

main <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="nb">exit </span>0
</code></pre></div></div>

<p>전체 코드를 다 올리지 못하고 부분만 올렸지만, 핵심은 빌드를 담당하는 tsconfig.json 과 nest-cli.json을 교체하는 방식이다. 매우 무식하지만(?) 확실하게 변경이 되었고, 원하면 각 상황마다 다른 옵션을 추가할 수 있다는 점에선 아주 괜찮았다.</p>

<h3 id="현재-개선-방향">현재 개선 방향</h3>

<p>현재는 컴파일러를 공부하면서 타입 체크 기능만 구동할 수 있다는 것을 알게 되면서, <del>나의 무지함을 이해했다(…).</del>
그러나 막상 확인해보니, 단순히 타입 체킹만을 tsc 에게 넘기는 것 만으로는 완벽하게 기본값의 환경을 만들진 못했다.</p>

<p>대표적으로 debug 모드, vsc 디버그 모드를 사용하는 입장에선 SWC 상태론 지원이 정상적이지 못하여 대체가 불가능했다. (결국 컴파일러를 이중으로 쓰기 + 짧게 필요할 땐 타입 검사만 의 구조를 차용해야 한다.) 혹시나 이것에 대한 조언을 해줄 수 있는 분이 있다면 좋을것 같다…😂</p>

<h4 id="환경별-정리">환경별 정리</h4>
<ol>
  <li>개발 환경 + Dev 환경 =&gt; 빠른 체킹 &amp; 테스팅을 위해 SWC 기반의 타입체킹 배제</li>
  <li>debug 환경 =&gt; SWC 로 구동하기 어려울 수 있음. 에러 핸들링을 포함해 아직 호환이 안되므로 tsc 를 그대로 사용할 것</li>
  <li>Prod, Staging 환경 =&gt; lint 포함, 타입 체킹 사전 진행 =&gt; 미 통과시 배포 중단 및 알림</li>
</ol>

<h4 id="환경별-스크립트">환경별 스크립트</h4>
<ol>
  <li>
    <p>간단하게 빌드 전 테스팅 방법</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c"># tsc 타입 검사 성공 시 build 를 수행(SWC)</span>
 yarn tsc <span class="nt">--noEmit</span> <span class="o">&amp;&amp;</span> yarn build:fast
</code></pre></div>    </div>
  </li>
  <li>
    <p>husky 를 활용하여</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/sh</span>
 <span class="c"># husky / pre-push 문서 </span>

 <span class="c"># run_command 는 로깅을 포함한 함수 실행부로 공통으로 명령어를 대신 수행하는 함수 스크립트</span>

 <span class="c"># 공통 함수 로드</span>
 <span class="nb">.</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$0</span><span class="s2">"</span><span class="si">)</span><span class="s2">/common.sh"</span>

 <span class="c"># 명령어 실행</span>
 run_command <span class="s2">"lint"</span> <span class="s2">"yarn lint --max-warnings=0"</span> <span class="o">||</span> <span class="nb">exit </span>1

 <span class="c"># type checking </span>
 run_command <span class="s2">"type-check"</span> <span class="s2">"yarn typecheck"</span> <span class="o">||</span> <span class="nb">exit </span>1
 <span class="c"># run_command "build" "yarn build:external" || exit 1</span>
 <span class="c"># 깃 최상위 위치 체크, 이동하여서 항상 dist 폴더가 삭제 되도록 함</span>
 <span class="c"># run_command "clean dist" "git rev-parse --show-toplevel &amp;&amp; cd \$(git rev-parse --show-toplevel) &amp;&amp; rm -rf dist" || exit 1</span>

 <span class="nb">echo</span> <span class="s2">"🚀 All checks passed! Pushing..."</span>

</code></pre></div>    </div>
  </li>
</ol>

<h2 id="마치며">마치며</h2>
<p>Rust 는 이런 영역에서 점점 빛을 발하고 있다는게 느껴진다. Rust 기반 백엔드 성능도 상당하다고 들었지만, 컴파일러로의 SWC 는 개발 생산성 향상에서 정말 괜찮은 도구이며, 다소 아쉬움은 있지만, 빌드의 시간이 정말 ‘월등히’ 빨라지기 때문에 확실히 초반부터 도입하고 사용하는 것을 기본으로 깔고 가는 것이 좋다.</p>

<p>단, 부재의 제목처럼, 한계가 작게 있고, 작긴 한데 그 작은 한계가 매우 위험 할 수 있다는 것은 주의가 필요해 보인다. 타입체킹이 안되고, 이에 대해 고려하지 않으면 타입 문제가 발생할 수 있다. 또한 어디까지나 확실한 영역은 아니지만 최신의 언어나 프레임워크까지 가버리면 SWC 의 트랜스파일링의 결과물이 tsc 의 그것과 다를 수 있다는 평가도 있다는 점은, 반드시 이에 대한 안전망을 확보하는 것을 최 우선으로 필요하다고 보며, 개발 환경자체에서 어렵다면 CICD 파이프라인 속에 해당 절차를 넣어두는 것이 좋아 보인다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="Backend" /><category term="Node" /><category term="NestJS" /><category term="TypeScript" /><category term="Programming" /><summary type="html"><![CDATA[introduce Node 계열 프레임워크에서 TypeScript 언어 방식으로 개발을 하게 되면, 잘 알듯 JavaScript 로의 변환의 과정이 반드시 필요하다. 타입 체크를 비롯한 TypeScript의 강력한 기능으로 한 번 더 래핑된 상태라, JS 로의 변환 과정은 필수인 것이다.]]></summary></entry><entry><title type="html">AI에게 답을 찾는 새로운 방법 ‘Slow Think’</title><link href="http://0.0.0.0:4000/ai/2025/05/31/slow-think.html" rel="alternate" type="text/html" title="AI에게 답을 찾는 새로운 방법 ‘Slow Think’" /><published>2025-05-31T00:00:00+00:00</published><updated>2025-05-31T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/05/31/slow-think</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/05/31/slow-think.html"><![CDATA[<h2 id="ai-에게도-생각할-시간이-필요하다--slow-thinking">AI 에게도 생각할 시간이 필요하다 : Slow Thinking</h2>
<p>LLM 과 관련하여 AI를 사용하다보면 답을 정확하게 준다고 생각이 들긴 하지만, 그럼에도 여전히 할루시에이션(hallucination)이 발생하는 경우를 느끼거나, 데이터가 오염되었다고 느끼는 경우가 발생한다. 그러는 와중에 이런 영상을 발견하게 되었다.</p>

<p><a href="https://www.youtube.com/watch?v=mN6FXDeSfAc&amp;t=3s"><img src="https://i.ytimg.com/vi/mN6FXDeSfAc/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&amp;rs=AOn4CLA44jSpAlGNEUistYs9DJaIgH4gXQ" alt="GPT/클로드/..." /></a></p>

<p>프롬프팅에 대한 내용은 AI에 익숙한 사람들이라면 이미 충분히 알고 있을 만한 단어일 것이며, 그렇지 않다고 하더라도 ‘명령’이 왜 내가 하면 제대로 답을 못하는지를 한 번이라도 생각해봤다면 ‘어떤 식으로 명령을 내리면 ‘더 잘 답을 한다’’ 라는 이야기를 들어 봤을 것이다.</p>

<h3 id="ai-는-확률의-문제다">AI 는 확률의 문제다.</h3>

<p>LLM 모델의 구조가 방대한 양의 3차원 축으로 데이터의 ‘연관성의 맵’을 구성하고, 거기서 어떤 질문이 들어올 때 그 ‘답’이라는 것은 소위 ‘연관성’ 이라는 것과 연결되는 것이다.</p>

<p>그렇기에 질문을 할 때, ‘연관성’을 잘 살려내는가 아닌가가 매우 중요해진다. 하지만 <strong>컴퓨터의 연산은 이 확률 계산에서 항상 동일한 값을 얻어내지 못한다</strong> 그리고 이러한 부분은 놀랍게도 마치 사람처럼, 같은 내용의 요청에 같은 답을 너무나 쉽게 내뱉던 기계가, 같은 내용의 답을 ‘매번 다를 수 있게’ 만드는 매우 신비로운 특성을 만들어냈고, 이러한 결과는 매우 훌륭한 도구임에도 치명적인 단점을 만들어낸다.</p>

<blockquote>
  <p>서비스는 일관성이 있어야한다.</p>
</blockquote>

<p>무형에서 유형까지, 우리가, 사회가 약속하고 있는 많은 것들이 있는데, 그런 것들 중 하나의 가치는 당연히 ‘재화를 제공한 서비스는 그 재화 만큼이라고 ‘느낄 수 있는’ 동일한 서비스를 재화를 들인 모두에게 제공해야 한다’ 라는 특성이다.</p>

<p>이러한 일관성이란 특성은 산업마다 그 편차는 있겠지만, 결국 상품이라는 근본적 성격에는 존재해야 한다는 게 우리의 문화속에, 가치 속의 근본적 성질이다.</p>

<p>빙 돌아왔지만, 다시 AI에 대해 돌아오면, 이러한 특성을 고려하게 될 때 매우 치명적인 단점을 AI 로부터 얻을 수 있다. 즉, 1만원을 내고도 어떤 사람의 AI는 유능해 보이지만, 어떤 사람의 AI는 그렇게 보이지 않게 될 수 밖에 없고, 이러한 편차가 존재 하기에 AI 프롬프팅 엔지니어링에 대한 이야기가 나올 수 밖에 없는 것이다. (물론 예전보단 지금은 덜 필요시 되긴 한다.)</p>

<p>서론이 길었지만, 어쨌든, 결론적으로 AI 는 그렇기에 ‘정답’에 가깝게 끌어낼 줄 아는가, 일관된 결과를 정확히 도출할 수 있는가? 는 매우 중요한 AI의 성능 지표가 된 것이다.</p>

<h3 id="새로운-프롬프팅-slow-thinking">새로운 프롬프팅 ‘Slow Thinking’</h3>

<p>기존에는 Chain of Thought 라는 방식이 굉장한 파장을 가져왔고, 많은 대형 모델들이 차례차례 방식을 기본값으로 넣으면서, 그 강화된 형태들을 통해 성능의 극대화를 끌어왔다. ‘Let’s Think Step by Step(단계별로 생각해보자)’ 라는 아주 기초적인 프롬프팅 문구일 텐데, 그럼에도 이러한 방식은 유효했다.</p>

<p>하지만 ‘slow thinking’ 이라는 프롬프팅 문구</p>

<p>‘Take a deep breath and work through this carefully.</p>

<p>This is a complex strategic decision that requires examining our assumptions…’</p>

<p>라는 문구를 넣으면서 다음 수준의 성능 향상이 있었다고 한다.</p>

<ul>
  <li>GPT Slow thinking 적용 시 Chain of Thought 보다 최소 4 ~ 10% 더 정확한 결과를 제공한다.</li>
  <li>클로드는 100점 만점 기준 4점의 성과</li>
  <li>제미나이 역시 8점 높은 결과를 제공함</li>
</ul>

<p>해당 내용을 찾아보면, 이러한 결과가 나온 이유는 ‘관점의 전환’ 이라는 차원으로 설명을 했다. 속도보다 정확성을 우선하고, 체계적인 접근을 유도하고, 복잡성의 인식 및 가정 검증을 이야기 하여 사실과 주장을 분해하며, 다층적 분석 유도의 키워드가 포함되어 단순히 단계별로 이미 ‘결정된 듯’ 한 사고 패턴에서 벗어날 수 있었기 때문이다.</p>

<h2 id="ai에게-프롬프팅의-의미하는-바는-뭘까">AI에게 프롬프팅의 의미하는 바는 뭘까?</h2>
<p>프롬프팅을 보면 볼 수록, AI가 언제 잘 이해하는가? AI는 언제 자신의 포텐셜을 100% 활용하는가? 그것은 사람이 어떤 문제, 어떤 상황, 어떤 조건을 어떻게 온전하게 이해하고 있는가?를 ‘외재화’ 시킨 형태와 유사하다는 생각이 든다.</p>

<p>좀 어렵게 표현 되었는데… 말 그대로 객관적으로 한 사람이 어떤 것들에 대해 온전히 ‘이해했다’ 는 상태를 외부적으로 나타낼 때의 특성이 고려 된게 아닐까? 하는 생각이 드는 것이다.</p>

<p>사람이 무언가를 이해할 때는, 단계적으로 이해할 때도 있고, 어떨 때는 인과관계를 기반으로 이해할 때도 있으며, 복합적인 다층 관계로 지식 자체도 일종의 구조화를 달성하여 이해하기도 한다. 이러한 뇌내의 정렬 상태는 외부적으로는 ‘이해했다’ 라고 표현할 수 있는 상태가 되고, 이를 기반으로 지식을 설명하거나 공유가 가능하다.</p>

<p>그런데 이러한 언어와 사고의 구조를 설명하는 표현을 LLM의 프롬프터로 넣어줌으로써 그 형태를 AI에게 요구하고, 그러한 구조적 형태가 잡히니 확률의 싸움인 LLM에게 보다 명확한 결과를 도출하는 보정의 작용을 하는게 아닐까?</p>

<p>그렇다면 앞으로의 AI를 다루는 사람, 혹은 AI를 다루는 도구의 방식은 더더욱 사람, 인류가 쌓아올린 지적 재산, 지적 철학과 방법론을 누가 더 세밀하게 적용하냐, 보정을 정밀하게 해내냐의 싸움이 아닐까? 라는 생각을 하게 된다.</p>

<h2 id="프롬프팅-가이드">프롬프팅 가이드</h2>
<p>부록 느낌이다. 공유해주신 분의 내용에서 발췌했다…</p>

<h3 id="프롬프팅-적용-방법">프롬프팅 적용 방법</h3>

<table>
  <thead>
    <tr>
      <th>분류</th>
      <th>문구 (Phrase)</th>
      <th>효과 (Effect)</th>
      <th>사용 시점 (When to Use)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.단계적 사고 (CoT 기반)</td>
      <td>"Let’s think step by step."</td>
      <td>복잡한 문제를 단계별로 명확하게 사고하게 함 (CoT의 기본)</td>
      <td>수학 문제, 로직 설명, 계획 및 전략 설계, 복잡한 지시 이해</td>
    </tr>
    <tr>
      <td>1.단계적 사고 (CoT 기반)</td>
      <td>"Show all your reasoning before you answer."</td>
      <td>사고 과정을 투명하게 드러내어 논리적 오류를 줄이고, 사용자가 검토 용이하게 함</td>
      <td>중간 과정의 논리가 중요한 문제<br />(예: 과학적 추론, 법률적 판단 근거, 디버깅)</td>
    </tr>
    <tr>
      <td>2.신중함 및 정확성 강조</td>
      <td>"Take a deep breath and work on this carefully."</td>
      <td>AI가 서두르지 않고 신중하게 정보를 처리하고 답변하도록 유도</td>
      <td>오류가 잦거나 민감한 정보를 다룰 때,<br />정밀한 판단이나 높은 정확도가 요구될 때</td>
    </tr>
    <tr>
      <td>2.신중함 및 정확성 강조</td>
      <td>"Let’s take it slow and go through this logically, ensuring each step is sound."</td>
      <td>논리적 흐름을 따라 차분히 문제를 해결하도록 유도하며, 각 단계의 타당성을 강조</td>
      <td>논증 구성, 토론 준비, 복잡한 시스템 분석,<br />의사결정 로직 수립 시</td>
    </tr>
    <tr>
      <td>2.신중함 및 정확성 강조</td>
      <td>"Take a deep breath and let’s work this out in a step-by-step way to be sure we have the right answer." (결합형)</td>
      <td>신중함과 단계적 분석을 동시에 강조하여, 복잡하고 중요한 문제에 대한 답변의 정확성과 신뢰도를 극대화</td>
      <td>매우 복잡하거나 결과의 파급효과가 큰 중요한 판단 문제, 여러 조건이 얽힌 문제</td>
    </tr>
    <tr>
      <td>3.전문가 관점 및 역할 부여</td>
      <td>"Think through this like a top expert in [분야] would. Consider all relevant factors and methodologies they would use."</td>
      <td>특정 분야 최고 전문가의 심층적이고 체계적인 사고방식과 지식 체계를 적용하도록 유도</td>
      <td>고난이도 전문분야 질문, 특정 역할<br />(예: 의사, 변호사, 과학자)의 관점에서 문제 해결 필요 시</td>
    </tr>
    <tr>
      <td>4.불확실성 관리 및 정직성</td>
      <td>"If you are unsure about any part of your answer, please state your uncertainty clearly and explain the reasons for it."</td>
      <td>AI가 자신의 지식 한계를 인지하고, 불확실한 정보에 대해 솔직하게 표현하며 그 근거를 제시하도록 유도</td>
      <td>최신 정보가 반영되지 않았을 가능성이 있거나, 정보의 모호성이 존재할 때, AI가 환각(hallucination)을 일으킬 가능성이 우려될 때</td>
    </tr>
    <tr>
      <td>5.심층 분석 및 다각적 고려</td>
      <td>"Let’s analyze this issue from multiple perspectives (e.g., economic, social, ethical). What are the pros and cons from each viewpoint?"</td>
      <td>단일 관점에서 벗어나 여러 각도에서 문제를 종합적으로 분석하고 평가하도록 유도</td>
      <td>사회적 이슈 분석, 정책 결정, 복잡한 딜레마 상황, 전략 수립 시 다양한 이해관계 고려</td>
    </tr>
    <tr>
      <td>5.심층 분석 및 다각적 고려</td>
      <td>"Before proposing a solution, let’s first identify the root causes of this problem and any underlying assumptions."</td>
      <td>피상적인 해결책이 아닌, 문제의 근본 원인을 파악하고 숨겨진 가정을 점검하여 더 본질적인 해결책을 찾도록 유도</td>
      <td>문제 해결 시나리오, 원인 분석이 중요한 과제,<br />장기적인 해결책 모색</td>
    </tr>
    <tr>
      <td>6.Step-Back Prompting</td>
      <td>"Before answering [구체적 질문 X], let’s first consider the general principles or concepts related to [더 넓은 주제 Y]."</td>
      <td>구체적인 문제에 매몰되기 전에, 관련된 일반 원칙이나 배경 지식을 먼저 활성화하여 문제 해결의 맥락과 깊이를 더함</td>
      <td>특정 사례에 대한 판단, 역사적 사건 분석, 새로운 개념 이해, 복잡한 이론 적용 시</td>
    </tr>
    <tr>
      <td>7.자기 비판 및 개선</td>
      <td>"Draft an initial response. Then, critically review your own response for any potential biases, inaccuracies, or areas for improvement. Finally, provide a revised and improved response."</td>
      <td>AI가 스스로 생성한 답변을 비판적으로 검토하고 개선하는 과정을 통해 답변의 질을 높임 (자기 교정 능력 향상)</td>
      <td>보고서 초안 작성, 주장 개발, 창의적 글쓰기, 코드 생성 후 디버깅 등 완성도 높은 결과물이 필요할 때</td>
    </tr>
    <tr>
      <td>8.문제 분해 및 구조화</td>
      <td>"This is a complex problem. Let’s break it down into [3-5] smaller, manageable sub-problems. Address each sub-problem systematically."</td>
      <td>큰 문제를 작고 다루기 쉬운 부분으로 나누어 체계적으로 접근함으로써 해결 가능성을 높임</td>
      <td>프로젝트 계획, 대규모 시스템 설계, 복잡한 연구 질문 해결, 장문의 글 구성</td>
    </tr>
  </tbody>
</table>

<h3 id="️-효과성-등급표">⚡️ 효과성 등급표</h3>

<table>
  <thead>
    <tr>
      <th>등급</th>
      <th>기법</th>
      <th>정확도 향상</th>
      <th>사용 난이도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>S급</td>
      <td>2번 (결합형), 7번</td>
      <td>매우 높음</td>
      <td>중간</td>
    </tr>
    <tr>
      <td>A급</td>
      <td>1번, 3번, 8번</td>
      <td>높음</td>
      <td>낮음</td>
    </tr>
    <tr>
      <td>B급</td>
      <td>5번, 6번</td>
      <td>중간-높음</td>
      <td>중간-높음</td>
    </tr>
    <tr>
      <td>C급</td>
      <td>4번</td>
      <td>중간</td>
      <td>낮음</td>
    </tr>
  </tbody>
</table>

<h3 id="-상황별-권장-기법">🎯 상황별 권장 기법</h3>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>권장 기법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>📊 수학/계산 문제</td>
      <td>1번 → 2번</td>
      <td>"Let’s think step by step" → "Take a deep breath and work carefully"</td>
    </tr>
    <tr>
      <td>🔬 전문적 분석</td>
      <td>3번 + 5번 + 4번</td>
      <td>전문가 관점 + 다각적 고려 + 불확실성 관리</td>
    </tr>
    <tr>
      <td>💼 복잡한 의사결정</td>
      <td>2번(결합) + 6번 + 7번</td>
      <td>신중함 강조 + Step-Back + 자기 비판</td>
    </tr>
    <tr>
      <td>🏗️ 대규모 프로젝트</td>
      <td>8번 + 5번 + 1번</td>
      <td>문제 분해 + 근본 원인 분석 + 단계적 사고</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="etc" /><category term="AI" /><category term="prompting" /><summary type="html"><![CDATA[AI 에게도 생각할 시간이 필요하다 : Slow Thinking LLM 과 관련하여 AI를 사용하다보면 답을 정확하게 준다고 생각이 들긴 하지만, 그럼에도 여전히 할루시에이션(hallucination)이 발생하는 경우를 느끼거나, 데이터가 오염되었다고 느끼는 경우가 발생한다. 그러는 와중에 이런 영상을 발견하게 되었다.]]></summary></entry><entry><title type="html">백엔드 개발자의 이직 커리어 준비 연구</title><link href="http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/31/t-backend-developper-career-preparing.html" rel="alternate" type="text/html" title="백엔드 개발자의 이직 커리어 준비 연구" /><published>2025-05-31T00:00:00+00:00</published><updated>2025-05-31T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/31/t-backend-developper-career-preparing</id><content type="html" xml:base="http://0.0.0.0:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/31/t-backend-developper-career-preparing.html"><![CDATA[<h2 id="introduce">Introduce</h2>
<p>백엔드 개발자로 생존한지 1년차… 
이제는 AI가 등장하면서 개발자의 위치는 지속적인 블러핑의 대상(?) 이 되어버렸다.</p>

<p>생각해보면 AI 덕에 엄청 편해졌지만, 그게 결국 오히려 ‘들킨’ 게 되어 버린걸까. 성장하지 않고 발전하지 않는 개발자들의 종말이라는 듯이.. 수 많은 회사들은 필요하지 않은 개발자들을 배제하기 시작했다.</p>

<p>끔찍하지만, 그래도 뭐 별수 있나. 이러한 일들이 수 차례 있어왔고 저항한다고 돈, 재화, 분배의 기준은 결국 기원 전이나 기원 후나 동일하다. 약육강식이 아니길 바라는 것은 사람의 본성일지 몰라도, 약육강식 아닌 방식이 완벽하게 정착할 수 없는 건 어쩌면 자연계가 정한 물리적 환경인데.</p>

<p>오히려 기술을 배우고 조금이라도 할 수 있게 된 내가 될수 있었단 점은 감사하다. 심지어 무언가를 만들 수 있다는 점은, 무언가를 다시 배우거나 생산해 낼 수 있다는 것이므로, 그것이 주는 안도감은 부정할 수 없다.</p>

<p>그런 점에서 이제 신입이지만… 필요한건 결국 길이다. 재직 중인 회사에서 백엔드는 나 혼자이고, 그러한 점은 내가 해야 할 일들과, 그러는 와중에 성장하기 위해 무얼 해야할지 알려주지도 가르쳐주지도 않는다. 뿐만 아니라 누군가가 말해주지 않아도 전문가가 되기 위해서는 단순한 것들은 최대한 AI에게 맡기고, 내가 할 일은 계속해서 더 어렵고, 더 복잡한 것들을 더 빠르게 해낼 수 있게 되는 것이다.</p>

<p>그러기 위해서 필요한 것은 길이다. 방향성이다. 트렌드를 읽고, 내 부족한 전문 지식을 채우는 것이다. 그렇기에 AI를 활용해 분석한 글을 그냥 올리는게 아니라 읽고, 소화하고, 해석해서, 내것으로 만든다. 이 글의 목적은 그것이다.</p>

<h2 id="백앤드-개발자-1--3년차-요구사항-분석-내용">백앤드 개발자 1 ~ 3년차 요구사항 분석 내용</h2>

<h3 id="조사-기반">조사 기반</h3>

<p>국내 개발자 채용시장의 인지도, 공고 수 등을 기반으로 높은 플랫폼을 선정하고, 이를 AI에게 크롤링을 맡겼다. 그리하여 선정한 플랫폼은 아래와 같다.</p>

<ul>
  <li>원티드 : 너무나 잘 아는, IT 스타트업 채용 공고가 꽤 많이 올라옴.</li>
  <li>프로그래머스 : 코드 중심의 개발자 채용 지향. 당연히 코테로도 유명하고, 플랫폼을 제공해주므로 주시해야 하는 사이트.</li>
  <li>점핏 : 사람인에서 만든 개발자 중심의 채용 플랫폼</li>
  <li>로켓펀치 : 스타트업 정보 공유 및 채용 플랫폼.</li>
  <li>잡코리아 / 사람인 : 이젠 레거시라고 불러도 될만한, 전형적인 구인구직 플랫폼</li>
  <li>랠릿 : 인프런이 만든 구인구짓 플랫폼</li>
</ul>

<p>각 플랫폼 검색에서 키워드들을 조합해서 경력 요건을 필터링하여 공고 수집을 요청했고 2.5 Gemini Pro 기반으로 수행되었다.</p>

<h3 id="전반적인-시장-동향">전반적인 시장 동향</h3>

<p>예상은 했지만, 1 ~ 3년차 백엔드 개발자 채용 공고는 역시나 AI 키워드가 눈에 띌 정도로 증가 했다. AI 기능은 기계적, 코딩으로 해결하지 못하는 것들을 해결하기 시작했고, 특히나 AI 기반 새로운 서비스는 정말 초고속으로 증가되는 만큼, 백엔드 인프라 구축의 필요성을 인지하고 있다고 AI 는 분석했다.</p>

<p>단, 여기서 AI 역량이라는 키워드가 주로 등장했다. 이는 AI 서비스에 대한 수요에 맞춰 백엔드 개발이 필요하지만, 그에 대한 이해도가 있진 않기에 이에 대한 이해, 활용 경험, 서빙 경험 등의 전반적인 경험치가 있으면 이를 중요시 하지만, 이에 비해 확립된 기술체계가 아직 정돈이 안되어 있다는 것을 보여주는 대목이라고 느꼈다.</p>

<p>당연히, 그러는 와중에도 비교적 AI 에 대해 자세하고 세세하게 언급하는 케이스들도 있다는 점에서 그냥 어떤 AI 든 Okay 이런 느낌은 아니니 주의가 필요해 보인다.</p>

<p>그러나 어쨌든 AI 의 분석 왈, 백엔드 개발 능력 위에 AI 라는 키워드가 추가적으로 요구되며, 이에 대해 정확히 파악하고 어떤 전략으로 구체적으로 AI를 어떻게 활용하였는가 라는 점을 중점적으로 생각할 필요가 있음을 보여주었다.</p>

<h3 id="필수-자격-요건">필수 자격 요건</h3>

<p>AI 가 분석한 핵심 백엔드 개발자들의 평균적인 필수 자격 요건은 다음 정도로 정리했다.</p>

<ul>
  <li>핵심 프로그래밍 언어 및 프레임워크:
    <ul>
      <li>NestJS 스택: Node.js, TypeScript에 대한 이해를 바탕으로 NestJS 프레임워크를 활용한 실무 개발 경험이 필수적으로 요구됩니다.</li>
      <li>Java 스택: Java 언어와 Spring Boot, Spring Framework(MVC 등)에 대한 깊이 있는 이해 및 이를 활용한 실무 개발 경험이 중요합니다.</li>
      <li>일부 공고에서는 NestJS와 Java/Spring 기술 스택을 함께 언급하며, 둘 중 하나에 대한 능숙한 활용 능력 또는 양쪽 모두에 대한 경험을 요구하기도 합니다.</li>
    </ul>
  </li>
  <li>데이터베이스 기술:
    <ul>
      <li>RDBMS (MySQL, PostgreSQL 등) 사용 경험과 SQL 작성 능력은 기본적인 요구사항입니다.</li>
      <li>NoSQL (MongoDB, Redis 등) 데이터베이스 사용 경험 또한 많은 공고에서 찾아볼 수 있으며, 특히 Redis는 캐싱, 비동기 처리 등 다양한 목적으로 활용될 수 있음을 명시하는 경우가 있습니다.</li>
    </ul>
  </li>
  <li>API 설계 및 개발:
    <ul>
      <li>RESTful API 설계 원칙에 대한 이해와 실제 개발 경험은 대부분의 백엔드 개발자에게 필수적으로 요구됩니다.</li>
      <li>API 문서화 도구(e.g., Swagger/OpenAPI) 사용 경험을 명시하는 공고도 있습니다.</li>
    </ul>
  </li>
  <li>버전 관리 시스템:
    <ul>
      <li>Git 및 Github (또는 유사 플랫폼) 사용 경험은 협업을 위한 기본적인 역량으로 간주됩니다.</li>
    </ul>
  </li>
  <li>기본적인 AI/ML 이해도:
    <ul>
      <li>AI/ML 관련 주요 용어 및 기본 개념에 대한 이해가 요구될 수 있습니다. 이는 명시적으로 자주 언급되지는 않으나, AI 역량을 요구하는 공고에서는 암묵적으로 포함되는 경우가 많습니다.</li>
      <li>AI 관련 프로젝트 경험이 없더라도, AI 기술에 대한 학습 의지나 높은 관심을 표명하는 것이 긍정적으로 작용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<p>분석한 내용에서 분명하게 드러나는 것은 다음과 같다.</p>

<p>1) 탄탄한 백엔드적 기술 능력은 필수 중에 필수. 언어나 프레임워크의 중요도는 당연히 Java 중심. 그러나 Node, NestJS 가 안되는 건 아님 
2) AI 와 관련된 언급은 필수적으로 등장하지만, 이는 우대적으로 언급됨.
3) 결론적으로 AI 역량을 더하더라도 NestJS, Java 등의 백엔드 기술 숙련도는 절대 놓치지 말아야 할 영역이다.</p>

<h3 id="평균-권장--우대-자격-요건">평균 권장 / 우대 자격 요건</h3>
<p>필수에서는 빠졌으나, 상당히 많이 요구된 것으로 정리된 키워드들이다.</p>

<ul>
  <li>프로그래밍 언어 (AI 관련):
    <ul>
      <li>Python: AI 및 머신러닝 분야의 사실상 표준 언어입니다. NestJS 또는 Java 개발자 채용 공고에서도 Python 사용 경험이나 학습 의지를 우대 조건으로 명시하는 경우가 많습니다.</li>
    </ul>
  </li>
  <li>AI/ML 프레임워크 및 도구:
    <ul>
      <li>TensorFlow, PyTorch, Scikit-learn 등 주요 머신러닝 라이브러리 및 프레임워크 사용 경험. (직접적인 언급 빈도는 낮으나, AI 프로젝트 경험을 우대하는 경우 관련 기술 포함 가능성 높음)</li>
      <li>Langchain, OpenAI API 등 LLM(거대 언어 모델) 관련 기술 활용 경험.</li>
    </ul>
  </li>
  <li>클라우드 플랫폼 경험:
    <ul>
      <li>AWS, GCP, Azure 등 주요 클라우드 서비스 사용 경험은 매우 빈번하게 요구됩니다. 특히 AI/ML 관련 서비스(e.g., AWS SageMaker, Google Vertex AI, Azure Machine Learning) 사용 경험은 큰 장점으로 작용합니다.</li>
    </ul>
  </li>
  <li>컨테이너화 및 오케스트레이션:
    <ul>
      <li>Docker, Kubernetes 사용 경험은 애플리케이션 배포 및 확장성 확보에 중요하게 고려됩니다.</li>
    </ul>
  </li>
  <li>메시지 큐 시스템:
    <ul>
      <li>Kafka, RabbitMQ 등 메시지 큐 시스템 사용 경험. 이는 대용량 데이터 처리 및 비동기 통신 아키텍처 구현에 중요합니다.</li>
    </ul>
  </li>
  <li>CI/CD 경험:
    <ul>
      <li>Jenkins, GitLab CI, GitHub Actions 등 CI/CD 파이프라인 구축 및 운영 경험은 개발 생산성 및 안정성 향상에 기여합니다.</li>
    </ul>
  </li>
  <li>대용량 트래픽/데이터 처리 경험:
    <ul>
      <li>대규모 사용자 요청을 효율적으로 처리하거나, 대용량 데이터를 분석하고 처리하는 시스템 개발 경험을 우대합니다.</li>
    </ul>
  </li>
  <li>AI 관련 프로젝트 수행 경험:
    <ul>
      <li>실제 AI 모델을 활용한 서비스 개발 프로젝트 또는 AI 관련 기능을 구현한 프로젝트 참여 경험은 직접적인 역량 증명으로 이어집니다.</li>
      <li>MLOps(Machine Learning Operations) 관련 경험 또는 이에 대한 높은 관심도 긍정적으로 평가될 수 있습니다. (단, 해당 공고는 4년 이상 경력 대상)</li>
    </ul>
  </li>
  <li>기타:
    <ul>
      <li>MSA (Microservices Architecture) 설계 및 개발 경험.</li>
      <li>테스트 코드 작성 능력 및 TDD(Test-Driven Development) 경험.</li>
    </ul>
  </li>
</ul>

<p>내용을 종합해보자면 여전히 백엔드라는 기둥에 AI 라는 장식이라는 구성에 가깝다. 내용적으로는 마치 DevOps 적 특성이 강하게 묻어나오는데, 이러한 특성은 내용을 생각해보면 짐작해볼 수 있을 것이다.</p>

<p>AI 서비스는 강력한 컴퓨팅 성능이 필요하다. 여전히 그 능력은 고성능 모델에 촛점이 맞춰져 있고, 최적화나, 가격 경쟁을 하기엔 여전히 실험적인 영역이 있다는 점은 부정할 수 없다. 그리고 이러한 점에서 서버에서 처리해 내는 것들은 당연히 필요하고, 온디바이스 컴퓨팅, 엣지 컴퓨팅은 아직은 갈길이 멀다. 이러한 점에서 클라우드 플랫폼 위에서 제공되는 다양한 기술을 서빙할 수 있어야하고, 그걸 위해서 알아야하는 백엔드 기술들은 자연스럽게 키워드에 녹아들어 있다.</p>

<p>비동기 IO 처리, 메시지 큐, 데이터베이스, 컨테이너, MSA 등 많은 요소들이 결국 클라우드 상에서 개발과 운영의 통합, 서비스의 전체적인 라이프사이클의 통합 및 체계화를 말하게 된다. 즉, DevOps 역량이 매우매우 중요하다는 것이다.</p>

<h2 id="데이터를-기반으로-정리해보면">데이터를 기반으로 정리해보면</h2>

<p>AI 의 대두는 기존에 웹 프로바이저닝을 해주던 업체, 플랫폼들의 방향에 나름의 파문을 일으켰다. 기존에 클라우드 플랫폼들은 서버리스, RDB서비스 등을 통해 백엔드라는 절차를 신경쓰지 않아도 되게 만든다던가, 다양한 서비스를 제공하여 결론적으로 백엔드 개발의 범위를 좁히고, 더 줄이는 역할을 하려는 서비스들 쪽으로 귀결되고 있었다.</p>

<p>하지만 AI는 발전되는 과정에서 하드웨어에 대한 성능 요구값을 매우 크게 끌어올렸고, 특히나 GPU 리소스의 필요를 끌어올리는 등을 포함하여 기존 클라우드 플랫폼의 노선에 부담을 주었다는 생각이 든다. 즉, 자원이 다시 한정적이게 만들었고, 그 만큼 백엔드 개발이나, 성능의 분배, 대용량 처리라는 전통적인 영역에 대한 더 큰 수요를 불러낸것 같다는 것이다.</p>

<p>그 결과 DevOps 의 중요성은 더욱 키워가는 게 아닌가 싶고, 그 과정에서 개발이 필요한 업체들은 자연스럽게 DevOps 기능을 포함한 클라우드 플랫폼 역량, 그리고 거기에 AI를 얹은 역량치를 요구하게 자연스럽게 흘러가고 있는게 보인다.</p>

<p>넓게 보면 오히려 AI가 백엔드의 가치나, 기회를 늘린 것이기도 하다는 생각도 ? 할 수 있는게 아닐까.</p>

<h3 id="nestjs-백엔드-개발자에-대한-ai-역량-심층-분석">NestJs 백엔드 개발자에 대한 AI 역량 심층 분석</h3>

<p>이 부분은 제미나이의 분석 과정에서 나온 내용인데, 학습의 키워드가 될 수 있으리라 생각되어 간단히 정리해보면 다음과 같다.</p>

<ul>
  <li>A. NestJS 백엔드 개발자의 기본 역량
    <ul>
      <li>TypeScript 및 Node.js 생태계에 대한 깊은 이해: NestJS는 TypeScript를 기반으로 하며 Node.js 런타임 환경에서 동작함. 따라서 TypeScript의 타입 시스템, 비동기 처리 방식, Node.js의 이벤트 루프, 모듈 시스템 등에 대한 충분한 이해가 필요.</li>
      <li>NestJS 프레임워크의 핵심 개념 숙달: 모듈(Modules), 컨트롤러(Controllers), 서비스(Services), 프로바이더(Providers), 의존성 주입(Dependency Injection), 미들웨어(Middleware), 파이프(Pipes), 가드(Guards), 인터셉터(Interceptors) 등 NestJS의 핵심 아키텍처 구성 요소에 대한 명확한 이해와 활용 능력이 요구.</li>
      <li>비동기 프로그래밍 및 이벤트 기반 아키텍처 이해: Node.js의 특성상 비동기 프로그래밍(Promise, async/await)에 능숙해야 하며, 이벤트 기반 아키텍처에 대한 이해는 실시간 서비스나 복잡한 데이터 흐름을 다룰 때 중요.</li>
      <li>Express.js 또는 Fastify 경험: NestJS는 내부적으로 Express.js (기본값) 또는 Fastify를 HTTP 서버 프레임워크로 사용함. 이들 프레임워크에 대한 기본적인 이해나 사용 경험은 NestJS를 더 깊이 있게 활용하는 데 도움이 된다.</li>
    </ul>
  </li>
  <li>B. NestJS 와 AI의 접점. 어떤 업무를 연관지어 해봐야 할까?
    <ul>
      <li>AI 모델 서빙 API 개발: Python 등 다른 언어로 개발된 AI 모델의 예측 기능을 외부 또는 내부 시스템에서 사용할 수 있도록 RESTful API 또는 GraphQL API 형태로 노출하는 역할을 담당.   </li>
      <li>외부 AI 서비스 연동: OpenAI API(ChatGPT, DALL-E 등), Google AI Platform API, AWS AI 서비스 API 등 이미 상용화된 외부 AI 서비스를 호출하고, 그 응답을 가공하여 애플리케이션의 특정 기능에 통합하는 작업을 해봐야 한다.</li>
      <li>데이터 전처리/후처리 API 개발: AI 모델에 입력될 데이터를 정제하거나 특정 형식으로 변환하는 전처리 과정, 또는 AI 모델로부터 나온 결과값을 사용자에게 보여주기 적합한 형태로 가공하는 후처리 과정을 담당하는 API를 개발해본다.</li>
      <li>실시간 AI 서비스 백엔드 개발: WebSocket 등을 활용하여 실시간으로 사용자 입력에 따라 AI 모델과 상호작용하는 서비스(예: AI 챗봇, 실시간 개인화 추천)의 백엔드 로직을 NestJS로 구현해본다.   </li>
      <li>AI 애플리케이션을 위한 인프라 지원: AI 모델의 학습 데이터 수집, 학습된 모델 관리, 모델 버전 관리, 배포 파이프라인과의 연동 등을 지원하는 백엔드 시스템 및 API를 구축하는 역할도 포함될 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="기술-면접-준비-방향">기술 면접 준비 방향</h3>

<ul>
  <li>A. 분석된 자격 요건 기반의 핵심 기술면접 주제 리스팅
    <ul>
      <li>NestJS/NodeJS 또는 Java/Spring 핵심 개념
        <ul>
          <li>NestJS: 모듈(Module), 컨트롤러(Controller), 서비스(Service), 프로바이더(Provider), 의존성 주입(DI), 데코레이터(Decorator), 파이프(Pipe), 가드(Guard), 인터셉터(Interceptor), 미들웨어(Middleware) 등 프레임워크의 핵심 구성 요소와 작동 원리에 대한 질문, TypeScript 및 Node.js 비동기 처리 방식에 대한 이해도</li>
          <li>Java/Spring: JVM(메모리 구조, GC), OOP(SOLID 원칙), 컬렉션 프레임워크, 동시성(멀티스레딩, Thread-safe), Spring Core(IoC 컨테이너, DI, Bean의 생명주기 및 스코프), Spring MVC(DispatcherServlet 동작 방식, 요청 처리 과정), Spring Boot(자동 설정, Actuator), JPA(영속성 컨텍스트, N+1 문제), Spring Data, AOP, Spring Security 기본 원리 등에 대한 질문</li>
        </ul>
      </li>
      <li>데이터베이스:
        <ul>
          <li>SQL 작성 능력(JOIN, 서브쿼리, 집계함수 등) 및 최적화.</li>
          <li>데이터베이스 Index의 원리와 효과적인 사용법.</li>
          <li>Transaction의 개념과 ACID 원칙, 격리 수준(Isolation Level).</li>
          <li>정규화(Normalization)의 개념과 장단점.</li>
          <li>Sharding과 Replication의 차이점 및 사용 사례.RDBMS와 NoSQL 데이터베이스의 차이점 및 각각의 적합한 사용 사례.</li>
        </ul>
      </li>
      <li>API 설계:
        <ul>
          <li>RESTful API 설계 원칙 (자원 표현, HTTP Method 활용, 상태 코드의 적절한 사용).</li>
          <li>API 보안 (인증/인가 방식: JWT, OAuth2 등).</li>
          <li>API 버전 관리 전략.</li>
        </ul>
      </li>
      <li>네트워크 기초:
        <ul>
          <li>TCP/IP 프로토콜 스택 및 계층별 역할.</li>
          <li>HTTP/HTTPS 프로토콜의 특징 및 차이점 (SSL/TLS 핸드셰이크 과정 포함).</li>
          <li>CORS(Cross-Origin Resource Sharing)의 개념과 해결 방법.</li>
        </ul>
      </li>
      <li>운영체제 기초:
        <ul>
          <li>프로세스(Process)와 스레드(Thread)의 차이점 및 컨텍스트 스위칭.</li>
          <li>동기(Synchronous)와 비동기(Asynchronous) 처리 방식의 차이.</li>
          <li>데드락(Deadlock) 발생 조건 및 해결 방법.</li>
        </ul>
      </li>
      <li>자료구조 및 알고리즘:
        <ul>
          <li>주요 코딩 테스트 플랫폼(프로그래머스, 백준 등)의 Level 2~3 수준 문제 해결 능력.</li>
          <li>자주 출제되는 유형: 배열, 문자열 처리, 정렬, 탐색(이진 탐색, DFS, BFS), 그래프 이론 기초, 동적</li>
          <li>프로그래밍(DP), 구현 중심 문제.</li>
        </ul>
      </li>
      <li>클라우드 및 컨테이너:
        <ul>
          <li>AWS, GCP, Azure 등 주요 클라우드 플랫폼의 핵심 서비스(컴퓨팅, 스토리지, 데이터베이스, 네트워킹)에 대한 이해 및 사용 경험.</li>
          <li>Docker 컨테이너의 기본 개념, 이미지 생성 및 관리, 컨테이너 실행 경험.</li>
          <li>Kubernetes의 기본 개념 및 필요성에 대한 이해 (1~3년차에게는 심층적인 운영 경험보다는 개념 이해 수준을 묻는 경우가 많음).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>B. AI 통합 역량에 관련된 예상 면접 질문 리스트
    <ul>
      <li>“AI/ML 관련 프로젝트 경험이 있다면 자세히 설명해주세요. 어떤 역할을 하셨고, 어떤 기술을 사용했으며, 결과는 어떠했나요?”</li>
      <li>“AI 모델을 서빙하기 위한 API를 설계한다면 어떤 점들을 고려해야 할까요?”</li>
      <li>“대용량 데이터를 AI 모델 학습에 사용하기 위해 백엔드에서 어떤 처리를 할 수 있을까요? 혹은 어떤 지원을 할 수 있을까요?”</li>
      <li>“AI 모델을 실제 서비스에 배포하고 운영할 때 백엔드 개발자로서 겪을 수 있는 어려움은 무엇이라고 생각하며, 이를 어떻게 해결하거나 기여할 수 있을까요?”</li>
      <li>“최근 관심 있게 보고 있는 AI 기술이나 트렌드가 있나요? 이를 현재 담당하고 있거나 앞으로 개발하고 싶은 백엔드 시스템에 어떻게 적용해볼 수 있을지 아이디어를 제시해주세요.”</li>
      <li>“AI 개발 도구(예: ChatGPT, GitHub Copilot)를 실제 개발 업무에 활용해본 경험이 있다면, 어떤 방식으로 효과적으로 사용했고, 사용하면서 느낀 한계점은 무엇이었는지 설명해주세요.”</li>
      <li>“머신러닝의 기본적인 개념(예: 지도학습과 비지도학습의 차이, 회귀와 분류 문제의 정의, 주요 알고리즘 한두 가지 예시)에 대해 간략히 설명해주실 수 있나요?”</li>
    </ul>
  </li>
  <li>C. 포트폴리오 프로젝트의 중여성 및 AI 역량 어필 전략
    <ul>
      <li>AI 관련 역량을 효과적으로 어필하기 위해서는 실제 프로젝트 경험을 포트폴리오에 잘 담아내는 것이 매우 중요할 것이다. 단순히 “AI 모델을 사용해봤다”는 수준을 넘어, <strong>어떤 구체적인 문제를 해결하기 위해 AI 기술을 도입했고, 그 과정에서 백엔드 개발자로서 어떤 기술적 고민을 하고 어떤 노력을 통해 문제를 해결했는지를 명확하고 설득력 있게 전달해야 한다는 점은 면접의 기본 중의 기본이리라.</strong></li>
      <li>GitHub 등을 통해 프로젝트 코드와 함께 README 파일을 체계적으로 관리하는 것이 좋다. README에는 프로젝트의 목표, 사용된 AI 기술 및 백엔드 기술 스택, 본인이 담당한 역할과 기여도, 그리고 프로젝트를 통해 얻은 정량적/정성적 성과를 명확히 명시해야 한다. 예를 들어, “AI 챗봇 응답 속도 개선을 위해 Redis 캐싱 전략을 도입하여 평균 응답 시간을 X% 단축” 또는 “사용자 이탈 방지를 위해 AI 기반 개인화 추천 API를 개발하고, A/B 테스트 결과 클릭률 Y% 증가”와 같이 구체적인 수치를 제시하면 더욱 효과적이다.</li>
      <li>AI 관련 기술 면접에서는 “왜 이 AI 기술을 선택했는가?” 그리고 “그 기술 도입을 통해 어떤 실질적인 가치를 창출했는가?” 에 대한 질문이 핵심적으로 나올 수 있다. 기업은 단순히 새로운 기술을 사용해 본 경험이 있는 개발자보다는, 기술을 통해 실제 문제를 해결하고 비즈니스 가치를 만들어낼 수 있는 인재를 선호하기 때문이다. 따라서 AI 기술 선택의 배경과 타당성, 그리고 그로 인해 얻어진 구체적인 효과를 명확하게 설명하는 것이 중요다.</li>
      <li>또한, 코딩 테스트 외에 CS(Computer Science) 기본 지식에 대한 테스트가 포함될 수 있으며 , 1~3년차 개발자에게 AI 관련 질문은 주로 프로젝트 경험이나 기본 개념 이해 수준에서 출제될 가능성이 높다. AI 모델의 복잡한 수학적 원리나 알고리즘을 직접 구현하는 것을 요구하기보다는, AI 시스템을 구성하는 백엔드 요소(데이터 처리, API 설계, 인프라 구축)에 대한 이해도와 실제 적용 경험을 더 중요하게 평가할 것이다. 물론, CS 기본기는 모든 개발 분야의 바탕이 되므로 꾸준한 학습과 준비가 필요하다.</li>
      <li>결론적으로, 기술 면접을 준비할 때는 자신이 참여했던 AI 관련 프로젝트의 전체 아키텍처, 데이터 흐름, 사용한 AI 기술의 구체적인 역할, 그리고 프로젝트 진행 과정에서 겪었던 트러블슈팅 경험과 해결 과정을 명확하게 설명할 수 있도록 철저히 준비해야 한다. 더불어 기본적인 머신러닝 용어와 개념, 그리고 자신이 주로 사용하는 백엔드 기술과의 연관성을 깊이 있게 숙지하는 것이 성공적인 면접의 핵심이 될 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="결론">결론</h2>
<p>어우 할 것도 많다. 사실 이걸 다 완벽하게 채울 수 있을까? 그럴리가. 시간도 돈도, 능력도 부족한게 사람인데 말이다… 😂 아픈 몸, 해야할 일 들 사이에서 얼마나 죽지 않고 버틸 수 있냐, 그렇게 해서 내 위치를 잡아내냐… 거의 인생 줄타기라는 생각이 새삼 든다.</p>

<p>그럼에도 Docker로 컨테이너화 하여 모듈화 시켜서 완벽하게 동작하는 서버를 볼 때 기분이 좋고, 이런 서비스를 만들어 보면 어떨까? 할 때 내 나름의 두근거림이 있다는 점에서, 역시나 백엔드가 맞았구나 라는 생각을 종종 해왔는데, 정리한 내용을 보면 더더욱 그렇게 느껴지는 것 같다.</p>

<p>Cursor, ContinueAI 를 시작으로 HuggingFace 를 써보고 Ollama를 써보고, 내가 원하는 AI 서비스를 만들어 보고자 노력하고, 그 과정에서 틈틈히 MSA 구축이나, Docker, Jenkins 를 통한 파이프라인 구축의 과정은 다행이도 1년이란 시간, 헛되지 않았음을 보여주는 귀한 경험들이었구나 하는 생각이다</p>

<p>오히려 사수가 없으니, 내마음대로 할 수 있었다고 해야 하려나? ㅋㅋㅋ….</p>

<p>앞으로 더 노력해야지. 이제 현 프로젝트의 대망의 꽃 CICD 구축을 필두로하여 신규 플젝 마무리까지 달려보자.</p>

<h2 id="참고자료">참고자료</h2>
<p>내가 본것 및 AI가 분석을 위해 자동으로 크롤링한 자료들이다</p>
<ol>
  <li><a href="https://blog.naver.com/jj601400/223108054162?viewType=pc">개발자 채용 공고 사이트 5선 모음 - 네이버 블로그</a></li>
  <li><a href="https://groupby.careers/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%B1%84%EC%9A%A9-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9%EC%82%AC%EC%9D%B4%ED%8A%B8-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%B6%94%EC%B2%9C/">스타트업채용 개발자 채용사이트 플랫폼 추천 - 그룹바이 블로그</a></li>
  <li><a href="https://www.jobkorea.co.kr/Search/?stext=NestJs">‘NestJs’ 관련 채용공고 - 총 70건의 검색결과 - 잡코리아</a></li>
  <li><a href="https://jumpit.saramin.co.kr/position/49520">AI연관 백엔드 개발자 (경력 3년이상) - 점핏</a></li>
  <li><a href="https://zighang.com/recruitment/31c6d1d0-758b-47a2-9184-42f788413d3a">로켓에이아이 채용 - Express &amp; ts-node 백엔드 개발자 - 직행</a></li>
  <li><a href="https://zighang.com/recruitment/68a9c26f-8954-4e17-8835-811ad7690dd2">외식인 채용 - Java(Spring) 백엔드 개발자 - 직행</a></li>
  <li><a href="https://www.jobkorea.co.kr/Recruit/GI_Read/46907671">(주)토리에듀핀 : Nest.Js/Next.Js /TypeScript 경력자 채용 - 잡코리아</a></li>
  <li><a href="https://www.wanted.co.kr/wd/218914">[빅웨이브로보틱스] 주니어 백엔드 개발자 (4년 이하) - 원티드</a></li>
  <li><a href="https://jumpit.saramin.co.kr/position/20607">백엔드 개발자 - NestJs (2년 이상) / 연봉 최소 5,000 - 점핏</a></li>
  <li><a href="https://www.wanted.co.kr/wd/227117">[살린] 백엔드 개발자 (Node.js, Nestjs) - 원티드</a></li>
  <li><a href="https://zighang.com/recruitment/72061315-8193-4bbf-9430-561d6b7b3f62">텐 채용 - MLOps 플랫폼 백엔드 개발자 (자바/4년 이상) - 직행</a></li>
  <li><a href="https://www.rallit.com/positions/89/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88-saas-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90">월간해킹 [정보보안 SaaS] 백엔드 개발자 - 랠릿</a></li>
  <li><a href="https://zighang.com/recruitment/fd435d07-ed0f-4cec-993c-ad2ad759881e">도슨티 채용 - AI engineer (prompt engineer) - 직행</a></li>
  <li><a href="https://www.wanted.co.kr/wd/273991">[에고이즘] 미뇽맨션 앱 개발자 (신입 3년 이하) - 원티드</a></li>
  <li><a href="https://www.jobkorea.co.kr/Search/?stext=nest%20JS">‘nest JS’ 관련 채용공고 - 총 66건 - 잡코리아</a></li>
  <li><a href="https://www.wanted.co.kr/wd/150445">[미리디] 백엔드 개발자 - 이미지 프로세싱 - 원티드</a></li>
  <li><a href="https://www.wanted.co.kr/wd/241717">[미리디] 백엔드 개발자 / 이미지 프로세싱 - 원티드</a></li>
  <li><a href="https://www.finalroundai.com/blog/backend-developer-interview-questions">The 25 Most Common Backend Developers Interview Questions - FinalRoundAI</a></li>
  <li><a href="https://roadmap.sh/questions/backend">50 Popular Backend Developer Interview Questions and Answers - roadmap.sh</a></li>
  <li><a href="https://www.reddit.com/r/dataengineering/comments/17ve0jc/what_are_the_fundamental_questions_in_a_data/?tl=ko">데이터 엔지니어링 면접 질문 모음 - Reddit</a></li>
  <li><a href="https://github.com/villainscode/tech-interview-for-junior">GitHub - tech-interview-for-junior - villainscode</a></li>
  <li><a href="https://www.interviewbit.com/system-design-interview-questions/">Top System Design Interview Questions (2025) - InterviewBit</a></li>
  <li><a href="https://igotanoffer.com/blogs/tech/system-design-interviews">System Design Interview Q&amp;A - IGotAnOffer</a></li>
  <li><a href="https://velog.io/@jx7789/%EC%8B%A0%EC%9E%85-AI%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A4%80%EB%B9%84%ED%95%98%EB%8A%94-30%EA%B0%80%EC%A7%80-ML%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5">신입 AI개발자 면접 기초 개념 30가지 - velog</a></li>
  <li><a href="https://github.com/boost-devs/ai-tech-interview">GitHub - ai-tech-interview - boost-devs</a></li>
  <li><a href="https://velog.io/@jx7789/%EC%8B%A0%EC%9E%85-AI%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A4%80%EB%B9%84%ED%95%98%EB%8A%94-30%EA%B0%80%EC%A7%80-Python-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5">신입 AI개발자 Python 면접 기초 개념 30가지 - velog</a></li>
  <li><a href="https://programmers.co.kr">프로그래머스 공식 홈페이지</a></li>
  <li><a href="https://m.blog.naver.com/codeitofficial/223431910683">신입 개발자 면접 단골 질문 가이드 - 네이버 블로그</a></li>
  <li><a href="https://bagyun.tistory.com/73">NodeJS/NestJS 신입 질문 모음 - 빠균’s 개발노트</a></li>
  <li><a href="https://velog.io/@jaegeunsong_1997/NestJS-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8">NestJS 면접 질문 정리 - velog</a></li>
  <li><a href="https://github.com/gasangw/NestJS-Interview-Questions-And-Answers">GitHub - NestJS Interview Questions - gasangw</a></li>
  <li><a href="https://dev-coco.tistory.com/153">신입 자바 기술면접 질문 정리 - 슬기로운 개발생활</a></li>
  <li><a href="https://study-easy-coding.tistory.com/145">주니어 JAVA 백엔드 면접 질문 - 개발 개맛집</a></li>
  <li><a href="https://devsurimlee.tistory.com/50">백엔드 면접 질문 리스트 - 개발새발 블로그</a></li>
  <li><a href="https://www.baeldung.com/spring-interview-questions">Top Spring Framework Interview Questions - Baeldung</a></li>
  <li><a href="https://www.geeksforgeeks.org/spring-interview-questions/">Spring Interview Q&amp;A - GeeksforGeeks</a></li>
  <li><a href="https://zero-base.co.kr/event/media_BE_school_qna">신입 백엔드 면접 질문 사례 - 제로베이스</a></li>
  <li><a href="https://ddooroong.tistory.com/entry/%EC%B7%A8%EC%A4%80-%EA%B8%B0%EB%A1%9D-%EC%8B%A0%EC%9E%85-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%ED%9B%84%EA%B8%B0-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%9D%B8%EC%84%B1%EB%A9%B4%EC%A0%91-%EC%B5%9C%EC%A2%85%EB%A9%B4%EC%A0%91">신입 백엔드 면접 후기 (기술/인성/최종) - ddooroong 블로그</a></li>
  <li><a href="https://m.blog.naver.com/jnh02215/223669963273">3년 차 백엔드 면접 후기 (2024) - 네이버 블로그</a></li>
  <li><a href="https://velog.io/@lifeisbeautiful/%EC%9E%90%EC%A3%BC-%EB%B4%90%EC%95%BC%ED%95%A0-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%EC%9C%A0%ED%98%95-%EB%B0%8F-%EC%A0%95%EB%A6%AC">코딩테스트 문제 유형 및 정리 - velog</a></li>
  <li><a href="https://katfun.tistory.com/226">프로그래머스 코딩테스트 전략 - katfun.tistory</a></li>
  <li><a href="https://www.wanted.co.kr/events/22_11_s01_b15">코딩테스트 가이드 (원티드)</a></li>
  <li><a href="https://hoons-dev.tistory.com/66">2023 카카오 코딩테스트 후기 - 1차</a></li>
  <li><a href="https://hoons-dev.tistory.com/71">2023 카카오 코딩테스트 후기 - 2차</a></li>
  <li><a href="https://kimtaesoo99.tistory.com/265">삼성 SW 역량테스트 B형 후기 - 김태수 블로그</a></li>
  <li><a href="https://algosketch.tistory.com/187">팀네이버 신입공채 후기 (2024) - 알고스케치</a></li>
  <li><a href="https://blog.naver.com/skbalm/221695335862?viewType=pc">백엔드 주니어 면접 후기 총정리 - 네이버 블로그</a></li>
  <li><a href="https://mand2.github.io/others/interviews/">면접 질문 정리 - 고라니의 개발일기</a></li>
  <li><a href="https://github.com/ksundong/backend-interview-question">GitHub - 백엔드 인터뷰 질문 모음 - ksundong</a></li>
  <li><a href="https://velog.io/@spamdong/%EB%A9%B4%EC%A0%91-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8">데이터 엔지니어 면접 질문 - velog</a></li>
  <li><a href="https://velog.io/@minsgy/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%ED%95%99%EC%8A%B5%EB%82%B4%EC%9A%A9">백엔드 면접 학습내용 정리 - velog</a></li>
  <li><a href="https://m.hanbit.co.kr/channel/view.html?cmscode=CMS9960904389">경력별 면접 준비 도서 추천 5권 - 한빛+</a></li>
  <li><a href="https://haesoo9410.tistory.com/351">코딩테스트 준비 - Harry’s diary</a></li>
  <li><a href="https://sophuu.tistory.com/89">코딩테스트 플랫폼 비교 - sophuu.tistory</a></li>
  <li><a href="https://nbcamp.spartacodingclub.kr/blog/2025-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%EB%AC%B8%EC%A0%9C%EC%9D%80%ED%96%89-%EB%A9%B4%EC%A0%91-%EA%BF%80%ED%8C%81%EA%B3%BC-%EC%98%88%EC%83%81-%EC%A7%88%EB%AC%B8-top-25-47008">백엔드 개발자 면접 문제은행 (2025) - Spartan</a></li>
  <li><a href="https://techdevguide.withgoogle.com/paths/interview/">Interview Prep - Google Tech Dev Guide</a></li>
  <li><a href="https://interviewkickstart.com/courses/back-end-engineering-interview-masterclass">Backend Developer Interview Course - InterviewKickstart</a></li>
  <li><a href="https://m.blog.naver.com/khaiblog/222520897031">면접에서 인재 찾기 힘들 때 - 네이버 블로그</a></li>
  <li><a href="https://www.codestates.com/blog/content/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EC%8B%A0%EC%9E%85-%EB%A9%B4%EC%A0%91-tip">IT 스타트업 신입 면접 준비 가이드 - 코드스테이츠</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><category term="이직" /><category term="Backend" /><summary type="html"><![CDATA[Introduce 백엔드 개발자로 생존한지 1년차… 이제는 AI가 등장하면서 개발자의 위치는 지속적인 블러핑의 대상(?) 이 되어버렸다.]]></summary></entry><entry><title type="html">백엔드 개발자, 2025년 트렌드 정리하기</title><link href="http://0.0.0.0:4000/backend/2025/05/25/00-backend-developper-issues.html" rel="alternate" type="text/html" title="백엔드 개발자, 2025년 트렌드 정리하기" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/05/25/00-backend-developper-issues</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/05/25/00-backend-developper-issues.html"><![CDATA[<h2 id="1-백엔드-왜-지금-이-변화를-주목하려고-하는가">1. 백엔드, 왜 지금 이 변화를 주목하려고 하는가?</h2>
<p>백엔드는 더 이상 단순히 데이터를 처리하고 저장하는 ‘뒷단’이 아니다. 서비스의 확장성, 안정성, 그리고 궁극적으로 사용자 경험의 질을 결정하는 핵심 두뇌이자 심장부이다. 기업들은 갈수록 더 빠르고, 더 유연하며, 더 비용 효율적인 시스템을 요구하고 있으며, 이러한 요구는 백엔드 아키텍처와 기술 스택의 끊임없는 진화를 촉진한다.</p>

<p>최신 트렌드를 이해하는 것은 단순히 유행을 쫓는 것이 아니라, 더 나은 아키텍처를 설계하고, 문제를 해결하며, 궁극적으로 더 가치 있는 서비스를 만들어내는 데 필수적이다. 더불어 점점 가속화되고 바이브 코딩이라는 말이 나올 정도로 개발의 사이클이 변화하고 있고, 이는 비즈니스적 문화와 가치 역시 바뀌고 있다는 것을 말하고 있으며, 이러한 상황은 인력시장의 개편 역시 당연한 말이지만 영향이 있다는 점을 새삼 느끼고 있다.</p>

<p>그렇기에 이러한 점들을 종합하여, AI의 성능, 능력을 봄과 함께 나의 백엔드 개발자로의 역량을 위하여 정리해본다.</p>

<h2 id="2-2025-백엔드-시장의-핵심-트랜드-5가지">2. 2025 백엔드 시장의 핵심 트랜드 5가지</h2>
<p>백엔드 시장의 변화를 주도하는 주요 기술 트렌드를 여러분의 시선으로 함께 살펴본다.</p>

<p><strong>2.1 클라우드 네이티브 &amp; 서버리스 아키텍처의 확산</strong>
서버리스 컴퓨팅은 인프라 비용 절감과 확장성 향상을 위해 기업들이 점차 더 많이 채택하고 있으며, AWS Lambda, Google Cloud Functions, Azure Functions와 같은 플랫폼이 이러한 추세를 주도한다. 서버리스 컴퓨팅 시장은 2024년부터 2029년까지 연평균 15.3% 성장하여 447억 달러에 이를 것으로 예상된다. 이러한 아키텍처의 핵심 이점은 서버 관리가 필요 없고, 수요에 따라 자동으로 확장되며, 사용량 기반 과금으로 비용 효율적이라는 점이다. 이러한 변화는 광범위한 디지털 전환 노력과 하이브리드 작업 환경의 증가에 의해 더욱 가속화된다.  </p>

<p>클라우드 네이티브 기술의 채택은 컨테이너화의 발전을 이끌고 있으며, 조직들은 마이크로서비스와 클라우드의 확장성 및 민첩성을 적극적으로 활용한다. Kubernetes는 컨테이너화된 애플리케이션의 배포, 관리, 확장을 자동화하여 클라우드 전환을 가속화하는 데 핵심적인 역할을 한다. 서버리스 및 클라우드 네이티브 아키텍처의 광범위한 도입은 백엔드 개발의 근본적인 변화를 의미하며, 인프라 관리에서 코드 및 서비스 관리로 초점이 이동한다. 서버리스 컴퓨팅의 주요 이점은 서버를 관리할 필요가 없다는 점이며 , Docker와 Kubernetes를 통한 컨테이너화 및 오케스트레이션은 배포, 관리, 확장을 자동화하고 , 인프라 계층을 추상화한다. 이러한 점진적인 추상화는 개발자들이 기저 하드웨어에 대한 걱정을 덜고 애플리케이션 로직, 서비스 계약, 분산 환경 내 서비스 상호작용에 더 집중하게 만든다. 이는 백엔드 개발에서 더 높은 수준의 관심사로의 전환을 의미하며, 운영 부담을 덜어줌으로써 개발자 생산성을 향상시킨다.  </p>

<p>그러나 이러한 광범위한 도입에도 불구하고, Kubernetes 구성의 내재된 복잡성은 여전히 중요한 과제로 남아있으며, 특히 보안 및 비용 최적화 측면에서 두드러진다. 57%의 조직이 컨테이너 권한 조정(rightsizing)을 효과적으로 관리하지만, 43%는 여전히 개선이 필요하며 이는 클라우드 비용에 직접적인 영향을 미친다. 또한, 이미지 취약점과 오래된 컨테이너 이미지는 증가하는 우려 사항이다. 이는 Kubernetes가 강력한 기능을 제공함에도 불구하고, 기본 보안 설정이 견고하지 않고 사용자 정의 가능성이 오작동으로 이어질 수 있음을 시사한다. 따라서 조직은 지속적인 모니터링, 권한 조정, 취약점 스캔을 위한 전문 기술과 자동화된 도구에 투자하여 컨테이너화의 이점을 완전히 실현하면서도 위험을 완화해야 한다.  </p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0002.png" alt="" /></p>

<blockquote>
  <p>클라우드 환경에서 서버리스 함수, 컨테이너, 그리고 Kubernetes 클러스터가 상호작용하는 모습을 보여주는 아키텍처 다이어그램.(출처 - <a href="https://www.researchgate.net/figure/In-the-test-platform-serverless-functions-are-deployed-in-a-Kubernetes-cluster-using-the_fig1_348914380">ResearchGate</a>)</p>
</blockquote>

<p><strong>2.2 AI 기반 개발의 가속화</strong>
인공지능(AI)은 백엔드 개발 효율성을 높이는 데 통합되고 있으며, GitHub Copilot, Cursor, ChaGPT Codex, Claude Code 와 같은 AI 코드 어시스턴트, OtterTune과 같은 AI 기반 데이터베이스 쿼리 최적화 도구, Postman AI와 같은 자동화된 API 문서화 도구가 활용된다. AI는 개발자를 대체하기보다는 반복적인 작업을 자동화하여 개발자의 업무를 용이하게 하는 데 기여한다. AI 알고리즘은 마이크로서비스의 확장성과 성능을 최적화하여 추가 하드웨어 및 인프라 비용을 절감할 수 있다. AI는 예측 분석 및 실시간 의사결정을 통해 애플리케이션 성능을 향상시키며, 서버리스 환경에서도 자동화와 결합되어 효율성을 증대시킨다. 2024년에는 콘텐츠 생성 및 통찰력 제공을 넘어 실제 행동을 수행할 수 있는 ‘Agentic AI’의 등장은 매우 핫하였고 2025년은 그러한 관심과 노력의 결실들이 대거 쏟아지고 있다.  </p>

<p>AI의 역할은 백엔드 개발에서 단순한 지원을 넘어 소프트웨어 전달 수명 주기 전반에 걸쳐 자동화 및 자율적 의사결정에 적극적으로 참여하는 방향으로 진화하고 있다. 초기에는 AI가 코드 지원 및 API 문서화와 같은 도구로 인식되었지만 , 이제는 마이크로서비스를 최적화하고 , 예측 알고리즘을 통해 애플리케이션 성능을 향상시키며 , 심지어 ‘Agentic AI’로서 행동을 수행하는 단계에 이르렀다. 이러한 발전은 AI가 백엔드 시스템 내에서 자율 최적화 및 운영이 가능한 내장된 능동적 구성 요소가 되고 있음을 시사한다. 따라서 <strong>백엔드 개발자들은 AI 에이전트와 통합되거나 잠재적으로 AI 에이전트에 의해 관리되는 시스템을 설계하는 방법을 이해해야 하며, 이는 AI 모델 통합 및 윤리적 AI 고려 사항에 대한 새로운 기술을 요구한다.</strong></p>

<p>AI가 백엔드 시스템 전반에 걸쳐 통합이 증가함에 따라, 효과적인 AI 활용을 위한 기본 요구 사항으로서 데이터 품질 및 통합 데이터 제어에 대한 더 큰 초점이 필요하다. AI는 “올바른 데이터가 없으면 지능형 애플리케이션으로서의 가치를 얻을 수 없다”고 명시하며 , 데이터에 대한 “통합 제어”의 필요성을 강조한다. 이는 백엔드 시스템에서 AI로부터 얻는 가치(예: 최적화, 지능형 애플리케이션)가 AI 모델에 공급되는 데이터의 품질, 접근성 및 거버넌스에 직접적으로 비례한다는 점을 강조한다. 따라서 백엔드 개발자와 데이터 아키텍트들은 강력한 데이터 파이프라인, 실시간 데이터 처리 능력 , 그리고 강력한 데이터 거버넌스를 우선시하여 AI 모델이 신뢰할 수 있고 잘 관리된 데이터로 작동하도록 해야 한다.  </p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0003.png" alt="" /></p>
<blockquote>
  <p>The AI Code Editor 를 표방하는 <strong>Cursor</strong>(출처 - <a href="https://www.cursor.com/">커서 공식 사이트</a>)</p>
</blockquote>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0004.png" alt="" /></p>
<blockquote>
  <p>백엔드 기술에 특화를 표방한 VSC 확장 프로그램 <strong>Workik</strong>(출처 - <a href="https://workik.com/">Workik. 공식 사이트</a>)</p>
</blockquote>

<p><strong>2.3 마이크로서비스 및 컨테이너화의 진화</strong>
마이크로서비스 아키텍처는 <code class="language-plaintext highlighter-rouge">DevOps</code> 엔지니어에게 복잡한 분산 시스템 관리를 용이하게 하여 확장 가능하고 효율적인 애플리케이션 구축에 집중할 수 있도록 돕는다. 이는 애자일 방법론과 결합하여 협업, 유연성, 배포 속도를 향상시키며, 각 팀이 독립적으로 작업할 수 있게 한다. 마이크로서비스가 증가함에 따라 서비스 메시는 서비스 간 통신, 관찰성, 보안, 트래픽 관리 등을 위한 전용 인프라 계층을 제공하여 복잡성을 완화한다. <code class="language-plaintext highlighter-rouge">GitOps</code>는 Git을 단일 진실 공급원(SSOT)으로 사용하여 인프라 및 애플리케이션을 선언적으로 관리함으로써 DevOps 관행을 혁신하고, 배포 프로세스를 투명하고 자동화하며 협업적으로 만든다.  </p>

<p>서비스 메시와 GitOps에 의해 지원되는 마이크로서비스의 진화는 분산 시스템 관리에서 추상화 및 자동화의 증가로 이어지고 있으며, 개발자의 초점을 저수준 오케스트레이션에서 비즈니스 로직 및 애플리케이션 설계와 같은 고수준 관심사로 이동시킨다. 서비스 메시는 “서비스 간 통신을 촉진하는 전용 인프라 계층을 제공하여 이러한 과제를 완화”하고 “서비스 검색, 장애 복구, 로드 밸런싱, 메트릭”을 처리하여  개발자들이 “핵심 비즈니스 생산성 향상에 집중”할 수 있도록 한다. GitOps는 “모든 배포를 자동화하고 기존 인프라를 효율적으로 관리”한다. 이는 마이크로서비스에 내재된 운영 복잡성이 전용 도구와 방법론에 의해 점차 관리되고 있음을 나타내며, 개발자들을 수동 구성 및 문제 해결에서 해방시킨다. 이는 “플랫폼 엔지니어링” 으로의 강력한 추진을 의미하며, 내부 플랫폼이 “황금 경로(golden paths)”와 개발자 친화적인 인터페이스를 제공하여 개발자 생산성을 더욱 향상시키고 시장 출시 시간을 단축한다. 결국 결론은 자동화와 단일화되고 보다 섬세하게 가속화된 것들이 개발의 속도를 더욱 가속화시킨다고 볼 수 있다. </p>

<p>그러나 모듈성과 확장성의 이점에도 불구하고, 분산 시스템의 내재된 복잡성, 특히 데이터 일관성 및 연쇄적 장애와 관련하여 여전히 중요한 아키텍처적 과제로 남아있으며, 개발자들이 적극적으로 해결해야 한다. 마이크로서비스 아키텍처에서 “복잡성은 개별 기능의 상호 연결로 이동”하며, “아키텍처적 과제에는 비동기 통신, 연쇄적 장애, 데이터 일관성 문제, 서비스 검색 및 인증 처리가 포함된다”고 명시되어 있다. <strong>서비스 메시가 통신 및 검색에 도움이 되지만, 독립적인 서비스 간 데이터 일관성을 보장하고 장애의 파급 효과(연쇄적 장애)를 관리하는 문제는 완전히 추상화되지 않는다.</strong> 이는 고급 도구가 있더라도 백엔드 개발자들은 특히 중요한 데이터를 다룰 때 탄력적이고 일관성 있으며 내결함성 있는 마이크로서비스를 설계하기 위해 분산 시스템 원리에 대한 깊은 이론적 이해가 필요하다는 것을 의미한다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0005.png" alt="" /></p>
<blockquote>
  <p>GitOps 프로세스 도식(출처 - <a href="https://saramin.github.io/2020-05-01-k8s-cicd/">사람인 기술 블로그</a>)</p>
</blockquote>

<p><strong>2.4 API 경제의 확장과 보안강화</strong>
API는 거의 모든 소프트웨어 개발의 핵심이며, 사용자 경험, 파트너 생태계, 내부 아키텍처를 지원한다. <code class="language-plaintext highlighter-rouge">RESTful API</code>가 여전히 지배적이지만, <code class="language-plaintext highlighter-rouge">GraphQL</code>은 유연한 데이터 페칭과 단일 요청으로 여러 API 호출을 줄이는 이점 때문에 복잡한 애플리케이션에서 대안으로 성장하고 있다. GraphQL은 필요한 데이터만 가져오고 여러 API 호출을 단일 요청으로 줄여 모바일 및 마이크로서비스에 적합하다. <code class="language-plaintext highlighter-rouge">gRPC</code>는 마이크로서비스 환경에서 고속 통신을 지원한다.  </p>

<p>사이버 위협이 정교해짐에 따라 <strong><a href="https://cloud.google.com/learn/what-is-zero-trust?hl=ko">Zero Trust 보안 모델</a></strong>이 백엔드 인증 및 API 보안에 필수적이다. 2024년에는 API에 대한 공격이 49% 급증했으며, 비효율적인 인증/인가가 주요 원인이다. API의 보편성과 증가하는 공격 표면은 반응적 보안 조치에서 개발 수명 주기 전반에 걸쳐 통합된 사전 예방적 “보안 설계” 원칙으로의 근본적인 전환을 요구한다. API는 “대부분의 소프트웨어 개발의 핵심”이며 , 2023년 1분기부터 2024년 1분기 사이에 애플리케이션 및 API에 대한 웹 공격이 49% 급증했으며, “비효율적인 API 인증 및 권한 부여”가 주요 원인이다. 이러한 직접적인 상관관계는 API가 더 이상 단순한 통합 지점이 아니라 중요한 보안 경계임을 의미한다. 따라서 “백엔드 개발에서 보안은 더 이상 부차적인 고려 사항이 아니라 핵심 요구 사항”이다. 개발자들은 Zero Trust 보안 모델 을 채택하고, CI/CD 파이프라인에 “자동화된 보안 테스트” 를 통합하며, 초기 설계 단계부터 강력한 인증/권한 부여 메커니즘 을 우선시해야 한다.  </p>

<p>이러한 흐름에서 API 프로토콜(REST, GraphQL, gRPC)의 다양화는 특정 사용 사례에 대한 최적화된 데이터 가져오기 및 고성능 통신 요구에 의해 주도되는 아키텍처 성숙도의 증가를 반영하지만, 각 설명이 이렇게 길어지는 만큼 당연히 실제 API 관리의 복잡성도 가중시킨다. 따라서 GraphQL은 “정확히 필요한 데이터”를 가져오고 “여러 API 호출을 줄여”  “마이크로서비스 및 모바일 애플리케이션에 더 적합”하다. gRPC는 “마이크로서비스 환경에서 고속 통신”을 지원한다. 이는 API 프로토콜 선택이 단순한 선호를 넘어 성능 및 데이터 유연성 요구 사항에 의해 주도되는 미묘한 결정이 되고 있음을 나타낸다. <strong>백엔드 개발자들은 여러 API 패러다임에 능숙하고 각 패러다임의 장단점을 이해하며, 멀티 클라우드 환경에서 다양한 프로토콜을 처리할 수 있는 “클라우드 중립적”이고 “범용 API 관리 솔루션” 을 설계할 수 있어야 한다.</strong></p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0006.png" alt="" /></p>
<blockquote>
  <p>각 통신 방식에 대한 요약 이미지(출처 - <a href="https://blog.stackademic.com/choosing-between-grpc-rest-and-graphql-for-designing-and-implementing-apis-25df124848dc/">Ian Kiprono</a>)</p>
</blockquote>

<p><strong>2.5 데이터 아키텍처의 현대화</strong>
2024년 데이터 아키텍처는 실시간 데이터 처리를 위한 인프라 현대화와 AI/ML 기능 활성화에 중점을 둔다. IoT 장치 및 소셜 미디어 피드와 같은 스트리밍 데이터 소스의 증가는 실시간 분석을 통한 효율적인 통찰력 확보를 요구한다. 분산 데이터 아키텍처는 실시간 데이터 처리, 데이터 접근 시간 단축, 중복성 제공, 유연성 증대 등의 이점을 제공한다. Oracle, SQL Server, IBM Db2와 같은 데이터베이스는 AI 기반 자동 인덱싱 및 지능형 워크로드 관리 기능을 포함하고 있다. AI는 데이터베이스 관리의 일상적인 작업을 자동화하고 데이터 분석 기능을 향상시킨다. 데이터 품질 문제가 기술 예산의 상당 부분을 차지하므로, 분산 아키텍처 구현 시 데이터 거버넌스에 신중한 접근이 필요하다.  </p>

<p>실시간 데이터 요구 사항과 AI 통합의 융합은 현대 데이터 아키텍처의 성공적인 구현과 실행 가능한 통찰력을 위해 강력한 데이터 품질과 책임 있는 데이터 거버넌스를 중요하게 만든다. 보고서들은 “운영 실시간 분석을 늘리고 AI 및 ML 기능을 활성화하기 위해 데이터 아키텍처를 현대화”할 필요성을 강조한다. AI는 “자율 데이터베이스 운영” 및 “향상된 데이터 분석”을 통해 데이터베이스 관리를 혁신하고 있다. 그러나 “데이터에 대한 신뢰가 없으면 어떤 분산 아키텍처도 ‘감탄하고 분석할 수는 있지만 실행할 수 없는’ 귀중한 보석에 불과할 것”이라는 경고가 반복된다. 이는 고급 분석 및 AI 기능이 낮은 데이터 품질에 의해 병목 현상을 겪는다는 중요한 의존성을 강조한다. 따라서 백엔드 개발자와 데이터 아키텍트들은 “책임 있는 데이터 거버넌스” 와 강력한 데이터 파이프라인을 우선시하여 이러한 고급 시스템에 공급되는 데이터가 신뢰할 수 있고 잘 관리되도록 해야 한다</p>

<p><strong>2.6 엣지 컴퓨팅 및 분산 시스템의 중요성 증대</strong>
5G 및 IoT의 부상으로 인해 엣지 컴퓨팅은 백엔드 서비스를 사용자에게 더 가깝게 실행하여 속도와 효율성을 향상시키는 데 필수적이다. Cloudflare, Akamai와 같은 CDN 제공업체는 엣지 컴퓨팅 기능을 확장하고 있으며, FaunaDB, Cloudflare D1과 같은 데이터베이스는 전역 분산 스토리지를 제공한다. 실시간 애플리케이션(게임, AR/VR, IoT)이 엣지 컴퓨팅의 가장 큰 이점을 얻는다. 분산 시스템 아키텍처 중 셀 기반 아키텍처는 복원력을 강조하고 “블래스트 반경”을 최소화하여 시스템의 한 부분이 실패하더라도 다른 부분에 미치는 영향을 제한한다.  </p>

<p>5G 및 IoT에 의해 촉진되는 초저지연 및 향상된 복원력에 대한 요구는 백엔드 서비스가 설계되고 배포되는 방식을 근본적으로 변화시키며, 컴퓨팅과 데이터를 사용자에게 더 가까운 엣지로 이동시킨다. 엣지 컴퓨팅은 백엔드 서비스를 “사용자에게 더 가깝게 실행하여 속도와 효율성을 향상”시키며 , 특히 “실시간 애플리케이션(게임, AR/VR, IoT)”에 중요하다. 이는 밀리초가 중요한 5G 및 IoT의 요구 사항에 대한 직접적인 응답이다. 동시에 “셀 기반 아키텍처는 복원력과 블래스트 반경 최소화를 강조하며 주목받고 있다”. 이는 중앙 집중식 모놀리식 배포에서 로컬 처리 및 데이터 저장이 핵심인 고도로 분산되고 내결함성 있는 시스템으로의 전략적 전환을 나타낸다. 따라서 백엔드 개발자들은 “엣지 환경을 위한 API 및 데이터 저장 방식”을 재고하고 , 네트워크 지연, 간헐적 연결, 로컬 의사결정을 고려하는 아키텍처 패턴을 수용해야 한다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0007.png" alt="" /></p>
<blockquote>
  <p>Edge Computing 구조도 (출처 - <a href="https://maddevs.io/blog/everything-you-need-to-know-about-edge-computing/">“Everything You Need to Know About Edge Computing” - Roman Panarin</a>)</p>
</blockquote>

<p><strong>2.7 새로운 프로그래밍 언어 및 프레임워크의 부상</strong>
Rust는 Node.js와 Go를 넘어 성능이 중요한 백엔드 시스템에서 선호되는 언어로 부상하고 있다. Rust는 메모리 안전성, Node.js 및 Go보다 빠른 성능, 보안성 등의 이점을 제공한다. Axum 및 Actix와 같은 Rust 백엔드 프레임워크의 성장이 예상된다. Python, JavaScript (Node.js), Java, PHP, Golang은 여전히 주요 백엔드 언어로 사용되고 있으며 , Django, Spring Boot, Laravel, Express.js 등 다양한 프레임워크가 개발 효율성, 보안, 확장성을 제공한다.  </p>

<p>기존 언어와 프레임워크가 백엔드 환경에서 여전히 지배적이지만, Rust의 인기가 높아지는 것은 특히 성능에 민감하고 안전한 인프라 구성 요소에 대해 고성능과 메모리 안전성을 모두 제공하는 언어에 대한 업계의 수요가 증가하고 있음을 의미한다. Python, Node.js, Java는 가독성, 광범위한 생태계 및 다용성으로 인해 주요 백엔드 언어로 나열되어 있다. 그러나 Rust는 “메모리 안전성”, “성능”, “보안” 덕분에 “성능에 민감한 백엔드 시스템을 위한 언어”로 빠르게 자리 잡고 있다. 이는 모든 것을 대체하는 추세라기보다는, 기존의 가비지 컬렉션 언어가 오버헤드를 유발할 수 있는 고성능, 보안 및 리소스 효율적인 시스템에 대한 특수화된 요구를 나타낸다. 따라서 조직은 단일 언어 스택을 고수하기보다는 특정 비기능적 요구 사항(예: 지연 시간, 보안, 리소스 사용량)에 따라 최적의 도구를 선택하는 다중 언어 프로그래밍(polyglot programming)으로 나아가고 있다. 이는 개발자들이 특수 작업을 위해 새로운 언어를 배우고 채택하는 데 개방적이어야 함을 의미한다.</p>

<p>물론 한국의 상황을 고려한다면, 이러한 가치가 중요시 되는 것이 국제적 트렌드는 되지만, 그렇지 않은 것도 사실이다. 하지만 과거 대비 Java 스타트 사업 및 글로벌 서비스가 확대되는 상황에서 이러한 대안의 등장은 비즈니스 특성에 따라 따라가거나 대비되어야 할 영역이리라 생각된다. 특히나 AI 서비스를 비롯하여 점차 서비스를 위한 대용량 처리가 더욱 강조되고, AI 확산에 따라 생겨나는 무수한 보안 공격을 비롯한 AI 기반의 크롤링 수법의 진화 등은 보다 안전하고, 보다 성능이 뛰어난 백엔드 인프라의 중요성을 더욱 부각시킨다고 볼 수 있다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0008.png" alt="" /></p>
<blockquote>
  <p>Rust Backend (출처 - <a href="https://www.youtube.com/watch?v=Rnw-x21kGaA">“How to Build A Rust Backend with Actix Web and SurrealDB (Full Tutorial)” - White Sponge</a>)</p>
</blockquote>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0009.png" alt="" /></p>
<blockquote>
  <p>2023년 stack overflow 조사로 84.66% 로 가장 인기 있는 언어로 나타났다.  (출처 - <a href="https://strapi.io/blog/rust-vs-other-programming-languages-what-sets-rust-apart">Munir Adavize Abdullahi</a>)</p>
</blockquote>

<h2 id="3-미래를-위한-백엔드-개발자의-핵심-역량">3. 미래를 위한 백엔드 개발자의 핵심 역량</h2>

<p>변화하는 백엔드 시장에서 개발자들이 경쟁력을 유지하고 성장하기 위해서는 다음과 같은 핵심 역량과 전략을 갖춰야 한다.</p>

<ul>
  <li><strong>아키텍처 및 설계 역량 강화</strong>: 수평적 확장성(stateless services, load balancers, sharding), 마이크로서비스(loosely coupled, message queues, API gateways), 이벤트 기반 아키텍처(asynchronous processing, event sourcing)에 대한 깊은 이해와 설계 능력이 필수적이다.  </li>
  <li><strong>클라우드 및 컨테이너 기술 숙달</strong>: AWS, Azure, GCP 등 주요 클라우드 플랫폼의 서비스와 Docker, Kubernetes와 같은 컨테이너 및 오케스트레이션 도구 활용 능력이 핵심이다. Terraform, CloudFormation, Pulumi와 같은 인프라 자동화 도구를 통해 환경을 코드로 정의하고 관리하는 능력이 요구된다.  </li>
  <li><strong>데이터 관리 및 최적화</strong>: SQL (MySQL, PostgreSQL) 및 NoSQL (MongoDB, DynamoDB) 데이터베이스에 대한 이해와 함께, 캐싱 (Redis, Memcached), 읽기 복제본, 데이터 샤딩을 통한 성능 최적화 능력이 중요하다. AI 기반 데이터베이스 관리 및 쿼리 최적화 도구의 활용도 고려해야 한다.  </li>
  <li><strong>보안 의식 및 실천</strong>: API 보안(RBAC, OAuth 2.0, TLS, JWT), 데이터 암호화(전송 및 저장), 취약점 관리(정기 감사 및 침투 테스트), Zero Trust 모델 구현이 필수적이다. 보안은 더 이상 부차적인 고려사항이 아니라 핵심 요구사항이며, 개발 초기 단계부터 보안을 통합하는 DevSecOps 접근 방식이 중요해진다.  </li>
  <li><strong>자동화 및 운영 효율성</strong>: CI/CD 파이프라인을 통한 테스트 및 배포 자동화, 인프라 자동화 (Infrastructure as Code), GitOps (Git 기반 인프라 관리)를 통한 운영 효율성 향상 능력이 요구된다. DevOps는 대규모 시스템 관리에 중요한 역할을 하며, 자동 스케일링 및 모니터링 시스템 구축이 포함된다.  </li>
  <li><strong>AI/ML 도구 활용 및 이해</strong>: AI 코드 어시스턴트, AI 기반 쿼리 최적화 도구 등 AI/ML 도구를 개발 워크플로우에 통합하고, AI 모델과의 API 연동 방식을 이해하는 것이 중요하다. AI는 개발자의 생산성을 높이고 반복 작업을 자동화하는 데 기여한다.  </li>
  <li><strong>지속적인 학습 및 적응</strong>: 빠르게 변화하는 기술 환경에 대한 유연한 대응과 지속적인 학습이 가장 중요하다. 새로운 언어, 프레임워크, 아키텍처 패턴, 보안 위협에 대한 최신 정보를 습득해야 한다. 기술 스택의 다양화와 복잡성 증가는 끊임없는 자기 계발을 요구한다.  </li>
</ul>

<h2 id="마무리하며--변화는-기회다">마무리하며 : 변화는 기회다</h2>
<p>지난 5월 13일 마이크로소프트는 인공지능의 적극적인 도입으로 엔지니어링 개발자, 회사 인력의 3%에 해당하는 6800명을 감원하였다. 이러한 모습들은 개발자의 ‘용도’와 ‘필요’가 이제 변화하고 있다는 사실을 이야기 한다. AI 를 통해 지능적으로 바뀌는 온갖 보안문제, 그에 비해 발생하는 엄청난 효율성과 자동화 영역에 대한 AI의 개발자 대체 가능성 등, 이 글에서 언급하지 않았지만 LLM 을 필두로 발생한 AI의 파동은 더욱 피부 속을 파고들 정도로 체감되기 시작했다.</p>

<p>그러한 상황에서 백엔드 개발자, 아울러 개발자라는 직군은 다른 포지셔닝이 필요하게 되었으며, 그러한 포지셔닝, 가치의 재정립은 이러한 트랜드를 이해하며, 숨쉬듯 AI 를 자신의 또 다른 뇌, 또 다른 자아처럼 다룰 수 있어야 함을 요구한다. 그런 상황에서 구체적인 역할이, 명료하게 자리 잡아야만 AI가 사람을 대체할 수 있어지는 이 시대에서의 개발자의 역할을 할 수 있으리라 보인다.</p>

<p>이러한 변화에 발맞춰 분산 시스템 설계, 클라우드 및 컨테이너 기술, 데이터 관리, 그리고 보안에 대한 깊은 이해를 갖춰야 한다. 또한, AI 도구를 적극적으로 활용하고 DevOps 및 GitOps 원칙을 내재화하여 효율성을 극대화해야 한다. 백엔드 시스템의 복잡성과 규모가 증가함에 따라 자동화는 선택이 아닌 필수 전략이 되고 있으며, 데이터 품질과 거버넌스는 AI 기반 시스템의 성공을 위한 필수적인 기반이 된다. 궁극적으로, 끊임없는 학습과 적응력은 이 역동적인 환경에서 성공적인 커리어를 위한 핵심 열쇠가 될 것이다. 이러한 것들을 의미는 무엇인가? <strong>결국 AI 를 진두지휘하는 커맨더적 개발자의 대두가 반드시 필요하며, 그러한 백엔드 개발자가 되지 못한다는 것은 더 빠른 시장에서의 퇴출 내지는 시장에서의 퇴보를 의미할 것이다.</strong></p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0010.png" alt="" /></p>
<blockquote>
  <p>이미지 프롬프팅 (출처 - 제미니 2.5 Flash)</p>
</blockquote>

<h2 id="진짜-마무리-이-글을-쓰기-위한-ai와-나의-노력">진짜 마무리, 이 글을 쓰기 위한 AI와 나의 노력</h2>
<p>구글 IO 2025 에서 사실 많은 사람들은 Flow 나 Whisk, veo3 등에 열광 했을지 모르겠다. 하지만 내가 가장 주목한 건 사실 다른 무엇보다 제미니 2.5 였다. 제미니는 2.0 부터 점차 두각을 드러내기 시작했다. 데이터의 양이나 플랫폼의 수준을 생각하면 사실 ChatGPT 나 Claude 가 사실 범접할 수준이 아니기에, 그 시작은 Google이 아닐지 모르지만, 그 끝은 Google 이 아닐까? 라는 생각을 했다.</p>

<p>그리고 그 결과, 나의 생각은 역시나 틀리지 않았다. 구글은 처음에는 후발 주자와 같은 미숙함이 보였지만, 데이터를 어떻게 다루면 되는지를 알며, 무엇보다 그러한 데이터의 정제를 위한 AI 적 사고가 어떻게 되면 되는지를 여실없이 보여주었다(….)</p>

<p>대충이라도 재어 본 결과, 위의 글의 살을 거의 완성시키는데 걸린 시간은 고작 10분이었고, 읽어보고 개선하고 하는데 걸린시간은 30분. 전체 글을 다 쓰는데 현재 3시간 남짓이 걸렸다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0011.png" alt="" /></p>
<blockquote>
  <p>최초 연구 요청</p>
</blockquote>

<p>물론, 첨삭이 필요하긴 했다. 하지만 나의 요청에 제미니는 말 그대로 연구의 목적과 이를 위한 사고를 보여주었고, 그 사고의 과정의 기법은 매우 체계적일 뿐 아니라 ‘자연어’ 스러웠다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0012.png" alt="" /></p>
<blockquote>
  <p>사과정의 기록이 보여주는 구글의 AI 철학은 인문학과 과학, 그 어딘가를 논하지 않을 수 없다고 생각이 든다.</p>
</blockquote>

<p>AI는 많이 두려운 존재인 것은 사실이다. 생각해보면 AI의 등장은 더 이상 ‘어중간한 존재’들이 필요없다는 식의 매우 냉랭한 말을 세상이 더더욱 말하고 있는 것이란 생각이 든다. No Code Low Code 라는 키워드가 흥할 때부터 이러한 낌새는 보였다. 점점 발전하고 감싸지면서 쉬워지는 프레임워크들, 그것을 1 나노초라도 더 빨리 구동하기 위해 구현되고 있는 하드웨어들, 이러한 상황 속에서 어중간한 실력과 어중간한 안목을 가진 개발자들, 아니 어쩌면 그러한 사람들의 소멸이나 사형선고가 아닐까 하는 무서운 상상도 든다.</p>

<p>하지만, 그런 과정 속에서도 나는 이런 생각을 하게 된다. 제미니의 이러한 수준은 사진에서도 다소 나오지만, 단순한 하드웨어나 데이터셋의 문제가 아니라는 점을 느끼게 만든다. CoT 프롬프팅, 지식 그래프 및 상징적 AI, 뇌신경-상징적 AI 패턴, 검색 증강 생성을 비롯한 고도의 인간의 고차원적 사고 패턴을 기계가 이용 가능하도록 형태를 변화 시킨것들의 접목된 결과가 이것이 아닐까?</p>

<p>인간만큼 뛰어나지는 것은 무엇 때문인가? 그것은 바로 인간의 고도화된 사고, 논리, 철학, 그러한 기준들의 존재가 있고 그것이 확률성과 붙었을 때, 비로소 LLM 이라는 형태로 인간의 확률성을 나타내는 것이 되고, AI라는 도구화 되어 확실한 두각을 내 비치는게 아닐까?</p>

<p>젠슨황의 말 처럼, 이젠 진짜 인문사회학과 과학, 그 사이 어딘가에서 창조적 가치, 그리고 인간만이 가능한 고등한 더 넓거나 더 고도의 사고체계를 구축하여, 물질세계에 구현해내는 작업들을 해낸다면 그것이 곧 AI의 성능 향상으로 끌어올리는게 아닐까 생각이 들고, 그러한 작업이 이제 인간의 업이 되는게 아닌가 조심스레 예상해본다. 그리고 그런 상황에서 개발자들은 단순하게 만든다의 의미에서 ‘가치’를 부여한다는 의미를 보다 되새길 수 있는 테크니션 리더가 되어야 하는게 아닌가 생각한다.</p>

<h2 id="참고-문헌">참고 문헌</h2>
<ol>
  <li>8 Trends In Backend Development You Can’t Ignore In 2025, <a href="https://arunangshudas.com/blog/8-trends-in-backend-development-you-cant-ignore-in-2025/">https://arunangshudas.com/blog/8-trends-in-backend-development-you-cant-ignore-in-2025/</a></li>
  <li>Serverless Computing Market Size &amp; Trends, Growth Analysis …, <a href="https://www.marketsandmarkets.com/Market-Reports/serverless-computing-market-217021547.html">https://www.marketsandmarkets.com/Market-Reports/serverless-computing-market-217021547.html</a></li>
  <li>Latest Microservices Architecture Trends in 2024 - Cloud Destinations, <a href="https://clouddestinations.com/blog/evolution-of-microservices-architecture.html">https://clouddestinations.com/blog/evolution-of-microservices-architecture.html</a></li>
  <li>How GitOps is Revolutionizing DevOps Practices in 2024 …, <a href="https://coffeebeans.io/blogs/how-gitops-is-revolutionizing-devops-practices-in-2024">https://coffeebeans.io/blogs/how-gitops-is-revolutionizing-devops-practices-in-2024</a></li>
  <li>Top K8s Workload Trends in the 2024 Kubernetes Benchmark …, <a href="https://cloudnativenow.com/features/top-k8s-workload-trends-in-the-2024-kubernetes-benchmark-report/">https://cloudnativenow.com/features/top-k8s-workload-trends-in-the-2024-kubernetes-benchmark-report/</a></li>
  <li>Docker and Containerization Trends in 2024 - Slashdev, <a href="https://slashdev.io/-docker-and-containerization-trends-in-2024">https://slashdev.io/-docker-and-containerization-trends-in-2024</a></li>
  <li>The Best Backend Frameworks for Speed, Scalability, and Power in 2025 - Fively, <a href="https://5ly.co/blog/best-backend-frameworks/">https://5ly.co/blog/best-backend-frameworks/</a></li>
  <li>Key Trends from 2024: Cell-Based Architecture, DORA &amp; SPACE …, <a href="https://www.infoq.com/podcasts/2024-year-review/">https://www.infoq.com/podcasts/2024-year-review/</a></li>
  <li>AI and event driven architecture – the perfect partnership to make …, <a href="https://vmblog.com/archive/2024/02/02/ai-and-event-driven-architecture-the-perfect-partnership-to-make-the-connected-enterprise-a-reality-2024.aspx">https://vmblog.com/archive/2024/02/02/ai-and-event-driven-architecture-the-perfect-partnership-to-make-the-connected-enterprise-a-reality-2024.aspx</a></li>
  <li>Data Architecture Trends in 2024 - DATAVERSITY, <a href="https://www.dataversity.net/data-architecture-trends-in-2024/">https://www.dataversity.net/data-architecture-trends-in-2024/</a></li>
  <li>A Stroll Through API Economy Trends - Nordic APIs, <a href="https://nordicapis.com/a-stroll-through-api-economy-trends/">https://nordicapis.com/a-stroll-through-api-economy-trends/</a></li>
  <li>Top API Trends that will Change the World Beyond 2025 - ImpactQA, <a href="https://www.impactqa.com/infographics/top-api-trends-that-will-change-the-world-beyond/">https://www.impactqa.com/infographics/top-api-trends-that-will-change-the-world-beyond/</a></li>
  <li>7 Best Practices for API Security in 2024 - GeeksforGeeks, <a href="https://www.geeksforgeeks.org/api-security-best-practices/">https://www.geeksforgeeks.org/api-security-best-practices/</a></li>
  <li>Database trends of 2025: Rankings, new technologies and changes in the industry, <a href="https://www.baremon.eu/database-trends-of-2025/">https://www.baremon.eu/database-trends-of-2025/</a></li>
  <li>Database Trends and Innovations: A Comprehensive Outlook for 2025 - Rapydo, <a href="https://www.rapydo.io/blog/database-trends-and-innovations-a-comprehensive-outlook-for-2025">https://www.rapydo.io/blog/database-trends-and-innovations-a-comprehensive-outlook-for-2025</a></li>
  <li>Top 11 Backend Programming Languages in 2025 - Webandcrafts, <a href="https://webandcrafts.com/blog/backend-languages">https://webandcrafts.com/blog/backend-languages</a></li>
  <li>Most Popular Backend Frameworks: Top 10 in 2025 - Netguru, <a href="https://www.netguru.com/blog/backend-frameworks">https://www.netguru.com/blog/backend-frameworks</a></li>
  <li>7 Essential Tips For Scalable Backend Architecture, <a href="https://blog.arunangshudas.com/7-essential-tips-for-scalable-backend-architecture/">https://blog.arunangshudas.com/7-essential-tips-for-scalable-backend-architecture/</a></li>
  <li>What Is Event-Driven Architecture? Comprehensive Guide 2024 …, <a href="https://estuary.dev/blog/event-driven-architecture/">https://estuary.dev/blog/event-driven-architecture/</a></li>
  <li>How to Become a Backend Developer in 2025 - GeeksforGeeks, <a href="https://www.geeksforgeeks.org/back-end-developer-roadmap/">https://www.geeksforgeeks.org/back-end-developer-roadmap/</a></li>
  <li>2024 Cloud Service Providers: Comparison &amp; Guide (Top Choices) - TechAhead, <a href="https://www.techaheadcorp.com/blog/2024-cloud-service-providers-comparison-guide-top-choices/">https://www.techaheadcorp.com/blog/2024-cloud-service-providers-comparison-guide-top-choices/</a></li>
  <li>Key Skills for Successful DevOps Engineers in 2024 - Creole Studios, <a href="https://www.creolestudios.com/key-skills-for-successful-devops-engineer-2024/">https://www.creolestudios.com/key-skills-for-successful-devops-engineer-2024/</a></li>
  <li>2024 Cloud Computing Spending Trends: AWS, Azure, GCP Insights - DEV Community, <a href="https://dev.to/ssojet/2024-cloud-computing-spending-trends-aws-azure-gcp-insights-5fg1">https://dev.to/ssojet/2024-cloud-computing-spending-trends-aws-azure-gcp-insights-5fg1</a></li>
  <li>Caching Best Practices: Boost Performance in 2024 - Eyer.ai, <a href="https://www.eyer.ai/blog/caching-best-practices-boost-performance-in-2024/">https://www.eyer.ai/blog/caching-best-practices-boost-performance-in-2024/</a></li>
  <li>Top 8 Skills Required in DevOps Engineer for 2024 - Softqube Technologies, <a href="https://www.softqubes.com/blog/top-8-skills-required-in-devops-engineer-for-2024/">https://www.softqubes.com/blog/top-8-skills-required-in-devops-engineer-for-2024/</a></li>
  <li>Best Certifications for Backend Developers in 2025 (Ranked) - Teal, <a href="https://www.tealhq.com/certifications/backend-developer">https://www.tealhq.com/certifications/backend-developer</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="AI" /><category term="GitOps" /><category term="Google" /><category term="Gemini" /><summary type="html"><![CDATA[1. 백엔드, 왜 지금 이 변화를 주목하려고 하는가? 백엔드는 더 이상 단순히 데이터를 처리하고 저장하는 ‘뒷단’이 아니다. 서비스의 확장성, 안정성, 그리고 궁극적으로 사용자 경험의 질을 결정하는 핵심 두뇌이자 심장부이다. 기업들은 갈수록 더 빠르고, 더 유연하며, 더 비용 효율적인 시스템을 요구하고 있으며, 이러한 요구는 백엔드 아키텍처와 기술 스택의 끊임없는 진화를 촉진한다.]]></summary></entry><entry><title type="html">NestJS Deep Dive</title><link href="http://0.0.0.0:4000/backend/2025/05/25/01-NestJS-Deep-Dive.html" rel="alternate" type="text/html" title="NestJS Deep Dive" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/05/25/01-NestJS-Deep-Dive</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/05/25/01-NestJS-Deep-Dive.html"><![CDATA[<h2 id="1-서론-nestjs-왜-선택해야-할까">1. 서론: NestJS, 왜 선택해야 할까?</h2>
<p>NestJS는 Node.js 환경에서 효율적이고 확장 가능한 서버 사이드 애플리케이션을 구축하기 위한 진보적인 프레임워크다. 이 프레임워크는 Angular의 아키텍처에서 영감을 받아 개발되었으며, TypeScript를 기본 언어로 적극 지원한다는 특징을 가집니다. TypeScript의 강력한 타입 시스템은 개발 과정에서 발생할 수 있는 잠재적인 오류를 미연에 방지하고, 코드의 가독성과 안정성을 크게 향상시킨다.  </p>

<p>백엔드 개발에서 NestJS의 강점은 여러 면에서 확인할 수 있다.</p>

<ul>
  <li>
    <p>첫째, 모듈식 아키텍처를 채택하여 유연한 확장성을 제공하며, 다른 라이브러리와의 통합이 용이하다. 이는 대규모 프로젝트에서 코드의 재사용성을 높이고, 개발 과정을 체계적으로 관리할 수 있게 한다.</p>
  </li>
  <li>
    <p>둘째, 객체 지향 프로그래밍(OOP)의 캡슐화 특성을 적극 활용하여 유사한 기능을 하는 컨트롤러와 서비스 등을 모듈 단위로 묶어 관리함으로써 코드의 응집도를 높이고 유지보수를 용이하게 한다.</p>
  </li>
  <li>
    <p>셋째, 의존성 주입(DI) 시스템을 내장하여 컴포넌트 간의 결합도를 낮추고 테스트 용이성을 극대화한다.</p>
  </li>
</ul>

<p>이러한 특성들은 NestJS가 국내외, 특히나 빠른 대응이 필요한 스타트업에서 기존 Node 나 Express 기반의 프로젝트 대비 빠르게 인기를 얻으며 다양한 회사에서 프로젝트에 적용되는 주요 원인이 되고 있다.</p>

<p>전체 내용을 한 번 정리해가 된 이유는 다음과 같다.</p>

<ol>
  <li>
    <p>NestJS 를 기반으로 하는 현재의 라이브 서비스를 보다 레퍼런스 철학에 맞는 형태로 유지하기 위하여, NestJS 개발 철학을 체득화하고 싶다.</p>
  </li>
  <li>
    <p>라이프 사이클에 대해 좀더 고심하여 기존의 비즈니스 로직, 라우팅 과정 등에서 비즈니스 로직과 전 후처리에 대한 결합도를 낮추고 싶다.</p>
  </li>
  <li>
    <p>위의 목표들을 위하여 심도있는 학습 전 빠르게 NestJS 에 대한 기초를 복습하고 싶다.</p>
  </li>
</ol>

<p>이러한 이유로 정리해본다.</p>

<h2 id="2-nestjs-핵심-구조-및-설계-원리">2. NestJS 핵심 구조 및 설계 원리</h2>
<p>NestJS는 모듈(Module), 컨트롤러(Controller), 프로바이더(Provider)의 세 가지 핵심 구성 요소를 기반으로 애플리케이션을 구조화한다. 이들은 각각의 명확한 역할을 가지며 유기적으로 상호작용하여 견고하고 유지보수 가능한 백엔드 시스템을 구축할 수 있도록 돕는다.</p>

<h3 id="21-모듈-애플리케이션의-빌딩-블록">2.1 모듈: 애플리케이션의 빌딩 블록</h3>
<p>모듈은 NestJS 애플리케이션을 구성하는 빌딩 블록이자 기능들을 조합하여 작성한 응집체이다. 각 모듈은 관련된 컨트롤러, 서비스 등을 하나의 단위로 묶어 애플리케이션의 구조를 모듈화한다. 예를 들어, 사용자 관리 기능을 담은 모듈은 UserModule로, 게시판 기능은 BoardModule로 구성할 수 있다.</p>

<p>모듈의 주요 역할은 애플리케이션의 기능을 그룹화, 코드의 재사용성 및 유지보수성을 높이는 것이다. <code class="language-plaintext highlighter-rouge">@Module()</code> 데코레이터는 NestJS가 애플리케이션 구조를 구축하는 데 사용하는 메타데이터를 제공한다. 이 메타데이터에는 다음과 같은 핵심 속성들이 포함된다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">imports</code>: 현재 모듈에서 사용할 다른 모듈들의 목록이다. 이를 통해 모듈 간의 의존성을 명시적으로 관리할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">controllers</code>: 이 모듈에서 사용하는 컨트롤러들의 목록이다.</li>
  <li><code class="language-plaintext highlighter-rouge">providers</code>: 이 모듈에서 사용하는 서비스나 프로바이더들의 목록이다.</li>
  <li><code class="language-plaintext highlighter-rouge">exports</code>: 이 모듈에서 제공하며, 이 모듈을 가져오는 다른 모듈에서 사용할 수 있도록 공개할 프로바이더들의 목록이다.</li>
</ul>

<p>NestJS 애플리케이션은 반드시 하나의 루트 모듈(AppModule)을 가지며, 이 루트 모듈은 다른 기능별 모듈들을 포함하여 애플리케이션을 실행하는 데 필요한 모든 요소를 구성한다. 모듈 구성 전략으로는 도메인 주도 설계(DDD) 기반의 접근법이 권장된다. 이는 비즈니스 도메인을 먼저 모델링한 후, 해당 도메인에 따라 모듈을 분리하는 방식이다. 예를 들어, blog, user, auth와 같은 다른 도메인 이름을 가진 폴더를 생성하고 각 폴더 내에 해당 모듈 파일을 생성하는 방식이다.또한, DB 연결이나 Swagger API 생성과 같이 개발자 도메인에만 속하는 공통 기능은 common 폴더를 생성하여 모듈로 관리할 수 있다.</p>

<p>모듈 시스템의 장점은 명확하다. 1) 어떤 모듈이든 가져와 다른 곳에서 재사용할 수 있어 코드 중복을 방지하고 모듈성을 향상시킨다. 2) 강력한 의존성 주입(DI) 시스템을 제공하여 컴포넌트 간의 결합도를 낮춘다. 3) 기능에 문제가 있을 때 작업해야 하는 코드를 빠르게 찾을 수 있어 디버깅 및 유지보수가 용이하다. 4) 마지막으로, NestJS의 모듈 시스템은 개발자를 서비스 지향적 사고의 방향으로 이끌어 주어, 각 기능의 책임을 명확히 분리하고 응집도를 높이는 데 기여한다.</p>

<h3 id="22-컨트롤러-controllers-요청-처리의-관문">2.2 컨트롤러 (Controllers): 요청 처리의 관문</h3>
<p>컨트롤러는 클라이언트로부터 들어오는 요청을 처리하고 적절한 응답을 반환하는 역할을 한다. Express 프레임워크의 라우터(Router)와 유사하게, 컨트롤러는 라우팅 메커니즘을 이용하여 특정 URL 엔드포인트에 대한 요청을 구분하고 매칭한다.</p>

<p>컨트롤러 클래스는 <code class="language-plaintext highlighter-rouge">@Controller()</code> 데코레이터를 사용하여 정의된다. 이 데코레이터는 클래스를 필요한 메타데이터와 연결하고 라우터 기능을 활성화한다. @Controller() 데코레이터 내부에 인자값을 넣어 경로를 설정할 수 있으며, @Get(), @Post(), @Put(), @Delete()와 같은 HTTP 메서드 데코레이터를 사용하여 특정 HTTP 요청에 대한 핸들러 메서드를 정의한다.</p>

<p>컨트롤러는 직접적으로 복잡한 비즈니스 로직을 처리하지 않는다. 대신, 요청을 받아 서비스 계층으로 위임하고, 서비스에서 처리된 결과를 받아 클라이언트에 응답을 반환하는 역할을 수행한다. 이러한 역할 분리는 단일 책임 원칙(SRP)을 준수하며, 코드의 가독성과 유지보수성을 높이는 데 기여한다.</p>

<h3 id="23-프로바이더-providers--서비스-services-비즈니스-로직의-심장">2.3 프로바이더 (Providers) &amp; 서비스 (Services): 비즈니스 로직의 심장</h3>
<p>프로바이더는 NestJS의 근본적인 개념으로, <code class="language-plaintext highlighter-rouge">서비스(Service)</code>, <code class="language-plaintext highlighter-rouge">리포지토리(Repository)</code>, <code class="language-plaintext highlighter-rouge">팩토리(Factory)</code>, <code class="language-plaintext highlighter-rouge">헬퍼(Helper)</code> 등 NestJS의 많은 기본 클래스들이 프로바이더로 취급된다. 프로바이더의 핵심 아이디어는 의존성 주입(DI)을 통해 다른 컴포넌트에 주입될 수 있다는 것이다. NestJS 프레임워크는 내부적으로 IoC(Inversion of Control) 컨테이너를 만들어 이 프로바이더들을 관리한다.</p>

<p><code class="language-plaintext highlighter-rouge">서비스</code>는 프로바이더의 가장 흔한 형태로, 애플리케이션의 핵심 비즈니스 로직을 처리하는 역할을 한다. 데이터 생성, 조회, 변경, 삭제와 같은 데이터 가공 작업이 서비스 계층의 책임이다. 여러 컨트롤러에서 재사용되는 로직은 서비스로 분리하여 코드 중복을 피하고 유지보수성을 높일 수 있다.</p>

<p>서비스 클래스는 <code class="language-plaintext highlighter-rouge">@Injectable()</code> 데코레이터를 사용하여 정의된다. 이 데코레이터는 해당 클래스가 NestJS IoC 컨테이너에 의해 관리될 수 있는 주입 대상임을 NestJS에 알린다. @Injectable() 데코레이터가 붙은 서비스는 모듈의 providers 배열에 ‘등록’되어야 컨트롤러에서 의존성 주입을 통해 사용할 수 있게 된다.</p>

<p>프로바이더와 서비스, 그리고 컨트롤러의 관계는 공급자-제품-소비자 비유로 쉽게 이해할 수 있다. 서비스가 ‘제품’이라면, 프로바이더는 이 제품을 ‘공급’하는 역할을 하며, 컨트롤러는 이 제품을 ‘소비’하는 주체이다. 공급자가 제품을 제공해야 소비자가 사용할 수 있듯이, 프로바이더에 서비스가 등록되어야 컨트롤러에서 주입받아 사용이 가능하다. 이러한 구조는 비즈니스 로직과 통신 계층의 관심사를 명확하게 분리하여 유연하고 지속 가능한 아키텍처를 제공한다.</p>

<h3 id="24-의존성-주입-dependency-injection-di-제어의-역전">2.4 의존성 주입 (Dependency Injection, DI): 제어의 역전</h3>
<p>의존성 주입(DI)은 NestJS의 핵심 개념 중 하나이자 제어의 역전(IoC) 기술의 구체적인 구현체이다. 제어의 역전이란 개발자가 직접 제어해야 할 영역을 프레임워크에 위임하는 것을 의미하며, DI는 개발자가 필요한 외부 자원(클래스, 함수 등)을 직접 생성하는 대신 프레임워크로부터 제공받을 수 있도록 하는 방식이다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-26-0001.png" alt="" /></p>

<p>예를 들어, 아이가 냉장고에서 스스로 물건을 꺼내는 대신 부모님에게 필요한 것을 말하면 부모님이 대신 가져다주는 상황과 유사하다. 이는 아이(소비자)가 냉장고 문을 열고 물건을 찾는 복잡한 과정(의존성 생성 및 관리)을 직접 처리하는 대신, 부모님(프레임워크)에게 그 일을 위임하여 필요한 것을 공급받는 것과 같다. NestJS에서는 이처럼 프레임워크가 주체가 되어 필요한 클래스 인스턴스들을 대신 관리하고 주입해준다.</p>

<p>NestJS에서 의존성 주입은 주로 생성자 주입(Constructor Injection) 방식을 통해 이루어진다. 컨트롤러 클래스의 생성자 매개변수로 필요한 서비스 인스턴스를 선언하면, NestJS는 해당 서비스의 타입을 인지하고 자동으로 인스턴스를 주입한다. 이 덕분에 별도의 import 작업 없이도 주입된 서비스의 메서드를 호출할 수 있다. 필드 위에 @Inject() 데코레이터를 사용하는 프로퍼티 스타일 주입도 가능하지만, NestJS 공식 문서에서는 생성자 주입을 권장한다.</p>

<p><strong>DI의 이점은 다음과 같다:</strong></p>

<ul>
  <li>
    <p><strong>결합도 감소</strong>: 컴포넌트들이 서로의 구체적인 구현에 직접 의존하지 않고 추상화(인터페이스)에 의존하게 되어, 컴포넌트 간의 결합도가 낮아진다. 이는 코드 변경 시 다른 부분에 미치는 영향을 최소화한다. 각 영역에 대해 필요한 변화나, 개선이 필요시 각기 규역이 맞는다는 전제하에 변화가 용이하다.</p>
  </li>
  <li>
    <p><strong>테스트 용이성</strong>: 의존성을 외부에서 주입받으므로, 단위 테스트 시 실제 의존성 대신 모의(Mock) 객체를 쉽게 주입하여 테스트 환경을 고립시킬 수 있다.</p>
  </li>
  <li>
    <p><strong>코드 단순화 및 재사용성</strong>: 필요한 자원을 프레임워크가 관리해주므로 개발자는 비즈니스 로직에 더 집중할 수 있으며, 동일한 객체를 여러 곳에서 재사용하기 용이해진다.</p>
  </li>
  <li>
    <p><strong>유연성 및 확장성 향상</strong>: 의존성 관계가 명확해지고 느슨해지므로, 새로운 기능을 추가하거나 기존 기능을 변경할 때 유연하게 대처할 수 있다.</p>
  </li>
</ul>

<h3 id="25-데코레이터-decorators-nestjs의-마법-지팡이">2.5 데코레이터 (Decorators): NestJS의 마법 지팡이</h3>
<p>데코레이터는 NestJS에서 매우 중요한 개념이다. 클래스, 속성, 메서드, 매개변수에 추가 기능을 쉽게 적용할 수 있도록 돕는 문법이다. C#의 어트리뷰트와 유사하며, JavaScript에서는 @ 기호를 앞에 붙여 사용한다. NestJS는 데코레이터를 통해 클래스나 메서드에 메타데이터를 추가하거나 특정 동작을 부여할 수 있다.</p>

<p>NestJS에서 자주 사용되는 주요 내장 데코레이터는 다음과 같다:</p>

<p><code class="language-plaintext highlighter-rouge">@Controller()</code>: 클래스를 컨트롤러로 정의하고 라우팅 기능을 부여한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Injectable()</code>: 클래스를 의존성 주입의 대상으로 선언하고 IoC 컨테이너가 관리할 수 있도록 한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Get(), @Post(), @Put(), @Delete()</code>: HTTP 요청 메서드에 해당하는 라우트 핸들러를 정의한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Body()</code>: HTTP 요청 본문(body)에서 데이터를 추출하여 매개변수에 할당한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Param()</code>: URL 경로 매개변수에서 값을 추출한다 (예: /users/:id에서 id 값).</p>

<p><code class="language-plaintext highlighter-rouge">@Query()</code>: URL 쿼리 파라미터에서 값을 추출한다 (예: /users?name=Alice에서 name 값).</p>

<p>NestJS는 개발자가 직접 커스텀 데코레이터를 만들 수 있는 기능도 제공한다. <code class="language-plaintext highlighter-rouge">createParamDecorator</code> 함수를 사용하여 사용자 정의 데코레이터를 생성할 수 있으며, 이는 특정 요청에서 사용자 객체를 가져오거나, 특정 메타데이터를 설정하는 등 반복적인 로직을 추상화하여 코드의 재사용성과 가독성을 높이는 데 유용하다.</p>

<h2 id="3-nestjs-애플리케이션-라이프사이클-심층-분석">3. NestJS 애플리케이션 라이프사이클 심층 분석</h2>
<p>NestJS 애플리케이션은 시작부터 종료, 그리고 요청 처리 과정에 이르기까지 명확한 라이프사이클을 가진다. 이 흐름을 이해하는 것은 애플리케이션의 동작 방식을 파악하고 문제를 해결하는 데 필수적이다.</p>

<h3 id="31-애플리케이션-부트스트랩bootstrap-과정">3.1 애플리케이션 부트스트랩(Bootstrap) 과정</h3>
<p>NestJS 애플리케이션의 진입점은 일반적으로 main.ts 파일이다. 이 파일에서 NestFactory.create() 메서드를 사용하여 NestJS 애플리케이션 인스턴스를 생성하고 초기화한다. 이후 app.listen() 메서드를 호출하여 애플리케이션이 들어오는 HTTP 요청을 수신 대기하도록 한다.</p>

<pre><code class="language-TypeScript">// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT?? 3000);
}
bootstrap();
</code></pre>
<p>이 부트스트랩 과정은 애플리케이션의 모든 모듈과 프로바이더가 초기화되고 의존성이 해결되는 중요한 단계이다. NestFactory.createApplicationContext()를 사용하여 애플리케이션 컨텍스트를 생성하고 ConfigService와 같은 구성 서비스를 통해 환경 변수에 접근하는 것도 가능하다. 이는 애플리케이션이 시작되기 전에 필요한 설정을 로드하는 데 활용될 수 있다.</p>

<h3 id="32-라이프사이클-후크lifecycle-hooks-생명의-주기">3.2 라이프사이클 후크(Lifecycle Hooks): 생명의 주기</h3>
<p>NestJS는 애플리케이션의 주요 생명 주기 이벤트에 대한 가시성을 제공하는 다양한 라이프사이클 후크를 제공한다. 이 후크들은 특정 시점에 로직을 실행할 수 있도록 하여 모듈 및 서비스의 적절한 초기화, 활성 연결 관리, 그리고 정상적인 종료 처리를 가능하게 한다.</p>

<table>
  <thead>
    <tr>
      <th>후크 메서드</th>
      <th>호출 시점</th>
      <th>주요 역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>onModuleInit()</td>
      <td>호스트 모듈의 종속성이 해결되면 호출</td>
      <td>동기 또는 비동기 초기화 작업 (예: 데이터베이스에서 데이터 가져오기)</td>
    </tr>
    <tr>
      <td>onApplicationBootstrap()</td>
      <td>모든 모듈이 초기화된 후 연결을 수신 대기하기 전에 호출</td>
      <td>애플리케이션이 요청을 받기 전 최종 초기화 작업</td>
    </tr>
    <tr>
      <td>onModuleDestroy()</td>
      <td>종료 신호(예: SIGTERM)가 수신된 후 호출</td>
      <td>모듈 내부의 자원 정리 (예: DB 연결 해제)</td>
    </tr>
    <tr>
      <td>beforeApplicationShutdown()</td>
      <td>모든 onModuleDestroy() 처리기가 완료된 후 호출</td>
      <td>모든 기존 연결이 닫히기 전 최종 정리 작업 (Promise 해결 또는 거부 완료 시)</td>
    </tr>
    <tr>
      <td>onApplicationShutdown()</td>
      <td>연결 종료 후 호출 (app.close() 해결)</td>
      <td>애플리케이션 종료 후 최종 작업 (예: 로그 기록)</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">onModuleInit()</code>과 같은 비동기 라이프사이클 후크의 경우, 모듈은 위상 순서(topological order)로 순차적으로 초기화되지만, 동일 모듈 내 프로바이더의 onModuleInit() 호출 순서는 보장되지 않을 수 있다. 이는 때때로 프로바이더 간의 비동기 의존성 문제로 이어질 수 있으며, 이를 완화하기 위해 각 비동기 후크를 가진 프로바이더를 별도의 모듈에 배치하는 방법이 제안되기도 한다.</p>

<p><code class="language-plaintext highlighter-rouge">onModuleDestroy()</code>, <code class="language-plaintext highlighter-rouge">beforeApplicationShutdown()</code>, <code class="language-plaintext highlighter-rouge">onApplicationShutdown()</code>와 같은 종료 후크들은 <code class="language-plaintext highlighter-rouge">enableShutdownHooks()</code> 메서드를 명시적으로 호출해야 활성화된다. 이는 Kubernetes와 같은 환경에서 애플리케이션이 종료 신호를 받았을 때 정상적인 종료(Graceful Shutdown)를 처리하는 데 중요한다. 이러한 후크를 사용하여 애플리케이션의 생명 주기를 섬세하게 제어하고, 자원 누수를 방지하며 안정적인 운영을 보장할 수 있다.</p>

<h3 id="33-요청-응답-라이프사이클-request-response-lifecycle-데이터의-여정">3.3 요청-응답 라이프사이클 (Request-Response Lifecycle): 데이터의 여정</h3>
<p>NestJS 애플리케이션에서 클라이언트의 요청이 들어와 응답이 반환되기까지는 일련의 정해진 흐름을 따른다. 이 흐름은 미들웨어, 가드, 인터셉터, 파이프, 컨트롤러, 서비스, 그리고 예외 필터와 같은 다양한 구성 요소들이 순차적으로 또는 조건부로 개입하며 요청을 처리하고 응답을 생성한다.</p>

<p><code class="language-plaintext highlighter-rouge">들어오는 요청</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 미들웨어</code> -&gt; <code class="language-plaintext highlighter-rouge">모듈 미들웨어</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 가드</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 가드</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 가드</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 인터셉터 (pre-controller)</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 인터셉터 (pre-controller)</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 인터셉터 (pre-controller)</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 파라미터 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 (메서드 핸들러)</code> -&gt; <code class="language-plaintext highlighter-rouge">서비스 (비즈니스 로직)</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 인터셉터 (post-request)</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 인터셉터 (post-request)</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 인터셉터 (post-request)</code> -&gt; <code class="language-plaintext highlighter-rouge">예외 필터 (라우트, 컨트롤러, 전역 순)</code> -&gt; <code class="language-plaintext highlighter-rouge">서버 응답</code></p>

<table>
  <thead>
    <tr>
      <th>단계</th>
      <th>순서</th>
      <th>역할</th>
      <th>주요 특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>미들웨어 (Middleware)</td>
      <td>1</td>
      <td>요청 및 응답 객체 변경, 로깅, 인증 등 공통 작업 처리</td>
      <td>요청-응답 주기의 첫 관문, next() 호출로 다음 미들웨어로 제어 전달</td>
    </tr>
    <tr>
      <td>가드 (Guards)</td>
      <td>2</td>
      <td>런타임에 요청이 라우트 핸들러에 의해 처리될지 여부 결정 (인증/인가)</td>
      <td>미들웨어와 달리 ExecutionContext에 접근 가능, 모든 미들웨어 실행 후 인터셉터/파이프 이전에 실행</td>
    </tr>
    <tr>
      <td>인터셉터 (Interceptors)</td>
      <td>3</td>
      <td>요청이 핸들러에 도달하기 전/응답이 클라이언트에 전송되기 전 가로채기</td>
      <td>로깅, 데이터 변환, 에러 처리 등에 사용. Pre-processing 및 Post-processing 단계 존재</td>
    </tr>
    <tr>
      <td>파이프 (Pipes)</td>
      <td>4</td>
      <td>클라이언트로부터 전송되거나 수신되는 데이터의 유효성 검사, 변환, 필터링</td>
      <td>@nestjs/common의 ValidationPipe와 class-validator 라이브러리 활용</td>
    </tr>
    <tr>
      <td>컨트롤러 (Controller)</td>
      <td>5</td>
      <td>클라이언트의 요청을 받아 처리하고 응답을 반환하는 역할</td>
      <td>라우팅 메커니즘을 통해 요청을 서비스로 위임</td>
    </tr>
    <tr>
      <td>서비스 (Service)</td>
      <td>6</td>
      <td>비즈니스 로직을 처리하는 역할</td>
      <td>컨트롤러에서 위임받은 작업을 수행 (데이터 처리, 외부 API 호출 등)</td>
    </tr>
    <tr>
      <td>예외 필터 (Exception Filters)</td>
      <td>7</td>
      <td>NestJS 요청 라이프사이클의 모든 단계에서 발생하는 예외/에러 처리</td>
      <td>에러 메시지 커스터마이징, 로깅 등. 포착되지 않은 예외 발생 시에만 작동</td>
    </tr>
  </tbody>
</table>

<p>각 단계의 역할은 다음과 같다.</p>

<ul>
  <li><strong>미들웨어 (Middleware)</strong>: 요청이 서버에 도달했을 때 가장 먼저 실행되는 부분이다. 요청 및 응답 객체에 접근하여 <code class="language-plaintext highlighter-rouge">로깅</code>, <code class="language-plaintext highlighter-rouge">인증</code>, <code class="language-plaintext highlighter-rouge">CORS</code> 설정 등 공통 작업을 처리하는 데 사용된다. 미들웨어는 next() 함수를 호출하여 다음 미들웨어 또는 라우트 핸들러로 제어를 전달한다. 글로벌 미들웨어와 모듈에 바인딩된 미들웨어가 순차적으로 실행된다.</li>
  <li><strong>가드 (Guards)</strong>: 모든 미들웨어 실행 후, 인터셉터나 파이프 이전에 실행된다. 가드의 주된 목적은 런타임에 요청이 라우트 핸들러에 의해 처리될지 여부를 결정하는 것으로, 주로 인증 및 인가 처리에 사용된다. 미들웨어와 달리 <code class="language-plaintext highlighter-rouge">ExecutionContext</code> 인스턴스에 접근하여 다음에 실행될 핸들러에 대한 정보를 알 수 있다는 차이점이 있다. 가드는 글로벌, 컨트롤러, 라우트 레벨로 바인딩될 수 있으며, 바인딩된 순서대로 실행된다.</li>
  <li><strong>인터셉터 (Interceptors)</strong>: 요청이 핸들러에 도달하기 전(pre-processing) 또는 응답이 클라이언트에 전송되기 전(post-processing)에 요청/응답을 가로챌 수 있다. 로깅, 데이터 변환(예: 응답 데이터를 data 키 안에 캡슐화), 에러 처리 등에 활용된다. 인터셉터는 RxJS Observable을 반환하며, 응답 경로에서는 ‘First In Last Out’ 방식으로 역순으로 해결된다.</li>
  <li><strong>파이프 (Pipes)</strong>: 클라이언트로부터 전송되거나 수신되는 데이터의 유효성 검사, 변환, 필터링을 담당한다. 예를 들어, 요청 본문의 데이터 형식을 원하는 형식으로 변환하거나, 데이터가 올바른지 검증하는 데 사용된다. <code class="language-plaintext highlighter-rouge">class-validator</code> 및 <code class="language-plaintext highlighter-rouge">class-transformer</code> 라이브러리와 함께 <code class="language-plaintext highlighter-rouge">ValidationPipe</code>를 사용하여 데코레이터 기반의 강력한 유효성 검사를 구현할 수 있다. 파이프는 예외 영역(exception zone) 내에서 실행되므로, 파이프에서 발생하는 예외는 <code class="language-plaintext highlighter-rouge">예외 필터</code>에서 처리된다.</li>
  <li><strong>컨트롤러 (Controller) 및 서비스 (Service)</strong>: 이 단계에서 컨트롤러는 요청을 받아 서비스로 비즈니스 로직 처리를 위임하고, 서비스는 실제 데이터 처리 및 로직을 수행한다. 서비스에서 처리된 결과는 다시 컨트롤러로 반환되어 최종 응답이 구성된다.</li>
  <li><strong>예외 필터 (Exception Filters)</strong>: NestJS 요청 라이프사이클의 모든 단계(미들웨어, 가드, 인터셉터, 파이프, 컨트롤러, 서비스 등)에서 포착되지 않은 예외/에러가 발생했을 때 호출된다. 예외 필터는 에러 메시지를 원하는 형태로 가공하여 응답하거나, 에러 로깅 등의 작업을 수행할 수 있다. NestJS는 내장된 전역 예외 필터를 제공하며, 개발자는 필요에 따라 커스텀 예외 필터를 작성하여 특정 예외를 섬세하게 처리할 수 있다. 예외가 발생하면 나머지 라이프사이클은 무시되고 즉시 예외 필터로 제어가 넘어간다.</li>
</ul>

<h2 id="4-백엔드-서버-관점에서의-nestjs-활용">4. 백엔드 서버 관점에서의 NestJS 활용</h2>
<p>NestJS는 백엔드 서버 개발에 필요한 다양한 기능을 효율적으로 구현하고 관리할 수 있도록 지원한다.</p>

<h3 id="41-인증-및-인가-authentication--authorization">4.1 인증 및 인가 (Authentication &amp; Authorization)</h3>
<p>백엔드 서버에서 사용자 인증(Authentication)과 인가(Authorization)는 필수적인 기능이다. 인증은 사용자의 신원을 증명하는 행위이며, 인가는 증명된 사용자에게 특정 자원에 대한 접근 권한을 부여하거나 거부하는 행위이다.</p>

<p>NestJS는 JWT(JSON Web Token)와 Session 기반 인증 방식을 모두 지원하며, 특히 Passport.js 라이브러리와의 통합을 통해 인증 및 인가 과정을 간소화한다. Passport.js는 다양한 인증 전략(예: JWT, 로컬, OAuth)을 플러그인 형태로 제공하여 유연한 구현을 가능하게 한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JWT 인증</code>: 사용자가 아이디와 비밀번호를 서버로 보내면, 서버는 JWT를 발급하여 클라이언트(브라우저)로 넘겨준다. 이후 클라이언트는 로그인 권한이 필요한 페이지를 요청할 때마다 HTTP Authorization 헤더에 <code class="language-plaintext highlighter-rouge">Bearer &lt;JWT&gt;</code> 형태로 토큰을 함께 보내 신분증처럼 사용하며, 서버는 이 토큰을 검증하여 접근을 허용한다. NestJS에서는 passport-jwt 패키지를 설치하고 PassportStrategy를 구현하여 JWT 토큰 검증 로직을 작성한다. secretOrKey를 통해 토큰 생성 시 사용한 비밀키를 설정하고, validate 메서드에서 토큰 검증 성공 시 사용자 객체를 Request.user에 저장하여 이후 로직에서 활용할 수 있도록 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Session 인증</code>: 클라이언트의 상태 정보를 서버에 저장하여 다루는 기술이다. 사용자가 로그인하면 서버는 SessionID를 발급하여 서버의 세션 목록에 추가하고, 이 SessionID를 사용자의 브라우저 쿠키에 저장하여 통행증처럼 사용한다. 이후 요청 시 클라이언트가 SessionID를 보내면 서버는 이를 세션 목록에서 확인하여 접근을 허용한다. JWT와 달리 민감한 정보가 서버에 저장되어 비교적 안전하지만, 요청마다 서버에서 확인하는 작업이 필요하여 부하가 걸릴 수 있다. 추가로 이러한 지속적인 상태 정보 저장은 stateful 한 특성으로 통상적인 서버에 비해 보다 많은 자원이 필요시 될 수 있다.</li>
</ul>

<p>가드(Guard)는 NestJS에서 인가 처리에 핵심적인 역할을 수행하며, @UseGuards() 데코레이터를 사용하여 특정 라우트나 컨트롤러에 적용할 수 있다.</p>

<h3 id="42-데이터베이스-연동">4.2 데이터베이스 연동</h3>
<p>NestJS는 TypeORM, Prisma와 같은 다양한 ORM(Object-Relational Mapping) 도구와의 통합을 강력하게 지원하여 데이터베이스와의 상호작용을 간소화한다. ORM은 JavaScript 객체를 사용하여 관계형 데이터베이스의 테이블에 접근할 수 있게 해주어, SQL 쿼리 없이도 데이터를 다룰 수 있게 한다.</p>

<ul>
  <li>TypeORM: 다양한 데이터베이스 시스템을 지원하며, 코드의 일관성을 유지하면서 유연하게 데이터베이스를 다룰 수 있도록 돕는다. TypeOrmModule.forRoot()를 사용하여 데이터베이스 연결 설정을 초기화하고 엔티티 클래스를 지정한다. Prisma 에 비하면 비교적 고전적인 형태지만, 그만큼 다양한 서버 연결구조나 데이터베이스 시스템의 다양한 활용성을 보장하는 편에서 비교적 사용이 용이할 수 있다.</li>
  <li>Prisma: 현대적인 ORM 도구로, 높은 수준의 타입 안정성을 보장하면서 효율적인 데이터베이스 작업을 가능하게 한다. Rust로 작성된 쿼리 엔진을 사용하며, schema.prisma 파일을 통해 데이터 모델과 관계를 쉽게 정의할 수 있다. PrismaService를 생성하여 NestJS 모듈 시스템에서 Prisma Client를 초기화하고 데이터베이스에 연결할 수 있다. NoSQL 을 포함하여 다양하고 현대적인 연결을 제공하지만, 한 편으로 TypeORM 에 비하면 데이터베이스의 다양한 시스템에 대응되는 수준 까진 아닌 경우가 있어, 데이터베이스의 복잡한 사용에 대응하기 어려울 수 있다는 점은 감안해야한다.</li>
</ul>

<h3 id="43-데이터베이스-쿼리-최적화">4.3 데이터베이스 쿼리 최적화:</h3>
<p>성능이 중요한 백엔드 애플리케이션에서 데이터베이스 쿼리 최적화는 필수적이다.</p>

<ul>
  <li>인덱스 사용: 자주 쿼리되거나 WHERE 절에 사용되는 컬럼에 <code class="language-plaintext highlighter-rouge">인덱스를 추가하여 데이터베이스가 필요한 데이터를 빠르게 찾을 수 있도록</code> 한다.</li>
  <li>SELECT * 지양: 모든 컬럼을 선택하는 대신, <code class="language-plaintext highlighter-rouge">필요한 특정 컬럼만</code> 선택하여 반환되는 데이터의 양을 줄이고 쿼리 속도를 높인다.</li>
  <li>Eager Loading 활용: 연관된 엔티티를 자주 로드하는 경우, <code class="language-plaintext highlighter-rouge">Eager Loading</code>을 사용하여 여러 쿼리를 실행하는 대신 한 번에 모든 관련 데이터를 가져와 쿼리 수를 줄인다.</li>
</ul>

<h3 id="44-테스트-전략">4.4 테스트 전략</h3>
<p>NestJS는 효과적인 테스트를 포함한 개발 모범 사례를 장려하며, Jest를 기본 테스트 프레임워크로 권장한다. NestJS 프로젝트를 생성할 때 Jest가 함께 주입되어 단위 테스트 및 E2E 테스트를 위한 기본 도구를 제공한다. 테스트 환경에서 Nest의 의존성 주입 시스템을 활용하여 컴포넌트를 쉽게 모킹(Mocking)할 수 있다.</p>

<p>테스트는 범위에 따라 크게 세 가지 유형으로 나뉜다:</p>

<ol>
  <li>
    <p><strong>단위 테스트 (Unit Test)</strong>: 애플리케이션을 구성하는 가장 작은 단위 기능(예: 단일 함수, 클래스 메서드)에 대한 테스트이다. NestJS에서는 서비스와 같은 단위 기능에 대한 테스트를 Jest를 사용하여 작성한다.</p>
  </li>
  <li>
    <p><strong>통합 테스트 (Integration Test)</strong>: 애플리케이션을 구성하는 여러 모듈 간의 상호작용에 대한 테스트이다. 개발자의 관점에서 모듈 간의 연동이 의도대로 동작하는지 확인하는 데 초점을 둔다. NestJS는 @nestjs/testing 패키지의 Test 클래스를 사용하여 테스트 모듈을 생성하고 특정 인스턴스를 검색하여 통합 테스트를 용이하게 한다.</p>
  </li>
  <li>
    <p><strong>E2E 테스트 (End-to-End Test)</strong>: 최종 사용자의 관점에서 애플리케이션이 시나리오대로 전체적으로 작동하는지 확인하는 테스트이다. 외부로부터의 요청부터 응답까지 기능이 잘 동작하는지에 대한 테스트이며, 실제 사용자 경험을 시뮬레이션한다. test 디렉토리에 위치하는 것이 일반적이다.</p>
  </li>
</ol>

<p>테스트 코드를 작성하는 것은 개발 안정성, 유지보수의 용이성, 그리고 디버깅 시간 단축에 크게 기여한다.</p>

<h3 id="45-성능-최적화">4.5 성능 최적화</h3>
<p>NestJS 애플리케이션의 성능을 최적화하기 위한 다양한 기법들이 있다.</p>

<ul>
  <li><strong>캐싱 (Caching)</strong>: 자주 접근하는 데이터를 메모리에 임시로 저장하여 애플리케이션의 속도를 높이는 기법이다. NestJS는 cache-manager 라이브러리를 통해 캐싱 구현을 지원한다. 캐싱 시에는 적절한 만료 시간을 설정하고, 데이터 업데이트 시 캐시를 무효화하며, 여러 서버에서 실행되는 경우 분산 캐시를 사용하는 것이 중요하다.</li>
  <li><strong>압축 (Compression)</strong>: 애플리케이션과 클라이언트 간에 전송되는 데이터 양을 줄여 성능을 향상시키는 기법이다. NestJS에서는 compression 미들웨어를 사용하여 응답 데이터를 압축할 수 있다. 압축 수준을 적절히 설정하고, 모든 응답을 압축하며, CPU 집약적인 압축 작업을 캐싱하는 것을 고려해야 한다.</li>
  <li><strong>Fastify 런타임 활용</strong>: NestJS는 기본적으로 Express를 런타임으로 사용하지만, Fastify 프레임워크를 래핑하여 동작할 수도 있다. Fastify는 Express보다 훨씬 높은 성능을 제공하며, 특히 API 중심의 애플리케이션과 마이크로서비스에 적합하다. 벤치마크 테스트에 따르면, Fastify는 Express보다 초당 요청 처리량에서 5배 이상 빠른 성능을 보였다. 이는 Fastify가 효율성과 낮은 오버헤드에 중점을 둔 설계와 이벤트 기반 아키텍처, 스키마 기반 유효성 검증을 사용하기 때문이다. 고성능이 요구되는 백엔드 애플리케이션에서는 Fastify를 런타임으로 선택하는 것이 유리할 수 있다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>Express</th>
      <th>Fastify</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>요청 처리 속도 (RPS)</td>
      <td>약 20,000</td>
      <td>약 114,000 (5.6배 이상 빠름)</td>
    </tr>
    <tr>
      <td>메모리 사용량 (1만 동시 연결 시)</td>
      <td>약 150MB</td>
      <td>약 100MB</td>
    </tr>
    <tr>
      <td>내장 유효성 검증</td>
      <td>없음 (외부 라이브러리 필요)</td>
      <td>스키마 기반 내장 (Ajv 사용)</td>
    </tr>
    <tr>
      <td>내장 로깅</td>
      <td>없음 (외부 라이브러리 필요)</td>
      <td>내장 (Pino 사용)</td>
    </tr>
    <tr>
      <td>TypeScript 지원</td>
      <td>커뮤니티 유지보수 <code class="language-plaintext highlighter-rouge">@types/express</code></td>
      <td>네이티브 지원</td>
    </tr>
    <tr>
      <td>HTTP/2 지원</td>
      <td>없음 (외부 라이브러리 필요)</td>
      <td>네이티브 지원</td>
    </tr>
    <tr>
      <td>주요 특징</td>
      <td>단순성, 유연성, 광범위한 생태계</td>
      <td>효율성, 낮은 오버헤드, 내장 유효성 검증, 구조화된 플러그인</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Docker 최적화</strong>: NestJS 애플리케이션을 Docker 컨테이너로 배포할 때, Dockerfile 및 .dockerignore 파일 최적화를 통해 빌드 시간과 이미지 크기를 크게 줄일 수 있다. <code class="language-plaintext highlighter-rouge">.dockerignore</code> 파일을 사용하여 node_modules/, dist/, .git 등 빌드에 불필요한 파일과 디렉토리를 제외한다. 또한, 멀티스테이지 빌드를 사용하여 빌드 단계와 프로덕션 단계를 분리함으로써, <code class="language-plaintext highlighter-rouge">최종 이미지에는 필요한 파일과 설정만 포함되도록 하여</code> 이미지 크기를 대폭 감소시킬 수 있다. 이는 <code class="language-plaintext highlighter-rouge">CI/CD 파이프라인에서 빌드 및 배포 효율성</code>을 높이는 데 기여한다.</li>
</ul>

<h3 id="46-고급-활용-패턴-간략-소개">4.6 고급 활용 패턴 (간략 소개)</h3>
<p>NestJS는 견고하고 확장 가능한 애플리케이션을 구축하기 위한 다양한 고급 아키텍처 패턴과 모범 사례를 적용할 수 있도록 지원한다.</p>

<ul>
  <li><strong>순환 의존성 해결 (forwardRef())</strong>: 두 개 이상의 모듈이 서로를 참조하는 순환 종속성(Circular Dependency)은 애플리케이션 초기화 실패, 무한 루프 등의 문제를 야기할 수 있다. NestJS에서는 @nestjs/common 패키지에서 제공하는 forwardRef() 기능을 사용하여 클래스에 중첩을 허용함으로써 이러한 순환 종속성 문제를 해결할 수 있다. 그 외에도 Shared Module 전략 등을 통해 의존성을 해결해줄 수 있다.</li>
  <li><strong>클린 아키텍처 (Clean Architecture) 및 DDD</strong>: NestJS는 모듈 기반 아키텍처와 의존성 주입을 통해 클린 아키텍처(Clean Architecture) 또는 헥사고날 아키텍처(Hexagonal Architecture)와 같은 계층형 아키텍처 패턴을 쉽게 적용할 수 있다. 클린 아키텍처는 애플리케이션을 동심원 계층으로 구성하여 내부 계층이 외부 계층에 의존하지 않도록 하며, 비즈니스 로직(도메인 레이어)을 외부 기술(인프라 레이어)로부터 분리하여 유연성과 유지보수성을 극대화한다. 도메인 주도 설계(DDD)는 비즈니스 도메인에 초점을 맞춰 소프트웨어 엔티티와 도메인 개념을 일치시키는 접근법으로, NestJS의 모듈 시스템이 이를 쉽게 구현하도록 돕는다.</li>
  <li><strong>CQRS (Command Query Responsibility Separation)</strong>: CQRS 패턴은 명령(Command, 쓰기 작업)과 조회(Query, 읽기 작업)를 분리하여 성능, 확장성, 보안성을 높이는 아키텍처 패턴이다. 복잡한 도메인 모델에서 읽기 모델과 쓰기 모델을 다르게 가져갈 수 있어, 읽기 작업이 많은 애플리케이션에서 특히 유용하다. NestJS는 @nestjs/cqrs 패키지를 통해 CommandBus, EventBus, QueryBus를 제공하여 CQRS 패턴을 쉽게 구현할 수 있도록 지원한다.</li>
  <li><strong>이벤트 소싱 (Event Sourcing)</strong>: 이벤트 소싱은 애플리케이션 상태의 모든 변경 사항을 불변의 이벤트 시퀀스로 저장하는 아키텍처 패턴이다. 현재 상태만 저장하는 대신, 상태를 변경하는 모든 동작을 이벤트로 기록한다. @event-nest/core와 같은 라이브러리는 NestJS 애플리케이션에서 이벤트, 애그리거트(Aggregate), 도메인 구독을 관리하는 도구를 제공하여 이벤트 소싱 구현을 간소화한다. 이는 CQRS 및 DDD와 함께 사용될 때 강력한 시너지를 발휘한다.</li>
</ul>

<h2 id="5-결론-및-향후-학습-방향">5. 결론 및 향후 학습 방향</h2>
<p>스프링부트의 그것과 유사한, 그러나 동시에 Node 라는 특성을 갖고 있는 언어적 기반 덕에 비동기 처리 서버로 아주 사용하기 편리한 NestJS에 대해 알아보았다.</p>

<p>정리해봄으로써 각 구성 요소들의 의미나 의도, 그리고 제일 중요한 라이프사이클에 대한 부분은 다시 봐도 개발에 반드시 필요한 요소라는 사실을, 그리고 조금 만 더 이해도를 높이면 단순히 서버를 만든다를 넘어서 어떤 파이프라인을 타고, 어떤 구조로 CICD 까지 이룰 수 있을지 이해의 길이 좀더 열릴 것 같다는 생각이다. 확실히 이제는 단위 단위의 정리도 좋지만, 전체를 아우르는 한번에 내용을 읽고 정리하는 작업도 상당히 도움이 된다는 것을 새삼 느끼게 된다.</p>

<p>제미니가 제시해주는 1년차 개발자의 추가 학습 방향도 참고할 것이지만, 좀더 고난이도 개발자가 되기위해 노력해야할 필요성은 보이는 것 같다. 제미니를 통해 향후 작성하고 세부적으로 알아볼 생각이지만, 한 12개 정도 나온다고 하니, 한 주에 하나는 꾸준히 써야 할 것이리라 생각된다(…)</p>

<p>주말도 바쁜게 끝이 없다 😅</p>

<h2 id="참조-문헌">참조 문헌</h2>
<ol>
  <li><a href="https://stack94.tistory.com/entry/NestJS-NestJS-%EC%84%A4%EC%B9%98%EB%B6%80%ED%84%B0-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">NestJS 설치부터 기본 개념 알아보자 - 느린 개발자</a></li>
  <li><a href="https://f-lab.kr/insight/efficient-backend-architecture-with-nestjs">NestJS를 활용한 효율적인 백엔드 구조 설계 - F-Lab</a></li>
  <li><a href="https://velog.io/@zvoniti/NestJS-Design-Pattern">NestJS-Design Pattern - velog</a></li>
  <li><a href="https://deemmun.tistory.com/35">NestJS가 각광받고 있는 이유? / 파일 트리 구조 / 실제코드</a></li>
  <li><a href="https://velog.io/@kimhalin/NestJS-Project-Structure">NestJS &amp; Project Structure - velog</a></li>
  <li><a href="https://ts01.tistory.com/15">[초보자의 눈으로 보는 NestJS] 3. 모듈, 컨트롤러, 그리고 프로바이더</a></li>
  <li><a href="https://velog.io/@dev_0livia/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0-01">NestJS 모듈이란? - velog</a></li>
  <li><a href="https://velog.io/@naljajm/NestJs-%EB%AA%A8%EB%93%88-%EC%84%A4%EA%B3%84">[NestJs] 모듈 설계 - velog</a></li>
  <li><a href="https://dev-junwoo.tistory.com/m/162">[NestJs] 데코레이터,컨트롤러,서비스,모듈</a></li>
  <li><a href="https://tristy.tistory.com/38">[Nest Js] Nest Js 공식 문서 파헤치기 - 시작하기</a></li>
  <li><a href="https://www.rldnd.net/nestjs-modules-controllers-providers">Nest.js의 Modules, Controllers, Providers 알아보기</a></li>
  <li><a href="https://puddingcamp.com/topics/nestjs-modular-architecture-principles">Nest.js와 모듈식 아키텍처: 원칙과 모범 사례 - 푸딩캠프</a></li>
  <li><a href="https://velog.io/@zunzero/Nest.js-%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C-%EC%A0%95%EB%A6%AC">[Nest.js] 공식문서 정리 (Overview) - velog</a></li>
  <li><a href="https://velog.io/@cocorig/NestJS-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%98%88%EC%8B%9C-Services-NotFoundException">[NestJS] 데코레이터 개념과 예시 - velog</a></li>
  <li><a href="https://velog.io/@jujube0/NestJS%EB%A1%9C-REST-API-%EB%A7%8C%EB%93%A4%EA%B8%B0">NestJS로 REST API 만들기 - velog</a></li>
  <li><a href="https://velog.io/@hyein0112/NestJS%EC%97%90%EC%84%9C%EC%9D%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85Dependency-Injection">NestJS에서의 의존성 주입(Dependency Injection) - velog</a></li>
  <li><a href="https://choidr.tistory.com/entry/NestJS-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85">NestJS - 의존성 주입 - 두루미의 개발기록</a></li>
  <li><a href="https://velog.io/@tlsdntjd95/NestJS-DI-%EB%94%B0%EB%9D%BC%ED%95%B4%EB%B3%B4%EA%B8%B0">NestJS DI 따라해보기 - velog</a></li>
  <li><a href="https://cdragon.tistory.com/entry/NestJS-Docs-Testing-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0">[NestJS- Docs] Testing 알아보기 - 티스토리</a></li>
  <li><a href="https://develop-const.tistory.com/11">NestJs Custom decorator에 대해 알아보자 - 티스토리</a></li>
  <li><a href="https://cdragon.tistory.com/entry/NestJS-Custom-Decorators-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0">[NestJS - Docs] Custom Decorators 알아보기 - 티스토리</a></li>
  <li><a href="https://docs.nestjs.com/recipes/hot-reload">Hot reload - NestJS 공식 문서</a></li>
  <li><a href="https://artosalminen.github.io/posts/how-to-use-config-service-in-nestjs-bootstrap/">ConfigService를 bootstrap에서 사용하는 방법</a></li>
  <li><a href="https://www.rldnd.net/nestjs-lifecycle-">Nest.js의 LifeCycle(생명 주기)는 어떻게 되지?</a></li>
  <li><a href="https://github.com/nestjs/nest/issues/14773">Provider Dependencies 관련 NestJS GitHub 이슈</a></li>
  <li><a href="https://docs.nestjs.com/fundamentals/overview">NestJS Fundamentals Overview 공식문서</a></li>
  <li><a href="https://ru-nestjs-docs.netlify.app/faq/request-lifecycle">Request lifecycle - Netlify</a></li>
  <li><a href="https://dev.to/ngtrthvu3007/nestjs-request-lifecycle-2jhe">NestJS: Request Lifecycle - DEV.to</a></li>
  <li><a href="https://velog.io/@ldhbenecia/NestJS-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC-class-Validator">NestJS - 유효성 검사 class-Validator - velog</a></li>
  <li><a href="https://velog.io/@wlduq0150/Nest.js-exception-filter-%ED%8C%8C%ED%97%A4%EC%B9%98">[Nest.js] exception filter 파헤치기 - velog</a></li>
  <li><a href="https://mag1c.tistory.com/476">[NestJS] 예외처리, Exception Filter - 티스토리</a></li>
  <li><a href="https://grepper.tistory.com/178">NestJS - 대충 서비스 만들어보기 (14)</a></li>
  <li><a href="https://choi-records.tistory.com/entry/NestJS-JWT1-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EA%B5%AC%ED%98%84">[NestJS] JWT(1) 기본 개념, 구현 - 티스토리</a></li>
  <li><a href="https://suloth.tistory.com/77">로그인의 원리와 Guard(1) - 개념편</a></li>
  <li><a href="https://sjh9708.tistory.com/48">[NestJS] JWT 토큰 인가 - PassportStrategy/Guard 사용과 토큰 재발급</a></li>
  <li><a href="https://develop-const.tistory.com/19">NestJs 데이터베이스 연동하기 (mysql, typeorm) - 티스토리</a></li>
  <li><a href="https://custom-li.tistory.com/209">제로부터 시작하는 Prisma와 Nest.js - 티스토리</a></li>
  <li><a href="https://www.oneclickitsolution.com/centerofexcellence/nodejs/nestjs-prisma-integration-guide">Boost Your Nest.js Project with Prisma - OneClick</a></li>
  <li><a href="https://delvingdeveloper.com/posts/nestjs-performance-optimization-tips">NestJS Performance Optimization: Expert Tips - Delving Developer</a></li>
  <li><a href="https://coldpresso.tistory.com/13">Jest를 이용한 Unit/E2E 테스트 - 티스토리</a></li>
  <li><a href="https://velog.io/@cxzaqq/NESTJS%EB%A5%BC-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%9020-Testing">NESTJS를 배워보자(20) - Testing - velog</a></li>
  <li><a href="https://velog.io/@hing/NestJS-%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C-Testing">NestJS 공식문서 Testing - velog</a></li>
  <li><a href="https://www.brilworks.com/blog/optimize-your-nest-js-app-performance/">Optimize Your Nest.js App Performance - Brilworks</a></li>
  <li><a href="https://betterstack.com/community/guides/scaling-nodejs/fastify-express/">Express.js vs Fastify - Better Stack</a></li>
  <li><a href="https://www.cbtnuggets.com/blog/technology/programming/express-vs-fastify">Express vs. Fastify - CBT Nuggets</a></li>
  <li><a href="https://velog.io/@carrykim/Nestjs-CI-CD-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-Docker-%EC%B5%9C%EC%A0%81%ED%99%94-%ED%9A%8C%EA%B3%A0">Nestjs CI CD 프로젝트에서 Docker 최적화 회고 - velog</a></li>
  <li><a href="https://developer-gyakya.tistory.com/22">[NestJs] 순환 종속성 문제 - 티스토리</a></li>
  <li><a href="https://junho2343.github.io/posts/clean-architecture-hexagonal-architecture-with-nestjs">클린 아키텍처(헥사고날 아키텍처) 알아보기 with NestJS</a></li>
  <li><a href="https://github.com/0xTheProDev/nestjs-clean-example">nestjs-clean-example - GitHub</a></li>
  <li><a href="https://assu10.github.io/dev/2023/04/29/nest-clean-architecture/">NestJS - 클린 아키텍처 · ASSU BLOG.</a></li>
  <li><a href="https://velog.io/@naljajm/NestJs-CQRS-%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC">[NestJs] CQRS 관심사 분리 - velog</a></li>
  <li><a href="https://assu10.github.io/dev/2023/04/16/nest-cqrs/">NestJS - CQRS · ASSU BLOG.</a></li>
  <li><a href="https://www.npmjs.com/package/@event-nest/core">@event-nest/core - npm</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="NestJS" /><category term="TypeScript" /><category term="Node" /><summary type="html"><![CDATA[1. 서론: NestJS, 왜 선택해야 할까? NestJS는 Node.js 환경에서 효율적이고 확장 가능한 서버 사이드 애플리케이션을 구축하기 위한 진보적인 프레임워크다. 이 프레임워크는 Angular의 아키텍처에서 영감을 받아 개발되었으며, TypeScript를 기본 언어로 적극 지원한다는 특징을 가집니다. TypeScript의 강력한 타입 시스템은 개발 과정에서 발생할 수 있는 잠재적인 오류를 미연에 방지하고, 코드의 가독성과 안정성을 크게 향상시킨다.  ]]></summary></entry><entry><title type="html">docker는 흔들리고 있을까?</title><link href="http://0.0.0.0:4000/backend/2025/05/06/alternative-for-docker.html" rel="alternate" type="text/html" title="docker는 흔들리고 있을까?" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/05/06/alternative-for-docker</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/05/06/alternative-for-docker.html"><![CDATA[<h2 id="도커-왕좌를-지키지-못하는-이유-컨테이너-생태계의-지각변동">도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동</h2>

<p><img src="/assets/images/posts/2025-05/docker-wallpaper.jpeg" alt="" /></p>

<p>수년간 <strong>컨테이너 생태계의 중심에는 도커가 있었다</strong>. 사실 도커는 ‘대명사’가 되긴 했지만 원래 그 기술의 근간은 ‘컨테이너’라는 기술이다.</p>

<p>리눅스 기반 OS 에서 제공하는 기술로 <strong>컨테이너</strong>는 시스템의 나머지 부분으로부터 격리된 하나 이상의 프로세스 집합을 의미한다.</p>

<p>이러한 프로세스를 실행하는 데 필요한 모든 파일과 필수 라이브러리, 종속성이 개별 이미지 내에 함께 패키징된다. 한 마디로 정리하면, Host 에 해당하는 영역에서 공통적인 걸 가져오고, 실제 독립적인 시스템 구현을 위해 필요한 부분은 ‘레이어’ 라는 이름으로 별도로 이미지 내부에 장착시켜서 호스트와는 별개의 시스템이 마치 구동되는 듯 보이게 만들어준다.</p>

<p>컨테이너는 가상 머신과 달리 <strong>가상 머신보다 적은 리소스를 사용</strong>하면서도 애플리케이션 격리를 유지할 수 있다. 또한, 표준 인터페이스를 갖추고 있어 대규모 애플리케이션(여러 컨테이너)의 일부로 더 쉽게 관리될 수 있으며, 여러 클라우드에 걸쳐 오케스트레이션될 수 있다. 궁극적으로 컨테이너는 <strong>애플리케이션 개발, 배포, 관리 방식에서 이식성과 일관성을 유지시키며 발전</strong>시킨 기술이라고 볼 수 있다. 그리고 이러한 컨테이너를 활용하여 시스테메틱한 관리체계를 정립한 도커는 컨테이너의 대명사처럼 여겨졌다.</p>

<p>하지만 이제는 도커만의 독주 무대가 아니게 되어감을 종종 느끼게 된다. 도커는 여전히 인기가 있지만, 점점 더 많은 기업과 개발자들이 다른 대안으로 눈을 돌리고 있다는 점은 고려해볼만한 논지가 아닐까 한다. 이는 도커가 선택지에서 제외되었다는 것이 아닌 성능, 보안, 유연성, 비용 등 주요 측면에서 도커가 뒤처지거나, 대안이 있다 혹은 대안을 찾아야 한다는 인식이 확산되고 있는 것이다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0001.png" alt="" /></p>

<h3 id="도커가-가지는-현안들">도커가 가지는 현안들</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0002.png" alt="" /></p>

<ol>
  <li>
    <p><strong>라이선스 및 비용 구조 변경</strong></p>

    <p>가장 중요한 전환점 중 하나는 <strong>도커 데스크톱의 라이선스와 비용 구조 변경</strong>이다. 도커는 일정 규모 이상의 조직에 유료 멤버십을 요구하기로 결정했으며, 이전까지 무료로 사용하던 도구에 대해 기업들이 갑자기 비용을 지불해야 하는 상황이 발생했다.</p>

    <p>이러한 부분은 비용에 민감한 팀들이 <strong>도커에 대한 의존도를 진지하게 재평가</strong>하도록 만들게 된다. 오픈 소스 도구로 전환하고자 하는 이들이 대안을 모색하는 계기가 되었다.</p>
  </li>
  <li>
    <p><strong>성능 문제</strong></p>

    <p>도커는 리눅스에서는 뛰어난 성능을 가집니다. 물론, 이는 컨테이너라는 기술 자체의 본질적으로 리눅스 시스템 구조와 밀접한 연관성을 갖고 있다.</p>

    <p>하지만 문제는 이러한 편리함을 윈도우나 Mac 에서 사용하고자 하면서 여러 이슈가 발생하게 된다. 도커는 기본적으로 Host로 사용할 영역을 각각 WSL2, HyperKit 을 활용하는데, 이를 기반으로 하는 도커 데스크톱은 리눅스 컨테이너를 에뮬레이트하기 위해 가상 머신을 사용하기 때문에, 이로 인한 불가피한 <strong>성능 저하, 과도한 메모리와 CPU 사용 등의 문제가 발생</strong>할 수 있다.</p>

    <p>고질적인 윈도우 WSL Vmmem 이슈, 파일 시스템의 비정상적인 느림, IO 성능 저하, CPU 오버헤드 문제 등등… 알려진 문제들, 불편함은 이미 충분히 지적되고 있고, 이에 대한 개선은 수년째 언급 되고 있는 실정이다.</p>

    <p>특히나 무거운 빌드나 복잡한 멀티 컨테이너 구성에서는 문제가 더욱 심각해진다. 수겹의 레이어를 만들어야 하고, 그걸 위한 이미지들은 기존보다 훨씬 많은 양의 가상화를 위한 리소스를 필요로 한다.</p>

    <p>반면, 핀치(Finch)에서 사용하는 리마(Lima) 같은 신기술은 맥 개발자를 위해 최적화된 가상화 환경을 제공하여 도커 데스크톱의 복잡성 없이 성능을 개선합니다. 맥 성능을 극대화하는 것이 대체 런타임을 고려하는 또 하나의 이유다.</p>
  </li>
  <li>
    <p><strong>보안 문제</strong></p>

    <p>도커의 아키텍처는 켜보면 바로 알 수 있는 특징이 있다. 내부의 구동에서 <strong>루트 권한으로 실행되는 데몬에 의존</strong>하고 있다는 점이다. 그러나 이러한 점이 바로 보안의 문제냐? 라고 하면 그렇지는 않다고 생각한다. 오히려 개발 친화적이고, Host 로의 입구 관문이 존재하는 데, 각 내부에 더 많고, 두꺼운 보안은 불필요한 요소일 수 있다.</p>

    <p>하지만 이로 인해 운영 환경에서 <strong>보안 위협 노출이 넓어질 수 있다</strong>. 이러한 점에서 도커는 보안 기능을 추가했지만, 보안을 중시하는 조직들은 애초부터 보안을 고려해 설계된 대안들을 선호하는 경우가 생길 수 밖에 없다.</p>
  </li>
  <li>
    <p><strong>모노리틱 접근 방식</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0003.png" alt="" /></p>

    <p>클러스터링을 위한 스웜(Swarm)과 이미지 레지스트리를 위한 도커 허브(Docker Hub)가 밀접하게 결합된 도커의 모노리틱 구조는 적응하고 난 사용자에게는 매우 편리하게 느껴질 수 있다. 모든 것이 물 흐르듯, 일사천리로 움직이게 되고 이러한 구조는 설정과 이식에서 우수한 성능을 보여준다.</p>

    <p>하지만 <strong>현대 클라우드 네이티브 환경에서는 오히려 제약</strong>으로 다가오게 될 수 있다. 오늘날의 트렌드는 <strong>특화되고 모듈화된 도구들로의 전환</strong>이다. 오케스트레이션은 쿠버네티스(Kubernetes)가 완전히 지배하고 있으며, 패키징은 헬름(Helm)이 담당하고, 컨테이너드(containerd)와 같은 전용 컨테이너 런타임은 컨테이너 관리에만 집중해준다. 즉, 각 역할에 맞는 수준의 관리를 하고 통제가 가능하다는 것은, 전체의 조율과 모듈화에 오히려 도움이 되지, 도커의 통합적 관리는, 오히려 <strong>복잡성을 증가</strong>시킬 수 있다.</p>
  </li>
  <li>
    <p><strong>밴더 종속성 우려</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0005.png" alt="" /></p>

    <p>개발자들은 도커의 특정 도구에 지나치게 의존하는 것에 신중해지고 있다. 도커 파일 문법은 널리 사용되지만, OCI 이미지 및 런타임 요구 사항처럼 공개 표준에 의해 관리되는 것이 아니다. 개발자들은 <strong>단일 툴체인에 묶이는 것을 피하고 싶어 하며</strong>, 특히 공개 표준이 더 큰 유연성과 장기적인 안정성을 보장해 줄 수 있다는 주장은 언제나 그렇지만 지속적으로 강조된다. <strong>다양한 도구와 플랫폼 간의 호환성 보장, 이식성, 밴더 중립성 확보가 더욱 중요</strong>해졌고 그렇지 못한 대상에 대해선 기피하는 것이 어느 기업이나, 개발자들의 공통된 영역이리라.</p>
  </li>
</ol>

<h3 id="도커의-대안들-새로운-플레이어들의-등장">도커의 대안들: 새로운 플레이어들의 등장</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0004.png" alt="" /></p>

<p>이러한 배경 속에서 여러 컨테이너 런타임들이 인기를 얻고 있으며, 이들은 현대적인 컨테이너 네이티브 환경의 핵심 가치인 모듈화, 성능, 개방성을 반영하고 있다. 주목할 만한 대안들은 다음과 같다.</p>

<ul>
  <li><strong>Podman</strong>: 레드햇(Red Hat)에서 개발한 포드만은 <strong>안전하고 데몬이 없는 대체재</strong>로 평가받는다. 도커와 달리 중앙 데몬에 의존하지 않으며, <strong>루트 권한 없이 컨테이너를 실행할 수 있는 루트리스 환경을 적극 지원</strong> 한다. 명령어 인터페이스도 도커와 매우 유사하여 보안을 중시하는 팀이 쉽게 전환할 수 있다.</li>
  <li><strong>containerd</strong>: 원래는 도커의 일부였지만 분리되어 현재는 CNCF가 관리하는 독립 프로젝트다. 특히 <strong>쿠버네티스 1.24에서 도커에 대한 직접 지원이 중단된 이후</strong>로, <strong>컨테이너드는 대부분의 쿠버네티스 배포판에서 기본 컨테이너 런타임으로 사용</strong>되고 있다. AWS, 구글 클라우드, 애저와 같은 주요 클라우드 제공 업체들도 자체 관리형 쿠버네티스 서비스에서 컨테이너드를 기반으로 사용한다. 컨테이너 관리에 단일 목적을 가지고 있어 <strong>경량화되고 확장 가능</strong>하다는 특징이 가장 크다.</li>
  <li><strong>CRI-O</strong>: CRI-O 역시 CNCF에서 관리하며, <strong>쿠버네티스를 위해 특별히 설계</strong>되었다. 컨테이너 런타임 인터페이스(CRI)를 엄격히 준수하며, 불필요한 요소를 제거한 간결하고 목적에 맞는 환경을 유지해준다. 오직 쿠버네티스 워크로드만을 지원하기 때문에 보안 측면에서도 이점을 제공한다. 레드햇 오픈 시프트의 기본 런타임이며, 최소주의와 규정 준수를 중시하는 팀들에게 선호된다.</li>
  <li><strong>Lima 및 Finch</strong>: 맥OS 성능 문제를 해결하기 위한 도구들이다. <strong>Lima는 맥OS에서 컨테이너 빌드를 위한 리눅스 가상 머신을 구성</strong>해 주는 도구로 성능에 최적화된 환경을 제공한다. <strong>Finch는 AWS가 후원하는 프로젝트</strong>로 리마와 컨테이너드/너드컨트롤(nerdctl)을 기반으로 하여 <strong>도커 데스크톱을 대체할 수 있는 고성능 도구를 제공</strong>한다. <strong>라이선스 제약 없이 사용할 수 있다는 점</strong>이 큰 장점이며, 맥OS 개발자들 사이에서 <strong>네이티브에 가까운 성능</strong>을 제공하는 대안으로 빠르게 선호되고 있다.</li>
</ul>

<h3 id="컨테이너-생태계의-미래">컨테이너 생태계의 미래</h3>

<p>컨테이너 생태계 전반의 분위기는 현재 지속적으로 <strong>모듈화와 전문화로의 전환</strong>을 반영하고 있다. 그러한 상황에서 도커의 아쉬운 부분을 이야기 해봤으나, 사실 지속적인 개선이 이루어지고 있다. 2025년 1월에 쓰여진 글로, <a href="https://www.paolomainardi.com/posts/docker-performance-macos-2025/">Docker on MacOS is still slow?</a>라는 이 글만 보더라도 2년 전 분석에 비하면 Docker 의 File Synchronization 기능으로 성능 저하는 최소화 가능하며, 아직 베타지만 Docker VMM 등 대안, 대첵 등도 거론된다는 점에서 MacOS 가상화 환경과 native linux 성능 간 격차 개선을 통해 컨테이너 생태계와 Docker가 여전히 개발자들의 선택을 받게 될 것이라는 점은 확실해 보인다.</p>

<p>도커는 사라지는 것이 아니라 변화하고 있는 것이다. 그러나 컨테이너라는 기술을 기반으로 하는 영역은 현재 <strong>개방형 표준, 경량화된 런타임, 클라우드 네이티브 원칙을 중심으로 빠르게 진화</strong>하고 있다. 도커가 이제는 컨테이너의 절대적인 중심은 아닐 수 있지만, 여전히 중요한 역할을 수행할 것이다. 우리가 목격하고 있는 것은 도커가 만들어낸 생태계의 성숙이며, 이를 통해 개발자들은 더 다양한 선택지를 갖게 되었다는 점이다.</p>

<p>미래는 <strong>모듈형 구조를 갖고 설계 단계부터 개방성을 지향하며, 기본적으로 안전하고 다양한 워크플로우에 유연하게 대응할 수 있는 도구들을 선호</strong>하는 것은 자연스러운 흐름일 것이고, 이 흐름을 읽고 대비하는 필요는 있어 보인다고 생각이 든다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="Container" /><category term="Docker" /><summary type="html"><![CDATA[도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동]]></summary></entry><entry><title type="html">@types/~ 의존성을 설치하면 얻는 것</title><link href="http://0.0.0.0:4000/backend/2025/05/03/Type-library.html" rel="alternate" type="text/html" title="@types/~ 의존성을 설치하면 얻는 것" /><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>http://0.0.0.0:4000/backend/2025/05/03/Type-library</id><content type="html" xml:base="http://0.0.0.0:4000/backend/2025/05/03/Type-library.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>요 최근 MSA 서버 구현 공부를 다시 하고 있다. 영어 강의고, 상당히 난감한 번역의 자막이라 열은 받지만… 그럼에도 구조적 설계를 배울 수 있어서 좋다.</p>

<p>그러는 와중에 여전히 모르는게 많은 응애 개발자 답게, 모르는 라이브러리의 설치에 대한 내용이 남아 이렇게 적어본다.</p>

<h2 id="typebcrypt-가-뭐시여">@type/bcrypt 가 뭐시여..?</h2>
<p>MSA auth 구현을 하던 도중, 강사가 개발환경에서 좋다고 하여 설치를 했고, 그러나 개발환경..? 굳이 구분이 필요한가 라고 생각을 했었는데… 그게 아니었다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">@types/</code> 라이브러리들은 TypeScript 개발 환경에서 매우 중요한 역할을 합니다. 이 라이브러리들은 주로 <code class="language-plaintext highlighter-rouge">-D</code> 플래그(또는 <code class="language-plaintext highlighter-rouge">--save-dev</code>)를 사용하여 개발 의존성으로 설치됩니다. <em>- Claude 3.7</em></p>
</blockquote>

<p>해당 패키지들이 괜히 구분된게 아니라고, 실질적으로 나름의 역할하는 거였구나. 새삼 깨닫게 되었다. 😅</p>

<h3 id="types-라이브러리의-역할은">@types/ 라이브러리의 역할은</h3>

<ol>
  <li>
    <p><strong>타입 정의 제공</strong>: JavaScript로 작성된 라이브러리에 대한 TypeScript 타입 정의를 제공한다. JavaScript는 원래 타입이 없는 언어이기 때문에, TypeScript에서 이러한 라이브러리를 사용할 때 타입 정보가 필요하고 없을 경우 당연히 TypeConflict 로 고생할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 시 코드 자동완성과 IntelliSense</strong>: 개발 도구(VS Code 등)에서 코드 자동완성, 파라미터 힌트, 메서드 시그니처 등의 도움말을 제공한다. 따라서 편의성 향상에 매우 도움이 된다.</p>
  </li>
  <li>
    <p><strong>타입 체크</strong>: TypeScript 컴파일러가 코드의 타입 오류를 찾아내는 데 사용된다. 이는 런타임 전에 많은 버그를 발견하는 데 도움이 되어 안정성에 도움이 된다.</p>
  </li>
  <li>
    <p><strong>문서화</strong>: 라이브러리의 API가 어떻게 사용되어야 하는지에 대한 문서 역할도 한다. 타입 정의를 통해 함수의 매개변수, 반환 값 등의 정보를 확인할 수 있다.</p>
  </li>
</ol>

<h3 id="예시">예시</h3>

<p>예를 들어, Express.js를 TypeScript 프로젝트에서 사용하려면:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>express          <span class="c"># 실제 라이브러리 설치</span>
npm <span class="nb">install</span> <span class="nt">-D</span> @types/express <span class="c"># TypeScript 타입 정의 설치</span>
</code></pre></div></div>

<p>이렇게 하면 다음과 같은 TypeScript 코드를 작성할 수 있습니다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">@types/express</code>는 <code class="language-plaintext highlighter-rouge">req</code>와 <code class="language-plaintext highlighter-rouge">res</code> 객체의 타입, 그리고 <code class="language-plaintext highlighter-rouge">express()</code> 함수의 반환 타입 등을 제공한다.</p>

<h2 id="알아둬야-하는-핵심-포인트">알아둬야 하는 핵심 포인트</h2>

<ol>
  <li>
    <p><strong>개발 의존성으로 설치할 것</strong>: <code class="language-plaintext highlighter-rouge">-D</code> 플래그를 사용하여 개발 의존성으로 설치하는 이유는 이 타입 정의가 런타임에 필요하지 않고 개발 및 컴파일 시에만 필요하기 때문.</p>
  </li>
  <li>
    <p><strong>라이브러리 버전 일치</strong>: <code class="language-plaintext highlighter-rouge">@types/</code> 패키지의 버전은 가능한 한 실제 라이브러리 버전과 일치해야 한다.</p>
  </li>
  <li>
    <p><strong>DefinitelyTyped</strong>: 대부분의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지는 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 프로젝트에서 관리됩니다. 이는 커뮤니티가 관리하는 타입 정의 저장소다.</p>
  </li>
  <li>
    <p><strong>내장 타입</strong>: 일부 라이브러리는 자체적으로 타입 정의를 포함하고 있어서 별도의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지가 필요하지 않기도 하다. 예를 들어, React 16.8 이후 버전은 자체 타입 정의를 포함하고 있다.</p>
  </li>
</ol>

<h2 id="yarn으로-types-패키지-설치하기">Yarn으로 @types/ 패키지 설치하기</h2>
<p>학습 시에는 pnpm 을 사용하였으나, 현재 회사의 의존성으로 yarn 을 사용 중이다. yarn 에선 다음과 같이 사용해서 type 을 다운받으면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 라이브러리 설치</span>
yarn add express

<span class="c"># 타입 정의를 개발 의존성으로 설치</span>
yarn add <span class="nt">--dev</span> @types/express
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 단축 </span>
yarn add <span class="nt">-D</span> @types/express
</code></pre></div></div>

<h2 id="yarn에서-packagejson-의존성-구분">Yarn에서 package.json 의존성 구분</h2>

<p>npm과 마찬가지로 Yarn도 <code class="language-plaintext highlighter-rouge">package.json</code> 파일에서 의존성을 다음과 같이 구분합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.1"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"devDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"@types/express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.13"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="타입-지원-여부-확인-방법">타입 지원 여부 확인 방법</h2>

<p>이렇듯 유용하기도 하고, 있는지 확인해 보면 좋은 <code class="language-plaintext highlighter-rouge">@type/~</code>는 각 라이브러리 마다 존재하는지 확인해서 필요시 설치하면 되고, 있는지 여부는 아래와 같은 방법을 활용하자.</p>

<ol>
  <li>패키지 설치 후 직접 확인</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 간단한 테스트 파일 작성</span>
<span class="k">import</span> <span class="o">*</span> <span class="kd">as </span><span class="kr">package</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">package-name</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>이 코드를 작성했을 때:</p>
<ul>
  <li>타입 오류가 없다면, 라이브러리가 이미 타입을 내장하고 있습니다.</li>
  <li>“Could not find a declaration file for module ‘package-name’” 오류가 발생한다면, 타입 정의가 없다고 보면 됨</li>
</ul>

<ol>
  <li>패키지 문서 확인</li>
</ol>

<p>대부분의 패키지는 README나 공식 문서에 TypeScript 지원 여부를 명시하니 확인 할 것</p>
<ul>
  <li>“Written in TypeScript” 또는 “TypeScript support included”와 같은 문구</li>
  <li>설치 안내에 <code class="language-plaintext highlighter-rouge">@types/package-name</code> 설치 지침이 포함되어 있는지 확인</li>
</ul>

<ol>
  <li>패키지 소스 확인</li>
</ol>

<p>패키지의 <code class="language-plaintext highlighter-rouge">package.json</code> 파일을 확인합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"package-name"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"types"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">       </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typings"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typescript"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"definition"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ol>
  <li>NPM 페이지 확인</li>
</ol>

<p>NPM 웹사이트에서 패키지 페이지를 확인하세요. 패키지 파일 목록에 <code class="language-plaintext highlighter-rouge">.d.ts</code> 파일이 있으면 타입을 제공한다.</p>

<ol>
  <li>DefinitelyTyped 검색</li>
</ol>

<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped GitHub 저장소</a> 또는 <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a>에서 <code class="language-plaintext highlighter-rouge">@types/package-name</code>이 있는지 확인한다.</p>

<ol>
  <li>자동화된 도구 사용</li>
</ol>

<h4 id="typescript-auto-importer-확장-프로그램">TypeScript-Auto-Importer 확장 프로그램</h4>

<p>VS Code의 <code class="language-plaintext highlighter-rouge">TypeScript-Auto-Importer</code>와 같은 확장 프로그램은 사용 가능한 타입 정의를 자동으로 감지한다.</p>

<h4 id="npx-typescript-check-esm-사용"><code class="language-plaintext highlighter-rouge">npx typescript-check-esm</code> 사용</h4>

<p>이 도구는 프로젝트 의존성의 TypeScript 호환성을 검사한다.</p>

<h4 id="typed-npm-registry-사용"><code class="language-plaintext highlighter-rouge">typed-npm-registry</code> 사용</h4>

<p>이 웹사이트에서 패키지 이름을 검색하여 타입 지원 여부를 확인 가능: https://www.typedregistry.com/</p>

<h3 id="실용적인-워크플로우">실용적인 워크플로우</h3>

<ol>
  <li>먼저 기본 패키지만 설치 함: <code class="language-plaintext highlighter-rouge">yarn add package-name</code></li>
  <li>코드에서 임포트해보고 오류가 발생하는지 확인</li>
  <li>오류가 발생하면 <code class="language-plaintext highlighter-rouge">@types</code> 패키지 존재 여부를 확인:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn info @types/package-name
<span class="c"># 또는</span>
npm view @types/package-name
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@types</code> 패키지가 존재하면 설치: <code class="language-plaintext highlighter-rouge">yarn add -D @types/package-name</code></li>
</ol>

<h2 id="마치며">마치며</h2>
<p>확실히 사용해보니, 없을 때 보다 공식 설명이 더 풍부한 경우가 많고, 객체, 타입에 대한 설명이 상세 해지는 걸 보니, 개발 시 무언가 추가 시 신경 써서 넣어두거나, 기본적으로 갖춰 둔 템플릿을 활용하면 좋을 것 같다.</p>

<p>이런 거 보면 아직 짬이 덜 찬 느낌이 든다. 🫥</p>

<p>개발의 길은 멀고, 아주 멀고, 아주 멀다. 😖</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="TypeScript" /><category term="Backend" /><summary type="html"><![CDATA[Intro]]></summary></entry></feed>