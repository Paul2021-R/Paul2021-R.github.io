<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-09-05T07:24:39+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">42 Seoul - 000_libft</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-00.html" rel="alternate" type="text/html" title="42 Seoul - 000_libft" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-00</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-00.html"><![CDATA[<h2 id="-libft-c-언어와의-첫-만남-나만의-라이브러리-만들기">🚀 Libft: C 언어와의 첫 만남, 나만의 라이브러리 만들기</h2>

<p>개발에 답은 없다. 왜냐면 개발이란 그렇기 때문이다.</p>

<p>도구들은 다양하고, 그 도구들의 어떤 연결이 얼마나 복잡하고, 최적화되며, 그걸 통해 동일한 결과라도 놀라운 결론에 도달하는가. 특히나 단 한 사람의 이야기가 아니라, 여러 사람들의 협업이 되면 그 때부터 개발은 단순히 ‘만든다’의 영역에서 ‘예술’까지도 넘볼 수 있는 꽤나 그럴 싸한 작품이 된다.</p>

<p>42 프랑스를 거쳐, 42 서울은 그런 철학을 인정한다.</p>

<p>그렇기에 답은 없고, 그저 모두에게 제공되는 것은 단 하나의 명제였다. 문제는 줄게, 답은 너가 찾아봐. 그리고 동료들과 그 과정을 치밀하게, 은밀하게, 그리고 치열하게 고민해봐.</p>

<p>다시 후기를 작성하게 된 지금 이순간에도 42서울의 그 가치는, 그 과정은 개발이 왜 매력적이고, 이제는 왜 ‘나에게 맞는 일이다’ 라고 생각하게 되었는가를 다시 한 번 느끼게 만든다.</p>

<p>그렇기에 <code class="language-plaintext highlighter-rouge">ft(forty two)</code>라는 키워드는 유난히 익숙하지만, 동시에 ‘뭔지 모를 느낌’을 주는 키워드이며, 그런 키워드와 함께 시작하는 <code class="language-plaintext highlighter-rouge">libft</code>라는 과제는 42 서울에서의 내 첫 번째 프로젝트이자, C언어의 깊은 물에 처음으로 발을 담갔던 순간으로 기억한다.</p>

<p>오픈 소스라는 키워드는 만드는 행위의 평등함을 추구했고, 그 와중에 생겨난 리눅스라는 시스템과 그 철학은 커져가면서 현대 컴퓨팅의 정수이다. 그리고 그런 리눅스의 표준, 기반들은 처음에 보기엔 생소했다. 왜 굳이 이런걸? 이라고 그때 당시에는 생각했지만, 지금 생각해보면 결국 지금, 양자 컴퓨팅에, AI 등 온갖 키워드의 시발점이 단어 하나를 메모리에 올리는 작업에서 비롯되었음을 깨달았다는 점에서 개발자들에게 컴퓨터의 이해는 어디서 오는가? 한다면 바로 여기서부터라고 자신있게 말할 수 있을 것이다.</p>

<p>C 표준 라이브러리 함수들을 직접 내 손으로 구현해야 했던 이 과제는, 마치 C언어의 심장부를 해부하는 것과 같은 경험이었다. 수많은 밤을 <code class="language-plaintext highlighter-rouge">man</code> 페이지와 함께 지새우며, 포인터와 메모리 주소와 씨름, printf 를 로직의 위치 위치마다 찍어보던 그 과정… 지금 생각하면 얼마나 고통스러웠는지 모른다.</p>

<p>이 프로젝트는 단순히 함수를 베끼는 것이 아니라, 그 작동 원리, 컴퓨터의 소통 방식을 근본부터 이해하고, 나만의 코드로 재창조하는 과정이었다.</p>

<h2 id="-주요-학습-내용-key-learnings">📚 주요 학습 내용 (Key Learnings)</h2>

<p><code class="language-plaintext highlighter-rouge">libft</code> 프로젝트는 크게 세 부분으로 나눌 수 있다.</p>

<p>표준 라이브러리 함수를 구현하는 <strong>Part 1</strong>,</p>

<p>조금 더 복잡하고 유용한 함수들을 만드는 <strong>Part 2</strong>,</p>

<p>그리고 연결 리스트(Linked List)를 다루는 <strong>Bonus</strong> 파트</p>

<h3 id="1-표준-라이브러리-함수-재구현-re-implementing-standard-library-functions">1. 표준 라이브러리 함수 재구현 (Re-implementing Standard Library Functions)</h3>

<p>여기서는 C 언어를 기반으로 리눅스 시스템이 사용하는 언어의 특징, 그리고 그 언어를 통해 다시 사람의 명령을 어떻게 표현하면 될지, OS 가 어떻게 이해하는지를 가장 기본적으로 이해하는 방법을 배웠다.</p>

<ol>
  <li><strong>메모리 다루기 (<code class="language-plaintext highlighter-rouge">&lt;string.h&gt;</code> 등)</strong>: <code class="language-plaintext highlighter-rouge">memset</code>, <code class="language-plaintext highlighter-rouge">memcpy</code>, <code class="language-plaintext highlighter-rouge">memmove</code> 같은 함수들을 만들면서 포인터와 메모리에 대한 이해가 깊어졌다. 특히 <code class="language-plaintext highlighter-rouge">memcpy</code>와 <code class="language-plaintext highlighter-rouge">memmove</code>의 차이점, C 언어의 메모리 사용 방식에 따라, 메모리 오버랩(overlap) 문제가 발견하고, 어떻게 해결하는지를 배웠다. “아니, 그냥 복사하면 되는 거 아냐?” 싶은데, 주소 값이 겹칠 때의 그 미묘한 차이를 이해하고, C 언어라는 걸 기반으로 무언가를 만든다고 하는 것은, 언어의 정해진 특성들을 기반으로 어떤 한계가 생기는지 처음 이해했던 순간이었다.</li>
  <li><strong>문자열 갖고 놀기 (<code class="language-plaintext highlighter-rouge">&lt;string.h&gt;</code> 등)</strong>: <code class="language-plaintext highlighter-rouge">strlen</code>, <code class="language-plaintext highlighter-rouge">strlcpy</code>, <code class="language-plaintext highlighter-rouge">strlcat</code>, <code class="language-plaintext highlighter-rouge">strchr</code>, <code class="language-plaintext highlighter-rouge">strncmp</code> 등등… C언어에서 문자열이 사실상 <code class="language-plaintext highlighter-rouge">char</code> 배열이며, 자료 타입들은 결국 이러한 데이터열의 연속임을 배웠다. 특히 문자열의 편집 과정에서, 데이터의 ‘단위’를 위한 <code class="language-plaintext highlighter-rouge">NULL</code> 문자의 중요성과 버퍼 오버플로우(buffer overflow)를 방지하기 위한 <code class="language-plaintext highlighter-rouge">strlcpy</code>의 소중함 등을 느낄 수 있는 시간이었다.</li>
  <li><strong>문자 판별과 변환 (<code class="language-plaintext highlighter-rouge">&lt;ctype.h&gt;</code> 등)</strong>: <code class="language-plaintext highlighter-rouge">isalpha</code>, <code class="language-plaintext highlighter-rouge">isdigit</code>, <code class="language-plaintext highlighter-rouge">isalnum</code> 같은 함수들은 비교적 간단했지만, 컴퓨터가 사람의 언어를 표현하는 아스키 문자 등에 대해 완벽한 이해가 필요 했다.</li>
  <li><strong>문자열을 숫자로 (<code class="language-plaintext highlighter-rouge">&lt;stdlib.h&gt;</code> 등)</strong>: 가장 난이도 있는 영역이었는데, <code class="language-plaintext highlighter-rouge">atoi</code>를 구현하면서 온갖 예외 케이스(공백, 부호, 숫자 아닌 문자 등)가 왜 생기는지, 그리고 특히나 동료 학습을 통해 이런 예외 처리가 얼마나 중요한지를(…) 뼈저리게 깨달았던 기억이난다.</li>
</ol>

<h3 id="2-나만의-유틸리티-함수-구현-implementing-additional-utility-functions">2. 나만의 유틸리티 함수 구현 (Implementing Additional Utility Functions)</h3>

<p>Part 1이 ‘모방’의 단계였다면, Part 2는 ‘창조’의 단계였다. 주어진 명세에 따라 Part 1에서 만든 아주 기초 단위의, 메모리 상의 데이터 하나를 수정하거나, 데이터를 다른 데이터 형식으로 바꾸는 등의 기술을 배웠으니, 이것들을 래핑(wrapping) 해보는 것을 요구했다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ft_split</code></strong>: 이 녀석이 아마 최종 보스 였을 것이다. 😂 문자열을 특정 구분자(delimiter) 기준으로 쪼개서 2차원 배열에 담아 반환하는 함수인데, 메모리 동적 할당과 당시 배열의 관점, 특히 차원을 가지고 배열을 만드는 것이 머릿속에 구조화가 전혀 되지 않아(…) 정말 어려웠다. 할당해야 할 메모리의 크기를 정확히 계산하고, 오류가 났을 때 이미 할당된 메모리를 모두 해제(<code class="language-plaintext highlighter-rouge">free</code>)해주는 누수(leak) 방지 처리까지… 컴퓨터가 깨끗하게 일을 시작해, 마무리 짓기까지 정말 많은 걸 배울 수 있었던 함수였다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ft_itoa</code></strong>: 정수를 문자열로 바꾸는 이 함수는 <code class="language-plaintext highlighter-rouge">INT_MIN</code> 같은 극단적인 케이스를 처리하는 게 핵심이었다. 사실 split 을 어려워하여 먼저 했었는데, 결국 각 자료타입이 표현할 수 있는 숫자의 양, 그리고 위에서 언급한 케이스들 조사를 하면서 정말 많이 틀렸었던 기억이 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ft_substr</code>, <code class="language-plaintext highlighter-rouge">ft_strjoin</code>, <code class="language-plaintext highlighter-rouge">ft_strtrim</code></strong>: 문자열을 자르고, 합치고, 특정 문자를 제거하는 등, 전에는 단순히 메서드 하나가 하나의 전체 작업을 담당하고 있었다면 그것을 구분하고, 단계를 구성하는 연습을 이 메서드들 기반으로 처음 해봤던 기억이난다.</li>
</ul>

<h3 id="3-보너스-연결-리스트-다루기-handling-linked-lists">3. 보너스: 연결 리스트 다루기 (Handling Linked Lists)</h3>

<p>배열까지는 접근했으나, 다음을 살짝 맛볼 수 있는 기회가 해당 보너스 내용이었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_list</span>
<span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">content</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_list</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>					<span class="n">t_list</span><span class="p">;</span>
</code></pre></div></div>

<p>추상화된 개념, ‘노드’는 꽤나 신선했다. 머릿속에서, 혹은 수학이나 과학에서 사용되는 개념의 캡슐을 만들고, 그 캡슐을 활용한 추상적인 표현을 오히려 구조로 만드는 과정. 그렇게 되었을 때, 단순한 수식으로 풀어 내려면 복잡할 수 있는 것을 좀더 가시적으로 인지하기 용이하게 만든다는 개념은, 수포자였던 나에게는 대단히 신선한 충격이었다.</p>

<p>이처럼 간단한 구조체로 노드(node)를 만들고, 그 노드들을 엮어서 리스트를 만들고, 새로운 노드를 추가하고(<code class="language-plaintext highlighter-rouge">lstnew</code>, <code class="language-plaintext highlighter-rouge">lstadd_front</code>, <code class="language-plaintext highlighter-rouge">lstadd_back</code>), 리스트를 순회하고(<code class="language-plaintext highlighter-rouge">lstiter</code>), 삭제하는(<code class="language-plaintext highlighter-rouge">lstdelone</code>, <code class="language-plaintext highlighter-rouge">lstclear</code>) 등… 연결 리스트의 기본적인 모든 것을 구현했을 때, 더 복잡한 문제나 데이터의 처리를 훨씬 빠르게 대응하는게 가능했다. 특히 <code class="language-plaintext highlighter-rouge">t_list **lst</code>처럼 이중 포인터를 사용해서 리스트의 시작 주소 자체를 변경해야 했던 <code class="language-plaintext highlighter-rouge">ft_lstadd_front</code> 같은 함수는 포인터에 대한 이해도를 한 단계 끌어올려준 기억이었다.</p>

<h2 id="️-makefile의-마법-the-magic-of-makefile">🛠️ Makefile의 마법 (The Magic of Makefile)</h2>

<p>프로그래밍, 코딩만 하다보면 잊는 경우도 많고, 특히 요즘은 인터프리팅 언어를 많이 쓰게 되다보니 잊고 살았지만. 본 과제에서는 C 코드뿐만 아니라 <code class="language-plaintext highlighter-rouge">Makefile</code> 작성법을 제대로 배운 첫 경험이기도 했다. 단순히 <code class="language-plaintext highlighter-rouge">gcc</code> 명령어를 나열하는 것을 넘어, 변수를 사용하고, <code class="language-plaintext highlighter-rouge">%.o: %.c</code> 같은 규칙을 만들고, <code class="language-plaintext highlighter-rouge">all</code>, <code class="language-plaintext highlighter-rouge">clean</code>, <code class="language-plaintext highlighter-rouge">fclean</code>, <code class="language-plaintext highlighter-rouge">re</code>, <code class="language-plaintext highlighter-rouge">bonus</code> 같은 목표(target)를 설정하면서 빌드 자동화를 지정하여 컴퓨터가 이해할 수 있는 목적 파일을 만들어낸다. 이 과정을 통해 만들어진 <code class="language-plaintext highlighter-rouge">libft.a</code>라는 정적 라이브러리(static library)는 그 뒤로 C 언어를 사용하는 동안 유용한 도구가 되어 주었다.</p>

<h2 id="-성찰-및-배운-점-reflection--lessons-learned">🤔 성찰 및 배운 점 (Reflection &amp; Lessons Learned)</h2>

<p><code class="language-plaintext highlighter-rouge">libft</code> 과제를 동료들과 이야기 하고, 메모리나, 추상적 개념을 설명하거나, Makefile에 아스키 이펙트를 넣는 등의 작업은 정말 재밌는 작업이자, 시간 가는 줄 모르는 작업이었다.</p>

<ul>
  <li><strong>메모리, 그리고 포인터</strong>: C가 왜 강력하고, 동시에 왜 위험한 언어인지 몸소 체험했다. 내가 직접 메모리를 할당하고 해제하면서 왜 그리 문제가 되고, 실제로 다른 언어들을 쓰게 되는 이유가 뭔지를 알 수 있었다.</li>
  <li><strong>문제 해결 능력</strong>: <code class="language-plaintext highlighter-rouge">man</code> 페이지를 친구 삼아, 수많은 오류와 세그폴(segmentation fault)을 디버깅하면서 끈질기게 문제를 파고들었다. 특히 man 페이지는 영어로 되어 있기도 하고 개발자의 언어로 적혀 있다보니 ‘간결’ 하지만 동시에 어느 영역에서 얼마나 이 메서드가 움직이는 건가? 와 같은 내용들을 다 파악할 수 없다는 점에서 첫 과제는 대략 1달의 시간이 들었다.</li>
  <li><strong>코드 규약(Norm)</strong>: 42의 엄격한 코드 스타일 규약(Norminette)이란 것도 일종의 불만 이었다. 몇자 내에 작성이 되어야하고, 언어의 컨벤션을 지켜야 하는 등의 일들은 도대체 왜 그렇게까지 필요한가 라고 의문을 품었었는데, 지금 생각하면 얼마나 중요한 ‘프로세스’였는지를 새삼 느낄 수 있다.</li>
</ul>

<p>돌이켜보면 <code class="language-plaintext highlighter-rouge">libft</code>는 단순한 과제가 아니라, C언어라는 세계를 탐험하기 위한 나만의 지도와 나침반을 만드는 과정이었어. 비록 힘들었지만, 이 프로젝트를 통해 얻은 지식과 경험은 앞으로 어떤 어려움이 닥쳐도 헤쳐나갈 수 있는 단단한 기초가 되어주었다. 특히나 정말 빠른 친구들은 순식간에 완성시키고 다른 과제를 하곤 했다. 그걸 바라보는 내 입장에선 참 당연히 비교적인 생각, 내가 정말 이 분야에 어울리는 사람인가? 하는 불평, 불만도 생겼지만 오히려 끝까지 붙잡고 한달에 걸쳐 완성했던 내 프로젝트를 통해, ‘하면 된다’라는 막연하지만 확고한 신뢰감이 생겼던 첫 프로젝트가 아니었나 싶다. 💪</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🚀 Libft: C 언어와의 첫 만남, 나만의 라이브러리 만들기]]></summary></entry><entry><title type="html">42 Seoul - 001_get_next_line</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-01.html" rel="alternate" type="text/html" title="42 Seoul - 001_get_next_line" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-01</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-01.html"><![CDATA[<h2 id="-get_next_line-상태를-기억한다는-것의-의미">📄 Get_Next_Line: ‘상태’를 기억한다는 것의 의미</h2>

<p>만약 컴퓨터에게 기억이 없다면 어떻게 될까? 모든 연산은 그저 일회성으로 끝나고, 방금 전에 했던 작업을 다시 이어가는 것은 불가능할 것이다. <code class="language-plaintext highlighter-rouge">libft</code>가 C언어의 문법과 메모리 조작이라는 ‘행위’에 집중하는 과제였다면, <code class="language-plaintext highlighter-rouge">get_next_line</code>(이하 GNL)은 컴퓨터가 어떻게 ‘상태(state)’를 기억하고 연속적인 작업을 처리하는지에 대한 깊은 통찰을 요구하는, 완전히 새로운 차원의 도전이었다.</p>

<p>“파일에서 한 줄씩 읽어오라”는 명제는 단순해 보였다. 하지만 이내 깨달았다. 이것은 단순히 파일을 읽는 기술을 넘어, ‘시간’이라는 축 위에서 데이터의 흐름을 제어하고, 함수의 생명주기를 뛰어넘는 ‘기억’을 구현해야 하는 문제라는 것을. C언어의 저수준(low-level) 파일 입출력과 씨름하며, <code class="language-plaintext highlighter-rouge">static</code>이라는 키워드에 담긴 철학을 비로소 이해하게 된 여정이었다.</p>

<h3 id="-핵심-개념-정복하기-conquering-core-concepts">🧠 핵심 개념 정복하기 (Conquering Core Concepts)</h3>

<p>GNL의 세계로 들어가기 위해선, 컴퓨터의 가장 기본적인 소통 방식을 먼저 이해해야 했다.</p>

<h4 id="1-파일-디스크립터file-descriptor-추상화의-첫걸음">1. 파일 디스크립터(File Descriptor): 추상화의 첫걸음</h4>

<p>우리가 키보드를 두드리고, 모니터를 보고, 파일을 읽는 모든 행위는 운영체제(OS)의 눈에는 그저 ‘데이터의 흐름’일 뿐이다. OS는 이 복잡한 장치들을 <code class="language-plaintext highlighter-rouge">0</code>(표준 입력), <code class="language-plaintext highlighter-rouge">1</code>(표준 출력), <code class="language-plaintext highlighter-rouge">2</code>(표준 에러)와 같은 정수 번호로 단순화하여 우리에게 제공한다. 이것이 바로 <strong>파일 디스크립터(FD)</strong>다. <code class="language-plaintext highlighter-rouge">open()</code> 함수를 통해 파일을 열면, OS는 새로운 번호표를 발급하며 “자, 이제 이 번호로 파일과 소통해”라고 말해주는 것과 같다. GNL은 이 번호표 하나에 의지해 거대한 파일의 내용을 한 줄씩 탐험하는 항해사와 같았다.</p>

<h4 id="2-read와-buffer_size-경계-위의-줄타기">2. <code class="language-plaintext highlighter-rouge">read()</code>와 <code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>: 경계 위의 줄타기</h4>

<p>GNL의 유일한 무기는 <code class="language-plaintext highlighter-rouge">read</code> 함수였다. 이 함수는 <code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>라는 정해진 크기만큼만 데이터를 가져온다. 여기서 GNL의 본질적인 딜레마가 시작된다. 우리가 읽으려는 ‘한 줄’이라는 개념은 지극히 인간적인 단위이지만, 컴퓨터는 그저 바이트(byte)의 흐름으로 세상을 본다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>가 한 줄보다 작으면, 개행 문자(<code class="language-plaintext highlighter-rouge">\n</code>)를 만날 때까지 여러 번 <code class="language-plaintext highlighter-rouge">read</code>를 호출해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>가 한 줄보다 크면, 한 줄을 읽고도 데이터가 버퍼에 남는다.</li>
</ul>

<p>바로 이 ‘남아버린 데이터’를 어떻게 처리할 것인가? 이번 호출에서 남은 데이터를 다음 호출을 위해 어딘가에 고이 보관해두어야만 했다. 함수가 호출되고 끝나는 찰나의 순간을 넘어, 다음을 기약하는 ‘기억’이 필요했다.</p>

<h4 id="3-마법의-키워드-static-함수에-영혼을-불어넣다">3. 마법의 키워드, <code class="language-plaintext highlighter-rouge">static</code>: 함수에 영혼을 불어넣다</h4>

<p>이 문제의 해답은 바로 <code class="language-plaintext highlighter-rouge">static</code> 변수에 있다. ✨</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">get_next_line</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">backup</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수가 끝나면 사라지는 일반 지역 변수와 달리, <code class="language-plaintext highlighter-rouge">static</code> 변수는 프로그램이 시작될 때 단 한 번 메모리에 할당되어 프로그램이 끝날 때까지 자신의 값을 유지한다. 즉, GNL 함수가 수십, 수백 번 호출되어도 <code class="language-plaintext highlighter-rouge">backup</code> 변수는 마치 어제의 일을 기억하는 사람처럼, 이전에 읽고 남겨둔 데이터를 간직하고 있는 것이다.</p>

<p>이 <code class="language-plaintext highlighter-rouge">static</code> 변수 <code class="language-plaintext highlighter-rouge">backup</code>에 <code class="language-plaintext highlighter-rouge">read</code>로 읽어온 내용을 계속 이어 붙이고(<code class="language-plaintext highlighter-rouge">strjoin</code>), 개행 문자를 발견하면 그 앞부분까지를 세상에 내보내고(<code class="language-plaintext highlighter-rouge">return</code>), <code class="language-plaintext highlighter-rouge">backup</code>에는 개행 문자 뒤의 나머지 약속을 담아두는 것. 이 로직을 깨달았을 때, 나는 비로소 함수에서 아주 기본적인 ‘상태’라는 걸 보관하는 방법을 배울 수 있었다.</p>

<h3 id="️-나의-gnl-구현기-my-gnl-implementation-journey">🛠️ 나의 GNL 구현기 (My GNL Implementation Journey)</h3>

<p>그러나 알다시피 머리로 이해하는 것과 손으로 구현하는 것은 천지 차이다.</p>

<ol>
  <li><strong>읽고, 쌓고, 또 쌓고</strong>: <code class="language-plaintext highlighter-rouge">read</code> 함수가 더 이상 읽을 것이 없을 때까지, 또는 개행을 만날 때까지 반복문을 돌았다. <code class="language-plaintext highlighter-rouge">backup</code>이라는 공간에 <code class="language-plaintext highlighter-rouge">BUFFER_SIZE</code>만큼의 벽돌을 계속해서 쌓아 올리는 과정이었다. 이 과정에서 <code class="language-plaintext highlighter-rouge">ft_strjoin</code>은 나의 든든한 시멘트가 되어주었다.</li>
  <li><strong>자르고, 내보내고</strong>: 마침내 개행이라는 이정표를 만나면, 그곳까지의 길을 잘라내어 결과로 반환한다.</li>
  <li><strong>기억하고, 준비하고</strong>: 그리고 가장 중요했던 단계. <code class="language-plaintext highlighter-rouge">backup</code> 변수에는 잘라내고 남은 나머지 부분을 담아, 다음 호출의 시작점이 될 수 있도록 준비시켰다. 이 과정에서 수없이 터져 나오는 메모리 누수(leak)를 막기 위해 <code class="language-plaintext highlighter-rouge">free</code>와 사투를 벌였다. 정말 이 부분에서 생길 수 있는 에러, 특히 반복되는데 내가 놓치지 않으려면 구조적으로 생각해야 했고, C언어가 왜 그토록 정교한 메모리 관리를 요구하는지 온몸으로 깨달았다. (정말이지, 세그폴 화면은 다시 보고 싶지 않다… 😇)</li>
</ol>

<h3 id="-보너스-여러-개의-기억을-동시에-bonus-multiple-states-at-once">✨ 보너스: 여러 개의 기억을 동시에 (Bonus: Multiple States at Once!)</h3>

<p>필수 파트의 GNL은 <code class="language-plaintext highlighter-rouge">static</code> 변수 하나에 의존하기에, 오직 하나의 기억(파일)만 유지할 수 있었다. 하지만 보너스 파트는 <code class="language-plaintext highlighter-rouge">여러 파일을 동시에 열고</code>, 각 파일의 읽기 상태를 독립적으로 기억하라는 더 높은 차원의 과제를 제시했다.</p>

<p>하나의 뇌로는 여러 사람의 기억을 동시에 관리할 수 없듯, <code class="language-plaintext highlighter-rouge">static</code> 변수 하나로는 부족했다. 해결책은 ‘기억의 목록’을 만드는 것이다.</p>

<p>파일 디스크립터(FD)를 열쇠 삼아, 각 열쇠에 맞는 <code class="language-plaintext highlighter-rouge">backup</code> 데이터를 저장하는 배열(<code class="language-plaintext highlighter-rouge">static char *backup[OPEN_MAX]</code>)이나 연결 리스트를 활용했다.</p>

<p>GNL이 특정 <code class="language-plaintext highlighter-rouge">fd</code>와 함께 호출되면, 우리는 기억의 목록에서 해당 <code class="language-plaintext highlighter-rouge">fd</code>에 맞는 기억을 꺼내 작업을 이어간다는 것을 구조화 하는 것이 관건이었다.</p>

<h3 id="-성찰-및-배운-점-reflection--lessons-learned">🤔 성찰 및 배운 점 (Reflection &amp; Lessons Learned)</h3>

<p>GNL은 나에게 ‘보이지 않는 것을 다루는 법’을 가르쳐줬다.</p>

<ul>
  <li><strong>상태 관리의 본질</strong>: 파일 입출력을 넘어, ‘상태’라는 추상적인 개념을 어떻게 코드 레벨에서 구체화하고 유지하는지 깊이 이해하게 되었다. 이는 나중에 웹 서버가 수많은 클라이언트의 연결 상태를 기억하거나, UI 프레임워크가 컴포넌트의 이전 상태를 기억하는 등 모든 프로그래밍의 근간이 되는 원리였다. 이제는 정말 다양한 도구나, 개념이 있고, 사실 조금 더 곰곰히 생각해보면 ‘static’이 내부에 당연히 녹아 있겠지만, 이제는 다소 구식(….) 방법임을 새삼 느끼긴한다. 그러나 결국 최적화가 필요하고, 데이터를 더 고속으로, 더 빠르게 처리해야한다면 어쩌면 다시 끄집어낼 기회가 오지 않을까, 그렇게 생각해본다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">static</code>의 철학</strong>: <code class="language-plaintext highlighter-rouge">static</code>은 단순한 C언어의 키워드가 아니었다. 함수의 생명주기를 초월하여 데이터를 보존하는, C언어가 제공하는 가장 원시적이면서도 강력한 상태 관리 도구임을 깨달았다. 그때는 얼마나 빠른가? 이걸 기반으로 꽤나 호들갑을 떨었던(…) 기억이 난다.</li>
  <li><strong>디버깅과의 처절한 사투</strong>: 끝없이 터지는 메모리 누수와 세그폴은 나를 좌절시켰지만, 동시에 메모리의 할당과 해제의 흐름을 집요하게 추적하는 인내심과 문제 해결 능력을 길러주었다. 그게 핵심이기도 했다. 특히 보너스를 하게 되면, FD 의 관리가 병렬로 진행되는데, 조건이 추가될 수록 당연히 기존 내용을 두고, 다른 내용을 찾아온다는 작업이 이제는 머릿속에 그려지기에 어디서 뭘 잡아야 하는가? 를 기억하지만, 그땐 정말 힘들었다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">get_next_line</code>은 한 줄의 문장을 읽어낸다라고 쉽게 이야긴 했지만, 핵심은 상태를 저장하고, 어떤 비즈니스 로직을 거치고, 또 거기서 여러 파일을 다룬다면 어떤 과정으로 작업을 왔다 갔다 할 수 있는지, 그 논리적 로직이 뭔지를 실질적으로 배우는 기회였다고 생각한다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[📄 Get_Next_Line: ‘상태’를 기억한다는 것의 의미]]></summary></entry><entry><title type="html">42 Seoul - 02_born2beroot</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-02.html" rel="alternate" type="text/html" title="42 Seoul - 02_born2beroot" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-02</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-02.html"><![CDATA[<h2 id="-born2beroot-시스템의-주인이-된다는-것">🐧 Born2beroot: 시스템의 주인이 된다는 것</h2>

<p>GUI의 안락한 유저 인터페이스 뒤편, 모든 것이 날것의 텍스트로 존재하는 세상이 있다. <code class="language-plaintext highlighter-rouge">libft</code>와 <code class="language-plaintext highlighter-rouge">get_next_line</code>이 C언어라는 도구를 날카롭게 벼리는 과정이었다면, <code class="language-plaintext highlighter-rouge">born2beroot</code>는 그 도구를 들고 그곳의 법칙을 세우는 ‘설계자’의 역할을 경험하는 것을 요구한 첫 과제였다. 지금 생각해보면 Ops 영역을 처음으로 맛본게 아닐가 싶다.</p>

<p>이 과제는 단순한 서버 구축 기술을 배우는 것을 넘어선다. 사용자의 입장에서 시스템이 ‘제공하는’ 기능을 수동적으로 사용하던 관점에서 벗어나, 시스템의 모든 요소를 직접 제어하고 책임지는 관리자의 시점으로 전환하는 근본적인 패러다임의 변화를 경험하게 했다.</p>

<p>약간 가오를 잡는 역할을(ㅋㅋ) 하게 해주기도 하고, 검은 화면의 커서 깜빡임은 더 이상 공포의 대상이 아니라, 시스템과 직접 대화하는 강력하고 정밀한 언어임을 깨닫는 여정이었다. OS 라는 바탕, GUI 뒤에서 동작하는 실제 OS 라는 것을 이해하는 기회가 이 과제에서 첫 삽을 떳다고 볼수 있었다.</p>

<h3 id="-시스템-아키텍트의-청사진-무無에서-유有를-창조하다">📜 시스템 아키텍트의 청사진: 무(無)에서 유(有)를 창조하다</h3>

<p><code class="language-plaintext highlighter-rouge">born2beroot</code>의 목표는 명확했다. 우선 OS 라는 것을 이해한다. 그리고 그 바탕에서 가상 머신이라는 격리된 공간을 또 다시 이해한다.</p>

<p>환경을 설정한다는 것이 가지는 리스크를 최소화하는 방법을 배우고 나면, 데비안(Debian) 리눅스 서버를 오직 명령줄 인터페이스(CLI)만을 사용하여 요구사항에 맞춰 구축한다.</p>

<p>이는 마치 건축가가 허허벌판에 건물을 올리듯, 디스크 파티셔닝으로 기초 공사를 하고, 사용자 계정으로 골조를 세우며, 보안 정책과 방화벽으로 견고한 외벽을 쌓아 올리는 과정이었다.</p>

<p>모든 결정에는 이유 물음표를 띄워졌으며,모든 명령어는 시스템에 영구적인 흔적을 남기는 만큼, 이 과제를 하던 이들, OS 를 모르는 이들에게는 과정 하나 하나가 통곡의 반복을 이어나가야 했다.</p>

<h3 id="-핵심-과업들-단순한-설정을-넘어-원리를-이해하다">🔑 핵심 과업들: 단순한 설정을 넘어 원리를 이해하다</h3>

<p>과제를 수행하며 마주한 핵심 과업들은 시스템 관리의 근간을 이루는 개념들을 담고 있다.</p>

<ol>
  <li><strong>LVM(Logical Volume Manager) 파티셔닝</strong>: 물리적인 디스크의 한계를 넘어 논리적으로 공간을 분할하고 관리하는 방법을 배웠다. 이는 하드웨어를 소프트웨어적으로 추상화하여 유연성과 확장성을 확보하는, 현대 스토리지 관리의 핵심 원리를 체득하는 과정이었다. 고정된 칸막이(기본 파티션)가 아닌, 필요에 따라 늘이고 줄일 수 있는 가변적인 공간(논리 볼륨)의 개념을 이해하게 되었다. 또한 이러한 파티셔닝의 목표는 하드웨어 구축 시 특정 영역의 OS 의 역할에 따라 적절하게 대응하고, 보다 복잡한 시스템이라면 특정 하드웨어를 사용하는 등을 고려하고, 이를 통해 최적의 환경을 구축하거나 위험한 상황에 대응하여 서비스가 지속될 수 있는 방법이 무엇인지 배우는 아주 기초적 단편을 이해할 수 있었다.</li>
  <li><strong>강력한 암호 정책 (PAM)</strong>: <code class="language-plaintext highlighter-rouge">/etc/pam.d/common-password</code> 파일을 수정하며 사용자의 비밀번호 규칙을 강화하는 것은, 시스템 보안의 첫걸음이자 가장 중요한 원칙인 ‘선제적 방어’의 개념을 배우는 것이다. 복잡성, 주기적 변경, 재사용 금지 등의 규칙은 외부의 위협을 막는 최소한의 방어선이며 이를 OS 차원에서 어떻게 하는지, 리눅스 시스템은 무엇을 활용하는지 배울 수 있었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo</code> 권한 관리</strong>: <code class="language-plaintext highlighter-rouge">sudoers</code> 설정을 통해 최고 관리자(root) 권한의 사용을 통제하고 기록하는 것은 ‘최소 권한 원칙(Principle of Least Privilege)’을 실현하는 과정이었다. 모든 <code class="language-plaintext highlighter-rouge">sudo</code> 명령어 실행 시도를 로그로 남기는 것은 시스템의 모든 관리 행위에 대한 ‘감사 추적(Audit Trail)’의 중요성을 일깨워주었다. 지금은 이해하고 있지만, 시스템 내에서 동작하는 프로세스는 OS 의 주인인 유저가 동작시키기도 하지만, 시스템 구축 과정에서 이러한 권한을 제한된 계정으로 만들어 사용하게 만듦으로써 그 계정이 할 수 있는 동작의 한계를 지정하고, 이를 통해 시스템 전체에 대한 제한을 제공하는 것은, Ops 차원의 상당한 노하우임을 나중에 깨달았다.</li>
  <li><strong>SSH 포트 변경 및 UFW 방화벽 설정</strong>: 서버 개발과 관리, 유지보수 차원에서 본다면 원격의 접속은 가장 필수이자 기본이 된다. 그러나 이를 정해져있는데로 활용하는 것은 자칫 보안의 구멍을 만들 수 있다. SSH 포트(22)를 비표준 포트(4242)로 변경하고 UFW를 통해 해당 포트만 허용하는 작업은, 시스템의 ‘대문’을 지키는 가장 기본적인 보안 조치였다. 이는 무차별적인 자동화 공격(Brute-force attack)의 표적이 될 가능성을 낮추고, 허가된 경로 외의 모든 접근을 차단하는 ‘화이트리스트’ 기반 보안 모델의 기초를 다지는 경험이었다.</li>
  <li><strong>사용자 및 그룹 관리</strong>: 사용자를 생성하고 <code class="language-plaintext highlighter-rouge">user42</code> 및 <code class="language-plaintext highlighter-rouge">sudo</code> 그룹에 소속시키는 과정은, 역할 기반 접근 제어(RBAC, Role-Based Access Control)의 개념을 이해하게 했다. 각 사용자에게 필요한 최소한의 권한만을 부여함으로써, 시스템의 안정성을 높이고 잠재적인 보안 위협을 줄일 수 있음을 배웠다. 3번과 함께 생각해볼 여지가 있던 영역이었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">monitoring.sh</code> 스크립트와 <code class="language-plaintext highlighter-rouge">cron</code></strong>: 시스템 구축이나 사용에서 정말 핵심 중에 하나. 스크립트를 작성하고 이를 활용해 시스템 단계에서 각 프로세스들을 관리하는 기능은 지금도 흥미진진한 주제였다. 여기서는 주기적으로 서버의 상태를 보고하는 셸 스크립트를 작성하고 <code class="language-plaintext highlighter-rouge">cron</code>으로 자동화하는 것을 통해 시스템을 살아있는 유기체처럼 지속적으로 관찰하는 ‘모니터링’을 만들어보았다. 이는 문제가 발생했을 때 사후에 대응하는 것을 넘어, 시스템의 상태를 능동적으로 파악하고 예측하는 인프라 관리의 기본 자세를 길러주었다.</li>
</ol>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p>옛날 옛적, Windows Vista를 쓰던 시절 난 학생이었다.
무슨 변덕일까 윈도우 대신 새로운걸 경험해보고 싶다면서 OS 를 우분투를 깔아본 적도 있었다.
그때는 CLI 라는 개념이 뭔지도 모르는 상태로, GUI 없이 명령어를 쳐서 최적화 하는 작업은 그냥 아무것도 모르고 치면 되는 ‘전문가’들의 영역이라고 생각했다.
또한 그때 OS 는 어찌보면 좋은 성능의 새롭고 신선한 그림이 나오는 ‘게임기’ 취급을 했었다(ㅋㅋ)</p>

<p>그런데 <code class="language-plaintext highlighter-rouge">born2beroot</code>과제를 하면서 OS 를 다시 이해하자, 체계란게 뭐고, 개발에서 어떻게 활용하는가, 이런 부분을 꽤나 알 수 있었다.</p>

<ul>
  <li><strong>관점의 전환 (사용자에서 관리자로)</strong>: 더 이상 나는 시스템이 정해준 규칙 안에서 움직이는 사용자가 아니었다. 시스템의 규칙을 직접 만들고, 그 결과에 책임을 지는 관리자의 무게를 느끼며, 컴퓨터와의 관계가 근본적으로 재정의되었다.</li>
  <li><strong>CLI는 언어다</strong>: 처음 마주했을 때의 막막함과 달리, CLI는 시스템의 내부 구조와 직접 소통할 수 있는 가장 강력하고 효율적인 언어임을 깨달았다. 마우스 클릭으로는 결코 닿을 수 없는 깊이까지 시스템을 제어할 수 있는 힘을 얻었다.</li>
  <li><strong>모든 개발의 기초 체력</strong>: 서버 위에서 애플리케이션이 동작하는 한, 개발자는 운영체제로부터 자유로울 수 없다. 이 과제를 통해 다진 네트워크, 보안, 사용자 권한, 파일 시스템에 대한 이해는, 향후 어떤 애플리케이션을 개발하든 문제의 근본 원인을 파악하고 해결할 수 있는 단단한 기초 체력이 되어주었다.</li>
  <li><strong>신비로운 서버의 첫 걸음</strong>: 기본 세팅, 거기에 워드프레스를 설치하는 등의 작업으로 해놓고, 호스트에서 포트포워딩으로 접근하는 작업, 그렇게하여 웹 사이트가 딱 떴을 때 그 감각은 서버, 서빙이란게 뭔지 처음으로 제대로 이해한 순간이었다.</li>
</ul>

<p>결론적으로 <code class="language-plaintext highlighter-rouge">born2beroot</code>는 단순한 서버 세팅 가이드가 아니었다. 그것은 개발자로서 내가 서 있는 땅, 즉 운영체제라는 기반을 두 발로 직접 딛고 이해하게 만든, 진정한 의미의 ‘뿌리 내리기’ 과정이었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="Linux" /><category term="DevOps" /><summary type="html"><![CDATA[🐧 Born2beroot: 시스템의 주인이 된다는 것]]></summary></entry><entry><title type="html">42 Seoul - 003_printf</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-03.html" rel="alternate" type="text/html" title="42 Seoul - 003_printf" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-03.html"><![CDATA[<h2 id="️-ft_printf--데이터의-표현을-책임진다는-것의-의미">🖨️ ft_printf : 데이터의 ‘표현’을 책임진다는 것의 의미</h2>

<p>우리가 프로그래밍 세계에 입문하며 가장 먼저 배우는 주문은 아마 <code class="language-plaintext highlighter-rouge">printf("Hello, World!");</code>일 것이다.</p>

<p>너무나 당연하게, 마치 공기처럼 사용해왔던 이 함수는 컴퓨터 내부의 추상적인 데이터(숫자, 주소)를 인간이 인지할 수 있는 ‘문자’의 형태로 번역해주는 마법과도 같다.</p>

<p>처음, 디버그 툴을 배우기 전에 가장 쉽게, 가장 많이 쓰는 디버깅 툴도 보통 print 계열이리라.</p>

<p><code class="language-plaintext highlighter-rouge">born2beroot</code>가 시스템이라는 땅을 이해하는 과정이었다면, <code class="language-plaintext highlighter-rouge">ft_printf</code>는 그 땅 위에서 오가는 데이터의 ‘표현’을 직접 설계하고 책임지는, 언어의 번역가가 되어보는 과제였다.</p>

<p>이 과제의 핵심은 <strong>‘정해지지 않음’</strong>을 다루는 데 있다. 컴파일 시점에는 몇 개의 인자가, 어떤 타입으로 들어올지 전혀 알 수 없는 상황.</p>

<p>C언어의 엄격한 타입 시스템에 살짝 열린 뒷문을 통해, 함수의 호출 규약(Calling Convention)과 스택 메모리의 작동 방식을 어렴풋이나마 엿보며, 유연함의 대가가 얼마나 큰 책임감을 요구하는지(…) 알게 되는 과정이였다.</p>

<p>사실 이 과제를 먼저 해야 하는 것이었음에도, born2beroot 를 먼저 하게 된 이유도, 실질, 이 프로젝트가 가지는 방대함, 고려해야하는 우선순위 등 기존의 과제들과 격이 다른 수준의 것이었음이 가장 큰 문제였다.</p>

<h3 id="-가변-인자의-이해-약속과-신뢰의-메커니즘">🎩 가변 인자의 이해: 약속과 신뢰의 메커니즘</h3>

<p><code class="language-plaintext highlighter-rouge">ft_printf</code>의 구현은 <code class="language-plaintext highlighter-rouge">&lt;stdarg.h&gt;</code> 헤더에 정의된 매크로들을 이해하는 것에서 시작된다. 이는 단순한 기능 습득이 아니라, 함수를 호출하는 쪽과 호출되는 쪽 사이의 보이지 않는 ‘약속’을 이해하는 과정이었다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">va_list</code>, <code class="language-plaintext highlighter-rouge">va_start</code>, <code class="language-plaintext highlighter-rouge">va_arg</code>, <code class="language-plaintext highlighter-rouge">va_end</code>: 이 네 가지 도구는 컴파일러가 스택에 차례대로 쌓아둔 인자들을, 프로그래머가 제공한 ‘서식 문자열’이라는 지도를 보고 올바른 크기(타입)만큼씩 순서대로 읽어 나갈 수 있게 해주는 메커니즘이다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">printf</code> 함수는 서식 지정자 <code class="language-plaintext highlighter-rouge">%d</code>를 보고 “다음에 올 인자는 int 크기만큼 읽어야겠군”이라고 <strong>신뢰</strong>하고 <code class="language-plaintext highlighter-rouge">va_arg</code>를 실행한다. 만약 이 신뢰가 깨지면(예: <code class="language-plaintext highlighter-rouge">%d</code>에 <code class="language-plaintext highlighter-rouge">char*</code>를 전달), 프로그램은 곧바로 정의되지 않은 동작(Undefined Behavior)의 나락으로 떨어진다.</p>

<h3 id="-서식-지정자-파싱-작은-언어의-해석기interpreter-만들기">🧩 서식 지정자 파싱: 작은 언어의 해석기(Interpreter) 만들기</h3>

<p>처음 기본적인 메서드의 구조는 <code class="language-plaintext highlighter-rouge">ft_printf</code>의 본질은 서식 문자열(format string)이라는 작은 언어를 해석하고, 그에 맞는 동작을 수행하는 작은 해석기를 만드는 것과 같았다.</p>

<ol>
  <li><strong>문자열 순회 및 분기</strong>: 프로그램은 전달받은 서식 문자열을 루프를 통해 한 글자씩 읽다가, 제어 문자인 <code class="language-plaintext highlighter-rouge">%</code>를 만나면 해석기 모드로 전환된다. 이후 따라오는 문자에 따라 어떤 종류의 ‘번역’을 수행할지 결정해야 했다.</li>
  <li><strong>데이터 타입별 번역</strong>:
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">s</code>, <code class="language-plaintext highlighter-rouge">%</code></strong>: 가장 기본적인 번역. 데이터를 그대로 표현하거나(<code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">s</code>), 제어 문자를 일반 문자로 탈출(<code class="language-plaintext highlighter-rouge">%%</code>)시키는 역할을 담당했다. 특히 <code class="language-plaintext highlighter-rouge">s</code> 처리 시 <code class="language-plaintext highlighter-rouge">NULL</code> 포인터가 들어오는 예외 상황을 어떻게 다룰지는 ‘안정성’에 대한 첫 번째 시험대였다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">u</code></strong>: 2진수로 저장된 정수 데이터를 10진수 문자열로 변환하는 핵심적인 번역 과정. <code class="language-plaintext highlighter-rouge">libft</code>에서 만든 <code class="language-plaintext highlighter-rouge">ft_itoa</code>를 활용하고, 부호 없는 정수(<code class="language-plaintext highlighter-rouge">unsigned int</code>)를 처리하며 컴퓨터의 숫자 표현 범위를 다시 한번 상기하게 되었다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">X</code></strong>: 10진법에 익숙한 인간의 시각을 16진법으로 바꾸는 번역. 이는 메모리 주소나 비트 연산 결과를 확인할 때 왜 16진법이 유용한지에 대한 실용적인 이해로 이어졌다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">p</code></strong>: 가장 추상적인 개념인 ‘메모리 주소’를 눈에 보이는 16진수 문자열로 시각화하는 번역. 이는 포인터라는 개념을 단순한 변수가 아닌, 실제 물리 메모리 상의 한 점을 가리키는 구체적인 값으로 인지하게 만들었다.</li>
    </ul>
  </li>
</ol>

<h3 id="️-코드-구조화의-여정-기능에서-설계로">🏗️ 코드 구조화의 여정: 기능에서 설계로</h3>

<p>초기 버전은 거대한 <code class="language-plaintext highlighter-rouge">if-else</code> 혹은 <code class="language-plaintext highlighter-rouge">switch</code> 문 안에 모든 변환 로직을 담으려는 시도를 했다. 하지만 이는 곧 유지보수의 재앙으로 이어진다는 것을 빠르게 깨달았다.</p>

<p>‘처리’의 단위를 처음에는 어차피 비슷한 기능들의 나열이고, 그러니 전체를 모든 로직에서 처리하게 하는 구조는, 어쩌면 사람의 인식에서는 당연한 것이다. 노션에 로직을 설계하던 당시, 얼마나 괜찮다고 느꼈는지- 생각보다 자신감있게 그 설계를 괜찮다고 동료들에게도 자랑했던 기억이 난다.</p>

<p>하지만 위에서 말한 듯 재앙이 될 수 있다는 사실은 명확했다. 메서드로 구분되지 못하고, if-else, switch 의 사용은 결국 한 단어, 한 글자마다 조건문을 도는 것이었고, 수 많은 예외 케이스들을 만나는 순간 어디서 어떤 에러가 나는지를 알기가 매우 까다로웠다.</p>

<p>심지어 같은 로직이라고 생각하는 조건들도, 결국 겹치고 얽히다보면 논리적으로 빈틈이 생기는 경우도 있었고, 이러한 사실은 <code class="language-plaintext highlighter-rouge">메서드</code> 로 구분을 하고, 로직을 모듈화 하는 것이 왜 중요한지, 그리고 그 논리의 단위를 얼마나 <code class="language-plaintext highlighter-rouge">작게</code> 해야 하는지 아주 중요한 부분을 배울 수 있는 기회였다고 생각한다.</p>

<p>또한 저장 및 출력을 할 때 서식 지정자를 만날 때마다 <code class="language-plaintext highlighter-rouge">write</code> 시스템 콜을 직접 호출하는 방식과, 출력할 문자열 조각들을 자료구조(연결 리스트 등)에 담아두었다가 마지막에 한 번에 출력하는 방식 사이에서 고민하다가 성능의 차이를 느껴 직접 호출하는 방식으로의 개선되는 과정 등…</p>

<p>단순히 ‘기능 구현’을 넘어 ‘효율적인 설계’에 대한 아주 큰 고민들의 첫 문턱이 아니었나 싶다. 이 프로젝트까지 와서야 비로소 복잡한 문제를 잘게 나누어 정복하는 소프트웨어 공학의 기본 원칙을 체득할 수 있었다.</p>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">ft_printf</code>는 매일 사용하던 도구의 내부를 분해하고 재조립해보는 소중한 경험이었다.</p>

<ul>
  <li><strong>추상화의 이면</strong>: <code class="language-plaintext highlighter-rouge">printf</code>라는 편리한 추상화 계층 덕분에 데이터가 어떻게 ‘표현’되는지에 대한 고민 없이 개발할 수 있었다. 그 이면에는 가변 인자 처리, 데이터 타입 변환, 예외 처리 등 수많은 복잡한 과정이 숨어있음을 알 수 있었다.</li>
  <li><strong>신뢰 기반의 프로그래밍</strong>: C언어의 가변 인자 기능은 타입 체크를 컴파일러가 아닌 프로그래머의 책임으로 돌린다. 이는 유연함을 제공하는 대신, 사소한 실수가 프로그램 전체를 무너뜨릴 수 있는 위험성을 내포하고 있음을, 즉 C언어가 프로그래머를 얼마나 신뢰하는(혹은 방임하는) 언어인지 몸소 체험했고, 그렇기에 어떻게 대응해두는 것, 에러 핸들링을 어떤 식으로 하는 것으로 시스템 전체의 안전성을 유지할 수 있는지를 배우는 기회가 되었다.</li>
  <li><strong>문제 분할의 중요성</strong>: 하나의 거대한 문제를 ‘파싱’, ‘정수 변환’, ‘16진수 변환’ 등 작고 명확한 단위의 함수로 나누는 과정은, 이후 더 복잡한 프로젝트를 마주했을 때 어떻게 접근해야 하는지에 대한 훌륭한 훈련이 되었다.</li>
</ul>

<p>결론적으로 <code class="language-plaintext highlighter-rouge">ft_printf</code>는 단순히 문자열을 출력하는 함수를 만드는 과제가 아니었다. 컴퓨터 내부의 비트(bit) 덩어리를 인간이 이해할 수 있는 의미 있는 정보로 ‘번역’하고 ‘표현’하는 책임이 전적으로 프로그래머에게 있음을 깨닫게 한, 개발자로서의 책임감과 시야를 한 단계 넓혀준 프로젝트였다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🖨️ ft_printf : 데이터의 ‘표현’을 책임진다는 것의 의미]]></summary></entry><entry><title type="html">42 Seoul - 004_Minitalk</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-04.html" rel="alternate" type="text/html" title="42 Seoul - 004_Minitalk" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-04</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-04.html"><![CDATA[<h2 id="-minitalk--신호signal로-쌓아-올린-통신의-규약protocol">📢 Minitalk : 신호(Signal)로 쌓아 올린 통신의 규약(Protocol)</h2>

<p><code class="language-plaintext highlighter-rouge">printf</code>가 데이터의 ‘표현’을 다루는 과제였다면, <code class="language-plaintext highlighter-rouge">Minitalk</code>는 한 걸음 더 나아가, 분리된 프로세스들 사이에 어떻게 ‘의미’를 전달할 수 있는지에 대한 근본적인 질문을 던진다.</p>

<p>이 과제의 요구사항은 지극히 미니멀리즘하다: 네트워크 소켓 없이, 오직 두 종류의 유닉스 시그널(<code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR2</code>)만을 이용해 문자열을 전송하라.</p>

<p>본래 시그널은 프로세스를 중단시키거나(<code class="language-plaintext highlighter-rouge">SIGINT</code>), 특정 상태를 알리는 등 단방향의 강제적인 ‘사건(Event)’을 통지하기 위한 원시적인 메커니즘이자 OS 단에서 제공하는 안전 장치이다.</p>

<p><code class="language-plaintext highlighter-rouge">Minitalk</code>는 이 제약 조건을 역으로 이용하여, 가장 혼란스럽고 원시적인 통신 수단 위에 어떻게 질서정연한 ‘규약(Protocol)’을 세우고 안정적인 통신 채널을 구축할 수 있는지 온몸으로 증명해야 하는, 시스템 프로그래밍의 정수가 담긴 과제였다.</p>

<h3 id="-통신의-첫-단추-약속convention의-탄생">💡 통신의 첫 단추: 약속(Convention)의 탄생</h3>

<p>모든 통신은 ‘약속’에서 시작한다. <code class="language-plaintext highlighter-rouge">Minitalk</code>의 세계에서는 두 개의 시그널이 알파벳의 역할을 맡는다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SIGUSR1</code>은 비트(bit) <strong>0</strong>을 의미한다.</li>
  <li><code class="language-plaintext highlighter-rouge">SIGUSR2</code>는 비트(bit) <strong>1</strong>을 의미한다.</li>
</ul>

<p>이 지극히 단순한 약속 하나가 무질서한 신호에 의미를 부여하는 첫걸음이다.</p>

<p>시그널을 받으면, 이에 따라 프로세스가 OS 단의 개입을 인지하게 되고, 그 결과로 약속된 신호의 모음을 보내준다.</p>

<p>예를 들어 문자 ‘A’(ASCII 65, 이진수 <code class="language-plaintext highlighter-rouge">01000001</code>)를 보내는 행위로</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR2</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR1</code>, <code class="language-plaintext highlighter-rouge">SIGUSR2</code></p>
</blockquote>

<p>와 같은 8개의 시그널을 순차적으로 발신하는 행위로 번역된다.</p>

<p>이는 현대 네트워크 통신의 가장 밑단에 있는 물리 계층(Physical Layer)에서 전기 신호의 전압 차이를 0과 1로 해석하는 원리와 정확히 일치한다. 나는 이 과제에서 시그널을 통해 가장 원시적인 형태의 물리 계층을 직접 구현한 것이다.</p>

<h3 id="-프로토콜의-설계-주소-지정-직렬화-그리고-동기화">🤝 프로토콜의 설계: 주소 지정, 직렬화, 그리고 동기화</h3>

<p>단순히 0과 1을 보낼 수 있다고 해서 통신이 완성되지는 않는다. 단순히 통신을 하는 인코딩과 디코딩의 절차일 텐데, 결국 통신이라고 하는 것이 의미 있는 데이터 교환을 위해서는 정교한 프로토콜로의 구성이 필요시 된다.</p>

<ol>
  <li><strong>주소 지정 (Addressing) - <code class="language-plaintext highlighter-rouge">PID</code></strong>: 서버는 시작과 동시에 자신의 <code class="language-plaintext highlighter-rouge">PID(Process ID)</code>를 출력한다. 이는 네트워크에서 서버가 자신의 IP 주소와 포트 번호를 알리는 것과 같다. <code class="language-plaintext highlighter-rouge">PID</code>는 운영체제가 각 프로세스에게 부여한 고유한 주소이며, 클라이언트는 <code class="language-plaintext highlighter-rouge">kill</code> 시스템 콜을 통해 이 주소로 정확하게 신호를 보낼 수 있다. 통신의 가장 기본인 ‘누가 누구에게’ 보내는지를 명확히 하는 단계다.</li>
  <li><strong>직렬화와 역직렬화 (Serialization &amp; Deserialization) - 비트 연산</strong>:
    <ul>
      <li><strong>클라이언트 (송신자)</strong>: 문자(char)라는 고수준 데이터를 <code class="language-plaintext highlighter-rouge">(character &gt;&gt; i) &amp; 1</code>과 같은 비트 연산을 통해 8개의 비트 스트림으로 분해(직렬화)한다. 이는 통신 채널(시그널)을 통해 보낼 수 있는 형태로 데이터를 가공하는 과정이다.</li>
      <li><strong>서버 (수신자)</strong>: <code class="language-plaintext highlighter-rouge">sigaction</code>을 통해 등록된 핸들러 함수는 비동기적으로 도착하는 시그널들을 수신한다. 이 핸들러는 <code class="language-plaintext highlighter-rouge">char_byte = (char_byte &lt;&lt; 1) | bit;</code> 코드를 통해 흩어져서 도착한 비트들을 다시 8비트의 문자(char)로 조립(역직렬화)한다. 이는 외부의 비동기적 이벤트를 처리하는 <strong>이벤트 기반 프로그래밍(Event-driven programming)</strong>의 핵심 모델을 직접 구현하는 경험이었다.</li>
    </ul>
  </li>
  <li><strong>흐름 제어 (Flow Control) - 동기화</strong>: 만약 클라이언트가 일방적으로 시그널을 폭주시키면 서버는 이를 모두 처리하지 못하고 유실된다. 이를 막기 위해 <strong>핸드셰이크(Handshake)</strong> 기반의 동기화 프로토콜을 도입해야 했다.
    <ul>
      <li>클라이언트는 1비트를 보낸 후 <code class="language-plaintext highlighter-rouge">pause()</code>로 응답을 기다린다.</li>
      <li>서버는 1비트를 성공적으로 처리한 후, <code class="language-plaintext highlighter-rouge">kill</code>을 통해 클라이언트에게 <strong>ACK(Acknowledgement)</strong> 신호를 보낸다.</li>
      <li>ACK 신호를 받은 클라이언트는 비로소 다음 비트를 보낸다.</li>
      <li>이 ‘보내고-받고-확인하는’ 과정은 신뢰성 있는 통신의 대명사인 TCP 프로토콜의 흐름 제어 원리와 정확히 같다. 이러한 구성은 가장 원시적인 재료로 현대적인 통신 프로토콜의 핵심 개념을 재창조한 것이다.</li>
    </ul>
  </li>
</ol>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">Minitalk</code>를 한마디로 정리한다면 운영체제와의 깊은 교감을 통해 통신의 본질을 탐구하게 한 과제였다.</p>

<ul>
  <li><strong>프로토콜 설계의 본질</strong>: 통신은 단순한 데이터 전송이 아니라, 양측이 동의한 엄격한 ‘규칙의 집합’ 위에서 이루어진다. 주소 지정, 데이터 표현, 순서 보장, 오류 제어 등 모든 현대 네트워크 프로토콜에 담긴 철학을 가장 단순한 형태로 압축해서 경험할 수 있었다. 당연히 이러한 통신을 이해하고 난 뒤, <code class="language-plaintext highlighter-rouge">우아한 종료(graceful termination)</code> 의 개념을 이해할 수 있었으며, 이는 이후 프로젝트, 회사에서의 업무에서도 서버 작업에서도 아주 톡톡히 효과를 해주었다.</li>
  <li><strong>비동기 프로그래밍의 이해</strong>: 프로그램의 흐름이 나의 코드가 아닌 외부의 이벤트(시그널)에 의해 결정되는 이벤트 기반의 작업, 아주 원시적이지만 맛보기를 하고 직접 다루어 볼 수 있었다.</li>
  <li><strong>추상화에 대한 감사</strong>: 매일 당연하게 사용하던 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 소켓 통신이 얼마나 많은 복잡성을 감추고 우리에게 편리함을 제공하는지, 가장 낮은 수준의 통신을 구현해보고 나서야 비로소 실감하게 되었다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[📢 Minitalk : 신호(Signal)로 쌓아 올린 통신의 규약(Protocol)]]></summary></entry><entry><title type="html">42 Seoul - 005_push_swap</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-05.html" rel="alternate" type="text/html" title="42 Seoul - 005_push_swap" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-05</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-05.html"><![CDATA[<h2 id="-push_swap--제약constraints-속에서-최적의-경로를-탐색하다">🔄 push_swap : 제약(Constraints) 속에서 최적의 경로를 탐색하다</h2>

<p>이 과제의 핵심은 알고리즘 맛보기라는 일이었다.</p>

<p>이전의 과제들이 C언어의 문법, 시스템과의 소통 방식을 익히는 과정이었다면, <code class="language-plaintext highlighter-rouge">push_swap</code>은 완전히 새로운 차원의 질문을 던진다: <strong>“엄격한 제약 조건 하에서, 어떻게 ‘최적(Optimal)’의 해를 찾아낼 것인가?”</strong></p>

<p>이 과제는 단순히 주어진 숫자를 정렬하는 문제가 아니다. 두 개의 스택이라는 제한된 공간과 11개의 명령어(외부에 노출 될 수 있는 명령 갯수)라는 한정된 도구만을 사용하여, 가장 효율적인 데이터의 ‘이동 경로’를 설계해야 하는 복잡한 최적화 문제(Optimization Problem)이다.</p>

<p><code class="language-plaintext highlighter-rouge">Minitalk</code>가 원시적인 신호 위에 통신 프로토콜을 쌓아 올리는 경험이었다면, <code class="language-plaintext highlighter-rouge">push_swap</code>은 혼돈(Unordered state) 속에서 질서(Sorted state)로 나아가는 가장 우아한 알고리즘적 여정을 찾아내는 과정이였다.</p>

<p>이는 정해진 답을 구현하는 것을 넘어, 문제의 본질을 꿰뚫고 자신만의 해결 전략, 즉 휴리스틱(Heuristic)을 창조하고 증명해야 하는, 진정한 의미의 문제 해결 능력에 대한 시험대였다.</p>

<h3 id="-문제-공간의-정의-두-개의-스택과-11개의-연산자">🎲 문제 공간의 정의: 두 개의 스택과 11개의 연산자</h3>

<p><code class="language-plaintext highlighter-rouge">push_swap</code>의 세계는 다음의 공리(Axioms) 위에 세워져 있다.</p>

<ol>
  <li><strong>두 개의 스택 (<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>)</strong>: 모든 연산의 주체이자 대상이 되는 유일한 데이터 구조. 이는 임의 접근(Random Access)이 불가능하고 오직 LIFO(Last-In, First-Out) 접근만 허용되는 근본적인 제약을 의미한다.</li>
  <li><strong>11개의 연산자 (<code class="language-plaintext highlighter-rouge">sa</code>, <code class="language-plaintext highlighter-rouge">pb</code>, <code class="language-plaintext highlighter-rouge">ra</code>, <code class="language-plaintext highlighter-rouge">rra</code> 등)</strong>: 스택의 상태를 변경할 수 있는 유일한 합법적인 행위. 각 연산자는 ‘1’이라는 비용(cost)을 가지며, 과제의 목표는 이 비용의 총합을 최소화하는 것이다.</li>
</ol>

<p>이러한 제약은 퀵 정렬이나 병합 정렬과 같은 고전적인 효율적 정렬 알고리즘의 사용을 원천적으로 차단한다. 따라서 우리는 이 문제 공간의 특성에 맞는 새로운 전략을 수립해야만 했다.</p>

<h3 id="-핵심-전략-lis-최장-증가-부분-수열를-이용한-문제-재정의">💡 핵심 전략: LIS (최장 증가 부분 수열)를 이용한 문제 재정의</h3>

<p>제일 처음 이 문제를 받았을 때, 머리가 하얗게 변하는 것을 느꼈다. 내가 할 일이 뭔지를 알겠고 구현은 했지만, 각 행동을 어떻게 알고리즘으로 엮어야 하지?</p>

<p>지금은 그래도 AI 로 접근은 되는 것이었지만, 핵심적인 연산자를 구현한걸 어떻게 엮어야 알고리즘의 방식을 적용을 해서 최적화 시키지? 이 문제는 계속 머리를 쥐어 뜯게 만들고, 뭘 얼마나 해야할 지에 대한 망설임을 만들었던 기억이 난다.</p>

<p>그렇게 어느정도 알고리즘에 대해 이해가 쌓이기 시작하고, 손을 델 수 있게 된 것은 “어떻게 움직임의 수를 최소화할 것인가?”라는 질문에 문제 자체를 재정의하는 것을 하면서 부터 조금씩 가능해지기 시작했다.</p>

<blockquote>
  <p><strong>“모든 원소를 정렬하려 하지 말고, 이미 정렬된 것에 가까운 원소들은 그대로 둔 채, 흐름을 방해하는 최소한의 원소들만 옮기면 어떨까?”</strong></p>
</blockquote>

<p>이 접근법을 처음 알게 되고, 기존의 방법에서 해메던 도중이었고, 그 결과 나는 유레카를 불렀다. 이 방법이라면 뭔가 구현이 가능할 것으로 보이고, 내 이해도를 높이면서 최적화를 이룰 수 있을 것 같다는 감각적인 확신. 이러한 확신을 구현한 것이 바로 <strong>LIS (Longest Increasing Subsequence)</strong> 알고리즘, 한국어 명 최장증가수열 알고리즘이었다.</p>

<ol>
  <li><strong>기준점 설정 (LIS 탐색)</strong>: 먼저 스택 <code class="language-plaintext highlighter-rouge">a</code>에 존재하는 숫자들 중에서 LIS, 최장 증가 수열을 찾는다. LIS에 속한 원소들은 최종적으로 정렬된 상태에서도 그 상대적 순서를 유지할 가능성이 높은 ‘앵커(Anchor)’ 그룹이다. 이들은 우리가 최소한으로 움직여야 할 대상, 즉 보존해야 할 가치가 가장 큰 원소들의 묶음이었다.</li>
  <li><strong>문제의 분리</strong>: LIS 탐색 후, 문제는 두 가지 하위 문제로 분리된다.
    <ul>
      <li>LIS에 속하지 않는 원소들을 스택 <code class="language-plaintext highlighter-rouge">b</code>로 가장 효율적으로 이동시키는 문제.</li>
      <li>스택 <code class="language-plaintext highlighter-rouge">b</code>의 원소들을 다시 스택 <code class="language-plaintext highlighter-rouge">a</code>의 올바른 위치로 최소 비용으로 삽입하는 문제.</li>
    </ul>
  </li>
</ol>

<p>이처럼 LIS를 기준으로 문제를 재정의함으로써, ‘N개의 원소를 정렬하는 문제’는 ‘N-K개의 원소(K는 LIS의 길이)를 가장 효율적으로 이동시키는 문제’로 단순화된다. 이는 복잡한 문제에 직면했을 때, 불변의 기준을 찾아내고 이를 중심으로 문제를 분해하는 강력한 문제 해결 전략이며, 무엇보다 직관적이라는 장점은 기존의 만들어둔 기능들을 활용한 구현에서 아주 효과적이었다.</p>

<h3 id="-탐욕-알고리즘greedy-algorithm의-적용-최적-삽입-경로-탐색">💃 탐욕 알고리즘(Greedy Algorithm)의 적용: 최적 삽입 경로 탐색</h3>

<p>이렇게 LIS 그룹을 발견하고 나면, 이를 제외한 모든 원소가 스택 <code class="language-plaintext highlighter-rouge">b</code>로 옮겨진 후, 마지막 단계는 스택 <code class="language-plaintext highlighter-rouge">b</code>의 원소들을 다시 <code class="language-plaintext highlighter-rouge">a</code>로 돌려보내는 것이다.</p>

<p>이 과정은 매 순간 ‘지역적으로 최적인(Locally Optimal)’ 선택을 반복하는 <strong>탐욕 알고리즘</strong>의 아이디어를 기반으로 동작한다. 이때 핵심은 단순히 각각 스택으로 옮기는 방법도 있지만, 동시에 양쪽을 같이 움직이거나, 적절하게 오히려 거꾸로 순서를 정리하는 도구들을 얼마나 각 스텍에서 공통적으로 묶어서 동시에 실행하나에 달려 있었다.</p>

<ul>
  <li><strong>비용 함수 정의</strong>: 스택 <code class="language-plaintext highlighter-rouge">b</code>의 특정 원소를 스택 <code class="language-plaintext highlighter-rouge">a</code>의 올바른 위치에 삽입하기 위해 필요한 <code class="language-plaintext highlighter-rouge">ra</code>, <code class="language-plaintext highlighter-rouge">rra</code>, <code class="language-plaintext highlighter-rouge">rb</code>, <code class="language-plaintext highlighter-rouge">rrb</code> 연산의 총 횟수를 ‘비용’으로 정의한다.</li>
  <li><strong>최적해 탐색</strong>: 스택 <code class="language-plaintext highlighter-rouge">b</code>의 모든 원소에 대해 이 비용을 계산하고, 그중 가장 비용이 낮은, 즉 가장 적은 연산으로 제자리를 찾아갈 수 있는 원소를 이번 턴에 이동시킬 대상으로 선택한다.</li>
  <li><strong>최적화</strong>: 만약 <code class="language-plaintext highlighter-rouge">a</code>와 <code class="language-plaintext highlighter-rouge">b</code> 스택이 <strong>같은 방향</strong>으로 회전해야 한다면(<code class="language-plaintext highlighter-rouge">ra</code>와 <code class="language-plaintext highlighter-rouge">rb</code>), 이를 <code class="language-plaintext highlighter-rouge">rr</code>이라는 단일 연산으로 통합하여 비용을 절감하는 최적화를 적용한다. 이와 반대의 경우엔 <code class="language-plaintext highlighter-rouge">rrr</code>을 사용한다.</li>
</ul>

<p>이 과정을 스택 <code class="language-plaintext highlighter-rouge">b</code>가 빌 때까지 반복함으로써, 전체 이동 비용을 최소화하는 경로에 근사할 수 있다.</p>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p>이 과제는 체감상 printf 보다도 어렵고, 어쩌면 42서울 과정 중에서 상당히 길게 걸린, <code class="language-plaintext highlighter-rouge">push_swap</code>은 논리적 사고와 전략적 설계, 수학적 감각 등의 능력을 요구하는 과제였다. 나같은 문과생들에게는 정말 지옥과도 같았던 시간이라고(….), 그리고 동시에 그렇기에 진짜 수학을 왜 그리 열심히 배우는 지를 알 수 있었다.</p>

<p>그럼에도 이 과제를 마무리 함으로써</p>

<ul>
  <li><strong>알고리즘적 사고로의 전환</strong>: ‘어떻게 구현할까’를 넘어 ‘어떤 전략이 가장 효율적일까’를 고민하게 만들었다. 이는 단순히 코드를 짜는 행위에서 문제를 분석하고 해결책을 설계하는 단계로의 성장을 의미했고, 특히나 왜 그렇게 ‘알고리즘’이라는 키워드에 개발자들이 강조하고, 이를 통해 얼마나 작업의 차이가 크게 나는지를 직접 눈으로 볼 수 있던 경험이라고 생각한다.</li>
  <li><strong>휴리스틱의 가치</strong>: 수학적으로 완벽한 최적해를 찾는 것은 매우 어렵거나(NP-hard) 비효율적일 수 있다. LIS라는 강력한 휴리스틱을 통해 ‘충분히 좋은(good enough)’ 해를 효율적으로 찾아내는 과정은, 현실 세계의 복잡한 문제를 해결하는 실용적인 접근법을 가르쳐주었다.</li>
  <li><strong>연산의 비용에 대한 감각</strong>: 모든 명령어에 ‘비용’이라는 개념이 존재함을 인지하게 되었다. 이는 “작동하는 코드”와 “효율적인 코드”의 차이를 명확히 구분하게 만들었으며, 성능 최적화에 대한 마인드셋을 심어주었다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">push_swap</code>은 스택이라는 단순한 자료구조 위에서 펼쳐지는 한 편의 논리적인 왈츠였다. 이 프로젝트를 통해 나는 비로소 주어진 문제의 제약 조건을 이해하고, 그 안에서 최적의 해결책을 설계하는 ‘알고리즘 설계자’로서의 첫걸음을 뗄 수 있었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🔄 push_swap : 제약(Constraints) 속에서 최적의 경로를 탐색하다]]></summary></entry><entry><title type="html">42 Seoul - 006_so_long</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-06.html" rel="alternate" type="text/html" title="42 Seoul - 006_so_long" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-06</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-06.html"><![CDATA[<h2 id="-so_long--데이터의-시각화와-상호작용interaction의-시작">🎮 so_long : 데이터의 시각화와 상호작용(Interaction)의 시작</h2>

<p>42서울에 들어오면, 가장 흥이 나는, 의욕이 나는 과제가 무엇인가? 라고 한다면 바로 이 과제가 꽤나 상위권의 과제가 아닐까 싶다.</p>

<p>알고리즘의 추상적인 세계에 머물렀던 이전 과제들과 달리, <code class="language-plaintext highlighter-rouge">so_long</code>은 우리의 코드가 만들어낸 결과물을 처음으로 시각적이고 동적인 ‘세계’로 구현해내는 과제다.</p>

<p>이 프로젝트의 본질은 단순한 2D 게임 제작을 넘어, 메모리상의 정적인 2차원 배열 데이터가 어떻게 사용자와 상호작용하는 그래픽 인터페이스로 변환되는지를 이해하는 데 있으며, 이를 직접 눈으로 본다는 뿌듯함은, 게임의 개발의 로망을 가진 남자들이라면 상당한 설렘, 그리고 동시에 42서울의 원시 그래픽 라이브러리를 써본다는 점에서 꽤나 지옥을 맛보는(…) 과정이였다.</p>

<p>이는 <strong>상태(State), 입력(Input), 그리고 렌더링(Rendering)</strong> 이라는 GUI 애플리케이션의 세 가지 핵심 요소를 처음으로 다루는 경험이다. 삭막한 터미널을 벗어나, 프로그램의 내부 상태가 스크린 위의 픽셀로 실시간 투영되는 것을 보며, 우리는 비로소 ‘계산’을 넘어 ‘상호작용’의 영역으로 첫발을 내딛는 과제라 할 수 있겠다.</p>

<h3 id="-minilibx-복잡성을-감추는-추상화-계층">🎨 MiniLibX: 복잡성을 감추는 추상화 계층</h3>

<p><code class="language-plaintext highlighter-rouge">so_long</code>의 기술적 중심에는 <strong>MiniLibX</strong>가 있다. 이 라이브러리는 운영체제마다 다른 복잡한 그래픽 시스템(Linux의 X11, macOS의 AppKit 등)을 단순한 API로 감싸놓은 42라는 부트캠프가 자체적으로 갖고 있는, <strong>추상화 계층(Abstraction Layer)</strong>이다. 이를 통해 우리는 로우레벨의 윈도우 시스템을 직접 다루는 대신, 게임 로직 자체에 집중할 수 있다.</p>

<p>지금 생각해보면 그래픽스와 관련한 로우한 개념, 코드를 만약 만졌다면 수개월 공부로도 쉽지 않았겠지만, 그걸 뛰어넘게 만들어줬다는 점에선 아주 훌륭한 선택이었다고 본다. <del>(물론 유지보수가 안되어, 진짜 버그가 너무 많았다)</del></p>

<p>핵심은 <strong>이벤트 기반 아키텍처(Event-Driven Architecture)</strong>를 이해하는 것.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">mlx_loop</code></strong>: 이 함수는 프로그램의 제어권을 가져가 무한 루프를 돈다. 이는 명령을 순차적으로 실행하고 종료되던 기존의 프로그램과 다르다. 프로그램은 이제 사용자의 키보드 입력, 마우스 클릭, 창 닫기 버튼 등 외부에서 발생하는 <strong>비동기적 이벤트(Asynchronous Events)</strong>를 수신 대기하는 ‘반응형 시스템’이 되어 바쁜 루프(busy loop)를 돌게 된다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">mlx_key_hook</code>, <code class="language-plaintext highlighter-rouge">mlx_hook</code></strong>: 특정 이벤트가 발생했을 때 호출될 함수(콜백 함수 또는 핸들러)를 미리 등록하는 행위. 이를 통해 “W 키가 눌리면 <code class="language-plaintext highlighter-rouge">move_player_up</code> 함수를 실행하라” 와 같은 이벤트와 로직의 연결고리를 만들게 된다. 이러한 이벤트들이 들어올 때, 그 종합적인 상태들을 모아서, 맵과 캐릭터, 이미지의 상호작용을 만드는 것, 그것이 이 과제의 핵심 개념이었다.</li>
</ul>

<h3 id="️-ber-파일-세계의-설계도를-해석하다">🗺️ <code class="language-plaintext highlighter-rouge">.ber</code> 파일: 세계의 설계도를 해석하다</h3>

<p><code class="language-plaintext highlighter-rouge">.ber</code> 텍스트 파일은 기본적으로 42 과제에서 정한, 일종의 약속이었다. 게임 월드의 초기 상태를 정의하는 ‘설계도’이다. 이 설계도를 해석하여 인게임 데이터 구조로 변환하는 과정은 다음과 같은 단계로 이루어진다.</p>

<ol>
  <li><strong>파싱 (Parsing) 및 역직렬화 (Deserialization)</strong>: <code class="language-plaintext highlighter-rouge">get_next_line</code>을 활용해 텍스트 파일을 읽고, 이를 <code class="language-plaintext highlighter-rouge">char **</code> 와 같은 인-메모리 2차원 배열로 변환한다. 이는 파일에 직렬화되어 저장된 데이터를 프로그램이 이해할 수 있는 구조로 바꾸는 과정이다.</li>
  <li><strong>맵 유효성 검사 (Validation)</strong>: 파싱된 맵이 게임의 근본적인 <strong>불변 규칙(Invariants)</strong>을 만족하는지 검증한다.
    <ul>
      <li><strong>구조적 규칙</strong>: 직사각형 형태, 벽(<code class="language-plaintext highlighter-rouge">1</code>)으로의 완전한 둘러싸임.</li>
      <li><strong>구성 요소 규칙</strong>: 플레이어(<code class="language-plaintext highlighter-rouge">P</code>) 1개, 출구(<code class="language-plaintext highlighter-rouge">E</code>)와 수집품(<code class="language-plaintext highlighter-rouge">C</code>) 각각 1개 이상의 존재.</li>
      <li><strong>경로 유효성 규칙 (심화)</strong>: 단순히 구성 요소의 개수를 세는 것을 넘어, <strong>플레이어가 모든 수집품을 거쳐 출구에 도달할 수 있는 유효한 경로가 존재하는지</strong>를 검증해야 한다. 이는 일반적으로 <strong>DFS(깊이 우선 탐색)</strong>나 <strong>BFS(너비 우선 탐색)</strong> 같은 그래프 순회 알고리즘을 사용하여 맵 데이터 자체를 하나의 그래프로 보고, 시작점에서 목표 지점까지의 <strong>도달 가능성(Reachability)</strong>을 판별하는 방식으로 구현된다. 이 검증이 누락되면 플레이어가 절대로 클리어할 수 없는 맵을 허용하게 된다.</li>
    </ul>
  </li>
</ol>

<h3 id="️-게임-루프-입력-상태-업데이트-렌더링의-순환">🏃‍♂️ 게임 루프: 입력, 상태 업데이트, 렌더링의 순환</h3>

<p>게임의 실질적인 동작은 보이지 않는 <strong>게임 루프(Game Loop)</strong> 안에서 일어난다. <code class="language-plaintext highlighter-rouge">so_long</code>에서는 이벤트가 발생할 때마다 이 루프의 한 사이클이 동작한다고 볼 수 있다.</p>

<ol>
  <li><strong>입력 (Input)</strong>: <code class="language-plaintext highlighter-rouge">mlx_key_hook</code>이 키 입력을 감지한다.</li>
  <li><strong>상태 업데이트 (State Update)</strong>: 입력에 따라 게임의 핵심 데이터, 즉 <strong>상태</strong>를 변경한다.
    <ul>
      <li>플레이어의 다음 좌표를 계산하고, 벽(<code class="language-plaintext highlighter-rouge">1</code>)과의 충돌을 검사한다.</li>
      <li>이동이 유효하다면, 플레이어의 좌표(<code class="language-plaintext highlighter-rouge">game-&gt;player_x</code>, <code class="language-plaintext highlighter-rouge">game-&gt;player_y</code>), 움직인 횟수(<code class="language-plaintext highlighter-rouge">game-&gt;steps</code>), 남은 수집품 개수(<code class="language-plaintext highlighter-rouge">game-&gt;collectibles</code>) 등의 상태 변수를 갱신한다.</li>
      <li>게임의 모든 규칙과 로직은 오직 이 ‘상태’를 변경하는 단계에서만 처리되어야 한다.</li>
    </ul>
  </li>
  <li><strong>렌더링 (Rendering)</strong>: 변경된 최신 ‘상태’를 기반으로 화면 전체를 다시 그린다. 렌더링 함수는 현재 플레이어가 어디에 있는지, 수집품이 어디에 남았는지 등의 게임 로직을 알 필요가 없다. 오직 전달된 상태 데이터를 시각적으로 표현할 책임만 가진다.
    <ul>
      <li><strong>애니메이션 (심화)</strong>: 단순한 키 입력 기반 렌더링을 넘어, <code class="language-plaintext highlighter-rouge">mlx_loop_hook</code>을 사용하면 아무런 입력이 없어도 매 프레임마다 특정 함수를 호출할 수 있다. 이를 활용해 프레임 카운터를 두고, 특정 프레임마다 플레이어나 수집품의 이미지를 다른 이미지로 교체해주면 간단한 스프라이트 애니메이션을 구현하여 게임에 생동감을 불어넣을 수 있다.</li>
    </ul>
  </li>
</ol>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">so_long</code>은 C언어로 정적인 데이터를 동적인 상호작용의 세계로 이끌어내는 값진 경험이자, 이벤트 기반 루프라는 것이 어떤 식으로 애니메이션을 만들어내는 지를 배울 수 있었다. 특히 구조체를 본격적으로 쓴다는 점에서, 객체 지향적 구조의 일부를 맛본다는 차원에서 아주 흥미로운 과제였다고 생각한다.</p>

<ul>
  <li><strong>상태와 뷰의 분리</strong>: 게임의 모든 데이터를 담고 있는 ‘상태(State)’와, 그 상태를 화면에 그리는 ‘뷰(View/Rendering)’의 역할을 분리하는 것이 왜 중요한지 체감했다. 이 원칙은 이후 MVC, MVVM 등 모든 현대적인 UI 프레임워크의 근간이 되는 것이었고, 배울 당시는 몰랐지만, 이후 많은 작업들 속에서 그 원리의 구조를, 본질적인 의미와 특징을 나름 이해하게 된 경험이었다.</li>
  <li><strong>이벤트 기반 패러다임의 이해</strong>: 프로그램의 흐름이 위에서 아래로 흐르는 것이 아니라, 외부 이벤트에 의해 비동기적으로 촉발되는 이벤트 기반 프로그래밍 패러다임에 대한 깊은 이해를 얻었다. 결국 어떤 루프 안에서, 어떤 것들을 어떤 순서의 이벤트로 나타내고, 특히 최종적인 렌더링은 맨 마지막에서 이루어지는 구조가 된다는 의미는 상당히 복잡하고, 또 디버깅 과정에서 경험한 쉽지 않은 일이었다고 생각이 든다.</li>
  <li><strong>알고리즘의 시각적 응용</strong>: DFS/BFS 같은 자료구조/알고리즘이 단지 이론에 머무는 것이 아니라, ‘플레이 가능한 맵’을 검증하는 등 실제 게임 개발에서 어떻게 실용적으로 사용되는지 직접 확인할 수 있었다.</li>
</ul>

<p>내 코드가 만들어낸 작은 캐릭터가 맵을 돌아다니고, 아이템을 수집하며, 마침내 출구에 도달하는 일련의 과정을 지켜보는 것은 단순한 결과 확인을 넘어선 창작의 기쁨이었다. <code class="language-plaintext highlighter-rouge">so_long</code>은 나에게 코드가 어떻게 생명력을 얻어 사용자와 소통하는 ‘세계’가 될 수 있는지를 가르쳐준 프로젝트로 기억되며 지금까지 꽤나 기분 좋은 경험이었다고 생각이 든다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🎮 so_long : 데이터의 시각화와 상호작용(Interaction)의 시작]]></summary></entry><entry><title type="html">42 Seoul - 007_philosopher</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-07.html" rel="alternate" type="text/html" title="42 Seoul - 007_philosopher" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-07</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-07.html"><![CDATA[<h2 id="-philosopher--동시성concurrency의-두-가지-난제-교착상태와-경쟁상태">🤔 philosopher : 동시성(Concurrency)의 두 가지 난제, 교착상태와 경쟁상태</h2>

<p>동시성.</p>

<p>컴퓨터 공학을 배우면서, 그리고 실제 프로그래밍 하게 되면 특히나 고민되는 영역이다. 막연히 로망 같은 키워드로, 이걸 활용하면 정말 말도 안되게 성능이 좋아질 것 같다는, 그런 생각. 그런 로망을 실현하는 과제라는 점을 알게 되었을 때 한껏 신이 났었다. <del>물론 끔찍하단건 이젠 일상이다</del></p>

<p><code class="language-plaintext highlighter-rouge">so_long</code>이 프로그램의 상태를 시각적 세계로 확장하는 경험이었다면, <code class="language-plaintext highlighter-rouge">philosopher</code>는 눈에 보이지 않는 시간의 축 위에서 여러 실행 흐름이 얽힐 때 발생하는 문제, 즉 <strong>동시성(Concurrency)</strong>의 심연을 들여다보는 과제다.</p>

<p>이 프로젝트는 컴퓨터 과학의 고전적인 ‘식사하는 철학자들’ 문제를 통해, 현대 멀티코어 환경에서 동작하는 모든 소프트웨어가 필연적으로 마주하는 두 가지 핵심 난제를 우리 앞에 제시한다:</p>

<blockquote>
  <p><strong>자원 경쟁(Resource Competition)</strong>과 <strong>실행 흐름의 동기화(Synchronization)</strong>.</p>
</blockquote>

<p>이 과제는 단순히 스레드와 뮤텍스 API를 사용하는 법을 배우는 것을 넘어선다.</p>

<p>왜 동기화가 필요한지, 잘못된 동기화가 어떻게 시스템 전체를 마비시키는지, 그리고 교착상태와 경쟁상태라는 유령 같은 버그를 피하기 위해 얼마나 정교한 논리적 설계가 필요한지를 직접 증명하고 체감하는, 시스템 프로그래밍의 통과 의례와도 같은 과정이었다.</p>

<h3 id="-문제의-본질-한정된-자원과-비결정적-실행-순서">📜 문제의 본질: 한정된 자원과 비결정적 실행 순서</h3>

<p>‘식사하는 철학자들’ 문제는 동시성 시스템의 축소판이다.</p>

<ul>
  <li><strong>철학자 (Philosopher)</strong>: 스레드(Thread) 또는 프로세스(Process)와 같은 독립적인 실행 단위를 상징한다.</li>
  <li><strong>포크 (Fork)</strong>: 데이터베이스 커넥션, 파일 핸들러, 하드웨어 장치 등 동시에 접근할 수 없는 <strong>공유 자원(Shared Resource)</strong>을 상징한다.</li>
  <li><strong>식사 (Eating)</strong>: 공유 자원을 점유하여 작업을 수행하는 <strong>임계 영역(Critical Section)</strong>을 의미한다.</li>
</ul>

<p>이 모델에서 발생하는 근본적인 문제는, 각 스레드의 실행 순서와 시점을 운영체제의 스케줄러가 결정하기 때문에 <strong>비결정적(Non-deterministic)</strong>이라는 사실에서 출발한다. 이 비결정성이 두 가지 치명적인 버그를 낳는다.</p>

<ol>
  <li><strong>교착 상태 (Deadlock)</strong>: 둘 이상의 스레드가 서로가 점유한 자원을 기다리며 더 이상 진행하지 못하는 상태. 이는 다음의 <strong>4가지 조건(Coffman Conditions)</strong>이 모두 충족될 때 발생한다.
    <ul>
      <li><strong>상호 배제 (Mutual Exclusion)</strong>: 자원은 한 번에 하나의 스레드만 사용할 수 있다.</li>
      <li><strong>점유 대기 (Hold and Wait)</strong>: 자원을 하나 점유한 상태에서 다른 자원을 추가로 요청하며 대기한다.</li>
      <li><strong>비선점 (No Preemption)</strong>: 다른 스레드가 점유한 자원을 강제로 빼앗을 수 없다.</li>
      <li><strong>환형 대기 (Circular Wait)</strong>: 각 스레드가 다음 스레드가 점유한 자원을 요구하는 원형의 대기열이 형성된다.</li>
    </ul>
  </li>
  <li><strong>경쟁 상태 (Race Condition)</strong>: 여러 스레드가 동시에 공유 자원에 접근하여 수정할 때, 실행 순서에 따라 결과가 의도와 다르게 나오는 상황. <code class="language-plaintext highlighter-rouge">printf</code>와 같은 단순한 출력 함수조차도 내부적으로 여러 단계로 동작하기에, 동기화 없이는 메시지가 뒤섞여 깨지는 경쟁 상태를 유발한다.</li>
  <li><strong>기아 상태 (Starvation)</strong>: 특정 스레드가 자원을 할당받을 기회를 영원히 얻지 못하는 상태를 말한다. 교착 상태는 모든 스레드가 멈추지만, 기아 상태는 다른 스레드들은 정상 동작하는 와중에 일부 스레드만 고립된다는 차이가 있다. 어찌 보면 시스템이 정상적으로 동작하는 것과 같은 느낌을 제시하지만, 정상적이지 못한 스레드에서 나오는 데이터, 상태 값, 그 외에도 시스템 상호작용에서 의존성이 존재한다면 시스템 전체가 오작동, 오판이 이루어질 수 있는 심각한 문제이다.</li>
</ol>

<h3 id="️-part-1-스레드와-뮤텍스를-이용한-동기화-mandatory">🛠️ Part 1: 스레드와 뮤텍스를 이용한 동기화 (Mandatory)</h3>

<p>이 파트의 목표는 공유 메모리 모델의 동시성 단위인 <strong>스레드(Thread)</strong>와, 임계 영역을 보호하기 위한 가장 기본적인 동기화 도구인 <strong>뮤텍스(Mutex)</strong>를 사용하여 문제를 해결하는 것이다.</p>

<p>간단히 설명하면 철학자들은 양손으로 포크를 잡아야 먹을 수 있고, 필수 먹는 시간이 곧 생명 연장이 가능하고, 포크를 내려 놓고 생각-잠에 들어가는 과정이 되어야 비로소 다른 자원(포크)들을 다른 철학자가 취하고 다시 자신의 필요한 양의 먹기,철학자는 죽을 수 있고, 궁극적으로 제시되는 수준의 포크 갯수, 철학자 수, 그 외에도 먹는 시간 등의 조건을 달성하는 것이 핵심 목표이다.</p>

<ul>
  <li><strong>솔루션의 핵심</strong>: 교착 상태를 유발하는 4가지 조건 중 하나를 깨뜨리는 것이다. 모든 철학자가 ‘왼쪽 포크 -&gt; 오른쪽 포크’ 순서로 자원을 요청하면 <strong>환형 대기(Circular Wait)</strong> 조건이 성립하기 쉽다. 이를 해결하기 위해선 결국 환형 대기가 생기지 않도록, 순서나, 잡는 방법이 서로 다른 진영을 능동적으로 만들어주면 된다. 이때 가장 쉽고 적절한 것으로 <strong>짝수 번호 철학자는 왼쪽부터, 홀수 번호 철학자는 오른쪽부터</strong> 포크를 집도록 순서를 비대칭적으로 설계했다. 이 간단한 규칙의 변화가 자원 요청의 의존성 고리를 끊어 환형 대기를 원천적으로 방지한다. 추가로 하나 더 팁, 내지는 최적화를 하는 방법이 있다면, 먹기를 시작하는 것이 일제히 될 필요가 없다는 점도 중요하다. 홀수, 짝수로 먹되, 그 시작도 약간의 딜레이를 가지고 시작하게 함으로써 같은 그룹에서도 우선 먼저 먹게하는 사람과 나중 먹게 하는 사람을 만들어, 가능한 경쟁 관계가 바로 생기지 않도록 유도하는 것은, 초기 성능에 꽤나 중요한 역할을 했었다.</li>
  <li><strong>모니터링 스레드의 필요성</strong>: 동시에 각 철학자 스레드가 자신의 사망 여부를 스스로 판단하게 할 경우, 다른 스레드가 점유한 뮤텍스로 인해 블로킹되어 자신의 상태를 제때 확인하지 못할 수 있다. 따라서 철학자들의 상태를 감시하고 시뮬레이션을 종료하는 역할은, 철학자들이 사용하는 뮤텍스로부터 자유로운 별도의 <strong>모니터링 스레드(Watchdog)</strong>가 수행해야만 안정적인 감시가 가능하다고, 무엇보다 적절한 출력 및 사망 처리를 표시해줄 수 있어 반드시 필요했다.</li>
</ul>

<h3 id="-part-2-프로세스와-세마포어를-이용한-ipc-bonus">🚀 Part 2: 프로세스와 세마포어를 이용한 IPC (Bonus)</h3>

<p>보너스 파트는 독립적인 메모리 공간을 가진 <strong>프로세스(Process)</strong>를 <code class="language-plaintext highlighter-rouge">fork()</code>로 생성하고, <strong>프로세스 간 통신(IPC, Inter-Process Communication)</strong>을 통해 동기화 문제를 해결할 것을 요구한다.</p>

<ul>
  <li><strong>프로세스 모델의 차이</strong>: 스레드와 달리 프로세스는 메모리를 공유하지 않으므로, 뮤텍스처럼 메모리 주소를 공유하는 방식으로는 동기화할 수 없다. 따라서 커널 수준에서 관리되는 IPC 객체를 사용해야 한다.</li>
  <li><strong>세마포어 (Semaphore)</strong>: 뮤텍스가 단 하나의 실행 흐름만 허용하는 잠금(lock)이라면, 세마포어는 <strong>정해진 개수(N)만큼의 실행 흐름을 동시에 허용</strong>하는 계수기(counter)이다. 이 문제에서는 모든 포크를 하나의 자원 풀로 보고, 포크의 총 개수를 카운트로 하는 세마포어 하나로 관리할 수 있다. 철학자는 <code class="language-plaintext highlighter-rouge">sem_wait</code>으로 포크 하나를 획득(카운트 감소)하고, <code class="language-plaintext highlighter-rouge">sem_post</code>로 반납(카운트 증가)한다. 이는 N개의 자원을 관리하는 데 있어 N개의 뮤텍스를 사용하는 것보다 훨씬 간결하고 직관적인 모델을 제공한다.</li>
  <li><strong>프로세스 모니터링</strong>: 부모 프로세스가 <code class="language-plaintext highlighter-rouge">waitpid</code>를 통해 자식 프로세스들의 종료 상태를 감시한다. 한 명의 철학자라도 사망(비정상 종료)하면, 부모 프로세스는 다른 모든 자식 프로세스들에게 <code class="language-plaintext highlighter-rouge">kill</code> 시그널을 보내 전체 시뮬레이션을 정리하는 역할을 수행한다.</li>
</ul>

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">philosopher</code>는 멀티 프로세싱, 멀티 스레딩이 ‘필요하지만’ 왜 ‘필수가 아닌가?’ 라는 것의 답과도 같은 프로젝트였다. 단지 일을 많이, 여럿이 한다고 그 일을 잘 한다고 볼 수 없으며, 오히려 정보의 처리, 정보의 소통 과정이 오히려 작업의 딜레이를 만들수 있다는, trade-off 가 있음을 보여주었다. 또한 동시성 버그가 왜 재현하기 어렵고 디버깅하기 힘든지, 그리고 왜 처음부터 신중한 설계가 중요한지를 가르쳐주었다.</p>

<ul>
  <li><strong>동시성 설계의 중요성</strong>: 동시성 문제는 나중에 수정하는 것이 거의 불가능에 가깝다. 시스템 설계 단계부터 어떤 자원이 공유되고, 어떤 임계 영역이 존재하며, 어떤 동기화 전략을 사용할지 명확히 정의해야 함을 깨달았다.</li>
  <li><strong>동기화 도구의 이해</strong>: 뮤텍스는 <strong>상호 배제</strong>가 필요할 때, 세마포어는 <strong>자원 풀링(Pooling)</strong>이나 복잡한 실행 순서 제어가 필요할 때 사용하는 등, 각 동기화 도구의 본질적인 목적과 사용 사례를 구분하는 능력을 기를 수 있었다.</li>
  <li><strong>이론과 현실의 연결</strong>: 교착 상태의 4가지 조건과 같은 이론적 모델이 실제 코드에서 어떻게 발현되고, 그 이론에 기반하여 어떻게 문제를 해결할 수 있는지 직접 증명해 보았다. 이 경험은 데이터베이스의 트랜잭션 처리, 웹 서버의 스레드 풀 관리 등 현실 세계의 복잡한 동시성 시스템을 이해하는 단단한 기반이 되어주었다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[🤔 philosopher : 동시성(Concurrency)의 두 가지 난제, 교착상태와 경쟁상태]]></summary></entry><entry><title type="html">42 Seoul - 008_minishell</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-08.html" rel="alternate" type="text/html" title="42 Seoul - 008_minishell" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-08</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-08.html"><![CDATA[<h2 id="-minishell-운영체제의-축소판-텍스트와-프로세스-사이의-번역가를-자처하다">💻 Minishell: 운영체제의 축소판, 텍스트와 프로세스 사이의 번역가를 자처하다</h2>

<p>통곡의 벽.
수 많은 42서울의 과제들 과정에서도, 역대급으로 고민하고, 소통할 일이 많아지는 프로젝트. 
쉽지 않았던 이 프로젝트는 지금도 두고두고 생각나는, 정말 쉽지 않은 ‘험한 것’ 이었다.</p>

<p>이전의 과제들이 개별적인 시스템 콜이나 동기화 메커니즘을 깊게 파고드는 경험이었다면, <strong>Minishell</strong>은 이 모든 것을 아우르는 하나의 작은 운영체제를 설계하고 구현하는 종합적인 과제이다.</p>

<p>셸(Shell)은 단순히 명령어를 실행하는 프로그램을 넘어, 커널(Kernel)이라는 시스템의 심장부와 사용자 사이를 연결하는 정교한 인터페이스이자 번역가이다. 사용자가 입력한 한 줄의 텍스트 문자열이 어떻게 생명력을 얻어 여러 프로세스의 협연으로 재탄생하는지, 그 모든 과정을 직접 지휘해야 하는, 시스템 프로그래머로서의 진정한 역량을 시험받는 프로젝트이다.</p>

<p><code class="language-plaintext highlighter-rouge">Minishell</code>은 “어떻게 문자열을 해석하고(Parsing), 어떻게 프로세스를 생성하며(Process Management), 어떻게 그들 간의 데이터 흐름을 제어할 것인가(IPC &amp; I/O Redirection)”라는 세 가지 거대한 질문에 대한 답을 찾아가는 여정이다. 그리고 거기에 한 스푼 더.</p>

<p>이 과제는 42서울에서의 본 과정에서의 최초 팀 과제이다.</p>

<hr />

<h3 id="-0단계-협업-길-들이기">📞 0단계: 협업 길 들이기</h3>

<p>처음 수행한 협업의 시작은 정말로 ‘어색’ 했다.</p>

<p>처음 마지하는 git, 버전관리, git 전략과 같은 내용들은 생소한데, 심지어 ‘일’이 아니라 ‘배움’이란 차원에서 진행하는 프로젝트다보니 여럿의 생각이나, 주장이 이어졌고 이러한 것들 속에서 어떻게 프로세스를 만들어내는 지는 정말 어려운 일이었다. 그나마 2명이 한다는 점에서, 해당 프로젝트의 목표가 본격적인 협업이라기 보단, ‘협업 맛보기’ 라는 컨셉이라는 차원에서 본다면 그나마 괜찮았다고 본다.</p>

<p>우선, 상대를 파악했다. 상대의 표현, 상대가 바라는 바, 특히나 목표가 동일하다고 해도, 그 동일한 목표에 대해 이해하고 있는 것은 다른 경우도 많았다. 특히나 신경 쓴 것은 ‘표현’의 정교화다.</p>

<p>한쪽이 아무리 지식이 뛰어나도, 협업을 해서 효율을 내려면, 상대가 이해하는 말로 해줄 수 있어야 하고, 실제로 프로세스 과정에서 약속된 언어로 한다는 말은 정보의 공유 수준도 비슷해져야 한다는 것을 의미했다.</p>

<p>기술적인 전략으로 깃 브랜치 전략, PR 시 어떻게 할지… 등 처음 하는 것인 만큼, 팀원과 진행하는 과정에서 git 의 협업 관련 서적을 보면서, 가장 최선이 뭘까 고민했었다.</p>

<p>사실, 이 내용을 디테일하게 정리한다면 엄청난 일이 될 거다. 거의 한 프로젝트를 3개월간 수행했던걸 생각하면, 얼마나 많은 대화와 소통, 특히 거기서 서로 어떻게 하는 걸로 해야 효율적일지 논하던 시간들은 지금 생각하면 무척 값진 일이었지만 동시에 힘든 과정이기도 했다. 그나마 위안은 42서울의 학생들 상당 수가 개발자의 가능성, 성향, 그리고 무엇보다 열정과 재미를 느끼는 이들이었기에 그런 점들이 우리를 묶어주었던 것이다.</p>

<hr />

<h3 id="-1단계-문자열-해석-parsing---무의미한-텍스트에서-의미-있는-구조로">📜 1단계: 문자열 해석 (Parsing) - 무의미한 텍스트에서 의미 있는 구조로</h3>

<p>본격적으로 기능 구현에 들어가면 셸의 첫 번째 임무는 명령어를 컴퓨터가 이해할 수 있는 구조적인 데이터로 변환하는 것이다.</p>

<p>예를 들어 <code class="language-plaintext highlighter-rouge">ls -al | grep "main" &gt; result.txt</code>와 같이 약속된 명령어들의 나열이있다. 하지만 실제로 컴퓨터가 이 명령어를 알아듣나? 아니다. 실질 터미널에서 치는 내용을 컴퓨터는 알아듣지 못한다. 0, 1이 아니기 때문이다. 따라서 ‘이해시키는’ 작업이 필요하고 이는 작은 프로그래밍 언어의 컴파일러를 만드는 과정과 유사하며, 크게 두 단계로 나뉜다.</p>

<ol>
  <li>
    <p><strong>어휘 분석 (Lexical Analysis / Tokenization)</strong>:
입력된 문자열을 <code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">-al</code>, <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">"main"</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">result.txt</code> 와 같이 의미를 가진 최소 단위인 <strong>토큰(Token)</strong>으로 분해한다. 이 과정에서 공백은 분리의 기준이 되며, 파이프(<code class="language-plaintext highlighter-rouge">|</code>)나 리다이렉션(<code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>) 같은 특수 문자는 ‘연산자’ 토큰으로, 따옴표로 묶인 문자열은 하나의 단일 토큰으로 인식하는 등 정교한 규칙이 필요하다.
이러한 규칙들은 요구되는 조건들, 쉘의 기본 동작에대한 공식문서를 보고 전부 기술화하였다. 약속된 컨벤션의 예약된 단어나 도구들에 대해 리스트업을 한 뒤에는 우선순위나 어떤 걸 우선시 해야 하는지 가시화 하였다.</p>
  </li>
  <li>
    <p><strong>구문 분석 (Syntax Analysis / Parsing)</strong>:
생성된 토큰의 배열을 바탕으로, 명령어의 문법적 구조를 파악하여 <strong>추상 구문 트리(Abstract Syntax Tree, AST)</strong>와 같은 자료구조를 생성한다. 예를 들어, <code class="language-plaintext highlighter-rouge">A | B &gt; C</code> 라는 명령어는 ‘파이프’라는 최상위 노드를 가지고, 그 왼쪽 자식으로는 ‘A’라는 간단한 명령어(Simple Command) 노드가, 오른쪽 자식으로는 ‘리다이렉션’ 노드가 연결되는 형태가 된다. 이 트리를 통해 각 명령어의 관계와 실행 순서, 입출력 방향이 명확하게 정의된다. 이 과정에서 닫히지 않은 따옴표나 문법에 맞지 않는 특수문자 사용과 같은 구문 오류를 잡아내는 것도 파서의 중요한 역할이다. 특히나 히어독과 같은 것들을 위한 개별 로직이 언제 어떻게 실행 되는지와 같은 포인트들을 이해하는 것도 매우 중요헤지며, 이를 구조체로 담아내는 작업, 그리고 특히나 이런 데이터 단위로 탐색이 편리한 메소드를 구성하는 것은 개발 속도에도 지대한 영향을 주었다.</p>
  </li>
</ol>

<ul>
  <li><strong>따옴표와 환경 변수 처리</strong>: 파싱 과정에서 셸의 미묘한 규칙들을 구현해야 한다.
  <strong><em>작은따옴표(<code class="language-plaintext highlighter-rouge">'</code>)**는 내부의 모든 문자를 해석 없이 문자 그대로 취급한다.
  **</em>큰따옴표(<code class="language-plaintext highlighter-rouge">"</code>)</strong>는 내부의 <code class="language-plaintext highlighter-rouge">$</code> 문자를 환경 변수로 인식하여 그 값으로 <strong>치환(Expansion)</strong>해야 한다.<code class="language-plaintext highlighter-rouge">$?</code>와 같이 마지막으로 실행된 명령어의 종료 코드를 나타내는 특수한 환경 변수도 처리해야 한다.</li>
</ul>

<hr />

<h3 id="️-2단계-명령어-실행-execution---구조화된-명령에-생명을-불어넣다">🛠️ 2단계: 명령어 실행 (Execution) - 구조화된 명령에 생명을 불어넣다</h3>

<p>구문 분석을 통해 만들어진 실행 계획(AST)을 이제 직접 실행되게 하면 된다. 실행기는 트리를 순회하며 각 노드의 타입에 따라 적절한 시스템 콜을 호출하는 역할을 하고, 이때 리눅스 OS 의 철학, 프로세스의 라이프 사이클을 이해하는 것이 정말 중요해진다.</p>

<ol>
  <li>
    <p><strong>프로세스 생성 (<code class="language-plaintext highlighter-rouge">fork</code>)</strong>:
<code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">grep</code>과 같은 외부 명령어를 실행하기 위해 <code class="language-plaintext highlighter-rouge">fork()</code> 시스템 콜로 현재 셸 프로세스와 똑같은 자식 프로세스를 생성한다. 이후 자식 프로세스는 <code class="language-plaintext highlighter-rouge">execve()</code> 시스템 콜을 통해 자기 자신을 새로운 프로그램(<code class="language-plaintext highlighter-rouge">ls</code> 등)으로 교체하여 실행한다. 부모 프로세스(셸)는 <code class="language-plaintext highlighter-rouge">waitpid()</code>를 통해 자식 프로세스가 종료되기를 기다렸다가, 종료와 함께 제어권을 다시 가져와 다음 명령을 받을 준비를 한다. 이때 특히나 에러핸들링을 잘해주는 것이 필요하고, 적절한 문구를 통해 명령이 왜 실패했는지를 이해하는게, 디버깅의 핵심이었다.</p>
  </li>
  <li><strong>파이프 (<code class="language-plaintext highlighter-rouge">|</code>) - 프로세스 간 통신 (IPC)</strong>:
<code class="language-plaintext highlighter-rouge">pipe()</code> 시스템 콜은 두 개의 파일 디스크립터(읽기용, 쓰기용)를 생성하여 프로세스 간 통신 채널을 만단다. <code class="language-plaintext highlighter-rouge">A |B</code> 구문에서, 셸은 파이프를 생성한 후 두 개의 자식 프로세스를 만든다. 
여기서 중요한 부분이 파일, FD 를 통해 어떻게 관리되는지를 이해하는 것이었다. 특히나, 열고 닫는 것이 굉장히 중요해지는데, 여러개의 프로세스가 동작할 때, 출력-입력의 열려있는 것들을 잘 닫아주는 로직이 아니게 되면 이전 프로세스가 출력하고 담았지만, 프로세스가 정상 종료가 안 된 것, 혹은 데이터가 더 들어올게 남았다는 식으로 되기 때문에 이 특징을 이해하지 않으면 주구장창 대기하는 상태가 된다는 것은… 끔찍한 경험이었다(…)
    <ul>
      <li><strong>프로세스 A</strong>: 자신의 표준 출력(STDOUT, fd 1)을 파이프의 쓰기용 끝에 연결(<code class="language-plaintext highlighter-rouge">dup2</code>)하고, <code class="language-plaintext highlighter-rouge">A</code> 명령어를 실행한다. <code class="language-plaintext highlighter-rouge">A</code>의 모든 결과는 이제 화면이 아닌 파이프로 흘러 들어간다.</li>
      <li><strong>프로세스 B</strong>: 자신의 표준 입력(STDIN, fd 0)을 파이프의 읽기용 끝에 연결(<code class="language-plaintext highlighter-rouge">dup2</code>)하고, <code class="language-plaintext highlighter-rouge">B</code> 명령어를 실행한다. <code class="language-plaintext highlighter-rouge">B</code>는 이제 키보드가 아닌 파이프로부터 데이터를 입력받아 처리한다.</li>
    </ul>
  </li>
  <li>
    <p><strong>리다이렉션 (<code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>) - 파일 디스크립터 제어</strong>:
리다이렉션은 프로세스의 표준 입출력 대상을 파일로 변경하는 기술이다. 이는 <code class="language-plaintext highlighter-rouge">open()</code>으로 파일을 열고, <code class="language-plaintext highlighter-rouge">dup2()</code>로 기존의 표준 입출력 파일 디스크립터(0, 1, 2)를 새로 열린 파일의 디스크립터로 복제하는 방식으로 구현된다.
*<code class="language-plaintext highlighter-rouge">&gt;</code>: 명령어의 결과를 파일에 덮어쓴다.
*<code class="language-plaintext highlighter-rouge">&lt;</code>: 파일의 내용을 명령어의 입력으로 사용한다.
*<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>: 명령어의 결과를 파일 끝에 추가한다.
*<code class="language-plaintext highlighter-rouge">&lt;&lt; (Here Document)</code>: 구분자(delimiter)가 나올 때까지 입력을 받아 임시 파일에 저장한 후, 해당 임시 파일을 표준 입력으로 리다이렉션하는 방식으로 구현된다.</p>
  </li>
  <li><strong>내장 함수 (Built-ins)</strong>:
<code class="language-plaintext highlighter-rouge">cd</code>, <code class="language-plaintext highlighter-rouge">export</code>, <code class="language-plaintext highlighter-rouge">unset</code>, <code class="language-plaintext highlighter-rouge">exit</code>와 같이 셸 프로세스 자체의 상태(현재 작업 경로, 환경 변수 등)를 변경해야 하는 명령어들은 외부 프로그램으로 실행할 수 없다. 이러한 내장 함수들은 프로세스의 주인이 되는 메인 프로세스의 설정을 건드리거나, 상호작용하기 때문이다. 예를 들어 <code class="language-plaintext highlighter-rouge">cd</code>를 자식 프로세스에서 실행하면 자식의 경로만 바뀌고 셸 자신은 그대로이고, 이렇게 되면 그 뒤에 오는 명령이 비정상적으로 실행 및 종료 될 수 있다. 따라서 이는 <code class="language-plaintext highlighter-rouge">fork</code> 없이 셸이 직접 함수 호출을 통해 처리해야 한다. <code class="language-plaintext highlighter-rouge">README.md</code>에 명시된 <code class="language-plaintext highlighter-rouge">echo</code>, <code class="language-plaintext highlighter-rouge">cd</code>, <code class="language-plaintext highlighter-rouge">pwd</code>, <code class="language-plaintext highlighter-rouge">export</code>, <code class="language-plaintext highlighter-rouge">unset</code>, <code class="language-plaintext highlighter-rouge">env</code>, <code class="language-plaintext highlighter-rouge">exit</code>가 이에 해당되고, 이들은 독자적인 방식으로 OS 와 주 프로세스에 직접 영향을 주도록 만들어야 했다.</li>
</ol>

<hr />

<h3 id="-3단계-시그널-처리---예기치-않은-상황에-대응하기">🚦 3단계: 시그널 처리 - 예기치 않은 상황에 대응하기</h3>

<p>사용자는 언제든지 <code class="language-plaintext highlighter-rouge">Ctrl+C</code>(SIGINT)나 <code class="language-plaintext highlighter-rouge">Ctrl+D</code>(EOF)를 눌러 프로세스를 제어하려 할 수 있다.상호작용적인 셸은 이러한 시그널을 적절히 처리하여, 자식 프로세스가 실행 중일 때와 프롬프트에서 입력을 대기 중일 때 다르게 동작하도록 설계해야 한다. <code class="language-plaintext highlighter-rouge">signal</code> 또는 <code class="language-plaintext highlighter-rouge">sigaction</code> 함수를 통해 특정 시그널이 도착했을 때 수행할 동작을 정의하여, 프로그램의 안정성과 사용자 경험을 향상시켰다.
<strong>*대기 중</strong>: <code class="language-plaintext highlighter-rouge">Ctrl+C</code>는 새 프롬프트를, <code class="language-plaintext highlighter-rouge">Ctrl+D</code>는 셸을 종료한다.</p>
<ul>
  <li><strong>실행 중</strong>: <code class="language-plaintext highlighter-rouge">Ctrl+C</code>와 <code class="language-plaintext highlighter-rouge">Ctrl+\</code>는 실행 중인 자식 프로세스에게 전달되어야 한다.</li>
</ul>

<hr />

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p><code class="language-plaintext highlighter-rouge">Minishell</code>은 단순한 C 프로그래밍 과제가 아니었다. 운영체제가 어떻게 사용자 요청을 처리하고, 프로세스들을 조율하며, 데이터의 흐름을 관리하는지에 대한 이해도를 높일 수 있는 정말 좋은 과제였다고 생각한다. 뿐만 아니라 한 개인이 개발할 수 있는 한계가 있고, 결국 협업으로 만들어내는 종합 예술임을 처음으로 느낄 수 있던 과제다. 그 와중에 느낀 점들 몇가지를 정리해보면,</p>

<ul>
  <li><strong>추상화의 위대함</strong>: <code class="language-plaintext highlighter-rouge">|</code>나 <code class="language-plaintext highlighter-rouge">&gt;</code> 같은 간단한 기호 뒤에 <code class="language-plaintext highlighter-rouge">fork</code>, <code class="language-plaintext highlighter-rouge">pipe</code>, <code class="language-plaintext highlighter-rouge">dup2</code>, <code class="language-plaintext highlighter-rouge">execve</code>와 같은 복잡한 시스템 콜들의 오케스트라가 숨어있음을 깨달으며, 잘 설계된 추상화의 힘을 체감했다.</li>
  <li><strong>프로세스 관리의 정수</strong>: 부모와 자식 프로세스의 관계, 파일 디스크립터의 상속, 프로세스의 라이프사이클을 직접 관리하며 운영체제의 핵심 역할인 프로세스 관리를 피부로 이해하게 되었다.</li>
  <li><strong>설계의 중요성</strong>: 어휘 분석기, 구문 분석기, 실행기를 각각 독립된 모듈로 설계하고, 이들을 연결하는 명확한 자료구조(AST)를 정의하는 과정은, 복잡한 시스템을 구축하기 위해선 견고한 아키텍처 설계가 선행되어야 함을 가르쳐주었다.</li>
</ul>

<p>정말 쉽지 않았다. 
포기하고 싶다는 생각을 정말 많이 했고, 무엇보다 팀원과 함께 기운이 빠지는 정말 쉽지 않은 프로젝트였다.
그래도 역시 그런 걸까? 돌아보니 정말 재밌고, 치열했던것 같다. 🤣</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="C" /><category term="Linux" /><summary type="html"><![CDATA[💻 Minishell: 운영체제의 축소판, 텍스트와 프로세스 사이의 번역가를 자처하다]]></summary></entry><entry><title type="html">42 Seoul - 010_NetPractice</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-10.html" rel="alternate" type="text/html" title="42 Seoul - 010_NetPractice" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-10</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/09/05/resume-post-42-10.html"><![CDATA[<h2 id="-netpractice-네트워크의-법칙을-설계하다---osi-3계층-탐험기">🌐 NetPractice: 네트워크의 법칙을 설계하다 - OSI 3계층 탐험기</h2>

<p><strong>NetPractice</strong>는 분리된 기계들이 어떻게 서로를 인식하고 데이터를 주고받는지에 대한 ‘통신의 법칙’을 직접 설계하는 과제다. 쉬운 말로 푼다면, 네트워크 망의 형태를 구축해주고, 기계들이 인식하게 직접 설정해보는 것이 핵심 목표인 미니 프로젝트이다.</p>

<p>이 프로젝트는 IP 주소, 서브넷 마스크, 라우팅이라는 개념을 통해, 복잡한 네트워크 스택 중 가장 핵심적인 <strong>OSI 7계층의 3계층, 네트워크 계층(Network Layer)</strong>의 동작 원리를 직관적으로 체득하게 하며, 원시적인 망 구축의 모방이라고 보면 되겠다.</p>

<p>NetPractice는 물리적인 케이블(1계층)이나 MAC 주소를 이용한 내부 통신(2계층)의 복잡성을 추상화하고, 오직 논리적인 주소(IP)와 경로 설정(Routing)만으로 전체 네트워크의 통신을 관장하게 하며, 이 과정에서 어떤 식으로 기계들이 서로를 인식하며, 서로를 부르는 방법이 뭔질 이해해야, 해당 프로젝트의 문제들을 풀고, 직접 IPv4 기반으로 어떤 기기에는 얼마나 주소를 할당 가능한지를 알 수 있는 그런 프로젝트라 할 수 있겠다.</p>

<hr />

<h3 id="-핵심-개념-주소-체계와-경로-설정">📜 핵심 개념: 주소 체계와 경로 설정</h3>

<p>성공적인 통신망을 구축하기 위해서는, 모든 장치가 고유한 <strong>주소</strong>를 가져야 하고, 한 주소에서 다른 주소로 가는 <strong>경로</strong>를 찾을 수 있어야 한다. NetPractice는 이 두 가지 원리를 중심으로 구성되어 있다.</p>

<p>우선 감사의 말씀을 전할 것은, 먼저 간 이들의 멋진 글들이(…) 교재가 되어 주어서, 일일히 찾거나 어디서부터 어디까지 공부 해야 하는지 등, 정말 많은 부분에서 해결이 쉬었다. <del><a href="https://80000coding.oopy.io/9f9642d8-0281-40ef-901f-3d5b68d5eef4">대표적으로 이런 글들…</a></del></p>

<ol>
  <li>
    <p><strong>IP 주소 (Internet Protocol Address)</strong>:
네트워크 계층에서 각 장치(호스트, 라우터 인터페이스)를 식별하기 위한 32비트(IPv4 기준)의 논리적 주소이다. 이 주소는 단순히 장치를 식별하는 것을 넘어, ‘어떤 네트워크에 속해 있는지’에 대한 정보를 내포하고 있다.</p>
  </li>
  <li><strong>서브넷 마스크 (Subnet Mask) 와 CIDR</strong>:
IP 주소의 가장 중요한 역할은 ‘네트워크 주소’ 부분과 ‘호스트 주소’ 부분을 구분하는 것이다.
    <ul>
      <li><strong>네트워크 주소</strong>: 장치가 속한 ‘동네’를 나타낸다.</li>
      <li><strong>호스트 주소</strong>: ‘동네’ 안에서 각 장치를 구분하는 ‘집 주소’에 해당한다.</li>
      <li><strong>서브넷 마스크</strong>는 이 두 부분을 구분하는 기준점이다. 컴퓨터는 자신의 IP 주소와 목적지 IP 주소를 각각 서브넷 마스크와 <strong>비트 AND 연산</strong>을 수행한다. 그 결과로 나온 네트워크 주소가 동일하면 ‘같은 네트워크’로 판단하고, 다르면 ‘다른 네트워크’로 판단한다.
        <ul>
          <li>` (IP 주소) &amp; (서브넷 마스크) = 네트워크 주소 `</li>
        </ul>
      </li>
      <li><strong>CIDR(Classless Inter-Domain Routing)</strong> 표기법은 <code class="language-plaintext highlighter-rouge">/24</code> 와 같이 IP 주소 뒤에 슬래시와 숫자를 붙여 서브넷 마스크를 간결하게 표현하는 현대적인 방식이다. <code class="language-plaintext highlighter-rouge">/24</code>는 32비트 중 앞의 24비트가 네트워크 주소임을 의미한다.</li>
    </ul>
  </li>
  <li><strong>게이트웨이 (Gateway) 와 라우팅 (Routing)</strong>:
‘다른 네트워크’에 있는 목적지로 데이터를 보내기 위해서는 현재 네트워크의 ‘출입구’ 역할을 하는 <strong>게이트웨이</strong>를 거쳐야 한다. 이 게이트웨이는 일반적으로 라우터가 담당한다.
    <ul>
      <li><strong>라우팅 테이블</strong>: 라우터는 내부에 ‘라우팅 테이블’이라는 이정표를 가지고 있다. 이 테이블에는 <code class="language-plaintext highlighter-rouge">[목적지 네트워크 주소, 다음으로 넘길 라우터(Next Hop), 사용할 네트워크 인터페이스]</code> 정보가 기록되어 있다.</li>
      <li><strong>라우팅 로직</strong>: 패킷을 수신한 라우터는 패킷의 목적지 IP 주소를 자신의 라우팅 테이블과 비교하여, 가장 구체적인 경로(Longest Prefix Match)를 선택해 패킷을 다음 목적지로 전달(Forwarding)한다.</li>
      <li><strong>기본 경로 (Default Route)</strong>: 라우팅 테이블에 명시된 경로가 없을 경우를 대비한 ‘기본값’ 경로이다. <code class="language-plaintext highlighter-rouge">0.0.0.0/0</code>으로 표기하며, “이 테이블에 없는 모든 목적지는 일단 이곳으로 보내라”는 의미를 가진다.</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="-netpractice-시뮬레이션-이론의-실체화">🚀 NetPractice 시뮬레이션: 이론의 실체화</h3>

<p>NetPractice는 위의 개념을 기반으로, 주소 배치를 어떻게 하면 되고, 서브넷 마스크를 어떻게 설정하면 되는지를 문제로 만들었고, 각 레벨로 나누어 이러한 이론적 개념들을 실제 토폴로지에 적용하는 식으로 진행되었다.</p>

<ul>
  <li>
    <p><strong>초반 레벨 (동일 네트워크 통신)</strong>:
  하나의 서브넷 안에 있는 호스트 간의 통신을 설정한다. 이 단계에서는 모든 장치가 동일한 네트워크 주소를 가지므로 게이트웨이나 라우팅이 필요 없다. IP 주소와 서브넷 마스크의 기본 개념을 확립하는 단계이다.</p>
  </li>
  <li>
    <p><strong>중반 레벨 (라우터를 통한 이종 네트워크 연결)</strong>:
  라우터를 중심으로 둘 이상의 다른 서브넷이 연결된 구조가 등장한다. 이 단계의 핵심은 각 호스트에 <strong>자신이 속한 네트워크의 출입구, 즉 게이트웨이의 IP 주소를 정확히 설정</strong>해주는 것이다. 또한, 라우터에는 <strong>자신이 직접 연결된 네트워크 외에 다른 네트워크로 가는 경로를 라우팅 테이블에 명시적</strong>으로 추가해야 한다.</p>
  </li>
  <li>
    <p><strong>후반 레벨 (복잡한 토폴로지와 라우팅 경로 설계)</strong>:
  여러 개의 라우터가 서로 연결된 복잡한 인터넷 구조를 모방한다. 패킷이 목적지까지 여러 라우터(홉, Hop)를 거쳐야 한다. 이 단계에서는 특정 라우터가 직접 연결되지 않은 ‘멀리 떨어진’ 네트워크까지 도달할 수 있도록, <strong>모든 라우터에 전체 네트워크 구성을 고려한 라우팅 정보를 연쇄적으로 설정</strong>해야 한다. A 라우터는 B로 가는 길을 알아야 하고, B 라우터는 C로 가는 길을 알아야만 A에서 C로의 최종 통신이 가능해진다.</p>
  </li>
</ul>

<hr />

<h3 id="-성찰-및-배운-점">✨ 성찰 및 배운 점</h3>

<p>NetPractice는 추상적인 네트워크 이론에 구체적인 형태와 감각을 부여하는 과제였다.</p>

<ul>
  <li><strong>네트워크 3계층에 대한 직관적 이해</strong>: 패킷이 라우터를 거칠 때마다 어떤 논리적 판단을 통해 경로가 결정되는지, 서브넷 마스크가 ‘우리 편’과 ‘남’을 구분하는 데 어떻게 사용되는지를 시뮬레이션을 통해 명확하게 이해하게 되었다.</li>
  <li><strong>추상화의 교훈</strong>: 우리가 네트워크 통신을 할 때 당연하게 여겼던 모든 과정이, 실제로는 이처럼 잘 정의된 주소 체계와 라우팅 프로토콜이라는 약속 위에서 동작하고 있음을 깨달았다. 복잡한 하위 계층을 숨기고 핵심 논리에 집중하게 해주는 추상화의 중요성을 다시 한번 느꼈다.</li>
  <li><strong>논리적 디버깅 능력</strong>: ‘KO’ 사인이 떴을 때, 패킷의 출발지부터 목적지까지의 경로를 머릿속으로 따라가며 어느 지점의 IP, 서브넷 마스크, 또는 라우팅 테이블 설정이 잘못되었는지를 논리적으로 추론하고 가설을 세워 수정하는 과정은, 네트워크 문제 해결의 축소판과도 같았다. 어렵게 이야기 하긴 했지만, 약간 인터넷 공유기, 라우터가 이런 거구나 라고 공감(?)을 가지게 되는 그런 과제였다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="프로젝트" /><category term="42Seoul" /><category term="Network" /><summary type="html"><![CDATA[🌐 NetPractice: 네트워크의 법칙을 설계하다 - OSI 3계층 탐험기]]></summary></entry></feed>