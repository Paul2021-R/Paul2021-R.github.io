<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-10-17T13:43:22+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">TIL - jenkins 로 무중단 nextjs 배포 구축하기</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins.html" rel="alternate" type="text/html" title="TIL - jenkins 로 무중단 nextjs 배포 구축하기" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins.html"><![CDATA[<h2 id="2025년-10월-17일-개발-내용-요약-및-학습-정리">2025년 10월 17일 개발 내용 요약 및 학습 정리</h2>
<h2 id="-jenkins-무중단-배포-구축을-위한-추가-밑작업">📝 Jenkins 무중단 배포 구축을 위한 추가 밑작업</h2>
<h3 id="-목적-purpose">✨ 목적 (Purpose)</h3>

<p>Jenkins 를 활용한 무중단 배포를 구축하기 위해, 단순히 Dodcker 컨테이너화로 끝나는게 아닌, 배포 용이, 무중단성을 확보하기 위한 구조 개선이 필요하다고 느꼈다. 이에 아래의 목표를 기반으로 NextJS 의 프로젝트에 추가적인 작업 목표를 설정해보았다.</p>

<ul>
  <li><strong>CI/CD 파이프라인 통합 용이성</strong>: Jenkins와 같은 CI/CD 도구를 통해 자동화된 빌드 및 배포를 더욱 용이하게 합니다.</li>
  <li><strong>개발 및 운영 환경 일관성 유지</strong>: Docker를 통해 개발 및 운영 환경 간의 차이를 최소화하고 일관성을 유지합니다.</li>
  <li><strong>무중단 배포(Zero-downtime Deployment) 지원</strong>: Nginx와 블루/그린 배포 전략을 통해 서비스 중단 없이 애플리케이션을 업데이트할 수 있는 기반을 마련합니다.</li>
  <li><strong>프로젝트 가독성 및 유지보수성 향상</strong>: 명확한 디렉토리 구조와 상세한 문서화를 통해 프로젝트의 가독성과 유지보수성을 높입니다.</li>
</ul>

<h3 id="️-주요-변경-사항">🛠️ 주요 변경 사항</h3>

<h4 id="1-프로젝트-구조-재편">1. 프로젝트 구조 재편</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">app/</code> 디렉토리로 파일 이동</strong>: 기존 루트 디렉토리에 있던 Next.js 관련 파일들 (<code class="language-plaintext highlighter-rouge">.dockerignore</code>, <code class="language-plaintext highlighter-rouge">.gitignore</code>, <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">eslint.config.mjs</code>, <code class="language-plaintext highlighter-rouge">next.config.ts</code>, <code class="language-plaintext highlighter-rouge">package.json</code>, <code class="language-plaintext highlighter-rouge">pnpm-lock.yaml</code>, <code class="language-plaintext highlighter-rouge">postcss.config.mjs</code>, <code class="language-plaintext highlighter-rouge">public/</code>, <code class="language-plaintext highlighter-rouge">src/</code>, <code class="language-plaintext highlighter-rouge">tsconfig.json</code>)이 모두 <code class="language-plaintext highlighter-rouge">app/</code> 디렉토리 내부로 이동시켰다. 이는 Next.js 애플리케이션의 모듈성을 높이고, 프로젝트의 각 구성 요소(Next.js 앱, Nginx)를 명확하게 분리하기 위함이다.</li>
</ul>

<h4 id="2-docker-환경-구성-개선">2. Docker 환경 구성 개선</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">app/Dockerfile</code> 다단계 빌드(Multi-stage Build) 개선</strong>: <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 스테이지 구성이 더욱 세분화 시켰다. <code class="language-plaintext highlighter-rouge">base</code>, <code class="language-plaintext highlighter-rouge">dev_runner</code>, <code class="language-plaintext highlighter-rouge">prod_modules_setter</code> 스테이지가 추가되어 개발 및 운영 환경에 맞는 의존성 설치 및 빌드 과정을 명확하게 분리했다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">dev_runner</code>: 개발용 의존성을 설치하여 빠른 개발 환경을 독립적으로 제공 목적으로 만듬.</li>
      <li><code class="language-plaintext highlighter-rouge">prod_modules_setter</code>: 운영용 의존성만 설치하여 최종 이미지 크기를 최적화하고 보안을 강화한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">app/docker-compose.yml</code> 추가</strong>: <code class="language-plaintext highlighter-rouge">app/</code> 디렉토리 내부에 Next.js 앱만을 위한 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, 이 파일은 <code class="language-plaintext highlighter-rouge">dev</code>와 <code class="language-plaintext highlighter-rouge">prod</code> 서비스를 정의하여 Next.js 앱의 개발 및 운영 환경을 독립적으로 관리하도록 만들었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">루트 최상단의 docker-compose.yml</code></strong> : 기존 <code class="language-plaintext highlighter-rouge">dev</code> 및 <code class="language-plaintext highlighter-rouge">prod</code> 서비스 정의가 삭제되고, <code class="language-plaintext highlighter-rouge">nginx</code>, <code class="language-plaintext highlighter-rouge">app-blue</code>, <code class="language-plaintext highlighter-rouge">app-green</code> 서비스가 새로 정의되어있다. 이는 블루/그린 배포 전략을 위한 핵심적인 내용만을 담고 있어서, 빌드 시 production으로 완전히 빌드되어주는 것만을 바라본다.</li>
</ul>

<h4 id="3-nginx-리버스-프록시reverse-proxy-및-블루그린-배포-설정">3. Nginx 리버스 프록시(Reverse Proxy) 및 블루/그린 배포 설정</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리 생성 및 설정 파일 추가</strong>: <code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리가 새로 생성되었고, 그 안에 <code class="language-plaintext highlighter-rouge">Dockerfile</code>과 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 를 만들었다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>: Nginx 이미지를 빌드한다. 기존 설정을 배제하는 것 까지만 포함된다.</li>
      <li><code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>: <code class="language-plaintext highlighter-rouge">nextjs_app</code> 업스트림을 통해 Next.js 앱(<code class="language-plaintext highlighter-rouge">app-blue:3000</code>으로 초기 설정)으로 트래픽을 전달하도록 설정시키는 용이다. 이는 Jenkins와 같은 CI/CD 도구를 통한 동적 배포를 염두에 둔 구성.</li>
    </ul>
  </li>
  <li><strong>블루/그린 배포 전략 도입</strong>: 루트 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 <code class="language-plaintext highlighter-rouge">nginx</code> 서비스가 <code class="language-plaintext highlighter-rouge">app-blue</code>와 <code class="language-plaintext highlighter-rouge">app-green</code> 서비스에 의존하도록 설정하여, 무중단 배포를 위한 블루/그린 배포 전략의 기반을 마련하였다.</li>
</ul>

<hr />

<h2 id="배운-것들-정리">배운 것들 정리</h2>
<h3 id="멀티-스테이지-빌드multi-stage-build">멀티 스테이지 빌드(Multi-stage build)</h3>
<ul>
  <li>멀티스테이지 빌드는 최종 이미지를 <strong>최대한 가볍고 안전하게</strong> 만들기 위해, 하나의 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 안에 여러 개의 독립적인 빌드 환경(스테이지)을 정의하는 기술이다.</li>
</ul>

<h4 id="필요한-이유는">필요한 이유는?</h4>
<p>만약 스테이지 개념 없이 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 작성하면, 다음과 같은 문제가 발생할 수 있다.</p>
<ol>
  <li><strong>이미지 비대화 (Bloated Image)</strong>: 코드를 빌드하기 위해 설치했던 <code class="language-plaintext highlighter-rouge">typescript</code>, <code class="language-plaintext highlighter-rouge">eslint</code> 같은 모든 개발용 도구(<code class="language-plaintext highlighter-rouge">devDependencies</code>)가 최종 실행 이미지에 불필요하게 포함된다.</li>
  <li><strong>보안 취약점 (Security Risk)</strong>: 사용하지 않는 도구나 라이브러리가 많을수록, 해커가 악용할 수 있는 공격 지점(Attack Surface)이 늘어난다.</li>
</ol>

<hr />
<h4 id="작동-원리-from--as-와-copy---from">작동 원리: <code class="language-plaintext highlighter-rouge">FROM ... AS</code> 와 <code class="language-plaintext highlighter-rouge">COPY --from</code></h4>

<p>멀티스테이지 빌드는 이 두 가지 명령어로 동작한다.</p>
<h5 id="1-from--as-스테이지_이름">1. <code class="language-plaintext highlighter-rouge">FROM ... AS &lt;스테이지_이름&gt;</code></h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Dockerfile</code>에서 <code class="language-plaintext highlighter-rouge">FROM</code> 명령어가 나올 때마다 새로운 스테이지가 시작됩니다. 이는 <strong>이전 스테이지와는 완전히 격리된, 새로운 환경</strong>에서 시작한다는 뜻이다.</li>
  <li><code class="language-plaintext highlighter-rouge">AS &lt;스테이지_이름&gt;</code> (예: <code class="language-plaintext highlighter-rouge">AS builder</code>) 구문을 사용해, 해당 스테이지에 우리가 알아볼 수 있는 <strong>이름표</strong>를 붙여주는 역할을 한다.</li>
</ul>

<h5 id="2-copy---from스테이지_이름">2. <code class="language-plaintext highlighter-rouge">COPY --from=&lt;스테이지_이름&gt;</code></h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">COPY</code> 명령어에 <code class="language-plaintext highlighter-rouge">--from</code> 플래그를 사용하면, 다른 스테이지에 붙여둔 이름표를 호출하여 <strong>해당 스테이지의 결과물만</strong> 현재 스테이지로 가져올 수 있다.</li>
</ul>

<h4 id="실-예제로-보면">실 예제로 보면?</h4>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ======= 1. BASE 스테이지 =======</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:22-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">base</span>
<span class="c"># 작업 위치 설정 - 해당 컨테이너 위치 </span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># pnpm 설치 </span>
<span class="k">RUN </span>npm <span class="nb">install</span> <span class="nt">-g</span> pnpm

<span class="c"># package.json, pnpm-lock.yaml 등 의존성 관련 파일만 복사</span>
<span class="k">COPY</span><span class="s"> package.json pnpm-lock.yaml ./</span>

<span class="c"># ======= 2. dev용 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">base</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">dev_runner</span>
<span class="c"># 의존성 설치 - dev 용</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span>

<span class="c"># ======= 3. 빌드 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">dev_runner</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>

<span class="c"># 나머지 소스 코드 전체 복사 </span>
<span class="k">COPY</span><span class="s"> . .</span>

<span class="c"># 애플리케이션 빌드</span>
<span class="k">RUN </span>pnpm run build

<span class="c"># ======= 4. 의존성 증류 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">base</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">prod_modules_setter</span>

<span class="c"># 의존성 중 production용만 받아오기</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span> <span class="nt">--prod</span>

<span class="c"># ======= 5. prod 실행 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:22-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">runner</span>

<span class="c"># 작업 디렉토리 설정 </span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># 빌드 스테이지의 운영에 필요한 파일들만 복사 </span>
<span class="c"># 1. 빌드 결과물 </span>
<span class="k">COPY</span><span class="s"> --from=builder /app/.next ./.next</span>

<span class="c"># 2. 정적 파일</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/public ./public</span>

<span class="c"># 3. 운영용 의존성</span>
<span class="k">COPY</span><span class="s"> --from=prod_modules_setter /app/node_modules ./node_modules</span>

<span class="c"># 4. package.json 파일</span>
<span class="k">COPY</span><span class="s"> --from=prod_modules_setter /app/package.json ./package.json</span>

<span class="c"># 애플리케이션이 사용할 포트 노출 </span>
<span class="k">EXPOSE</span><span class="s"> 3000</span>

<span class="c"># 컨테이너 시작 시 명령어</span>
<span class="k">CMD</span><span class="s"> ["node", "./node_modules/next/dist/bin/next", "start"]</span>
</code></pre></div></div>

<ul>
  <li>BASE 스테이지는 공통된 영역까지를 전제로 작성되어 레이어를 구성한다.</li>
  <li>dev 개발 환경은 모든 의존성을 설치 및 HR(핫리로딩)으로 동작하므로 <code class="language-plaintext highlighter-rouge">dev_runner</code> 스테이지에서 모든 의존성을 받아서, 설정을 종료 하게 된다.(docker-compose.yml 을 통해)</li>
  <li>prod 의 경우 <code class="language-plaintext highlighter-rouge">builder</code> 를 통해 빌드가 이루어지는데, 이때 빌드 하면서 개발환경의 노드 모듈들을 포함해야 하는데, 그렇기에 실제 프로덕션 환경에서 필요한 노드 모듈만 받아오지 못하게 되어 있다.</li>
  <li>그렇기에 <code class="language-plaintext highlighter-rouge">prod_modules_setter</code>는 다시 <code class="language-plaintext highlighter-rouge">base</code> 기반에서 –prod 옵션을 통해 프로덕션에서 필요한 것들만을 받아 놓는 역할만을 수행한다.</li>
  <li>최종적으로 <code class="language-plaintext highlighter-rouge">runner</code>는 빌드된 파일, 순수한 production 기반의 모듈들만을 받아서, 깔끔하게 실행된다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 17일 개발 내용 요약 및 학습 정리 📝 Jenkins 무중단 배포 구축을 위한 추가 밑작업 ✨ 목적 (Purpose)]]></summary></entry><entry><title type="html">TIL - Next.js</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs.html" rel="alternate" type="text/html" title="TIL - Next.js" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs.html"><![CDATA[<h2 id="2025년-10월-14일-개발-내용-요약-및-학습-정리">2025년 10월 14일 개발 내용 요약 및 학습 정리</h2>

<h3 id="1-개발-내용-요약">1. 개발 내용 요약</h3>

<p>2025년 10월 14일, Next.js 프로젝트의 개발 환경 설정을 Docker 기반으로 고도화하는 작업이 완료되었다. 주요 내용은 다음과 같다.</p>

<ul>
  <li><strong>Next.js 프로젝트 설정:</strong> <code class="language-plaintext highlighter-rouge">create-next.js-app</code>을 사용하여 TypeScript 기반의 Next.js 프로젝트를 생성하고, <code class="language-plaintext highlighter-rouge">pnpm</code>을 최신 버전으로 업데이트하며 Next.js 15 버전으로 시작했다. Turbopack 사용 여부에 대한 검토 후, 현재 안정화된 webpack 기반으로 진행했다.</li>
  <li><strong>Docker 환경 구축:</strong>
    <ul>
      <li><strong>프로덕션(운영) Dockerfile 작성:</strong> 멀티 스테이지 빌드(Multi-stage builds)를 활용하여 <code class="language-plaintext highlighter-rouge">builder</code> 스테이지와 <code class="language-plaintext highlighter-rouge">runner</code> 스테이지로 나누어 효율적인 Docker 이미지를 생성했다. <code class="language-plaintext highlighter-rouge">builder</code> 스테이지에서는 의존성 설치 및 빌드를 수행하고, <code class="language-plaintext highlighter-rouge">runner</code> 스테이지에서는 빌드된 결과물만을 복사하여 가볍고 최적화된 운영 이미지를 구성했다. <code class="language-plaintext highlighter-rouge">.dockerignore</code> 파일을 통해 불필요한 파일이 이미지에 포함되지 않도록 설정했다.</li>
      <li><strong>Docker Compose를 활용한 개발 환경 구축:</strong> <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일을 작성하여 개발 환경(<code class="language-plaintext highlighter-rouge">dev</code> 서비스)을 설정했다. <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 <code class="language-plaintext highlighter-rouge">builder</code> 스테이지를 사용하고, <code class="language-plaintext highlighter-rouge">npm run dev</code> 명령어를 오버라이드하여 HMR(Hot Module Replacement)을 지원하며, 로컬 소스코드와 컨테이너를 볼륨으로 마운트하여 실시간 코드 변경이 반영되도록 했다.</li>
      <li><strong>Docker Compose를 활용한 프로덕션 환경 추가 및 분리:</strong> 동일한 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일 내에 프로덕션 환경(<code class="language-plaintext highlighter-rouge">prod</code> 서비스)을 추가했다. <code class="language-plaintext highlighter-rouge">prod</code> 서비스는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 전체를 빌드하되, 볼륨 마운트 없이 빌드된 이미지를 그대로 사용하고 <code class="language-plaintext highlighter-rouge">npm start</code> 명령어로 운영 서버를 실행하도록 설정했다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">package.json</code> 스크립트 연동:</strong> 개발 편의성을 극대화하기 위해 <code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">pnpm start:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm start:prod</code>, <code class="language-plaintext highlighter-rouge">pnpm set:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm set:prod</code>, <code class="language-plaintext highlighter-rouge">pnpm unset:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm unset:prod</code> 등의 Docker Compose 관련 스크립트를 추가하여 개발 경험(DX)을 효율화했다.</li>
</ul>

<h3 id="2-학습-내용-정리">2. 학습 내용 정리</h3>

<p>이번 개발 환경 설정을 통해 다음과 같은 내용을 학습하고 정리했다.</p>

<ul>
  <li><strong>Next.js 프로젝트 생성 및 기본 설정:</strong> <code class="language-plaintext highlighter-rouge">create-next-app</code> 사용법, TypeScript 및 <code class="language-plaintext highlighter-rouge">pnpm</code> 활용, Turbopack과 webpack의 차이점 및 선택 기준을 이해했다.</li>
  <li><strong>Docker Multi-stage Builds:</strong> 빌드 환경과 실행 환경을 분리하여 최종 이미지 크기를 최적화하고 보안을 강화하는 방법을 익혔다. 특히 <code class="language-plaintext highlighter-rouge">builder</code>와 <code class="language-plaintext highlighter-rouge">runner</code> 스테이지의 역할 분담을 명확히 이해했다.</li>
  <li><strong>Dockerfile 명령어 심층 이해:</strong> <code class="language-plaintext highlighter-rouge">RUN</code> vs <code class="language-plaintext highlighter-rouge">CMD</code>의 차이점, <code class="language-plaintext highlighter-rouge">COPY</code> 명령어의 역할과 캐싱 메커니즘, <code class="language-plaintext highlighter-rouge">alpine</code> 리눅스 이미지를 사용하는 이유(작은 크기, 보안) 등을 구체적으로 파악했다.</li>
  <li><strong>Docker Compose 활용:</strong> <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>을 통해 개발(<code class="language-plaintext highlighter-rouge">dev</code>) 및 운영(<code class="language-plaintext highlighter-rouge">prod</code>) 환경을 분리하고 관리하는 방법을 배웠다. 특히 개발 환경에서의 볼륨 마운트를 통한 HMR 구현과 프로덕션 환경에서의 최적화된 이미지 사용 방식을 이해했다.</li>
  <li><strong>개발 경험(DX) 최적화:</strong> <code class="language-plaintext highlighter-rouge">package.json</code> 스크립트를 활용하여 복잡한 Docker Compose 명령어를 단순화하고, 개발 워크플로우를 간소화하는 방법을 적용했다.</li>
</ul>

<h3 id="3-다음-단계-레포지토리-및-ai-리뷰-기능-연동">3. 다음 단계: 레포지토리 및 AI 리뷰 기능 연동</h3>

<p>이번 Docker 기반 개발 환경 설정을 성공적으로 마무리함에 따라, 다음 단계로는 이 환경을 기반으로 코드의 버전 관리 및 AI 기반 코드 리뷰 기능을 연동하는 작업을 진행할 예정이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="Front-End" /><summary type="html"><![CDATA[2025년 10월 14일 개발 내용 요약 및 학습 정리]]></summary></entry><entry><title type="html">Redis, 최근 보안 위협과 대응 방안</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/10/redis-critical-security-issues.html" rel="alternate" type="text/html" title="Redis, 최근 보안 위협과 대응 방안" /><published>2025-10-10T00:00:00+00:00</published><updated>2025-10-10T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/10/redis-critical-security-issues</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/10/redis-critical-security-issues.html"><![CDATA[<h3 id="redis-성능과-편의성-뒤에-숨겨진-보안-위협과-대응-방안">Redis, 성능과 편의성 뒤에 숨겨진 보안 위협과 대응 방안</h3>

<p>많은 시스템에서 캐싱(Caching) 전략이나 메시지 큐(Message Queue)의 구현체로 Redis를 활발하게 사용한다. 이전 직장에서 근무할 당시, 데이터베이스의 부하를 줄이고 애플리케이션의 응답 속도를 높이기 위해 Redis 도입을 적극적으로 추진했던 경험이 있다. 과정은 순탄치 않았고 여러 어려움이 있었지만, 성공적으로 적용한 뒤 눈에 띄게 향상된 성능과 줄어든 DB 사용량을 보며 큰 보람을 느꼈다.</p>

<h4 id="최근-동향과-경각심">최근 동향과 경각심</h4>

<p>최근 Redis의 보안 취약점을 악용한 공격 사례에 대한 보안뉴스 기사를 접하게 되었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-10-023.png" alt="" /></p>

<ul>
  <li><strong>참고 기사</strong>: <a href="https://m.boannews.com/html/detail.html?idx=139675">https://m.boannews.com/html/detail.html?idx=139675</a></li>
</ul>

<p>기사의 핵심은 <strong>별도의 인증 없이 외부에 노출된 Redis 서버가 주요 공격 대상이 되고 있다는 점</strong>이다. 많은 개발 환경에서 기능 구현의 편의성이나 개발 속도를 우선시하여 보안 설정을 간과하는 경우가 많다. 과거의 프로젝트들을 돌이켜보면, 나 또한 개발 편의를 위해 일부 보안 설정을 관대하게 적용했던 순간들이 있었다. 따라서 해당 기사를 계기로 Redis를 안전하게 운영하기 위해 반드시 적용해야 할 설정들을 다시 한번 정리하고 상기하고자 한다.</p>

<h4 id="redis-보안-강화를-위한-핵심-수칙">Redis 보안 강화를 위한 핵심 수칙</h4>

<p>기사에 따르면, 공격자는 외부에 노출된 Redis 서버에 접근해 데이터를 탈취하거나 서버를 악성코드 유포의 숙주로 삼을 수 있다. 이를 방지하기 위해 다음과 같은 설정은 필수로 적용해야 한다.</p>

<ol>
  <li>
    <p><strong>네트워크 격리를 통한 접근 제어</strong></p>

    <ul>
      <li>
        <p>Redis는 <strong>로컬 호스트(127.0.0.1) 바인딩을 기본 원칙</strong>으로 삼아야 한다. <code class="language-plaintext highlighter-rouge">redis.conf</code> 파일의 <code class="language-plaintext highlighter-rouge">bind</code> 지시어를 <code class="language-plaintext highlighter-rouge">bind 127.0.0.1</code>로 설정하여 외부에서의 직접적인 접근을 원천적으로 차단하는 것이 가장 중요하다.</p>
      </li>
      <li>
        <p>클라우드 환경(e.g., AWS)에서 여러 인스턴스를 운영할 때, <strong>같은 VPC(Virtual Private Cloud) 내에서 Private IP를 통해 통신하도록 아키텍처를 설계</strong>하는 것이 비용 효율성과 보안 강화 측면에서 필수적이다. 보안 수준을 높이기 위해 <code class="language-plaintext highlighter-rouge">0.0.0.0</code>과 같이 모든 인터페이스를 개방하는 설정은 반드시 지양해야 한다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>강력한 인증 체계 및 명령어 제어</strong></p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">redis.conf</code> 파일 내의 <code class="language-plaintext highlighter-rouge">requirepass</code> 항목을 통해 <strong>복잡하고 추측하기 어려운 비밀번호를 설정</strong>하는 것은 기본적이면서도 필수적인 조치이다. 데이터베이스와 달리 Redis의 데이터는 휘발성(in-memory)이라는 생각에 인증 절차의 중요성을 간과하기 쉽지만, 이는 세션 하이재킹이나 데이터 유출 등 심각한 보안 사고로 이어질 수 있는 매우 위험한 접근이다.</p>
      </li>
      <li>
        <p>데이터 전체 삭제(<code class="language-plaintext highlighter-rouge">FLUSHALL</code>, <code class="language-plaintext highlighter-rouge">FLUSHDB</code>)나 서버 설정 변경(<code class="language-plaintext highlighter-rouge">CONFIG</code>)과 같이 시스템 운영에 치명적인 영향을 줄 수 있는 명령어는 <code class="language-plaintext highlighter-rouge">rename-command</code> 설정을 통해 <strong>예측 불가능한 이름으로 변경하거나 비활성화</strong>하여 명령어 실행에 대한 리스크를 최소화해야 한다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>지속적인 버전 관리 및 모니터링</strong></p>

    <ul>
      <li>
        <p>소프트웨어의 구 버전에는 <strong>알려진 보안 취약점(CVE)이 존재</strong>할 수 있다. 따라서 항상 안정화된 최신 버전으로 Redis를 유지하여 잠재적인 위협을 사전에 방지해야 한다.</p>
      </li>
      <li>
        <p>외부로부터의 비정상적인 접근 시도나 내부에서의 비인가 명령어 실행 여부 등을 지속해서 감시할 수 있는 <strong>모니터링 및 로깅 시스템을 구축</strong>하는 것이 중요하다. 이를 통해 이상 징후를 조기에 탐지하고 신속하게 대응할 수 있다.</p>
      </li>
    </ul>
  </li>
</ol>

<p>결론적으로 향후 진행할 프로젝트에도 캐싱 전략은 선택이 아닌 필수 요소이다. 그때마다 안전하고 효율적인 Redis 환경을 구축하기 위해, 이번에 정리한 내용들을 표준 체크리스트로 활용하고자 한다. 더 나아가, 향후에는 이러한 보안 설정들을 코드화하여 구성 관리(Configuration Management)의 일부로 포함시키는 것을 목표로 해야겠다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Redis, 성능과 편의성 뒤에 숨겨진 보안 위협과 대응 방안]]></summary></entry><entry><title type="html">Ubuntu 서버 설정 할 때 snap 사용 시 주의해야하는 이유는?</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue.html" rel="alternate" type="text/html" title="Ubuntu 서버 설정 할 때 snap 사용 시 주의해야하는 이유는?" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue.html"><![CDATA[<h2 id="ubuntu에서-docker를-sudo-없이-사용하려다-발견한-snap-설치의-함정">Ubuntu에서 Docker를 sudo 없이 사용하려다 발견한 snap 설치의 함정</h2>

<h3 id="문제-상황">문제 상황</h3>

<p>Project 를 위하여 Ubuntu 서버 머신을 한대 구했다. Geekom의 A5 7530U 칩셋 탑재 제품으로 윈도우 데스크탑은 나쁘지 않으나, 전성비나, 항시 켜놓고 사용 하기 위함, WSL의 번거로움 등을 고려할 때, 온전한 리눅스 전용 머신의 필요성으로 미니 PC 를 한대 구매했다.</p>

<p>Ubuntu 22.04 LTS 기반으로 설치 후, 개발환경 설정, 컨테이너 활용을 위해 Docker 설정까지 끝냈었다. 그리하여 Docker 명령어를 실행할 때마다 <code class="language-plaintext highlighter-rouge">sudo</code>를 입력하는 것이 번거로워, 일반 사용자 계정을 docker 그룹에 추가하려고 했다. 그런데 예상치 못한 문제들이 연쇄적으로 발생했는데…</p>

<h3 id="발견한-문제들">발견한 문제들</h3>

<h4 id="1-docker-그룹이-존재하지-않음">1. docker 그룹이 존재하지 않음</h4>

<p>일반적으로 Docker를 설치하면 자동으로 생성되는 <code class="language-plaintext highlighter-rouge">docker</code> 그룹이 시스템에 존재하지 않았다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/group | <span class="nb">grep </span>docker
<span class="c"># 결과: 아무것도 출력되지 않음</span>
</code></pre></div></div>

<h4 id="2-systemctl로-docker-서비스를-찾을-수-없음">2. systemctl로 Docker 서비스를 찾을 수 없음</h4>

<p>Docker가 분명 설치되어 있고 실행도 되는데, <code class="language-plaintext highlighter-rouge">systemctl status docker</code> 명령이 작동하지 않았다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
<span class="c"># Docker version 24.x.x 등 정상 출력</span>

systemctl status docker
<span class="c"># Unit docker.service could not be found.</span>
</code></pre></div></div>

<h4 id="3-원인-snap으로-설치된-docker">3. 원인: snap으로 설치된 Docker</h4>

<p>Docker 그룹이 설정이 안되는 경우는 공식 가이드 문서에서 볼 때 수동 설치만 해주면 되는 것이었다. <a href="https://docs.docker.com/engine/install/linux-postinstall/">링크</a>
단, 다른 문제들에 대해서는 찾아본 결과 snap 패키지였던 것이 문제의 근본 원인이었다. (이번엔 편한게 해보겠다고 스토어로 GUI 로 설치했더니만…)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snap list | <span class="nb">grep </span>docker
<span class="c"># docker    xx.x.x    xxxx    latest/stable    canonical    -</span>
</code></pre></div></div>

<h3 id="snap-vs-apt-무엇이-다른가">snap vs apt: 무엇이 다른가?</h3>

<h4 id="snap의-특징">snap의 특징</h4>

<p>snap은 Ubuntu에서 개발한 독립적인 패키지 시스템으로, 다음과 같은 특징이 있다:</p>

<ul>
  <li><strong>완전한 격리(confinement)</strong>: 앱을 샌드박스 환경에서 실행</li>
  <li><strong>자체 포함(self-contained)</strong>: 모든 의존성을 패키지 내부에 포함</li>
  <li><strong>보안 우선</strong>: 시스템 리소스 접근이 제한적</li>
  <li><strong>자동 업데이트</strong>: 백그라운드에서 자동으로 업데이트</li>
</ul>

<h4 id="apt의-특징">apt의 특징</h4>

<p>전통적인 패키지 관리 시스템으로:</p>

<ul>
  <li><strong>시스템 통합</strong>: 시스템 라이브러리를 직접 공유</li>
  <li><strong>완전한 접근</strong>: 시스템 리소스에 제약 없이 접근</li>
  <li><strong>가벼움</strong>: 공유 라이브러리 사용으로 용량 절약</li>
  <li><strong>수동 관리</strong>: 사용자가 직접 업데이트 제어</li>
</ul>

<hr />
<h4 id="docker에는-왜-apt가-적합한가">Docker에는 왜 apt가 적합한가?</h4>

<p>결과적으로 차이점을 고려해본 결과  Docker는 시스템 레벨에서 동작하는 도구이므로:</p>

<ul>
  <li>호스트 파일시스템에 광범위하게 접근 필요</li>
  <li>네트워크, 프로세스, 저장소 등 시스템 리소스 제어 필요</li>
  <li>snap의 격리 정책이 오히려 제약으로 작용</li>
</ul>

<p>일반 사용자에게는 snap이 편리하고 안전하지만, <strong>서버 개발 도구로는 apt 방식이 훨씬 적합하다는 결론을 내릴 수 있었다</strong>.</p>

<h3 id="해결-방법-snap-제거-후-apt로-재설치">해결 방법: snap 제거 후 apt로 재설치</h3>

<h4 id="1-기존-snap-docker-제거">1. 기존 snap Docker 제거</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>snap remove docker
</code></pre></div></div>

<h4 id="2-기존-apt-docker-패키지-제거-있을-경우-대비">2. 기존 apt Docker 패키지 제거 (있을 경우 대비)</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt remove docker docker-engine docker.io containerd runc
</code></pre></div></div>

<h4 id="3-docker-공식-저장소에서-설치">3. Docker 공식 저장소에서 설치</h4>

<p><strong>필수 패키지 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> ca-certificates curl gnupg lsb-release
</code></pre></div></div>

<p><strong>Docker 공식 GPG 키 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo install</span> <span class="nt">-m</span> 0755 <span class="nt">-d</span> /etc/apt/keyrings
curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/docker.gpg
<span class="nb">sudo chmod </span>a+r /etc/apt/keyrings/docker.gpg
</code></pre></div></div>

<p><strong>Docker 저장소 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="se">\</span>
  <span class="s2">"deb [arch=</span><span class="si">$(</span>dpkg <span class="nt">--print-architecture</span><span class="si">)</span><span class="s2"> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu </span><span class="se">\</span><span class="s2">
  </span><span class="si">$(</span>lsb_release <span class="nt">-cs</span><span class="si">)</span><span class="s2"> stable"</span> | <span class="nb">sudo tee</span> /etc/apt/sources.list.d/docker.list <span class="o">&gt;</span> /dev/null
</code></pre></div></div>

<p><strong>Docker 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre></div></div>

<h4 id="4-일반-사용자로-docker-사용-설정">4. 일반 사용자로 Docker 사용 설정</h4>

<p><strong>docker 그룹에 사용자 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>usermod <span class="nt">-aG</span> docker <span class="nv">$USER</span>
</code></pre></div></div>

<p><strong>변경사항 적용:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newgrp docker
<span class="c"># 또는 로그아웃 후 재로그인</span>
</code></pre></div></div>

<p><strong>설치 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
docker run hello-world
</code></pre></div></div>

<h3 id="주의사항">주의사항</h3>

<h4 id="보안-고려사항">보안 고려사항</h4>

<p>docker 그룹에 속한 사용자는 <strong>root 권한과 동등한 접근</strong>이 가능하다. 이는 다음을 의미한다:</p>

<ul>
  <li>컨테이너를 통해 호스트 시스템의 모든 파일에 접근 가능</li>
  <li>권한 상승(privilege escalation) 위험 존재</li>
  <li>보안이 중요한 환경에서는 신중히 고려 필요</li>
</ul>

<h4 id="데이터-백업">데이터 백업</h4>

<p>snap에서 apt로 전환 시 기존 데이터가 삭제된다:</p>

<ul>
  <li>snap Docker 컨테이너 및 이미지: 모두 삭제됨</li>
  <li>볼륨 데이터 경로: <code class="language-plaintext highlighter-rouge">/var/snap/docker/</code>에서 <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>로 변경</li>
  <li>중요한 데이터가 있다면 사전에 <code class="language-plaintext highlighter-rouge">docker save</code>, <code class="language-plaintext highlighter-rouge">docker export</code> 등으로 백업 필요</li>
</ul>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://docs.docker.com/engine/install/linux-postinstall/">Docker 공식 문서 - Linux 설치 후 설정</a></li>
  <li><a href="https://docs.docker.com/engine/install/ubuntu/">Docker 공식 문서 - Ubuntu 설치</a></li>
  <li><a href="https://docs.docker.com/engine/security/rootless/">Docker 공식 문서 - Rootless 모드</a></li>
</ul>

<h3 id="결론">결론</h3>

<p>GUI를 통한 편리한 설치가 항상 최선은 아니네 싶다. 특히 개발 도구의 경우, 패키지 관리 방식에 따라 동작 방식과 시스템 통합 수준이 크게 달라진다. Docker처럼 시스템 레벨 접근이 필요한 도구는 snap보다 전통적인 apt 방식이 더 적합하며, 이를 통해 불필요한 제약 없이, 최적화된 개발 환경을 구축할 수 있다.</p>

<p>물론 일반 사용에선 전혀 그렇지 않다고 생각도 든다. 왜냐면 리눅스 시스템의 라이브러리의 의존성 문제로 업데이트를 잘못하면 큰일나는 경우를 몇 번 경험했고(…) 무지성하게 구글에서 명령어 긁어다가, install 박아버리는 순간 지옥이 펼쳐지는 경우를 생각한다면(…). 의존성을 확실하게 관리하고 마치 Docker 처럼 정확하게 컨테이너화 시키는게 확실히 이유가 있어 보였다. 이러한 지점에서 Ubuntu 가 일반 소비자용의 철학을 가진 OS 라는 점을, 새삼 느끼게 만든다. (근데 프로세스까지 독립적으로 관리하게 하는 건 좀…)</p>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="DevOps" /><category term="Docker" /><category term="Linux" /><summary type="html"><![CDATA[Ubuntu에서 Docker를 sudo 없이 사용하려다 발견한 snap 설치의 함정]]></summary></entry><entry><title type="html">Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html" rel="alternate" type="text/html" title="Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html"><![CDATA[<h2 id="obsidian--copilot---나만의-글쓰기-agent를-만들어보자">Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자</h2>
<h3 id="글쓰기의-길은-멀고도-험하다">글쓰기의 길은 멀고도 험하다</h3>

<p>기술 블로그를 써라.</p>

<p>프로젝트의 후기나, 느낀 점. 기술의 효용성이나 고민한 과정을 써라</p>

<p>개발자로 살아가는 이상, 노하우, 기술에 대한 이해를 표현하는 것이 프로그램의 ‘질’ 또는 ‘실력’을 결정한다는 개발 분야의 공통의 법칙은 언제나 우릴 괴롭힌다.</p>

<p>이에 끊임없이 글을 적어둬야 한다는 고통과 노이로제에 시달린다.</p>

<p>나 역시 글쓰기를 완전 잘한다거나 글을 뽑아내는 기계도 아니다. 그나마 글을 쓰는걸 좋아하는 편이라지만, 그럼에도 해야할 일 산더미인데, 언제 적냐.. 라는 말이 매번 튀어나온다. 글쓰기가 가장 시간을 많이 쓴다는 사실은 달라지지 않는다.</p>

<p>그러다가 최소 2-3주 걸릴 만한 미니 프로젝트, Obsidian + Copilot + gemini 의 에이전트 만들기를 진행해 보았다. 그리고 그걸 적용한 이 글. 이 글을 단 3일 만에 마무리 되었다면 믿겠는가?</p>

<p>AI를 활용해서 글을 대신 파바박, 하루 만에 뚝딱 하고 써주진 않지만… 그럼에도 이번 미니 프로젝트를 통해, 글쓰기, 학습에서 정말 도움이 되는 Agent 생성에 도전 그리고 나름의 결과를 만들어냈다.</p>

<p><strong>개인적으로 풀어내는 이 후기, 함께 적용 해본다면, 정말 괜찮게, 도움이 되는 글쓰기 보조 에이전트를 만들 수 있지 않을까?</strong> 조심스레 이야기를 시작해보고자 한다.</p>

<h2 id="본론">본론</h2>

<h3 id="시작은-obsidian-그리고-copilot">시작은 Obsidian 그리고 Copilot</h3>
<p>Notion 은 많이들 쓸 것이다. 언제 어디서든, 그리고 어떤 장비든 웹 기반의 Notion은 데이터를 저장하기에 적절하다고 생각하는 이들이 많다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-003.png" alt="" /></p>

<p>하지만 한때 이를 진지하게 써본 입장에서, Obsidian을 주력 정보 저장, 글쓰기 도구로 쓰게되었다. 이유는 다음과 같다.</p>

<ol>
  <li>Notion 업데이트 시 잔버그가 수시로 발생하는데, 데이터 영역까지 함께 문제가 되는 경우가 발생함.(데이터 삭제도 발생한다.)</li>
  <li>한글 유저는 영어보다 특히나 버그 발생률이 높다</li>
  <li>문서 양이 많아지면, 유료 계정임에도 검색 문제, 버벅거림 문제가 발생한다</li>
</ol>

<p>요즘은 많이 나아졌다고 하지만, 한 번쯤 API 문서 같은거 만들어두었다가 날려먹어보면, Notion은 쳐다보지도 않게 된다. 그냥 포트폴리오 를 위한 간단 공유용 정도면 모를까.</p>

<p>Obsidian은 가벼우며, 검색, 태깅 등 기본적인 기능이 강력하다. 특히나 퍼포먼스가 매우 훌륭하다. 플러그인도 제공하기 때문에, 이를 활용하면 Notion 그 이상의 확장성, 사용성, 글쓰는 데 편리함을 제공해준다. 그리고 운명 같은 날이 찾아왔으니… 바로 <code class="language-plaintext highlighter-rouge">Copilot</code> 이란 플러그인을 발견했을 때였다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-004.png" alt="" /></p>

<p>코파일럿. 누가보면 윈도우에서 만든 AI 인줄알 것 같다. 이 플러그인은 단어 의미대로의 윈도우의 AI와는 별도의 플러그인이다. 당당하게 유료 결제 버전도 존재하는데, 그에 대해선 나중에 이야기 하려고 하고, 지금은 이 녀석이 뭔가에 대해 설명해주려고 한다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-005.png" alt="" /></p>

<h3 id="ai-좀더-통합-좀더-효율적이게-분신-만들기">AI, 좀더 통합, 좀더 효율적이게.. 분신 만들기?</h3>

<p>AI 가 말 하나는 기똥차게 하고, 이미 VSC 나 각종 IDE 는 통합이 이루어졌다. 그런데 이 Copilot 은 글쓰기 도구인 Obsidian을 그렇게 만들어주는 프로그램이다. 설치 방법은 간단하다. 로컬 LLM 이나, api 키를 활용해 연결이 된다. 만약 API 발급이 궁금하면 하단의 글을 참고하면 좋다.</p>

<p>연결하고, 사용을 해보니 순간 머릿속에 스치는 게 있었다.</p>

<blockquote>
  <p>“이 정도 통합이면… 나 대신 글쓰기 해줄 수 있지 않을까?”</p>
</blockquote>

<p>본론으로 돌아와서 글쓰기. 생각해보면 학습, 개발을 하다보면 글쓸 자료는 넘쳐났다. 지금까지는 gemini + 기타 다른 ai  이런 식으로 하여 사용도 해보았고. gemini 의 세부 기능을 활용한다거나 gemini-cli 라는 프로그램으로 내 맥북 내부에서 llm 을 구동해 자료를 취합, 글을 써보기도 해보았다.</p>

<p>하지만 이런 방식이  대중화되거나 입소문을 많이 타진 않았다. 왜그런가? 우선, 다양한 자료, 글감은 여기저기 흩뿌려져 있는 경우가 있다. 설치도 복잡하고, 오류도 있다. 뿐만 아니라, 정리를 해서 어딘가에 모아서 글감들을 정리해도,  ‘나답게’, ‘내 냄새’ 가 나는 글로 만들 수 있냐! 라고 하면 그렇지 않기 때문에, 실상 내가 알고 있는 것들을 모아서 글을 쓰는 것과 큰 차이가 없는 것이다.</p>

<p>그러는 와중에 Copilot 의 기능으로 <code class="language-plaintext highlighter-rouge">Command</code>라는 기능을 발견하였다. 단순히 LLM 을 연결만 해주는게 아니라, 직접 명령을 적어서 매크로처럼 쓸 수 있는데, 심지어 프롬프트로 전역 설정하는 것들도 있는 것이 아닌가?</p>

<p><strong>그리고 아까 전 상황. 그렇다. 이정도면 나의 문체를 그대로 문서화, 프롬프트화 시켜서 등록을 해두면, ‘딸깍’ 하고 글을 써줄수 있지 않을까? 이 생각에 무릎을 탁친 나는 도전을 해보기로 하였다.</strong></p>

<h4 id="나를-분석해보자-how">나를 분석해보자 How?</h4>

<p>우선, 첫 시작은 나를 분석하는 것이다. 내가 누굴까? 글로 표현되는 나를 AI 가 모방하는게 우선이라고 생각했다. 나는 가능하면 나의 주관적 판단이 들어가는 것은 좋지 않다고 생각했다. 나의 주관은 나에 대한 여러 측면에 대해 ‘과소평가’ 와 ‘과대평가’가 함께 공존하고 있다고 생각하기 때문이다. 그러니 나에 대한 긍정 평가도 부정 평가도 아닌 어딘가의 제 3자 관점에서 분석을 하는 것이 가장 적절하다고 생각했다.</p>

<p>그런데 이제는 간단하다. 내가 쓴 글들을 다 가져와서 분석을 시키던가, 내 블로그에 AI 가 알아서 분석해라고 하는게 가능하다. 오히려 도구를 뭘 쓸지만 고민하면 되었다.  이에 Claude 와 Gemini 의 <code class="language-plaintext highlighter-rouge">deep research</code> 기능으로, 나의 글, 나의 문체에 대한 분석을 각각 요청했다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-006.png" alt="" />
<img src="/assets/images/posts/2025-10/2025-10-09-007.png" alt="" /></p>

<blockquote>
  <p>💡 핵심은 자신에 대한 분석을 준비하는 것이다. 방법의 제약은 없다. AI 를 활용해, 자신을 표현하는 자료들을 최대한 보여주면서 분석을 요청해라.</p>
</blockquote>

<h4 id="나의-분신을-등록해보았다">나의 분신을 등록해보았다.</h4>

<p>음~ 나의 계획은 완벽해! 이런 착각을 하며 Claude 와 Gemini 는 열심히 생각을, GPU가 녹고 있음을 느끼고 있었다. 이제 내가 퇴고만 해주면 되는게 아닌가! 새삼 AI 의 능력은 믿어 의심치 않고 있었고, 개발까지 가지 않아도 해결 될 수 있다는 이 행복한 시대를 살고 있음에 하늘을 향해 감사인사를 하면서, 기다렸다.</p>

<p>10분이 채 안되어, 결론은 순식간에 나왔고, 그 결과가 다음과 같았다.</p>

<pre><code class="language-plain"># gemini의 정확한 모사 버전
### Persona
당신은 '성실한 기술 기록자(Diligent Technical Archivist)'입니다. 당신의 주된 목표는 커리어 발전을 위해 스스로 학습한 기술 내용을 미래의 자신이 다시 참고할 수 있도록 정확하고 체계적으로 기록하는 것입니다. 당신의 글은 타인을 가르치기 위한 것이 아니라, 스스로의 이해를 완성하고 검증하기 위한 학습 과정의 산물입니다.

### Core Philosophy
모든 내용은 '촘촘한 학습'과 '치밀한 정리'라는 핵심 철학을 따라야 합니다. 피상적인 요약 대신, 공식 문서나 신뢰할 수 있는 자료를 기반으로 한 깊이 있고 상세한 내용을 우선시합니다. 정확성과 완전성이 가장 중요한 가치이며, 모든 기술적 설명은 검증 가능해야 합니다.

### Voice and Tone
- **어조**: 체계적이고, 객관적이며, 사실에 기반한 약간의 격식체를 사용합니다.
- **감정 배제**: 과장, 유머, 지나치게 친근한 말투는 피합니다.
- **목적 명시**: 글의 목적이 학습과 기록임을 명확히 하되, 독자를 가르치려는 듯한 계몽적인 어조는 사용하지 않습니다.

### Content Generation Modes
당신은 아래 두 가지 모드 중 하나로 콘텐츠를 생성해야 합니다. 각 모드는 목적과 형식 면에서 명확히 구분됩니다.

#### Mode 1: 심층 탐구 학습 로그 (Deep Dive Study Log)
- **목적**: Kubernetes, Docker, CS 기초 등 근본적이고 방대한 주제를 체계적으로 학습하고 정리합니다.
- **형식**:
    - 예상 읽기 시간 15~30분 분량의 긴 글을 작성합니다.
    - 공식 문서를 번역하거나 핵심 내용을 재구성하는 방식으로 정보를 전달합니다.
    - 복잡한 시스템을 구성 요소별로 나누어 상세히 설명합니다.
    - 제목은 '[기술명] - [세부 주제]' 형식을 따릅니다.
    - 논리적 흐름에 따라 명확한 소제목으로 내용을 구조화합니다.

#### Mode 2: 기술 메모 (Technical Memo)
- **목적**: 특정 도구 사용법, 문제 해결 과정, 설정 방법 등 구체적이고 실용적인 정보를 빠르게 기록합니다.
- **형식**:
    - 예상 읽기 시간 2~5분 분량의 짧고 간결한 글을 작성합니다.
    - '문제 상황 -&gt; 해결 과정 -&gt; 결과'의 구조를 명확히 합니다.
    - 필요한 경우 코드 스니펫, 설정 파일, 명령어 등을 정확히 포함합니다.
    - 제목은 'memo - [문제 또는 주제]'와 같이 직관적으로 작성합니다.

### Formatting and Structure
- **제목**: 기능적이고 내용을 명확히 설명하는 제목을 사용합니다.
- **마크다운**: 헤딩(##, ###), 목록(리스트), 코드 블록을 적극적으로 사용하여 가독성을 높입니다.
- **용어 사용**: 기술 용어는 한국어와 영어를 자연스럽게 혼용합니다. (예: 쿠버네티스 컨트롤 플레인(Control Plane))

### Task
이제 위의 모든 규칙을 준수하여 다음 요청을 수행해 주십시오:
[여기에 구체적인 콘텐츠 생성 요청 입력]
</code></pre>

<pre><code class="language-plain"># claude의 정확한 모사 버전
Paul2021-R 스타일로 글을 작성해주세요:

[문체 지침]
- 삼박자 수식어구로 리듬감 조성 (예: "종합적으로, 효율적으로, 효과적으로")
- 격식체 기본 + "...!" 감탄부호로 친근함 표현
- 영어 기술용어와 한국어 개념어 자연스럽게 혼용
- 불렛포인트와 계층적 구조로 체계적 정보 정리

[어조와 관점]
- 겸손하면서도 전문적인 태도 유지
- 솔직한 자기성찰과 현실적 사고
- 비전공자/학습자 관점에서의 공감과 조언
- 과정 중심적 서술 (결과보다는 시행착오 과정 중시)

[표현 스타일]
- 구체적 수치와 날짜로 생생함 표현
- 게임/레벨링 비유로 성장 과정 설명
- "하루 하루", "항상 고민하고, 궁금해하며" 같은 반복 패턴
- 실패 인정 후 교훈 도출하는 구조
</code></pre>

<p>내용은 읽으면 읽을수록 찰떡 같았다. 다소의 차이점은 Gemini의 경우 철학, 그리고 Mode 라는 식으로 내 글의 종류에 따라 다르게 접근하는 방법을 포함하여 프롬프트를 만들어주었다.</p>

<p>Claude 는 좀더 중립적이지만, 글의 형태를 따라하는 스타일 가이드 형태로 만들어준 것이 눈에 들어왔다. 그렇게 만들어진 내용들은 서로 특징은 다르지만 분명하게 ‘나’를 담고 있었다.</p>

<p>그렇게 생각하고 보니 하는 김에 이왕이면 글을 좀더 보완한다면 어떻게 하면 좋을까? 라는 생각도 들었다.  그렇기에 내 글의 아쉬운 점을 보완하는 프롬프트까지 만들어달라고 하였다.</p>

<pre><code class="language-plain"># gemini - 문체 개선 요청 버전 
### Persona
당신은 '전문가 멘토이자 성실한 기술 기록자(Expert Mentor and Diligent Archivist)'입니다. 당신은 자신의 심도 깊은 학습 과정을 기록함과 동시에, 당신과 비슷한 길을 걷는 다른 엔지니어들에게 의도적으로 명확하고 유용한 가이드를 제공합니다. 당신의 글은 개인적인 기록이자, 가치 있는 공유 자산입니다.

### Audience Awareness
당신의 글을 읽는 독자는 당신과 같이 똑똑한 엔지니어이지만, 당신과 동일한 사전 지식이나 맥락을 가지고 있지 않을 수 있다고 가정하십시오. 따라서 '무엇(what)'을 설명하기 전에 항상 '왜(why)'를 먼저 설명하여 동기를 부여하고 이해를 도와야 합니다.

### Core Philosophy
'촘촘한 학습'과 '치밀한 정리'의 원칙을 지키되, 이를 '명확한 전달'이라는 가치와 결합합니다. 기술적 정확성과 깊이를 유지하면서도, 독자가 개념을 직관적으로 이해할 수 있도록 돕는 것이 중요합니다.

### Narrative and Contextual Framing
모든 게시물은 반드시 다음 세 가지 구조적 요소를 포함해야 합니다.
1.  **도입부 - 맥락 설정 (Opening Context)**: 글의 시작 부분에 이 주제를 왜 지금 다루는지, 이것이 당신의 학습 여정에서 어떤 위치에 있는지를 1~2 문단으로 설명합니다.
2.  **본문 - 기술적 설명**: 핵심 기술 내용을 정확하고 상세하게 설명합니다.
3.  **결론부 - 개인적 종합 (Closing Synthesis)**: 글을 마무리하며, 이번 학습을 통해 얻은 핵심적인 깨달음, 다른 기술과의 연결점, 또는 개인적인 관점을 요약하여 제시합니다.

### Engagement and Readability Elements
콘텐츠 생성 시, 다음 요소들을 능동적으로 통합하여 가독성과 몰입도를 높여야 합니다.
- **비유 (Analogies)**: 복잡하고 추상적인 개념을 설명할 때, 독자의 직관적인 이해를 돕기 위한 적절한 비유를 포함시키십시오.
- **핵심 요약 (Key Takeaway)**: 각 중요 섹션이 끝나거나 글 전체의 마지막에, 핵심 내용을 강조하는 인용문(blockquote) 형식의 요약 박스를 추가하십시오.
- **질문형 소제목 (Interrogative Subheadings)**: "Service의 종류"와 같은 서술형 제목 대신, "쿠버네티스 Service에는 어떤 종류가 있으며, 각각은 언제 사용해야 하는가?"와 같은 질문형 제목을 사용하여 독자의 탐구심을 자극하십시오.

### Formatting and Structure
- **제목**: 기능적이면서도 독자의 흥미를 끌 수 있는 제목을 사용합니다.
- **마크다운**: 헤딩, 목록, 코드 블록, 인용문을 효과적으로 사용하여 시각적 계층 구조와 가독성을 극대화합니다.
- **용어 사용**: 기술 용어는 한국어와 영어를 자연스럽게 혼용합니다.

### Task
이제 위의 모든 규칙을 준수하여 다음 요청을 수행해 주십시오:
[여기에 구체적인 콘텐츠 생성 요청 입력]
</code></pre>

<pre><code class="language-plain"># claude - 문체 개선 요청 버전
Paul2021-R 스타일로 글을 작성해주세요:

[문체 지침]
- 삼박자 수식어구로 리듬감 조성 (예: "종합적으로, 효율적으로, 효과적으로")
- 격식체 기본 + "...!" 감탄부호로 친근함 표현
- 영어 기술용어와 한국어 개념어 자연스럽게 혼용
- 불렛포인트와 계층적 구조로 체계적 정보 정리

[어조와 관점]
- 겸손하면서도 전문적인 태도 유지
- 솔직한 자기성찰과 현실적 사고
- 비전공자/학습자 관점에서의 공감과 조언
- 과정 중심적 서술 (결과보다는 시행착오 과정 중시)

[표현 스타일]
- 구체적 수치와 날짜로 생생함 표현
- 게임/레벨링 비유로 성장 과정 설명
- "하루 하루", "항상 고민하고, 궁금해하며" 같은 반복 패턴
- 실패 인정 후 교훈 도출하는 구조
</code></pre>

<p>마지막으로 Gemini 와 Claude가 서로 다른 시각. 다른 형태의 프롬프트이니, 이걸 합치면 서로 부족한 부분을 보완하고, 완벽해지지 않을까? 아까 전에 언급했던 제 3의 관점의 완전체가 이것이라 생각했다. 화룡점정.</p>

<p>예전부터 gemini, 구글의 모델은 서비스 차원에서 과도한 긍정성, 아첨이 문제시 되기도 했는데, 그러니 서로 다른 관점을 엮거나 합친다면 얼마나 좋을까? 두 모델의 차이를 포함하여 온전한 프롬프트, 강력한 프롬프트를 상상했다. 머릿속에선 이미 나를 대신할 새로운 분신 1호의 탄생에 종이 울리고 있었다. 결과물을 만들 때였다.</p>

<h3 id="context-engineering">Context Engineering</h3>
<h4 id="-뭔가-이상하다--결과물의-상태가-">🤔 뭔가 이상하다 : 결과물의 상태가 ?</h4>

<p>나는 눈을 의심했다. 정리하고, 프롬프트를 등록하고, 데모 글을 작성해보기 위해 자료를 준비했다. 자동화 이전, 상당한 공을 드렸음에도 결과적으로 AI 가 뽑아낸 글은 뭔가 이상하다고 느꼈다.</p>

<p>분명히 나를 분석한 프롬프트고, 심지어 복합적인 시각을 녹이고자 AI 두개의, 다른 시각을 합쳐 만든 완벽한 프롬프트였다. 나를 정확하게 표현한 버전, 내 개선 포인트를 추가로 담은 버전… 온갖 노력을 다 했는데 너무 아쉬운 글들 뿐이지 않은가?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-008.png" alt="" /></p>

<p>글의 퀄리티는 내가 예상했던 수준에 미치지 못하는게 보였다. 이젠 에러 분석이 필요한 시점이었다. 내가 준비한 프롬프트는 다음과 같은 종류로 구성 되어 있었다.</p>

<blockquote>
  <ul>
    <li>Gemini 분석의 저자의 문체를 복사한 ‘정확도’ 버전</li>
    <li>Gemini 분석의 저자의 문체에서 개선사항을 포함한 ‘개선’ 버전</li>
    <li>Claude 분석의 저자의 문체를 복사한 ‘정확도’ 버전</li>
    <li>Claude 분석의 문체에서 개선사항을 포함한 ‘개선’ 버전</li>
  </ul>
</blockquote>

<p>이 버전들을 그냥 쓴게 아니라 언급한 바 Gemini 와 Claude 에게 다시 양측 자료를 제공해주면서, 합쳐진 최종 버전을 만들라고 했었다. 즉 최종 프롬프트는 다음과 같다.</p>

<ol>
  <li>Gemini 정확도 버전 + Claude 정확도 버전 =&gt; Gemini, Claude 각각 합치기를 요청
    <ul>
      <li>Gemini 정확도 버전</li>
      <li>Claude 정확도 버전</li>
    </ul>
  </li>
  <li>Gemini 개선 버전 + Claude 개선 버전 =&gt; Gemini, Claude 각각 합치기를 요청
    <ul>
      <li>Gemini 개선 버전</li>
      <li>Claude 개선 버전</li>
    </ul>
  </li>
</ol>

<p>이렇게하여 나름 통합적 사고가 가능한 프롬프트가 되었으리라 생각했다. 서로의 분석의 빈틈을 매꿔주리라 생각했던 것이다. 하지만…</p>

<p>gemini 정확도 버전의 프롬프트의 글들의 구성은 간소했다. 요구사항은 잘 따른 편이었으나, 정작 문단 구조가 길고, 줄 글이 되어서 가독성이 좋지 못했다. 단순히 나를 모방했다고 하기엔 특징이 너무 부족한 무미 건조한 글이 되어 있었다.</p>

<p>claude 정확도 버전은 인트로에 나의 철학이란 이름으로 42서울, 비전공자 등 굳이 쓸데없는 도입부를 만들어서 글을 작성하였다. 도입부가 굳이 쓸데없는 사족이 없어도 되는데 특정 단어들에 갇혀진 표현 뿐이었다. 학습, 공유, 자기 성장이 목적인 나에게 필요한 글의 구성은 아니었다.</p>

<p>개선버전의 경우엔 다행이도 글 자체의 느낌은 훨씬 좋았다. 그러나 이상하게 AI 개입이 좀더 많고 나의 의도를 넘어선 내용이 있었다. 나의 글의 특성을 모사하진 못한게 보였다. 오히려 AI의 느낌이 강해져버렸다.</p>

<p>정리하면, 선택지는 없었다. 뭔가 문제는 있었으니, 이젠 글이 문제가 아니라 프롬프트를 제대로 까봐야 한다는 판단이 들었다. 그리하여 이번에야말로 프롬프트를 제대로 읽어 보는 순간 납득이 가는 부분이 있었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-009.png" alt="" /></p>

<p>오리지날 원본 프롬프트들까지 준비하여 비교해본 결과, 구체적으로 차이점은 다음과 같았다.</p>

<ol>
  <li>Gemini 건 Claude 건 합치길 요청하여 얻은 결과물들은, 막상 양쪽의 모든 특성을 고려한게 아니라, 일정하게 프롬프트 내역이 빠져 있었다.</li>
  <li>Claude 버전은 공통적으로 기존의 내용에서 상당한 양의 가이드가 사라져 있었고, 스타일 가이드적인 특성이 훨씬 강했던 원본에 비해 Gemini의 철학이나 방향성에 대한 내용이 담겨 있었다.</li>
  <li>Gemini 버전의 경우 원본이 방향성, 철학, 태도 등이 담겨 있었는데, 이러한 부분의 내용이 사라져 있었다. 오히려 스타일 가이드가 일부만 들어가거나, 아예 빠져 있는 경우가 있었다.</li>
</ol>

<p>그리하야… 원본 프롬프트를 다시 써봐야 하겠다 는 생각에 원본 프롬프트로 글을 만들어 내는 것까지 진행해보고 난 뒤, 비로소 나는 결론을 내릴 수 있었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-010.png" alt="" /></p>

<p>내용을 읽어본다면 아마 납득이 갈 것이다. 원본 프롬프트들을 합쳐서 만든 프롬프트와는 달랐다. 오히려 더 나스러운 글을 만들어 낸 것이 보였고, 무엇보다 디테일 적 누락이 많은 부분 해소 되어 있었다. 이유가 무엇인가? 한참을 프롬프트와 결과물을 읽어보니, 이유를 알 수 있었다.</p>

<h4 id="프롬프트는">프롬프트는…</h4>

<h5 id="왜-프롬프트는-자동화가-이상하게-되었단-말인가">왜 프롬프트는 자동화가 이상하게 되었단 말인가?</h5>

<p>나는 두 가지 다른 관점의 프롬프트를 분석하게 해놓았고, 그 분석된 프롬프트를 기반으로 종합시켰을 때 프롬프트의 질이 올라갈 거라고 생각했다. 하지만 이는 ‘착각’이었다.</p>

<p>AI 들은 여러 관점의 합을 만들 때, ‘일반화’되어 버린다. 즉 고유한, 독특한 특징이 될 포인트를 잡는게 아니라, 여러 특징의 점을 찍다보니 결국 각이 많아지다 보면 원형이 되어 버리듯 아주 일반적인 내용화 되는 것이었고, 이런 점은 gemini 를 통해 합성한 프롬프트에서 나타났다. Claude 의 합성의 경우엔 오히려 정보가 손실된 경우도 있었고 말이다.</p>

<p>이러한 현상은 일종의 AI의 ‘정보 손실’의 특성이었다. AI 어텐션 메커니즘(Attention Mechanism) 원리를 생각해보면 보다 확실히 알 수 있다. 입력 정보가 많아질 수록, 중요도가 떨어지는 정보는 요약 과정에서  우선순위 면에서 밀리고, 이 과정이 길어지면 데이터는 누락이 될 수 있었다.</p>

<p>특히나 가장 ‘그럴듯 하게’ 다음 단어를 예측하는게 핵심인 AI 입장에서, 통계적으로 오히려 그럴듯한 결과를 내기 위해선 독특하거나, 독창적인 정보를 담기 보단 ‘일반적인’ 문장의 결과를 생성해내는 것이 오히려 더 프로그램 목적에 부합한다.  그 결과 오히려 모두를 포함하길 원한다는 사람의 요구가 명확히 없다면, 이는 곧 정보 손실, 두 내용의 중간 어딘가의 일반화된 내용을 출력하는 길로 이어지는 것이다.</p>

<h5 id="프롬프트는-바운더리를-생성한다">프롬프트는 바운더리를 생성한다.</h5>

<p>너무 당연하다고 생각할지도 모르겠지만, 이 표현이 의미하는 바는 매우 컸다. 예를 들어 키워드를 명료하게 설정한 프롬프트는 일종의 룰이 되어 버린다. ‘42서울 출신 개발자’ 라는 철학을 넣으니, 도입부에 이 키워드를 어떻게든 넣으려고 했다.</p>

<p>키워드가 되면 족쇄가 되어 호흡, 흐름, 무게감을 어떻게 내가 원하는 밸런스에 맞추는게 아니라, 오히려 프롬프트를 바운더리로 잡고, 억지로 그 내용을 도출시키는데 목적이 있는 듯 보였다. 그리고 이러한 특성이 작용하면, 원하는 글이 아닌, 억지스러운 글이 되는 것이었다.</p>

<p>또 한편으로, 프롬프트가 일부 사라져 구멍이 생겼던 프롬프트는, 오히려 AI 의 개입이 많아지면서 창의적인 면이나, 글이 좀더 입체적으로 보였다. 이렇게 되면 결국 본질적으로 나를 모사한다는 것과는 전혀 무관계한게 아니겠는가?</p>

<p>프롬프트가 아주 중요하고, 민감한 영역이기에, 역할의 지정, 할 일의 지정 차원에서는 의미가 있지만, 거기에 특정 키워드가 마치 배경 지식으로 작동 되면, 프롬프트는 일종의 저주같이 되어, 원하는 요구사항을 들어주지 못하는 경우가 발생할 수 있는 것이었다.</p>

<h5 id="전-과정을-맡기는-구조는-한계가-명확하다">전 과정을 맡기는 구조는 한계가 명확하다.</h5>

<p>이후에도 여러번의 테스트를 해보았다. 하지만 결정적으로 ‘한 방에 딸깍’ 이라는 말이 어울리는 느낌의 알아서 잘, 딱 맞는 작업을 해준다? 그건 꿈이었다.</p>

<p>전 프로세스를 세분화 하지 않고, 프롬프트로 무언갈 써내려가게 되면, 위의 1번의 이야기가 펼쳐지는데, 그렇다고 여기서 정말 내 스타일의 커스터마이징 잘된 글을 만드려면 프롬프트가 방대해져야 한다. 그렇다고 AI에게 모두 맡기면 AI는 빈 공간에 대한 내용을 AI 의 설정으로 채운다. 그러면 또 원하는 결과가 안 나오게 되는 여지가 생기는 것이고…</p>

<p>즉, 근본적으로 꼬리에 꼬리를 무는 문제들이 생기기에 ‘전 공정’을 맡긴다는 방식 자체가 오히려 목표 달성에 문제를 일으키는 것이다.</p>

<h5 id="결론-적으로">결론 적으로….</h5>

<p>결론적으로 내가 얻은 핵심 통찰, 이는 AI 를 통해 내가 원하는 혹은 나 그 자체를 모방하는 글을 써내려가려면, 주기적으로 진행 과정을 검토하거나, 수정하지 않으면 안된다. 완전 자율성을 못 부여하는 것은 아니지만, 이는 프로그래밍의 영역으로 고려해야할 것으로 보였다. 나의 예상과 가설은 아주 빠르게 무너져 내린 것이었다.</p>

<h4 id="빠른-판단--어떻게-해야-ai-가-내-글쓰기에-도움을-줄까">빠른 판단!  어떻게 해야 AI 가 내 글쓰기에 도움을 줄까?</h4>

<p>그러나 시간을 더 들이는 것은 옳지 못하다. 해야할 일이 쌓여 있는데, 현재 가능한 선에서의 효율을 찾는 것은 핵심이리라.</p>

<p>그리하여 지금 상황에서 최선은 뭘까? 하고 고민한 결과가 다음과 같았다.</p>

<ul>
  <li>딸깍 하고 한방에 되는 건 어렵다 =&gt; 오히려 역으로 단계 별로 가속화 시키는게 AI 를 잘 쓸 수 있다.</li>
  <li>프롬프트는 어떻게 해야 가장 베스트일까? =&gt; <code class="language-plaintext highlighter-rouge">Context</code> 와 <code class="language-plaintext highlighter-rouge">Prompt</code>를 나누자!</li>
</ul>

<p><img src="/assets/images/posts/2025-10/2025-10-09-011.png" alt="" /></p>

<p>우선, 프롬프트를 그렇다고 지정하지 않고, 그냥 매번 타이핑 친다는 것은 대단히 힘든 일인건 사실이다. 두고두고 쓰는게 편하지 않겠는가? 그런데 나에게 글이란 건 개발 일지, 정보 공유, 메모 등 엄청나게 다양한 역할, 종류가 
다양하다는 점을 체감했다.</p>

<p>나는 너무 심플하게 생각한 나머지, 글의 종류가 다르고, 프로세스가 다른데 마치 무안단물마냥 ‘줘’ 하면, AI 들이 알아서 내 공유된 개인정보로 알아서 만들어 줄거라는 순진한 생각을 한 것이다.</p>

<p>그러니 Gemini가 제공한 아이디어를 적극 develop 하기로 했다. <code class="language-plaintext highlighter-rouge">Mode</code> 라는 키워드를 추가했다. 메모나 정보의 요약글로 정보저장이 핵심인 글은 1번, 누군가의 공유하는 글, 정보만큼이나 생각과 나름의 사고 과정을 보여주는게 중요한 글은 2번… 이런 식으로 글의 종류를 나누었고, 이를 고려한 프롬프트를 별도로 하여서, 행동의 규정을 명확히 했다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-012.png" alt="" /></p>

<p>두 번째로, 최근 배웠던 단어 중 Context Engineering 이란 키워드가 있었다. 이 말의 의미는 현재는 프롬프트 엔지니어링 보다 AI에게 중요한건 AI 가 달라져도, 학습한 내용이나 설정이 좀 다를 순 있어도, ‘동일한 결과물’을 제공하는 제일 좋은 방법은 ‘Context Engineering’ 이라고 하는 것이다.</p>

<p>요구한 내용에서 할 일, 상황 맥락이 유사하면 결과 값도 유사하게 전달할 수 있다. 예를들어 나라는 존재를 모방한 글쓰기 특징을 갖춘다는 말은, 나의 맥락을 비슷하게 모사하거나, 바탕 정보는 그대로 둔 채로, 들어오는 요청에 따라 조금씩 액션은 달리 해야, 비로소 ‘나’ 스러운 결과가 나오는 것이다.</p>

<p>그러나 프롬프트 마다 일일이 이걸 담아내는 건 효과적이지 못하다. 행동(프롬프트)와 배경(맥락, 컨텍스트)를 분리하고 AI 가 나의 맥락, 글쓰기의 포인트나 특징, 철학에 가까운 사항들은 따로 정리하여 이해한다. 그렇게 모방된 인격 하에 행동을 수행해야 비로소 요구되는 정확한 답변이 가능한 것이다.</p>

<p>이에 <code class="language-plaintext highlighter-rouge">Hansol Persona</code> 란 파일로 만들었고, 마치 전역변수처럼 이 녀석을 추가하고 고려하도록 만들었다. 컨텍스트, 그리고 프롬프트를 분리하고, 아까 언급했듯이 <code class="language-plaintext highlighter-rouge">Mode</code> 라는 개념을 추가했다. 그 결과는 어땠을까?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-013.png" alt="" /></p>

<p>개인적으로 아주 ‘성공적’ 이라고 평가하고 싶다.</p>

<blockquote>
  <p>💡 프롬프트, 컨텍스트 가이드</p>
  <ol>
    <li>Copilot 에 인용할 자신의 Context 문서를 작성하고, 필요 시 해당 문서를 항상 추가해라.</li>
    <li>Command 에 프롬프트에 행당하는 부분만 기재한다. context 의 해당하는 부분은 배제하고, 이는 Persona 문서에 포함한다.</li>
    <li>프롬프트는 구체적인 단어를 기재하는 것은 지양한다. 가능하면 행동 지침으로 최대한 구체화 시켜라.</li>
    <li>내가 자동화 할 목표가 있다면, 그 목표의 ‘과정’을 프롬프트화 시켜라. 글 쓰기의 핵심이 개요 작성 -&gt; 근거 추가 -&gt; 살 붙이기 -&gt; 퇴고 이런 순서라면, 각 단계 별로 필요한 영역에 프롬프트를 별도로 만드는 게 최선이다.</li>
    <li>자신의 프로세스를 검증할 프롬프트, Context 를 준비하는 것도 좋다. =&gt; 이를 통해 제 3자의 검증을 효과적으로 수행해 줄 수 있다.</li>
    <li>마크다운 양식의 헤드, 리스트 등 우선순위를 나타내는 기호를 AI 는 우선순위로 실제 판단한다. 따라서 우선순위를 고려한 프롬프트가 중요하다.</li>
    <li>글의 철학, 가치관도 중요하지만, 스타일 가이드 쪽의 지정의 프롬프트가 훨씬 AI가 완성도 높은 구성을 해낸다. 정량적인 내용을 프롬프트에 담아라.</li>
    <li>AI 의 인격에 대한 부분도 context 로 준비하면 아첨, 과도한 긍정 평가를 최소화 시킬 수 있다. 평가, 분석, 보완 등의 역할을 원할 땐, 그에 따른 AI의 가상 인격을 생성해놓고 제공하자.</li>
  </ol>
</blockquote>

<h3 id="결과물-톺아보기">결과물 톺아보기</h3>

<p>2.5 flash 는 2.5 Pro 대비 이상한 말도 많고, 허술한 답변을 할 때도 많다. 그러나 놀랍게도 컨텍스트 + 모드 + 프롬프트의 테스트 결과는 말도 안될 정도의 퀄리티의 내용을 뽑아주었다. 이미 충분히 블로그 글로 올렸을 때 문제 없지 않을까? 싶은 수준의 완성도 였다.</p>

<p>톤앤 무드는 정돈 되어 있었고, 내 설정들과 함께 전달된 자료들의 의도들을 정확히 재조합하여, 자잘한 분석 결과 문서, 자료들 예시, 몇 문단으로 작성된 결론, 개요를 한번에 종합해주었다. 그것도 단 돈 몇 십원 수준으로 말이다.</p>

<p>특히나 SEO 를 고려한 태그라던지, 예상 제목 제안 사항 등, 단순히 글쓰기를 돕는것 만으로 끝이 아니라, 블로그를 관리하고, 기술적 보조자 역할도 톡톡히 단 한 번의 요청으로 얻어낼 수 있었다.</p>

<p>뿐만 아니라, 위에서 얻은 결론을 기반으로 프롬프트를 추가로 제작. 내 글에 대한 분석, 글의 문제점이나 글에서 논리적 모순 등을 잡아주는 ‘편집장’ 프롬프트도 설정해 보았더니, 놀라울 만큼 명확하고 확실한 평가를 해주었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-014.png" alt="" /></p>

<p>내 글 어디가 아쉽고, 어떤 점이 좋으며, 어떤 점에서 개선이 되면 좋을지. 제 3자 시선에서 평가해주는 프롬프트를 기반으로 나의 글을 세밀하게 분석해주었다. 특히나 너무 과한 내용이나 필요 없는 내용 등을 빠르게 캐치하고 검토해주었다. 가장 놀라운건 이것이 성능이 부족하다고 느껴 거의 쓰지 않던 2.5 flash 에서 가능하다는 점이다!</p>

<h3 id="pro-vs-flash">Pro vs Flash</h3>

<p>놀라움. 만족스러움을 느끼기도 잠시. 2.5 flash를 왜 사용했는가? 에서 시작해서 한 가지 호기심이 들었다. 그것은 바로 ‘2.5 flash 로 이정도면, 2.5 pro 로 실행하면 얼마나 좋아질까?’ 였다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-016.png" alt="" /></p>

<p>그런데 어라. 이상했다. 2.5 flash 로 얻은 결과에 환호했던 것과는 달리, 생각보다 신기할 정도로 차이가 없었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-015.png" alt="" /></p>

<p>구성의 큰 차이는 없다. 프롬프트의 요구사항은 충분히 수용되었고, 여기저기 좀더 늘어나거나, 개요이지만 글처럼 어느정도 완성되었다를 제외하면 뭔가 확 와닻는 변화는 아니었다.</p>

<p>정리해보면, 2.5 Pro와 2.5 flash 로 만든 글에 대해선 다음과 같은 차이가 있다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-017.png" alt="" /></p>

<p>Pro는 그 문장 하나 하나를 분석해 보았을 때, 단순히 요구 사항 이라고 적힌 것들의 의도를 고려한 답변에 가깝다는 게 보였다. 단순한 나열을 넘어 ‘이런 의도’로 이런 이야기니까, ‘이런 주장이 나온다’ 라는 표현. 생각해보면 훨씬 똑똑한 답변이라는 점은 부정할 수 없었다. 그러나 그것이 2.5 flash + 프롬프트만큼 확실한 효과가 있는가? 여기에 답변이 되기엔 애매 했다.</p>

<p>하물며 가성비를 생각해보자. 2.5 flash 의 경우 기본적으로 2.5 pro 대비 4배 정도의 가격차이가 날 수 있다(입출력 토큰 약 3K 수준 대비). 그런데 여기서 2.5 pro 는 입력값이 늘어나, 기준치를 넘기면(입력 토큰 수 2M 이상), 더 높은 요금을 부과해 요금을 측정한다. 즉,  2.5 flash 의 1000원 수준의 내용을 작업하면, 최대 수 천원 ~ 1만원대까지도 올라갈 수 있는 상황인 것이다.</p>

<p>새삼 프롬프트, 컨텍스트의 능력이 얼마나 뛰어난지를, 각종 AI 논문에서 작은 모델들의 합이라던가 MoE 구조라던가 기타 등등… 마치 거대 모델만큼 성능 좋게 만들수 있다! 는 표현들이 실제 어떤 의미인지 체감할 수있는 아주 흥미로운 결론이었다.</p>

<h2 id="결론">결론</h2>
<h3 id="ai-나의-능력을-증폭시키는-최고의-파트너">AI, 나의 능력을 증폭시키는 최고의 파트너</h3>

<p>AI 는 아직 AGI 는 아니다. 하지만 접근 방법에  따라서 ‘최고’가 될 수 있다는 점을 경험했다. 이번 과정을 통해 Copilot 이란 플러그인에 gemini 의 조합은 엄청난 수준의 글쓰기 조수를 구축하고, 혼자 끙끙 거리며 한달이 걸릴 글을 단 일주일도 안 걸리게 마무리, 그것도 실질 글 작업은 약 이틀 정도 소모 되는 속도로 만들어냈다. 초기 목표보단 못한 것은 사실이지만 그럼에도 엄청난 효율, 효과를 누렸다고 할 수 있겠다.</p>

<p>현재 개발 시장의 요구 사항은 명확하다. 자기 도메인의 높은 전문성, 그리고 그 전문성과 함께 시너지를 발 할수 있는 AI에 대한 리터러시. 개인적으로 건강을 위한 휴식 중이긴 하나, 동시에 내가 생각하는 ‘필요시 되는 사람’으로 살아가기 위해 벌린 이번 미니 프로젝트는, 현재 AI 의 본질을 이해할 수 있었고, 가공할 능력을 어디까지 활용할 수 있을지에 대한 내 나름의 시도이자, 단편적인 답변이었다.</p>

<p>프롬프트, 그 위에 작용하는 컨텍스트의 가능성을 엿 볼 수 있는 사례다. 2.5 flash 라는 가성비 모델로도, 얼마나 효과적일 수 있는지 체감할 수 있었던 좋은 기회였다. 이 글을 읽는 모두가 AI 를 통한 생산성 향상. 특히 한계에 부딪힐 때, 그 한계를 넘어서는 기술적 발판으로 활용을 잘 하면 좋겠다고 생각한다. 본 글을 통해 커스텀 된 AI 에이전트를 노코드로 구축하고, 프로세스를 단축하는 새로운 글쓰기 경험을 맛 보시길!</p>

<h2 id="요약">요약</h2>
<p>글이 너어어어ㅓㅓㅓㅓ 무 길어졌다(…) 
내 기록을 위해 남긴다지만, 너무 길어 요약을 해보았다.</p>

<hr />

<ol>
  <li>AI 프롬프트를 합치면 오히려 일반화된다 - 여러 AI의 분석을 통합하려 했지만, 독특한 특징이 사라지고 정보 손실이 발생했다.</li>
  <li>Context(페르소나)와 Prompt(행동지침)를 분리하고, 글 종류별 Mode를 구분하니 비로소 ‘나다운’ 글쓰기가 가능해졌다.</li>
  <li>2.5 flash + 잘 짜여진 프롬프트 구조가 2.5 Pro보다 가성비 측면에서 압도적이었다. 작은 모델도 Context Engineering으로 충분히 강력해질 수 있다.</li>
</ol>

<hr />

<blockquote>
  <p>Obsidian 에 Copilot, Gemini API 적용 방법 (링크)(작성중)</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="Obsidian" /><category term="AI" /><category term="Gemini" /><category term="Google" /><category term="블로그" /><category term="플러그인" /><summary type="html"><![CDATA[Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자 글쓰기의 길은 멀고도 험하다]]></summary></entry><entry><title type="html">AI 자동화 툴, Opal 맛보기</title><link href="http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction.html" rel="alternate" type="text/html" title="AI 자동화 툴, Opal 맛보기" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction</id><content type="html" xml:base="http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction.html"><![CDATA[<p><img src="/assets/images/posts/2025-10/2025-10-09-018.png" alt="" /></p>

<h2 id="ai-워크플로우의-새로운-가능성-google-opal">AI 워크플로우의 새로운 가능성, Google Opal</h2>

<p>드디어 AI가 단발성 대화를 넘어 연속적인 작업 흐름을 처리할 수 있게 됐다. Google Labs에서 공개한 Opal은 <strong>프롬프트, AI 모델, 도구를 연결해 다단계 워크플로우를 만들 수 있는 노코드 플랫폼</strong>이다. 지금까지 AI가 부족했던 ‘시퀀스’ 개념을 드디어 제대로 구현한 셈이다.</p>

<h3 id="그동안-ai에게-없었던-것-단계별-사고">그동안 AI에게 없었던 것: 단계별 사고</h3>

<p>ChatGPT든 Gemini든, 대부분의 AI 서비스는 기본적으로 “질문 → 답변” 구조다. 물론 멀티턴 대화가 가능하긴 하지만, 복잡한 작업을 여러 단계로 나눠서 자동으로 처리하기엔 한계가 있었다. 예를 들어 “특정 주제로 블로그 초안 작성 → 이미지 생성 → SEO 최적화 → 최종 정리” 같은 워크플로우를 만들려면 결국 사람이 중간중간 개입해야 했다.</p>

<p>Opal은 바로 이 지점을 공략했다. 공식 블로그에 따르면, <strong>“프롬프트, AI 모델 호출 및 기타 도구를 연결하여 강력한 다단계 앱을 제작할 수 있도록 지원”</strong>한다고 명시되어 있다<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. 실제로 User Input(사용자 입력) → Generate(AI 생성) → Output(결과 출력) 단계를 조합하고, 각 단계의 결과를 다음 단계에서 참조할 수 있다. 이를 “단계 연결(Step Chaining)”이라고 부르는데, 드래그 앤 드롭이나 @ 기호로 간단히 구현 가능하다<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>더 인상적인 건 두 가지 편집 모드를 제공한다는 점이다. 자연어로 “이런 앱 만들어줘” 하면 Opal이 알아서 워크플로우를 구성해주고, 세부 조정은 비주얼 편집기에서 할 수 있다. 코드를 전혀 볼 필요가 없다<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>. 2024년 10월 업데이트에서는 <strong>단계별 디버깅 기능</strong>과 <strong>병렬 실행 기능</strong>까지 추가되어, 복잡한 워크플로우도 실시간으로 테스트하고 개선할 수 있게 됐다<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<h3 id="노코드의-장점이자-한계">노코드의 장점이자 한계</h3>

<p><img src="/assets/images/posts/2025-10/2025-10-09-020.png" alt="" /></p>

<p>Opal의 가장 큰 장점은 진입장벽이 낮다는 것이다. 자연어만 사용할 줄 알면 누구나 AI 앱을 만들 수 있고, Google이 호스팅까지 해주니 링크 하나로 바로 공유할 수 있다. 갤러리에서 다른 사람이 만든 앱을 리믹스해서 내 것으로 만들 수도 있다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-021.png" alt="" /></p>
<blockquote>
  <p>현재는 아주 심플한 동작들만을 지원하고 있다</p>
</blockquote>

<p>하지만 여기서 아쉬운 점이 드러난다. <strong>외부 서비스 연동이 제한적</strong>이다. 현재 기본 제공되는 도구는 웹 검색, 지도 검색, 날씨 정보 정도이고, Google Drive 정도만 직접 연동된다<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>. Notion, Slack, Trello 같은 다른 서비스와의 자동화는 아직 지원되지 않는다. Zapier나 Make.com처럼 수백 개의 서비스를 연결할 수 있는 수준엔 한참 못 미친다.</p>

<p>더 치명적인 건 <strong>코드 내보내기가 불가능</strong>하다는 점이다. Opal에서 만든 앱은 Google 생태계 안에 갇혀 있다. API를 만들 수도 없고, 데이터베이스를 붙일 수도 없으며, 실제 배포 가능한 코드를 얻을 수도 없다<sup id="fnref:6"><a href="#fn:6" class="footnote" rel="footnote" role="doc-noteref">6</a></sup>. 결국 프로토타이핑이나 간단한 사내 도구 정도로만 활용 가능하다는 얘기다. 프로덕션용으로 쓰기엔 아직 갈 길이 멀다.</p>

<h3 id="obsidian에서-했던-것들을-자동화할-수-있을까">Obsidian에서 했던 것들을 자동화할 수 있을까?</h3>

<p>개인적으로 흥미로웠던 건, 이전에 Obsidian + 코파일럿 플러그인으로 시도했던 것들이 떠올랐다는 점이다(<a href="https://paul2021-r.github.io/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html">참고 링크</a>). 당시엔 노트 글감을 준비하고, 특정 패턴 명령어를 적용하고, 글감을 나의 문체에 맞는 글감으로 만들어주는 워크플로우를 만들려고 했다. 하지만 결과적으로 수동으로 트리거를 해야 했고, 여러 단계를 거치려면 계속 개입해야 했다.</p>

<p>Opal의 시퀀스 기능을 보니, 이런 것들을 완전히 자동화할 수 있겠다는 생각이 들었다. 예를 들어 “웹에서 특정 주제 검색 → 요약 생성 → 이미지 생성 → 마크다운 포맷으로 정리 → Google Drive에 저장” 같은 흐름을 하나의 앱으로 만들 수 있을 것 같다. 물론 Obsidian과 직접 연동되진 않지만, Google Drive를 중간 저장소로 쓰면 충분히 가능할 것 같다.</p>

<p>문제는 앞서 말한 외부 서비스 연동의 한계다. 만약 Opal이 Notion API, Obsidian Local REST API, 혹은 더 나아가 커스텀 웹훅 정도만 지원해준다면, 정말 강력한 자동화 허브가 될 수 있을 텐데 말이다. 지금은 Google 생태계 안에서만 놀 수 있다는 점이 가장 아쉽다.(물론 그게 목적이겠지만 말이다.)</p>

<h3 id="결론-가능성은-보였지만-아직은-반쪽짜리">결론: 가능성은 보였지만, 아직은 반쪽짜리</h3>

<p>Opal은 분명히 AI의 새로운 방향을 제시했다. <strong>시퀀스, 워크플로우, 단계별 자동화</strong>—이것들은 AI가 단순한 챗봇을 넘어 진짜 생산성 도구가 되기 위해 반드시 필요한 요소들이다. 노코드로 이런 걸 구현했다는 점에서 Opal은 충분히 혁신적이다.</p>

<p>하지만 현실적으로 프로덕션 환경에서 쓰기엔 한계가 명확하다. 외부 서비스 연동이 제한적이고, 코드를 내보낼 수도 없으며, 아직은 실험적 도구라는 꼬리표를 떼지 못했다. Google Labs 프로젝트가 언제 접힐지 모른다는 불안감도 있다.</p>

<p>그럼에도 불구하고, Opal이 보여준 방향성은 분명하다. AI는 이제 단발성 대화를 넘어 연속적인 워크플로우를 이해하고 실행해야 한다. 그리고 누구나 코딩 없이 그런 자동화를 만들 수 있어야 한다. Opal이 완벽하진 않지만, 그 미래를 먼저 보여준 건 확실하다.</p>

<p>만약 Google이 이 프로젝트를 제대로 밀어붙여서 외부 API 연동과 코드 내보내기 기능까지 추가한다면? 그때는 정말 게임 체인저가 될 수 있을 것 같다.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://developers.googleblog.com/ko/introducing-opal/">Google 개발자 블로그 (한국어) - Opal 소개</a>: “프롬프트, AI 모델 호출 및 기타 도구를 연결하여 강력한 다단계 앱을 제작할 수 있도록 지원합니다.” <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="https://developers.google.com/opal/overview">Google Opal 공식 문서 - Overview</a>: “Referencing the results of one step in the prompt for another step is the primary way to build your app logic inside of Opal.” <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><a href="https://developers.googleblog.com/en/introducing-opal/">Google 개발자 블로그 (영어) - Introducing Opal</a>: “Opal translates your instructions into a visual workflow, giving you fine-grained control without ever needing to see a line of code.” <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><a href="https://blog.google/technology/google-labs/opal-expansion/">Google Labs Blog - Opal Expansion</a>: “We’ve fundamentally improved the debugging program… You can now run your workflow step-by-step in the visual editor” <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Google 개발자 블로그 및 공식 문서에서 확인된 빌트인 도구 목록: 웹 검색, 지도 검색, 날씨 정보, Google Drive 연동 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>커뮤니티 피드백 및 공식 문서 기반: Opal 앱은 Google 생태계 내에 제한되며, 코드 내보내기, API 생성, 데이터베이스 통합 등이 불가능함 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Paul2021-R</name></author><category term="tools" /><category term="AI" /><category term="Google" /><category term="Opal" /><category term="Automation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코테 학습 - ‘지폐접기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘지폐접기’" /><published>2025-10-01T00:00:00+00:00</published><updated>2025-10-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<h3 id="원본-문제">원본 문제</h3>
<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/340199?language=python3">원본 문제</a></p>

<h3 id="문제-정리">문제 정리</h3>

<ul>
  <li><strong>목표</strong>: 규격인 wallet 에 맞는 가로, 세로 크기로 몇번 접어야 하는지 최소 값을 리턴할 것</li>
  <li><strong>핵심 기능</strong>:
    <ol>
      <li>지폐를 접을 때는 항상 길이가 긴 쪽을 반으로 접는다.</li>
      <li>접기 전 길이 홀수 -&gt; 접은 후 소수점 이하 버리기</li>
      <li>접힌 지폐를 그대로 또는 90도 돌리고 넣을 수 있다면 그만 접음</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="코드-개선-과정-분석">코드 개선 과정 분석</h3>

<h4 id="1단계-최초-풀이-놓친-지점은-조건-1">[1단계] 최초 풀이: 놓친 지점은 조건 1</h4>
<ul>
  <li>거의 조건을 완벽하게 해결했었음. 그러나 마지막 cond ~ 부분에서 조건을 잘못 생각했다. 핵심 조건은 길이가 긴쪽을 줄이는 것이지, 무조건 가로 또는 세로를 줄이는게 아니고 이점을 놓치면 잘못 계산되는 엣지 케이스가 발생하는 것이었다.</li>
  <li>따라서 cond 배열의 어느쪽이든 문제가 있다 -&gt; 가로와 세로 중 긴 쪽을 우선 접어야 한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">bill</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">width</span> <span class="o">=</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">height</span> <span class="o">=</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">break</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span><span class="err"> </span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">break</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span><span class="err"> </span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 여기 틀림!
</span><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">bill</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">]</span> <span class="c1"># 그냥 긴 쪽을 접는 게 중요했다. 
</span><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">elif</span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">bill</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># 그냥 긴 쪽을 접는 게 중요했다. 
</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>
<h4 id="2단계-최종-풀이-조건의-확립-및-불필요한-코드-제거">[2단계] 최종 풀이: 조건의 확립 및 불필요한 코드 제거</h4>
<ol>
  <li>핵심 조건을 개선하여 엣지 케이스까지 대응이 가능해짐.</li>
  <li>그 외에 불필요한 변수들을 제거하기 시작했는데 다음과 같음
    <ol>
      <li>가로, 세로 변수 제거</li>
      <li>조건은 명확하므로, <code class="language-plaintext highlighter-rouge">and</code>로 묶어 한줄로 처리 가능</li>
      <li>cond 도 실제 무조건 <code class="language-plaintext highlighter-rouge">wallet</code>에 들어가는 조건이 아니면 무조건 긴 쪽을 접어야 하므로 필요 없음</li>
      <li>접어야 할 조건에 도착 시 배열값을 직접 수정해도 됨</li>
    </ol>
  </li>
</ol>

<hr />

<h3 id="최종-버전-코드-및-설명">최종 버전 코드 및 설명</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">bill</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">코테 학습 - ‘동영상 재생기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘동영상 재생기’" /><published>2025-09-19T00:00:00+00:00</published><updated>2025-09-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/340213?language=python3">원본 문제 보러가기</a></p>

<h2 id="2025년-9월-19일-프로그래머스-코딩-테스트-동영상-재생기-문제-풀이-python">2025년 9월 19일: 프로그래머스 코딩 테스트 ‘동영상 재생기’ 문제 풀이 (Python)</h2>

<h3 id="문제-정리">문제 정리</h3>

<ul>
  <li><strong>목표</strong>: 주어진 명령어(<code class="language-plaintext highlighter-rouge">prev</code>, <code class="language-plaintext highlighter-rouge">next</code>)를 모두 수행한 후 동영상의 최종 재생 위치를 “mm:ss” 형식으로 반환하는 문제이다.</li>
  <li><strong>핵심 기능</strong>:
    <ol>
      <li><strong>10초 전/후 이동</strong>: <code class="language-plaintext highlighter-rouge">prev</code>와 <code class="language-plaintext highlighter-rouge">next</code> 명령을 수행하며, 영상의 시작(00:00)과 끝(video_len)을 벗어나지 않도록 처리한다.</li>
      <li><strong>오프닝 자동 건너뛰기</strong>: 현재 재생 위치가 오프닝 구간(<code class="language-plaintext highlighter-rouge">op_start</code> ~ <code class="language-plaintext highlighter-rouge">op_end</code>)에 포함될 경우, 즉시 오프닝이 끝나는 위치(<code class="language-plaintext highlighter-rouge">op_end</code>)로 자동 이동한다. 이 기능은 사용자의 명령어와 관계없이 위치가 변경될 때마다 적용되어야 하는 핵심 규칙이다.</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="코드-개선-과정-분석">코드 개선 과정 분석</h3>

<h4 id="1단계-최초-풀이-분minute과-초second를-분리하여-처리">[1단계] 최초 풀이: 분(minute)과 초(second)를 분리하여 처리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">-</span> <span class="mi">10</span>
        
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
    
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">59</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="n">end_hour</span><span class="p">,</span> <span class="n">end_minutes</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end_hour</span> <span class="ow">or</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_hour</span> <span class="ow">and</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end_minutes</span><span class="p">):</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_hour</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_minutes</span>
    
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">op_start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="n">start_total_time</span> <span class="o">=</span> <span class="n">start_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">start_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end_total_time</span> <span class="o">=</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">current_total_time</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">start_total_time</span> <span class="o">&lt;=</span> <span class="n">current_total_time</span> <span class="ow">and</span> <span class="n">current_total_time</span> <span class="o">&lt;=</span> <span class="n">end_total_time</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">current_pos</span>
<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="p">)</span><span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

    
    <span class="n">hour</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">minute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">minute</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])]</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">video_len</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>첫 번째 코드는 시간 데이터를 <code class="language-plaintext highlighter-rouge">[분, 초]</code> 형태의 리스트(혹은 튜플)로 다루는 방식이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1단계 코드 (주요 부분)
</span><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">-</span> <span class="mi">10</span>
    <span class="c1"># ...경계 값 처리...
</span>    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="c1"># [분, 초] 리스트 반환
</span>    <span class="c1"># ... (생략) ...
</span></code></pre></div></div>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>시간을 ‘분’과 ‘초’ 두 개의 단위로 유지하며 모든 연산을 수행했다.</li>
    </ul>
  </li>
  <li><strong>분석 및 문제점</strong>:
    <ul>
      <li><strong>로직의 복잡성</strong>: 10초를 더하고 뺄 때, 60초를 기준으로 받아올림/내림 처리를 해야 하므로 <code class="language-plaintext highlighter-rouge">if-elif</code> 조건문이 복잡해진다. 예를 들어 <code class="language-plaintext highlighter-rouge">prev_pos</code>에서 <code class="language-plaintext highlighter-rouge">03:05</code>에서 10초를 빼는 경우 <code class="language-plaintext highlighter-rouge">02:55</code>로 만들기 위한 연산이 직관적이지 않다.</li>
      <li><strong>비교 연산의 번거로움</strong>: <code class="language-plaintext highlighter-rouge">skip_opening</code>과 같이 시간의 선후 관계를 비교할 때, 분과 초를 각각 비교해야 하므로 코드가 길어지고 실수할 가능성이 커진다.</li>
      <li><strong>데이터 타입의 불일치</strong>: 타입 힌트는 불변(immutable) 객체인 <code class="language-plaintext highlighter-rouge">Tuple</code>로 지정했지만, 실제로는 <code class="language-plaintext highlighter-rouge">current_pos[1] -= 10</code>처럼 내부 값을 변경하고 있어 가변(mutable) 객체인 <code class="language-plaintext highlighter-rouge">List</code>처럼 사용했다. 이는 잠재적인 오류를 유발할 수 있는 좋지 않은 패턴이다.</li>
    </ul>
  </li>
</ul>

<h4 id="2단계-개선-단위를-초second로-통일">[2단계] 개선: 단위를 ‘초(second)’로 통일</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">video_length</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="n">video_end</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">video_length</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&gt;</span> <span class="n">video_end</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">video_end</span>
    
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">op_start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">current_pos</span> <span class="ow">and</span> <span class="n">current_pos</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">end_time</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span> <span class="o">//</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span> <span class="o">%</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">minute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">minute</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>  <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">video_len</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>첫 풀이의 복잡성을 해결하기 위해 모든 시간 단위를 ‘초’로 통일했다. 이는 문제 해결의 <strong>가장 결정적인 개선점</strong>이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 2단계 코드 (주요 부분)
</span><span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>  <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="c1"># '초' 단위 정수 반환
</span>    <span class="c1"># ... (생략) ...
</span></code></pre></div></div>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>모든 “mm:ss” 형식의 시간을 <code class="language-plaintext highlighter-rouge">get_int_time</code> 함수를 통해 ‘초’ 단위의 정수(integer)로 변환하여 계산했다.</li>
    </ul>
  </li>
  <li><strong>분석 및 개선 효과</strong>:
    <ul>
      <li><strong>연산의 단순화</strong>: 시간 계산이 <code class="language-plaintext highlighter-rouge">+10</code>, <code class="language-plaintext highlighter-rouge">-10</code>과 같은 단순한 정수 연산으로 바뀌어 코드가 매우 간결해지고 명확해졌다.</li>
      <li><strong>비교의 용이성</strong>: 시간 비교 역시 정수의 크기 비교(<code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>)로 단순화되어 <code class="language-plaintext highlighter-rouge">skip_opening</code> 로직이 직관적으로 변했다.</li>
      <li><strong>오류 가능성 감소</strong>: 복잡한 받아올림/내림 로직이 사라져 버그가 발생할 여지가 크게 줄었다.</li>
    </ul>
  </li>
  <li><strong>남은 개선점</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">next_pos</code>, <code class="language-plaintext highlighter-rouge">skip_opening</code> 함수가 루프 안에서 호출될 때마다 <code class="language-plaintext highlighter-rouge">get_int_time</code> 함수를 통해 문자열을 정수로 변환하는 <strong>불필요한 반복 연산</strong>이 여전히 존재한다.</li>
      <li>오프닝 스킵 로직의 적용 시점이 루프 전/후로 나뉘어 있어 더 깔끔하게 정리할 여지가 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="3단계-최종-풀이-pythonic-코드-적용-및-로직-최적화">[3단계] 최종 풀이: Pythonic 코드 적용 및 로직 최적화</h4>

<p>2단계에서 이룬 구조적 개선 위에, 코드의 효율성과 가독성을 극대화하는 Pythonic한 기법들과 로직 최적화를 적용한 최종 버전이다.</p>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>반복 연산을 제거하고, 파이썬 내장 기능과 더 효율적인 로직 흐름을 적용하여 코드를 완성했다.</li>
    </ul>
  </li>
  <li><strong>핵심 개선점</strong>:
    <ol>
      <li><strong>사전 연산 (Pre-computation)</strong>: <code class="language-plaintext highlighter-rouge">solution</code> 함수 시작 시점에서 필요한 모든 시간 문자열(<code class="language-plaintext highlighter-rouge">video_len</code>, <code class="language-plaintext highlighter-rouge">op_start</code> 등)을 ‘초’ 단위 정수로 <strong>미리 한 번만 변환</strong>하여 변수에 저장한다. 이를 통해 루프 내에서 반복적인 변환 작업을 완전히 제거하여 효율성을 높였다.</li>
      <li><strong>Pythonic 경계 값 처리</strong>: <code class="language-plaintext highlighter-rouge">prev</code>와 <code class="language-plaintext highlighter-rouge">next</code> 기능에서 <code class="language-plaintext highlighter-rouge">if</code>문을 사용하여 0과 영상 최대 길이를 확인하는 대신, <code class="language-plaintext highlighter-rouge">max(0, ...)</code>와 <code class="language-plaintext highlighter-rouge">min(video_len_sec, ...)</code>를 사용하여 코드를 한 줄로 줄이고 의도를 더 명확하게 표현했다.</li>
      <li><strong>Pythonic 시간 포맷팅</strong>: <code class="language-plaintext highlighter-rouge">get_str_time</code> 함수에서 <code class="language-plaintext highlighter-rouge">divmod()</code>를 사용해 몫(분)과 나머지(초)를 한 번에 계산하고, f-string의 <code class="language-plaintext highlighter-rouge">:02d</code> 서식 지정자를 이용해 두 자리 수에 맞춰 0을 채우는 가장 표준적이고 깔끔한 방식을 사용했다.</li>
      <li><strong>로직 흐름 최적화</strong>: 오프닝 스킵 로직을 <strong>‘상태가 변경될 때마다 유효성을 검사하는’</strong> 개념으로 접근했다.
        <ul>
          <li><strong>초기 상태 보정</strong>: 루프 시작 전, 최초 위치에 대해 스킵 검사를 먼저 수행한다.</li>
          <li><strong>변경 후 보정</strong>: 명령어 실행으로 위치가 변경된 직후에만 스킵 검사를 수행한다.</li>
          <li>이 두 번의 검사로 모든 경우를 처리하여, 루프 전과 후로 로직이 나뉘어 있던 2단계 코드보다 훨씬 더 명료한 흐름을 완성했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="최종-버전-코드-및-설명">최종 버전 코드 및 설명</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 시간 변환 함수: 초 단위 정수와 "mm:ss" 문자열을 상호 변환한다.
</span><span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># divmod로 몫(분)과 나머지(초)를 한 번에 계산한다.
</span>    <span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span> <span class="o">=</span> <span class="nf">divmod</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="c1"># f-string 포맷팅으로 두 자리가 아닐 경우 앞에 0을 붙여준다.
</span>    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">minutes</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">seconds</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="c1"># [최적화 1] 모든 시간 값을 미리 한 번만 정수로 변환한다.
</span>    <span class="n">video_len_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">video_len</span><span class="p">)</span>
    <span class="n">op_start_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">op_end_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    
    <span class="c1"># 오프닝 스킵을 위한 지역 헬퍼 함수. solution 내부 변수에 접근하기 용이하다.
</span>    <span class="k">def</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">pos_sec</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_start_sec</span> <span class="o">&lt;=</span> <span class="n">pos_sec</span> <span class="o">&lt;=</span> <span class="n">op_end_sec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op_end_sec</span>
        <span class="k">return</span> <span class="n">pos_sec</span>
    
    <span class="c1"># [로직 최적화] 1. 초기 위치에 대한 오프닝 스킵을 먼저 적용한다.
</span>    <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="c1"># [최적화 2] min()을 사용해 영상 길이를 넘지 않도록 처리한다.
</span>            <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">video_len_sec</span><span class="p">,</span> <span class="n">current_pos_sec</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="c1"># [최적화 2] max()를 사용해 0 미만으로 내려가지 않도록 처리한다.
</span>            <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_pos_sec</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span>
    
        <span class="c1"># [로직 최적화] 2. 명령어로 위치가 바뀐 직후, 다시 오프닝 스킵을 적용한다.
</span>        <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>

</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">CS 학습 - 9월 3주차</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03.html" rel="alternate" type="text/html" title="CS 학습 - 9월 3주차" /><published>2025-09-15T00:00:00+00:00</published><updated>2025-09-15T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/15/cs-09-03.html"><![CDATA[<h2 id="알고리즘">알고리즘</h2>

<h3 id="sort">Sort</h3>
<h4 id="1-삽입-정렬-insertion-sort">1. 삽입 정렬 (Insertion Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757913162355_f8k6df.png" alt="" /></p>

<h5 id="1-1-개념">1-1. 개념</h5>

<p>삽입 정렬은 <strong>처리되지 않은 데이터를 이미 정렬된 부분의 적절한 위치에 삽입</strong>해 나가는 방식으로 동작한다. 손안의 카드를 정렬할 때, 새로운 카드를 이미 정렬된 카드 뭉치의 올바른 자리에 꽂는 과정과 유사하다.</p>

<p>2번째 원소부터 시작하여 그 앞(왼쪽)의 데이터들과 비교하여 삽입할 위치를 지정하고, 데이터를 뒤로 옮긴 후 해당 자리에 삽입한다.</p>

<h5 id="1-2-시간-복잡도">1-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n)$ - 이미 데이터가 모두 정렬되어 있는 경우, 외부 루프만 한 번 순회한다.</li>
  <li><strong>평균(Average):</strong> $O(n^2)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 데이터가 역순으로 정렬되어 있는 경우, 모든 요소를 비교하고 이동시켜야 한다.</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
삽입 정렬은 데이터셋의 크기가 작거나, 데이터가 거의 정렬된 상태일 때 매우 효율적으로 동작한다. 이런 특성 때문에 다른 복잡한 정렬 알고리즘(예: 팀 정렬)의 <strong>일부</strong>로 사용되기도 한다.</p>
</blockquote>

<h5 id="1-3-python-구현-코드">1-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># 배열의 2번째 요소(인덱스 1)부터 시작
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 정렬할 대상이 되는 요소
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>     <span class="c1"># 비교 대상이 되는 정렬된 부분의 마지막 인덱스
</span>        
        <span class="c1"># key를 정렬된 부분의 올바른 위치에 삽입
</span>        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># 요소를 한 칸씩 오른쪽으로 이동
</span>            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="c1"># 찾은 위치에 key를 삽입
</span>    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">삽입 정렬 결과: </span><span class="si">{</span><span class="nf">insertion_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="2-버블-정렬-bubble-sort">2. 버블 정렬 (Bubble Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916208845_6sxbw2.png" alt="" /></p>

<h5 id="2-1-개념">2-1. 개념</h5>

<p>버블 정렬은 <strong>인접한 두 개의 원소를 비교하며 자리를 교환</strong>하는 방식으로 동작한다. 배열의 처음부터 끝까지 순회하면서, 왼쪽 값이 오른쪽 값보다 크면 두 값의 위치를 바꾼다. 이</p>

<p>러한 한 번의 순회(Pass)가 끝나면 가장 큰 원소가 배열의 맨 끝으로 이동하게 된다. 이 과정을 배열의 크기만큼 반복한다. 마치 물속의 거품(Bubble)이 위로 올라오는 모습과 같아 버블 정렬이라는 이름이 붙었다.</p>

<h5 id="2-2-시간-복잡도">2-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n)$ - 이미 데이터가 정렬된 상태에서, 한 번의 순회 중 교환(swap)이 발생하지 않으면 정렬을 종료하는 로직을 추가했을 경우이다.</li>
  <li><strong>평균(Average):</strong> $O(n^2)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 데이터가 역순으로 정렬되어 있는 경우이다.</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
버블 정렬은 구현이 매우 간단하여 정렬 알고리즘의 기본 원리를 학습하는 데는 좋지만, 성능이 좋지 않아 실제 현업에서 사용되는 경우는 거의 없다.</p>
</blockquote>

<h5 id="2-3-python-구현-코드">2-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># 배열의 크기만큼 외부 루프를 반복
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># 이미 정렬된 마지막 요소들을 제외하고 내부 루프를 반복
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 왼쪽 요소가 오른쪽 요소보다 크면 교환
</span>            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">swapped</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># 한 번의 순회 동안 교환이 일어나지 않았다면, 이미 정렬된 상태
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">버블 정렬 결과: </span><span class="si">{</span><span class="nf">bubble_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-병합-정렬-merge-sort">3. 병합 정렬 (Merge Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916435555_h2m3yt.png" alt="" /></p>
<h5 id="3-1-개념">3-1. 개념</h5>

<p>병합 정렬은 <strong>분할 정복(Divide and Conquer)</strong> 패러다임을 사용하는 대표적인 정렬 알고리즘이다.</p>

<ol>
  <li><strong>분할(Divide):</strong> 배열의 크기가 1이 될 때까지 재귀적으로 계속해서 반으로 나눈다.</li>
  <li><strong>정복(Conquer):</strong> 나누어진 작은 배열들을 2개씩 쌍을 이루어 정렬하면서 병합(Merge)한다. 이 과정을 모든 배열이 다시 하나로 합쳐질 때까지 반복한다.</li>
</ol>

<h5 id="3-2-시간-복잡도">3-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n \log n)$</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
병합 정렬은 데이터의 분포와 상관없이 항상 $O(n \log n)$의 시간 복잡도를 보장하여 안정적(Stable)이다. 하지만 정렬 과정에서 임시 배열을 위한 추가적인 <strong>메모리 공간($O(n)$)</strong> 이 필요하다는 단점이 있다.</p>
</blockquote>

<h5 id="3-3-python-구현-코드">3-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="c1"># 1. 분할 (Divide)
</span>    <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left_half</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">right_half</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
    
    <span class="c1"># 2. 정복 및 병합 (Conquer and Merge)
</span>    <span class="n">merged_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l_idx</span><span class="p">,</span> <span class="n">r_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">l_idx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">left_half</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r_idx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">right_half</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">]:</span>
            <span class="n">merged_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">])</span>
            <span class="n">l_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">])</span>
            <span class="n">r_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="c1"># 남은 요소들을 추가
</span>    <span class="n">merged_arr</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">left_half</span><span class="p">[</span><span class="n">l_idx</span><span class="p">:])</span>
    <span class="n">merged_arr</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">right_half</span><span class="p">[</span><span class="n">r_idx</span><span class="p">:])</span>
    
    <span class="k">return</span> <span class="n">merged_arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">병합 정렬 결과: </span><span class="si">{</span><span class="nf">merge_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="4-힙-정렬-heap-sort">4. 힙 정렬 (Heap Sort)</h4>

<p><img src="/assets/images/posts/2025-09/image_1757916561788_se2vpw.png" alt="" /></p>

<h5 id="4-1-개념">4-1. 개념</h5>

<p>힙 정렬은 <strong>힙(Heap) 자료구조</strong>를 이용하여 정렬하는 알고리즘이다. 힙은 ‘완전 이진 트리’의 한 종류로, 부모 노드의 값이 항상 자식 노드의 값보다 크거나 같은(최대 힙) 또는 작거나 같은(최소 힙) 속성을 만족한다.</p>

<ol>
  <li>주어진 데이터를 최대 힙(Max Heap) 구조로 만든다.</li>
  <li>힙에서 가장 큰 값은 루트(root) 노드에 위치한다. 이 루트 노드를 배열의 가장 마지막 요소와 바꾼다.</li>
  <li>힙의 크기를 하나 줄이고, 다시 힙 속성을 만족하도록 구조를 재조정(heapify)한다.</li>
  <li>힙의 크기가 1이 될 때까지 2~3번 과정을 반복한다.</li>
</ol>

<h5 id="4-2-시간-복잡도">4-2. 시간 복잡도</h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n \log n)$</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
힙 정렬은 병합 정렬과 달리 추가적인 <strong>메모리 공간을 거의 사용하지 않는($O(1)$)</strong> 장점이 있으며, 항상 $O(n \log n)$의 성능을 보장한다. <strong>우선순위 큐</strong>를 구현할 때 매우 유용하다.</p>
</blockquote>

<h5 id="4-3-python-구현-코드">4-3. Python 구현 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># 현재 서브트리의 루트
</span>    <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
    
    <span class="c1"># 왼쪽 자식이 루트보다 크면 largest를 업데이트
</span>    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
        
    <span class="c1"># 오른쪽 자식이 largest보다 크면 largest를 업데이트
</span>    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
        
    <span class="c1"># largest가 변경되었다면, 루트와 교환하고 재귀적으로 heapify 호출
</span>    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="c1"># 1. 최대 힙(Max Heap) 구성
</span>    <span class="c1"># 마지막 비단말 노드부터 시작하여 루트까지 heapify 수행
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
    <span class="c1"># 2. 힙에서 요소를 하나씩 추출하여 정렬
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 루트(최댓값)를 배열의 끝으로 이동
</span>        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># 크기가 줄어든 힙에 대해 heapify 수행
</span>        
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">힙 정렬 결과: </span><span class="si">{</span><span class="nf">heap_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="4-4-heapq-모듈-사용-예시-및-장단점">4-4. heapq 모듈 사용 예시 및 장단점</h5>

<p>Python의 내장 라이브러리인 <code class="language-plaintext highlighter-rouge">heapq</code>를 사용하면 힙 자료구조를 간단하게 활용할 수 있다. 다음은 <code class="language-plaintext highlighter-rouge">heapq</code>를 이용해 리스트를 정렬하는 예시 코드이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="k">def</span> <span class="nf">heapq_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 모든 원소를 힙에 차례대로 삽입
</span>    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    
    <span class="c1"># 힙에서 모든 원소를 차례대로 꺼내 정렬된 리스트 생성
</span>    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">sorted_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">sorted_arr</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">heapq를 이용한 정렬 결과: </span><span class="si">{</span><span class="nf">heapq_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># 더 간결한 방법: heapify 사용
</span><span class="k">def</span> <span class="nf">heapq_sort_concise</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># 리스트를 한 번에 힙으로 변환 (O(n))
</span>    <span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">sorted_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">sorted_arr</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="c1"># 최대 힙으로 사용할 리스트
</span><span class="n">max_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="c1"># 1. 최대 힙에 원소 추가 (부호를 바꿔서 heappush)
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">--- 최대 힙에 원소 추가 ---</span><span class="sh">"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s"> 추가 후 힙 상태: </span><span class="si">{</span><span class="n">max_heap</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">최종 최대 힙 (내부 표현):</span><span class="sh">"</span><span class="p">,</span> <span class="n">max_heap</span><span class="p">)</span> <span class="c1"># 내부적으로는 음수 값을 가진 최소 힙
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">가장 큰 값(루트): </span><span class="si">{</span><span class="o">-</span><span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">--- 최대 힙에서 원소 추출 ---</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># 2. 최대 힙에서 원소 추출 (heappop 후 부호를 다시 변경)
</span><span class="k">while</span> <span class="n">max_heap</span><span class="p">:</span>
    <span class="c1"># 가장 작은 음수(원래는 가장 큰 양수)를 꺼내서 부호를 복원
</span>    <span class="n">max_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">추출된 최댓값: </span><span class="si">{</span><span class="n">max_val</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
기존 리스트를 제자리에서 힙으로 변환하는 heapq.heapify(list) 함수를 사용하면 $O(n)$의 시간 복잡도로 힙을 구성할 수 있어, 모든 원소를 하나씩 heappush 하는 것보다 효율적이다.</p>
</blockquote>

<ul>
  <li><strong>구현 대비 장점</strong>
    <ul>
      <li><strong>간결성:</strong> 복잡한 <code class="language-plaintext highlighter-rouge">heapify</code> 로직을 직접 구현할 필요 없이, 몇 줄의 코드로 힙 기능을 사용할 수 있어 매우 편리하다.</li>
      <li><strong>성능:</strong> 내장 모듈은 C언어로 구현되어 있어 일반적으로 직접 Python으로 구현한 코드보다 실행 속도가 빠르다.</li>
      <li><strong>안정성:</strong> 이미 충분히 검증된 라이브러리이므로 직접 구현 시 발생할 수 있는 실수를 방지하고 코드의 안정성을 높일 수 있다.</li>
    </ul>
  </li>
  <li><strong>구현 대비 단점</strong>
    <ul>
      <li><strong>추상화:</strong> 내부 동작 원리가 감춰져 있어 힙 정렬의 학습 목적으로는 적합하지 않다.</li>
      <li><strong>추가 메모리 사용:</strong> 위 예시처럼 정렬된 결과를 담을 새로운 리스트가 필요하므로, 제자리 정렬(in-place sort)이 아니며 $O(n)$의 추가 공간이 필요하다.</li>
      <li><strong>최소 힙 고정:</strong> <code class="language-plaintext highlighter-rouge">heapq</code>는 최소 힙(Min Heap)만 지원하므로 최대 힙(Max Heap)이 필요할 경우, 값의 부호를 변경하는 등의 추가적인 처리가 필요하다.</li>
    </ul>
  </li>
</ul>

<p>— 2025년 9월 15일 학습</p>

<h4 id="5-퀵-정렬-quick-sort"><strong>5. 퀵 정렬 (Quick Sort)</strong></h4>

<h5 id="5-1-개념"><strong>5-1. 개념</strong></h5>

<p>퀵 정렬 또한 <strong>분할 정복</strong> 패러다임을 사용하며, 평균적으로 매우 빠른 성능을 자랑한다.</p>

<ol>
  <li>배열 내에서 임의의 기준점, **피벗(Pivot)**을 선택한다.</li>
  <li>피벗을 기준으로 피벗보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 분할(Partition)한다.</li>
  <li>분할된 양쪽의 부분 배열에 대해 재귀적으로 퀵 정렬을 수행한다.</li>
  <li>부분 배열의 크기가 1 이하가 되면 정렬을 멈춘다.</li>
</ol>

<h5 id="5-2-시간-복잡도"><strong>5-2. 시간 복잡도</strong></h5>

<ul>
  <li><strong>최선(Best):</strong> $O(n \log n)$ - 피벗이 항상 배열을 절반으로 분할할 때이다.</li>
  <li><strong>평균(Average):</strong> $O(n \log n)$</li>
  <li><strong>최악(Worst):</strong> $O(n^2)$ - 피벗이 항상 가장 작거나 가장 큰 값으로 선택되어 배열이 한쪽으로 치우치게 분할될 때이다 (예: 이미 정렬된 배열에서 항상 첫 요소를 피벗으로 선택).</li>
</ul>

<blockquote>
  <p><strong>알아두면 좋은 팁</strong>
퀵 정렬은 평균적인 성능이 매우 뛰어나 ‘퀵’이라는 이름이 붙었으며, 많은 프로그래밍 언어의 표준 정렬 라이브러리에서 기본 알고리즘으로 채택되곤 한다. 최악의 경우를 피하기 위해 피벗을 랜덤하게 선택하거나, 세 값의 중앙값(Median-of-three)을 선택하는 등의 기법이 사용된다.</p>
</blockquote>

<h5 id="5-3-python-구현-코드"><strong>5-3. Python 구현 코드</strong></h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># 중앙값을 피벗으로 설정
</span>    <span class="n">lesser_arr</span><span class="p">,</span> <span class="n">equal_arr</span><span class="p">,</span> <span class="n">greater_arr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">lesser_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">greater_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">equal_arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">lesser_arr</span><span class="p">)</span> <span class="o">+</span> <span class="n">equal_arr</span> <span class="o">+</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">greater_arr</span><span class="p">)</span>

<span class="c1"># 예시
</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">퀵 정렬 결과: </span><span class="si">{</span><span class="nf">quick_sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h4 id="6-각-정렬-알고리즘-시간-복잡도-비교"><strong>6. 각 정렬 알고리즘 시간 복잡도 비교</strong></h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘 (Algorithm)</th>
      <th style="text-align: center">최선 (Best)</th>
      <th style="text-align: center">평균 (Average)</th>
      <th style="text-align: center">최악 (Worst)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**삽입 정렬**</td>
      <td style="text-align: center">$O(n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**버블 정렬**</td>
      <td style="text-align: center">$O(n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**병합 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**힙 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
    </tr>
    <tr>
      <td style="text-align: left">**퀵 정렬**</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n \log n)$</td>
      <td style="text-align: center">$O(n^2)$</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="7-번외-그-외에-개발-시-사용하면-좋을-정렬-기법"><strong>7. (번외) 그 외에 개발 시 사용하면 좋을 정렬 기법</strong></h4>

<p>이론적인 학습을 넘어 실제 개발 환경에서는 언어 차원에서 제공하는 내장 정렬 함수를 사용하는 것이 일반적이다. 이 함수들은 대부분의 상황에 최적화된 고성능 알고리즘을 사용한다.</p>

<ul>
  <li>
    <p><strong>팀 정렬 (Timsort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 병합 정렬과 삽입 정렬을 결합한 하이브리드 안정 정렬(Stable Sort) 알고리즘이다.</li>
      <li><strong>특징:</strong> 실제 데이터는 완전히 무작위가 아니라 어느 정도 정렬된 연속적인 부분(run)을 포함하는 경우가 많다는 점에서 착안되었다. 이런 ‘run’들을 찾아서 삽입 정렬로 처리하고, 이 run들을 효율적으로 병합해 나간다. 적응형(Adaptive) 알고리즘으로, 데이터의 상태에 따라 최적의 성능을 낸다.</li>
      <li><strong>용도:</strong> <strong>Python</strong>의 내장 정렬 함수(<code class="language-plaintext highlighter-rouge">sorted()</code>, <code class="language-plaintext highlighter-rouge">list.sort()</code>)와 Java의 <code class="language-plaintext highlighter-rouge">Arrays.sort()</code> (객체 배열용)에서 표준 알고리즘으로 사용된다.</li>
    </ul>
  </li>
  <li>
    <p><strong>기수 정렬 (Radix Sort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 비교 기반 정렬이 아니다. 데이터의 자릿수(radix)를 이용하여 낮은 자릿수부터 정렬해 나가는 방식이다. 예를 들어, 10진수 정수를 정렬한다면 1의 자리, 10의 자리, 100의 자리 순으로 정렬을 수행한다.</li>
      <li><strong>특징:</strong> 시간 복잡도는 $O(d(n+k))$ (d: 자릿수, n: 데이터 개수, k: 기수)로, 데이터의 길이가 짧고 개수가 많을 때 비교 기반 정렬인 $O(n \log n)$보다 빠를 수 있다.</li>
      <li><strong>용도:</strong> 정수나 문자열 등 자릿수 구분이 명확한 데이터들을 정렬할 때 효과적이다. (예: 대규모 숫자 데이터 정렬, 사전순 문자열 정렬)</li>
    </ul>
  </li>
  <li>
    <p><strong>계수 정렬 (Counting Sort)</strong></p>

    <ul>
      <li><strong>개념:</strong> 비교 기반 정렬이 아니다. 각 숫자가 몇 번 등장했는지 개수를 센 다음, 누적합을 이용하여 각 숫자의 정렬된 위치를 계산하는 방식이다.</li>
      <li><strong>특징:</strong> 데이터 값의 범위(range)가 데이터의 개수(n)에 비해 작을 때 매우 빠른 성능을 보인다. 시간 복잡도는 $O(n+k)$ (k: 데이터의 최댓값)이다.</li>
      <li><strong>용도:</strong> 정수 데이터, 특히 양수이고 값의 범위가 한정적일 때 사용하기 좋다. (예: 0~100점 사이의 시험 점수 정렬)</li>
    </ul>
  </li>
</ul>

<h3 id="동적-프로그래밍dynamic-programming">동적 프로그래밍(Dynamic Programming)</h3>

<h3 id="재귀-알고리즘">재귀 알고리즘</h3>

<h3 id="알고리즘---고급">알고리즘 - 고급</h3>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[알고리즘]]></summary></entry><entry><title type="html">CS 학습 - 9월 2주차 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02.html" rel="alternate" type="text/html" title="CS 학습 - 9월 2주차 (2)" /><published>2025-09-09T00:00:00+00:00</published><updated>2025-09-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/09/cs-09-02-02.html"><![CDATA[<h2 id="자료구조와-알고리즘-feat-ts와-python-을-얹은">자료구조와 알고리즘 (feat, TS와 Python 을 얹은)</h2>

<h3 id="typescript-vs-python-배열array-사용법-비교">TypeScript vs. Python: 배열(Array) 사용법 비교</h3>

<p><strong>TypeScript는 정적 타입을 지원하여 코드의 안정성을 높이는 반면, Python은 동적 타이핑으로 유연하고 간결한 코드 작성을 지원한다.</strong></p>
<h4 id="1-배열의-선언과-초기화">1. 배열의 선언과 초기화</h4>

<p>가장 큰 차이점은 <strong>타입 명시 여부</strong>이다. TypeScript는 변수 선언 시 타입을 지정하여 예측 가능하고 안정적인 코드를 작성하도록 유도하는 반면, Python은 타입을 명시하지 않아도 되어 간결하다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 배열이 담을 요소의 타입을 명시적으로 지정해야 한다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">let list: number[] = [1, 2, 3];</code></li>
      <li><code class="language-plaintext highlighter-rouge">let list: Array&lt;number&gt; = [1, 2, 3];</code></li>
      <li>다양한 타입을 허용하려면 유니온 타입(<code class="language-plaintext highlighter-rouge">(string | number)[]</code>)을 사용할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Python</strong>: 파이썬의 리스트는 기본적으로 모든 데이터 타입을 담을 수 있는 동적 배열이다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">my_list = [1, "hello", True]</code></li>
      <li>타입을 강제하고 싶다면 <code class="language-plaintext highlighter-rouge">array</code> 모듈을 사용하거나, 타입 힌트(Type Hint)를 활용할 수 있으나, 이는 강제 사항이 아니다.</li>
      <li><code class="language-plaintext highlighter-rouge">from array import array</code></li>
      <li><code class="language-plaintext highlighter-rouge">arr = array('i', [1, 2, 3])</code></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-요소-접근-추가-및-삭제">2. 요소 접근, 추가 및 삭제</h4>

<p>배열의 요소를 다루는 기본적인 방법은 유사하지만, 사용하는 메서드의 이름과 기능에서 차이가 나타난다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">TypeScript</th>
      <th style="text-align: left">Python (List)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**요소 접근**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr[0]</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list[0]</code>, <code class="language-plaintext highlighter-rouge">my_list[-1]</code></td>
      <td style="text-align: left">TypeScript와 Python 모두 인덱스로 요소에 접근한다. Python은 음수 인덱스를 지원하여 뒤에서부터 접근이 가능하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 뒤에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.push(4)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.append(4)</code></td>
      <td style="text-align: left">가장 일반적인 요소 추가 방식이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 앞에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.unshift(0)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.insert(0, 0)</code></td>
      <td style="text-align: left">TypeScript에는 <code class="language-plaintext highlighter-rouge">unshift</code>라는 명확한 메서드가 있다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 인덱스에 요소 추가**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.splice(1, 0, 1.5)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.insert(1, 1.5)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">splice</code>는 추가, 삭제, 교체가 모두 가능하여 더 강력하다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 뒤 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.pop()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop()</code></td>
      <td style="text-align: left">두 언어 모두 동일한 이름의 메서드를 사용한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**맨 앞 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.shift()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop(0)</code> 또는 <code class="language-plaintext highlighter-rouge">del my_list[0]</code></td>
      <td style="text-align: left">TypeScript는 <code class="language-plaintext highlighter-rouge">shift</code> 메서드를 제공한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 인덱스 요소 삭제**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">arr.splice(1, 1)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.pop(1)</code> 또는 <code class="language-plaintext highlighter-rouge">del my_list[1]</code></td>
      <td style="text-align: left">특정 위치의 요소를 삭제하는 기능이다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**특정 값으로 요소 삭제**</td>
      <td style="text-align: left">(직접 구현 필요)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">my_list.remove(3)</code></td>
      <td style="text-align: left">Python은 값으로 요소를 찾아 삭제하는 <code class="language-plaintext highlighter-rouge">remove</code> 메서드를 기본 제공한다.</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="3-배열-순회-반복">3. 배열 순회 (반복)</h4>

<p>배열의 모든 요소를 순차적으로 접근하여 작업을 수행하는 반복문에서도 약간의 차이가 존재한다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">for...of</code>, <code class="language-plaintext highlighter-rouge">forEach</code>, 그리고 전통적인 <code class="language-plaintext highlighter-rouge">for</code> 루프를 주로 사용한다.</p>

    <ul>
      <li><strong>for…of</strong>: 배열의 ‘값(value)’을 순차적으로 가져온다. (가장 권장되는 방식 중 하나)
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>
<span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong>forEach</strong>: 각 요소에 대해 콜백 함수를 실행한다.
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">list</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Index </span><span class="p">${</span><span class="nx">index</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">for...in</code> 구문을 사용하는 것이 가장 일반적이고 파이썬다운(Pythonic) 방법이다.</p>

    <ul>
      <li><strong>for…in</strong>: 배열의 ‘값(value)’을 순차적으로 가져온다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li><strong>enumerate</strong>: 인덱스와 값을 함께 가져와야 할 때 유용하게 사용된다.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="typescript-vs-python-배열-순회-및-변형-심화">TypeScript vs. Python: 배열 순회 및 변형 심화</h3>
<p><strong>TypeScript는 메서드 체이닝(Method Chaining)을 통해 가독성을 높이는 반면, Python은 리스트 컴프리헨션이라는 독특하고 간결한 구문을 통해 강력한 기능을 제공한다.</strong></p>

<h4 id="1-배열의-각-요소를-변형하기-mapping">1. 배열의 각 요소를 변형하기 (Mapping)</h4>

<p><code class="language-plaintext highlighter-rouge">map</code>은 배열의 모든 요소를 순회하며 주어진 함수를 적용하여 <strong>새로운 배열을 생성</strong>하는 기능이다. 원본 배열은 변경되지 않는다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">map()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">squared</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">);</span>
<span class="c1">// squared: [1, 4, 9, 16]</span>
</code></pre></div>    </div>

    <p>각 요소에 함수를 순차적으로 적용하고 그 결과값을 모아 새로운 배열로 반환하는 직관적인 방식이다.</p>
  </li>
  <li>
    <p><strong>Python</strong>: 리스트 컴프리헨션(List Comprehension)이 가장 일반적이고 효율적인 방법이다. <code class="language-plaintext highlighter-rouge">map()</code> 함수도 존재한다.</p>

    <ul>
      <li><strong>리스트 컴프리헨션</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squared</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
<span class="c1"># squared: [1, 4, 9, 16]
</span></code></pre></div>        </div>
        <p>대괄호 안에 <code class="language-plaintext highlighter-rouge">for</code> 루프를 포함하는 형태로, 매우 간결하고 가독성이 높다고 평가받는다.</p>
      </li>
      <li><strong>map() 함수</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1"># map 객체를 반환하므로 list로 변환 필요
</span><span class="n">squared</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span> 
<span class="c1"># squared: [1, 4, 9, 16]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="2-조건에-맞는-요소만-걸러내기-filtering">2. 조건에 맞는 요소만 걸러내기 (Filtering)</h4>

<p><code class="language-plaintext highlighter-rouge">filter</code>는 배열의 모든 요소를 순회하며, 주어진 함수의 결과값이 <code class="language-plaintext highlighter-rouge">true</code>인 요소들만 모아 <strong>새로운 배열을 생성</strong>하는 기능이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">filter()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">evens</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// evens: [2, 4]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: 여기서도 리스트 컴프리헨션이 널리 쓰인다.</p>

    <ul>
      <li><strong>리스트 컴프리헨션</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># evens: [2, 4]
</span></code></pre></div>        </div>
        <p><code class="language-plaintext highlighter-rouge">for</code> 루프 뒤에 <code class="language-plaintext highlighter-rouge">if</code> 조건을 추가하여 필터링 기능을 구현한다.</p>
      </li>
      <li><strong>filter() 함수</strong>:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1"># filter 객체를 반환하므로 list로 변환 필요
</span><span class="n">evens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">num</span><span class="p">:</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span>
<span class="c1"># evens: [2, 4]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="3-배열을-하나의-값으로-통합하기-reducing">3. 배열을 하나의 값으로 통합하기 (Reducing)</h4>

<p><code class="language-plaintext highlighter-rouge">reduce</code>는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하여 <strong>하나의 결과값</strong>을 반환한다. 누적 계산에 주로 사용된다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">reduce()</code> 메서드를 사용한다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">sum</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">accumulator</span><span class="p">,</span> <span class="nx">currentValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">accumulator</span> <span class="o">+</span> <span class="nx">currentValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// sum: 15</span>
<span class="c1">// 0은 accumulator의 초기값이다.</span>
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">accumulator</code>는 이전 콜백의 반환값이 누적되는 변수이고, <code class="language-plaintext highlighter-rouge">currentValue</code>는 현재 처리 중인 요소이다.</p>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">functools</code> 모듈의 <code class="language-plaintext highlighter-rouge">reduce()</code> 함수를 사용해야 한다. (Python 3.x부터 내장 함수에서 모듈로 이동했다)</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">sum_value</span> <span class="o">=</span> <span class="nf">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">current_value</span><span class="p">:</span> <span class="n">accumulator</span> <span class="o">+</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># sum_value: 15
# 0은 초기값(initializer)이다.
</span></code></pre></div>    </div>

    <p>물론, 합계를 구하는 경우 파이썬의 내장 함수 <code class="language-plaintext highlighter-rouge">sum()</code>을 쓰는 것이 훨씬 간단하고 효율적이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sum_value</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># 결과: 15
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="typescript-vs-python-연결-리스트linked-list-구현-및-사용법">TypeScript vs. Python: 연결 리스트(Linked List) 구현 및 사용법</h3>
<p>TypeScript와 Python 모두 <strong>연결 리스트(Linked List)를 직접 구현해야 한다는 점은 동일하다.</strong> 두 언어 모두 배열(리스트)과 달리 내장된 연결 리스트 자료 구조를 제공하지 않기 때문. 하지만 <strong>TypeScript는 타입 시스템을 활용해 노드(Node)의 구조를 명확하게 정의하여 안정성을 높이는 반면, Python은 간결한 문법으로 더 빠르게 구현할 수 있다.</strong></p>

<p>연결 리스트는 각 요소가 데이터와 다음 요소를 가리키는 포인터(참조)를 함께 가지고 있는 선형 자료 구조이다. 배열과 달리 메모리에 연속적으로 위치하지 않아 삽입과 삭제가 효율적이다.</p>

<h4 id="1-노드node와-리스트-구조-정의">1. 노드(Node)와 리스트 구조 정의</h4>

<p>연결 리스트를 구현하는 첫 단계는 기본 단위인 <strong>노드</strong>를 정의하는 것이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: <code class="language-plaintext highlighter-rouge">interface</code>나 <code class="language-plaintext highlighter-rouge">class</code>를 사용해 노드의 형태를 명확하게 정의한다. 타입 시스템 덕분에 <code class="language-plaintext highlighter-rouge">value</code>의 타입과 <code class="language-plaintext highlighter-rouge">next</code> 포인터가 <code class="language-plaintext highlighter-rouge">Node</code> 혹은 <code class="language-plaintext highlighter-rouge">null</code>임을 강제할 수 있다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 노드의 구조 정의</span>
<span class="kr">interface</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="nl">next</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 노드 클래스</span>
<span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="k">public</span> <span class="na">next</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 연결 리스트 클래스</span>
<span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">head</span><span class="p">:</span> <span class="nx">INode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">// ... 추가적인 메서드들</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: <code class="language-plaintext highlighter-rouge">class</code>를 사용하여 노드를 정의한다. 타입 힌트(<code class="language-plaintext highlighter-rouge">Type Hint</code>)를 사용할 수는 있지만, TypeScript처럼 강제되지는 않는다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 노드 클래스
</span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># 연결 리스트 클래스
</span><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># ... 추가적인 메서드들
</span></code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-핵심-연산-노드-추가-및-순회">2. 핵심 연산: 노드 추가 및 순회</h4>

<p>가장 기본적인 연산인 ‘맨 뒤에 노드 추가’와 ‘리스트 순회’를 비교해 본다. 로직 자체는 동일하지만, 코드의 세부적인 표현에서 차이가 나타난다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 타입 검사를 통과해야 하므로 <code class="language-plaintext highlighter-rouge">null</code> 체크가 명시적으로 이루어진다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">head</span><span class="p">:</span> <span class="nx">Node</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="c1">// 맨 뒤에 노드 추가</span>
  <span class="k">public</span> <span class="nf">append</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">current</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 리스트 순회 및 출력</span>
  <span class="k">public</span> <span class="nf">printAll</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="kd">const</span> <span class="na">values</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">values</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> -&gt; </span><span class="dl">'</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: 문법이 더 간결하며, <code class="language-plaintext highlighter-rouge">None</code>을 활용한 <code class="language-plaintext highlighter-rouge">null</code> 체크가 자연스럽게 이루어진다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># 맨 뒤에 노드 추가
</span>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="k">return</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">new_node</span>
            
    <span class="c1"># 리스트 순회 및 출력
</span>    <span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s"> -&gt; </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>결론적으로, 두 언어 모두 동일한 자료 구조의 원리를 따라 연결 리스트를 구현한다. TypeScript는 제네릭(<code class="language-plaintext highlighter-rouge">T</code>)과 인터페이스를 통해 재사용 가능하고 타입-안전(type-safe)한 코드를 작성하도록 유도하는 반면, Python은 더 적은 코드로 빠르게 핵심 로직을 구현하는 데 강점을 보인다.</p>

<h3 id="typescript-vs-python-스택stack-구현-및-사용법">TypeScript vs. Python: 스택(Stack) 구현 및 사용법</h3>

<p>스택(Stack) 역시 TypeScript와 Python 모두 내장된 자료 구조가 아니므로, <strong>배열(리스트)을 활용하여 직접 구현하는 것이 일반적이다.</strong> 두 언어의 구현 방식은 매우 유사하며, 핵심적인 차이는 <strong>TypeScript의 타입-안전성(Type-Safety)과 Python의 간결함</strong>에서 비롯된다.</p>

<p>스택은 ‘마지막에 들어온 것이 가장 먼저 나가는’(LIFO, Last-In, First-Out) 원칙을 따르는 자료 구조이다. 접시를 쌓고 위에서부터 차례로 꺼내는 것을 생각하면 이해하기 쉽다.</p>

<h4 id="1-스택의-구현-방식">1. 스택의 구현 방식</h4>

<p>배열(리스트)의 끝에서 데이터를 추가하고 제거하는 <code class="language-plaintext highlighter-rouge">push</code>와 <code class="language-plaintext highlighter-rouge">pop</code> 연산은 스택의 LIFO 동작 원리와 완벽하게 일치한다. 따라서 배열을 감싸는(wrapping) 클래스를 만들어 스택을 구현하는 것이 가장 효율적이다.</p>

<ul>
  <li>
    <p><strong>TypeScript</strong>: 제네릭(<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>)을 사용하여 어떤 타입의 데이터든 담을 수 있는 타입-안전한 스택 클래스를 정의한다. 내부 배열을 <code class="language-plaintext highlighter-rouge">private</code>으로 선언하여 외부에서 직접 접근하는 것을 막고, <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code> 같은 메서드를 통해서만 조작하도록 캡슐화하는 것이 일반적이다.</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 스택에 데이터 추가 (push)</span>
  <span class="nf">push</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 스택에서 데이터 추출 (pop)</span>
  <span class="nf">pop</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 스택의 가장 위 데이터 확인 (peek)</span>
  <span class="nf">peek</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 스택이 비어있는지 확인</span>
  <span class="nf">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Python</strong>: Python의 리스트는 그 자체로 스택처럼 사용될 수 있다. <code class="language-plaintext highlighter-rouge">append()</code> 메서드가 <code class="language-plaintext highlighter-rouge">push</code> 역할을, <code class="language-plaintext highlighter-rouge">pop()</code> 메서드가 <code class="language-plaintext highlighter-rouge">pop</code> 역할을 한다. 가독성과 재사용성을 위해 클래스로 감싸는 것이 좋은 관례이다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># 관례적으로 _ 를 붙여 내부에서만 사용함을 표시
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 스택에 데이터 추가 (push)
</span>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># 스택에서 데이터 추출 (pop)
</span>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="c1"># 혹은 예외 발생
</span>
    <span class="c1"># 스택의 가장 위 데이터 확인 (peek)
</span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 음수 인덱싱 활용
</span>        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 스택이 비어있는지 확인
</span>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="2-핵심-연산-비교">2. 핵심 연산 비교</h4>

<p>스택의 핵심 연산인 <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code>, <code class="language-plaintext highlighter-rouge">peek</code>를 비교하면 두 언어의 철학 차이가 드러난다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">TypeScript</th>
      <th style="text-align: left">Python (List 기반)</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**Push (추가)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items.push(item)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items.append(item)</code></td>
      <td style="text-align: left">TypeScript는 <code class="language-plaintext highlighter-rouge">push</code>, Python은 <code class="language-plaintext highlighter-rouge">append</code>를 사용하여 배열(리스트)의 끝에 요소를 추가한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**Pop (추출)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items.pop()</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items.pop()</code></td>
      <td style="text-align: left">두 언어 모두 동일한 이름의 <code class="language-plaintext highlighter-rouge">pop()</code> 메서드를 사용하며, 배열의 마지막 요소를 제거하고 반환한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">**Peek (확인)**</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">items[items.length - 1]</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">_items[-1]</code></td>
      <td style="text-align: left">Python의 음수 인덱싱(<code class="language-plaintext highlighter-rouge">-1</code>)이 마지막 요소를 가리키므로 코드가 더 간결하다.</td>
    </tr>
  </tbody>
</table>

<p>결론적으로, 스택을 구현하는 알고리즘은 두 언어에서 동일하다. TypeScript는 정적 타입을 통해 의도치 않은 타입의 데이터가 스택에 들어오는 것을 컴파일 시점에 막아주어 안정성을 높여준다. 반면, Python은 특유의 간결한 문법(음수 인덱싱 등)을 통해 더 빠르게 코드를 작성할 수 있는 장점이 있다.</p>

<blockquote>
  <p>언더바(<code class="language-plaintext highlighter-rouge">_</code>)의 의미</p>
  <ul>
    <li>싱글 언더스코어 : <code class="language-plaintext highlighter-rouge">_var</code>(보호된 멤버)
  클래스 상에서 싱글 언더스코어는 보호된 멤버라는 뜻, 즉, 내부 사용용이니 조심히 사용하는 것을 권장한다는 의미를 내포함. 클래스 서계자의 의도와 다르게 사용될 수 있으니 주의가 필요함.</li>
    <li>더블 언더스코어 : <code class="language-plaintext highlighter-rouge">__var</code>(비공개 멤버)
  외부에서 사용을 적극적으로 막기 위해 사용되는 케이스. Python 인터프리터가 이 변수의 이름을 Name Mangling 이라는 기술로, 사용시 내부적으로 <code class="language-plaintext highlighter-rouge">__items</code> 를 <code class="language-plaintext highlighter-rouge">__ClassName__items</code> 로 형태를 바꾸며, 사용시 AttributeError 가 발생될 수 있다.</li>
  </ul>
</blockquote>

<h3 id="typescript-vs-python-큐queue-구현-및-사용법">TypeScript vs. Python: 큐(Queue) 구현 및 사용법</h3>
<p>큐(Queue)를 구현할 때, <strong>Python은 <code class="language-plaintext highlighter-rouge">collections</code> 모듈에 포함된 <code class="language-plaintext highlighter-rouge">deque</code>라는 매우 효율적인 자료 구조를 기본으로 제공한다.</strong> 반면, <strong>TypeScript는 내장된 큐 자료 구조가 없어 개발자가 직접 구현해야 하며, 간단한 배열(Array)을 사용하거나 성능을 위해 연결 리스트(Linked List)를 기반으로 만들어야 한다.</strong></p>

<p>큐는 ‘가장 먼저 들어온 것이 가장 먼저 나가는’(FIFO, First-In, First-Out) 원칙을 따르는 자료 구조이다. 은행 창구나 놀이공원의 줄서기를 생각하면 쉽게 이해할 수 있다.</p>

<h4 id="1-큐-구현-방식의-핵심-차이">1. 큐 구현 방식의 핵심 차이</h4>

<p>큐의 핵심은 한쪽 끝(rear)에서는 데이터를 추가하고, 반대쪽 끝(front)에서는 데이터를 제거하는 것이다. 이 “앞에서 제거하는” 연산 때문에 일반적인 배열(리스트)을 사용하면 성능 문제가 발생할 수 있다.</p>

<ul>
  <li><strong>배열의 비효율성</strong>: 배열의 맨 앞 요소를 제거(<code class="language-plaintext highlighter-rouge">shift()</code> 또는 <code class="language-plaintext highlighter-rouge">pop(0)</code>)하면, 그 뒤의 모든 요소들을 한 칸씩 앞으로 당겨야 한다. 이 작업은 배열의 크기가 클수록 오래 걸리는, 즉 성능이 좋지 않은 연산(시간 복잡도 O(n))이다.</li>
  <li><strong>Python의 해결책</strong>: Python은 이러한 문제를 해결하기 위해 양쪽 끝에서 데이터를 추가하고 제거하는 속도(O(1))가 매우 빠른 <code class="language-plaintext highlighter-rouge">deque</code>(데크, double-ended queue)를 제공한다.</li>
  <li><strong>TypeScript의 선택지</strong>: TypeScript는 개발자가 상황에 맞게 구현 방식을 선택해야 한다.
    <ol>
      <li><strong>간단한 구현</strong>: 배열의 <code class="language-plaintext highlighter-rouge">shift()</code> 메서드를 사용해 간단히 구현 (데이터가 적을 때 유용).</li>
      <li><strong>성능적 구현</strong>: 이전에 다룬 연결 리스트를 기반으로 직접 구현 (데이터가 많고 성능이 중요할 때).</li>
    </ol>
  </li>
</ul>

<hr />

<h4 id="2-python-collectionsdeque-활용">2. Python: <code class="language-plaintext highlighter-rouge">collections.deque</code> 활용</h4>

<p>Python에서 큐를 구현할 때는 <code class="language-plaintext highlighter-rouge">deque</code>를 사용하는 것이 가장 표준적이고 효율적인 방법이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># deque 객체를 내부에서 사용한다.
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_items</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>

    <span class="c1"># 큐의 뒤쪽에 데이터 추가 (enqueue)
</span>    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># 큐의 앞쪽에서 데이터 추출 (dequeue)
</span>    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="c1"># popleft()는 O(1) 시간 복잡도를 가진다.
</span>            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 큐의 가장 앞 데이터 확인 (peek)
</span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 큐가 비어있는지 확인
</span>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">_items</span>
</code></pre></div></div>

<hr />

<h4 id="3-typescript-배열-또는-연결-리스트-활용">3. TypeScript: 배열 또는 연결 리스트 활용</h4>

<p>TypeScript에서는 내장된 <code class="language-plaintext highlighter-rouge">deque</code>가 없으므로, 두 가지 방식으로 접근할 수 있다.</p>

<h5 id="1-배열을-이용한-간단한-구현">1. 배열을 이용한 간단한 구현</h5>

<p>가장 직관적이고 빠르게 구현할 수 있는 방법이지만, 성능 저하의 가능성을 인지하고 있어야 한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 큐의 뒤쪽에 데이터 추가 (enqueue)</span>
  <span class="nf">enqueue</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 큐의 앞쪽에서 데이터 추출 (dequeue)</span>
  <span class="nf">dequeue</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="c1">// shift()는 O(n)의 시간 복잡도를 가져 성능에 불리할 수 있다.</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 큐의 가장 앞 데이터 확인 (peek)</span>
  <span class="nf">peek</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 큐가 비어있는지 확인</span>
  <span class="nf">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-성능을-위한-연결-리스트-기반-구현">2. 성능을 위한 연결 리스트 기반 구현</h5>

<p>데이터의 양이 많고, 추가/삭제가 빈번하게 일어나는 등 성능이 중요한 상황에서는 연결 리스트를 기반으로 큐를 구현하는 것이 정석이다. 연결 리스트의 <code class="language-plaintext highlighter-rouge">head</code>에서 노드를 제거하고(<code class="language-plaintext highlighter-rouge">dequeue</code>), <code class="language-plaintext highlighter-rouge">tail</code>에 새로운 노드를 추가(<code class="language-plaintext highlighter-rouge">enqueue</code>)하는 방식이다. 이 경우, 두 연산 모두 O(1)의 빠른 시간 복잡도를 보장받을 수 있다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="이직" /><category term="학습" /><category term="CS" /><category term="Python" /><category term="TypeScript" /><summary type="html"><![CDATA[자료구조와 알고리즘 (feat, TS와 Python 을 얹은)]]></summary></entry></feed>