<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-11-24T09:22:54+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">Protostar 프로젝트를 소개합니다</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/24/project-protostar.html" rel="alternate" type="text/html" title="Protostar 프로젝트를 소개합니다" /><published>2025-11-24T00:00:00+00:00</published><updated>2025-11-24T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/24/project-protostar</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/24/project-protostar.html"><![CDATA[<h2 id="project-protostar-를-소개합니다">Project Protostar 를 소개합니다</h2>

<h3 id="forge-your-future">Forge Your Future</h3>
<p><img src="/assets/images/assets/protostar-icon.png" alt="" />
<img src="/assets/images/assets/protostar-demo.png" alt="" /></p>

<p>회사가 뭘 원할까?</p>

<p>이 질문은 회사를 다니는 경력자들조차 쉬이 확답으로 이야기 하기 어려운 영역이다. 전문성, 어떤 영역에서 깊이 있게 된 사람이라면 모를까, 그렇지 않다면 항상 어려운 이야기일 것이다.</p>

<p>이 사람은 과연 잘 할까?</p>

<p>이 질문 역시 HR을 하는 조직, 회사 입장에서 항상 어려운 영역이다. 전문성과 체계화를 통해 이를 시스템으로 정착 시킨 회사라면 그나마 괜찮겠지만, 그렇지 않은 회사들이 절대적이며, 그렇기에 많은 회사 경영진들은 비싼 돈을 주고서도 인사 관리, 어떻게 사람을 뽑고, 쓰며, 배치 할지에 돈과 시간을 쏟아붓는다.</p>

<p>그런 생각 도중에 이렇게 생각했다?</p>

<p>커리어에 대한 현실적인 질문을 노동자가 받을 수 있다면?
커리어에 대한 방대한 자료들에 직접 핵심으로 생각하는 질문을 하고, 그거에 능동적으로 답변이 가능하다면?</p>

<p>이력서는 압축이 필요하다
경력 기술서도 압축이 필요하다
자기 소개서도 압축이 필요하고 무엇보다 ‘매력적’인 부분을 어필해야한다.</p>

<p>HR 담당자의 시간은 금인데, 일일히 읽어보는게 아닌, 핵심으로 생각하는 질문을 던질 수 있고, 이에 준하는 사람을 능동적으로 찾아낼 수 있다면? 자연어로 구성된 복잡한 질문을 풀어낼 수 있다면?</p>

<p>또 반대로 HR 담당자가 어떤 질문을 하고, 어떤 부분을 관심 가지는지 알 수 있다면?</p>

<p>‘Forge Your Future’ 이라는 슬로건은 이러한 문제에서 시작하였다.</p>

<h3 id="기술적-성장-포인트">기술적 성장 포인트</h3>

<p>현재 3년간의 과정을 통해 나의 기술적 능력치는 상당히 끌어 올려졌다. 특히나 1년 간의 메인 백엔드 개발자로서의 일은, 물론 남들에겐 제대로된 사수가 없다는 사실에, 박봉이란 사실에 아쉬워 하거나, 저걸로 되겠냐? 라고 생각하고 질문하시는 분도 있었다.</p>

<p>하지만 그것은 나에겐 너무나 소중한 시간이었다. 온전한 책임, 온전한 집중이 가능하고, 다른 사람이 아닌 내가 실제 부딪혀서 생기는 불만과, 부족함, 그리고 어려움을 직접 고민해볼 수 있는 ‘권한’이 제공되었다는 점만으로도 감사했고, 그 감사한 순간에 하루가 다르게 성장하는 AI는. 비록 완벽하진 않지만, 그럼에도 불구하고 내가 써야할 다양한 기술들의 적용, 방법, 핵심을 잘 설명해주는 완벽한 비서였다.</p>

<p>그렇기에 1년하고도 수개월 간을 달려올 수 있었고, 그 달려옴으로 생긴 문제도 쉴 겸. 그리고 그걸 기반으로 더 큰 성장을 이루기 위해 이번 프로젝트를 기획하게 되었다. BM 차원에서나, 기획 차원에서 아쉬움도 있을 수 있고, 한계점이 명백하다고 생각은 한다. 그럼에도, 실제 구현을 해냈다. 그리고 동시에 이를 어떤 구조에서 세워 나갔는가! 를 더 중요시하기로 했기에, 몇가지 기술적 구현 목표를 설정했다.</p>

<ul>
  <li>v1 : 초기 MSA 기반 설계, Kubernetes 를 기반으로 하는 엔터프라이즈급 구성, 스케일링, 무중단(zero-downtime) 을 구축하는 걸 목표로 하고 AI와 DevOps 역량을 극대화 하자.</li>
  <li>v2 : 국내 시장의 요구사항을 점검하여 몇 가지 기술 스택을 개선하고, 특히 k8s 기반의 대중적인 툴인 ArgoCD 를 기반으로 CI/ CD의 영역의 책임 분리, Spring 을 기반으로 하는 기술 스택의 재 활용 등을 수행했다.</li>
  <li>v2.1 : 진행 과정에서 알게된 제약 사항, 특히 온프레미스에서 수행하게 되다보니 발생한 리소스 경합, 네트워크 문제를 해결하는 구조를 포함한다. 또한 단일 실패지점(SPOF) 에 대한 구조적 한계점을 인지하고, Admin과 Service 의 구조적 설계를 보강한다.</li>
</ul>

<p><img src="/assets/images/posts/2025-11/20251124-038.png" alt="" /></p>

<p>특히 이러한 아키텍트를 하게된 목표는 다음과 같은 기준 때문이다.</p>

<ol>
  <li>3년차 개발 직군의 역량을 갖춰 보자! : k8s, Grafana, Loki, RabbitMQ(혹은 kafka)</li>
  <li>현재의 표준화된 스케일링 도구들에 대한 이해도, 클라우드 플랫폼의 의존성을 탈피할 수단을 확실하게 배워 AWS, GCP, Azure 라는 굵직한 키워드 만큼이나, 기술 독립적인 역량을 갖추자</li>
  <li>AI를 서비스 개발, 서비스의 테스팅, 서비스 내부에 적극적으로 쏟아 넣어, 기계적으로 해결 어려운 문제를 해결하고, 생산성을 극대화 시키는 역량을 갖추자!</li>
</ol>

<p>나의 목표는 그렇다. 이 프로젝트의 성공적인 런칭을 통해 사업을 하거나 하는건 당장은 힘드리라 생각한다. 그러나 몸의 회복을 하는 6개월의 시간을 이를 하면서 보냄으로서 다음을 철저히 준비하고, 무엇보다 ‘연차’나 ‘비개발직군’이 가지는 한계치를 뛰어넘는 역량을 증명해 내는 것. 그것이 본 프로젝트를 하는 목표의 한 축이라 할 수 있겠다. (물론, 위에서 언급한 불편함을 ‘나’에게 적용시켜서 스스로의 아쉬운 포인트를 긁어내고 싶은 점도 있긴 하다.)</p>

<h3 id="디테일하게-아키텍처의-진화-문제해결을-위한-구조-탐구">디테일하게 아키텍처의 진화, 문제해결을 위한 구조 탐구</h3>

<p>위에서 언급한 v1 ~ v2.1 은 내 목표를 달성하기 위한 ‘실전 구현’의 목표보다는 ‘기술검증’을 위한 도구에 가깝다. 실제로 n8n 을 테스팅 하면서 AI의 구축이나 서버의 구축은 사실 모놀리스식, 가장 빠르고 쉬운 접근법이 구현이란 차원에서 보면 맞을 수 있었다.</p>

<p>하지만 목표가 있기에, 그걸 위한 구조를 짜보면서 정말 많은 공부를 했기에 얻어낸 결실이었다.</p>

<p>최초 버전에서 한계점이 보였다. Java Spring 에 대한 작업을 안 해본건 아니지만, 너무 오래 되었기에 다시 보겠다는 점, 특히 WebFlux처럼 NestJS에선 당연한 도구지만 비동기, 비봉쇄의 이벤트 루프 방식의 처리를 통해 Java 진영 역시 빠르고 안정적인 단일 프로세스 기반의 비동기 처리가 가능해졌다. 이를 이해할 필요는 있어 보였다.</p>

<p>또한 k8s를 단순히 CLI로 쓰는 건 매우 어렵고 복잡한 일이었다. 특히 패키지 매니징을 통해 실무에서 검증된 기술을 쓴다는 점에서 생각하면 생성되는 수십개의 노드들의 관계나 디테일을 관리하기란 생각 이상으로 어려웠고, 이를 위한 도구가 ArgoCD라는 것을 이해했을 때, 도입과 함께 CD의 기틀을 GitOps로 가야 함을 깨달았다.</p>

<p>특히, 구조 상 폴리레포 형태를 포함해야하고, Git repo를 단일한 공급원으로 삼아 CI의 구성 효율화가 필요함, 원본 정보를 RAG 하기 전 상태로 유지해야 한다는 점등을 볼 때, MinIO의 필요성 등을 느꼈다.</p>

<p>특히나 가장 문제점은 홈랩(Homelab)을 구축하였고, 이를 기반으로 한 서비스 배포를 생각해보고 있는데, 공인 IP 한대로는 한개의 종단간 암호화 인증 및 서비스 배포가 되기 때문에, 간단히 생각해 443 포트를 가상 도메인 방식으로 Admin, Servce 모두 연결 시킬 순 있지만. 그렇게 했다간 Service 의 과부하 일 경우 Admin 접속이 불가능하다는 문제를 파악. 이를 개선하는 것을 포함하기 위해 GCP 프리티어의 인스턴스를 활용 L4 레이어 TLS passthrough 를 도입하는 등의 변화를 겪었다.</p>

<p>이러한 v2의 변화 이후엔, 더욱이 기존의 NextJS기반의 프론트엔드 작업, Jenkins 기반으로 먼저 올려두었던 프론트엔드 구축과 k8s 기반으로 동작한 백엔드 사의 문제점을 파악. 이를 고려한 통합 체계 구축이 필요했고, 특히나 최신 표전 Gateway API 사용이 필요하다는 점, 보안 운영 자동화 등을 고려하여 얻은 최종 결과 아키첵처가 v2.1 로 정리 되었다.  그리하여 간단하게 정리한, 그리고 각 구성은 다음과 같이 정리 된다.</p>

<hr />

<h4 id="v21-최종-아키텍처">v2.1 최종 아키텍처</h4>

<table>
  <thead>
    <tr>
      <th>저장소</th>
      <th>역할</th>
      <th>저장 데이터</th>
      <th>위치</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**PostgreSQL**</td>
      <td>서비스 저장용, JSONB 기능으로 MongoDB 역할 포함</td>
      <td> </td>
      <td>A5</td>
    </tr>
    <tr>
      <td>**PostgreSQL - pgvector**</td>
      <td>AI를 위한 RAG 용</td>
      <td> </td>
      <td>A5</td>
    </tr>
    <tr>
      <td>**MinIO**</td>
      <td>ObjectStorage(S3호환)</td>
      <td>원본 파일 저장용, HTML 백업 등</td>
      <td>Centre</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>개선 이유
    <ol>
      <li>현재의 온프레미스 상황에서 리소스의 분산은 효과적이지 못하고, 트래픽 대응에서 비효율적이다. (한 서버내에서 동작해야 하는 병목을 고려시)</li>
      <li>PostgreSQL 은 기본 VectorDB 기능을 포함하고 있기 때문에 RAG 데이터와 임베딩 벡터를 단일 트랜잭션으로 관리할 수 있게 되며, 이는 데이터 정합성, 일관성을 보장할 수 있게 만든다. 두개의 DB 를 별도 운영시 생기는 복잡한 동기화 문제를 원천적으로 제거하는 역할을 함.</li>
      <li>MinIO 는 RAG를 위한 원본데이터들의 보존, 외부 서비스(AWS 등)와 호환성 유지를 위한 도구로 사용함</li>
    </ol>
  </li>
  <li>ORM
    <ul>
      <li><strong>NestJS (Prisma):</strong> 익숙한 스택으로 <strong>개발 속도</strong> 확보</li>
      <li><strong>Spring (R2DBC):</strong> 새로운 논블로킹 스택 호환성을 위해,  <strong>기술 깊이</strong> 확보</li>
      <li><strong>FastAPI (SQLModel):</strong> 파이썬 네이티브 스택으로 <strong>AI/RAG 연동성</strong> 확보</li>
    </ul>
  </li>
  <li>MSA 서버 구성</li>
</ul>

<table>
  <thead>
    <tr>
      <th>서버명</th>
      <th>주요 역할</th>
      <th>내장 서비스</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**Auth 서버**</td>
      <td>인증/인가, JWT 토큰 관리</td>
      <td> </td>
    </tr>
    <tr>
      <td>**User 서버**</td>
      <td>사용자 프로필 및 권한 관리</td>
      <td>• 기본 유저 서비스<br />• 별지기 서비스<br />• 샛별 서비스</td>
    </tr>
    <tr>
      <td>**Chat 서버**</td>
      <td>대화 및 커리어 데이터 관리</td>
      <td>• Chat 서비스<br />• ActiveStatics 서비스<br />• Content 서비스</td>
    </tr>
    <tr>
      <td>**AI 서버**</td>
      <td>LLM 호출 및 RAG 처리, FastAPI 기반</td>
      <td>• RAG 서비스<br />• Crawling AI 서비스 (요약)</td>
    </tr>
    <tr>
      <td>**Noti 서버**</td>
      <td>알림 발송</td>
      <td>• Discord Webhook<br />• Email</td>
    </tr>
    <tr>
      <td>**Logging 서버**</td>
      <td>로그 수집 및 파일 저장</td>
      <td>• 내장 Message Queue<br />• 파일 관리</td>
    </tr>
    <tr>
      <td>**Schedule 서버**</td>
      <td>배치 작업 오케스트레이션</td>
      <td> </td>
    </tr>
    <tr>
      <td>**Psychological 서버**</td>
      <td>선행 서비스로, 심리 테스트 서비스 구현용</td>
      <td>- 답변 저장<br />- 답변 호출<br />- AI 서비스에 판단 요청</td>
    </tr>
    <tr>
      <td>**API Gateway**</td>
      <td>모든 통신의 출입구 역할. 가장 먼저 대응하는 서버</td>
      <td> </td>
    </tr>
    <tr>
      <td>**Redis 서버**</td>
      <td>캐싱 전략용</td>
      <td> </td>
    </tr>
    <tr>
      <td>**RabbitMQ**</td>
      <td>메시지 전략용 서비스</td>
      <td> </td>
    </tr>
    <tr>
      <td>**Loki**</td>
      <td>stdout 로그를 수신하고, Grafana 로 전달 역할</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h5 id="서버별-책임-및-설계-결정">서버별 책임 및 설계 결정</h5>

<ul>
  <li>API Gateway
    <ul>
      <li>==Spring Cloud Gateway==</li>
      <li>모든 API 를 마주하는 공간. 여길 통해 접근이 되며, 최초의 트래픽의 대응 역할을 수행하여서 내부 서비스들을 보호하고 동시에 조절 관리한다.</li>
      <li>특정 사용 제한 사항이 있다면, 이에 대한 조절, 통제 역할</li>
      <li>서비스를 위한 전역 관리 사항들에 대해 통제하고, 문제 발생시 조절하는 브레이커 역할기(서비스들 보호 및 로직 단순화를 위한 용도)</li>
      <li><strong>기술 스택: <code class="language-plaintext highlighter-rouge">Auth 서버</code>와 동일한 Spring WebFlux(논블로킹) 스택을 사용하여, v2 기술 목표(Spring 경험) 및 아키텍처 기술 일관성 확보.</strong></li>
      <li><strong>중앙 집중형 제어: 인증/인가, 사용량 제한(Rate Limiting), 서킷 브레이커(Circuit Breaker) 역할을 전담하여 백엔드 서비스들의 비즈니스 로직을 단순화.</strong></li>
      <li><strong>성능 및 안정성: 비동기 논블로킹 스택으로 대규모 동시 트래픽을 효율적으로 처리하고, 장애 격리를 통해 시스템 전체 안정성 보장.</strong></li>
    </ul>
  </li>
  <li>Auth 서버
    <ul>
      <li>==Spring WebFlux + R2DBC==</li>
      <li>JWT 발급/검증, 리프레시 토큰 관리</li>
      <li>다른 서비스와 분리하여 보안 계층 독립성 확보</li>
      <li><strong>기술 스택: v2 핵심 목표인 ‘Spring 비동기 논블로킹’ 스택 경험을 위해 선정.</strong></li>
      <li><strong>도메인 적합성: 인증/인가는 I/O(DB 조회)가 잦지만 로직이 비교적 고립되어 있어, WebFlux의 성능 이점 테스트 및 새 스택 적용에 가장 안정적인 도메인.</strong></li>
      <li><strong>R2DBC: WebFlux의 논블로킹 철학을 DB까지 일관되게 유지하기 위해, 블로킹(Blocking) 방식의 JPA 대신 반응형(Reactive) DB 접근 기술인 R2DBC 채택.</strong></li>
    </ul>
  </li>
  <li>User 서버
    <ul>
      <li><strong>통합 이유:</strong>
        <ul>
          <li>별지기/샛별은 역할(Role)이며 완전히 다른 도메인이 아님</li>
          <li>하나의 계정이 두 역할을 동시 보유 가능 (샛별 = 별지기 + 샛별 기능)</li>
          <li>초대 코드 기반 소규모 사용자로 병목 없음</li>
          <li>PostgreSQL 단일 트랜잭션으로 권한 변경 관리 단순화</li>
        </ul>
      </li>
      <li>
        <p><strong>권한 체계:</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  guest → 회원가입 → stargazer → 초대코드 입력 → protostar
  (질문 3회)         (질문 10회/일)              (모든 기능 사용)
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Chat 서버
    <ul>
      <li><strong>Content 서비스 통합 이유:</strong>
        <ul>
          <li>초기 단계에서는 Content가 Chat 도메인과 밀접 (대화를 위한 자료)</li>
          <li>장기적으로 비대해지면 독립 서버로 분리 가능하도록 모듈화</li>
        </ul>
      </li>
      <li><strong>책임:</strong>
        <ul>
          <li>대화 저장/조회</li>
          <li>질문 횟수 제한 체크</li>
          <li>피드백 관리</li>
          <li>통계 생성 (ActiveStatics)</li>
          <li>커리어 데이터 업로드/관리 (Content)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>AI 서버
    <ul>
      <li>==FastAPI 서버==
        <ul>
          <li>Python 생태계가 LLM 통합에 유리</li>
          <li>Gemini API 사용으로 로컬 추론 부하 없음 (512MB-1GB 수준)</li>
          <li>Claude API로 전환 가능하도록 추상화 계층 구현 예정</li>
        </ul>
      </li>
      <li><strong>RabbitMQ 적용 (RAG 파이프라인): <code class="language-plaintext highlighter-rouge">Chat 서버</code>의 파일 업로드(빠른 응답)와 <code class="language-plaintext highlighter-rouge">AI 서버</code>의 임베딩 처리(느린 작업)를 비동기 큐로 완벽하게 분리(Decoupling). NestJS(Publisher)와 FastAPI(Consumer) 이종 스택 간의 안정적인 교차 통신 구현.</strong></li>
    </ul>
  </li>
  <li>Noti 서버
    <ul>
      <li>==RabbitMQ== 적용으로 메시지를 구독하고, 각종 서비스에서 이벤트를 발행 이를 수신한다</li>
      <li>Dicord 알림이나, 이메일을 알림, 비밀번호 찾기 등의 보내기를 관리하는 서버</li>
      <li><strong>RabbitMQ 적용 (이벤트 기반 디커플링): 타 서비스(Chat, User)가 발행(Publish)한 이벤트를 구독(Subscribe)하여 처리. 알림 API(Discord/Email)의 지연/장애가 원본 서비스에 영향을 주지 않도록 완벽히 격리.</strong></li>
    </ul>
  </li>
  <li>Logging 서버
    <ul>
      <li>==RabbitMQ== 적용으로 메시지르 구독하고 수신한다.</li>
      <li>각 서버는 Logging 서비스에 로그 전송 후 무시 (fire-and-forget)</li>
      <li>
        <p>파일 저장이 핵심 역할 (장기 보관, 감사 로그)</p>
      </li>
      <li><strong>이중화 전략:</strong>
        <ul>
          <li><strong>Loki (실시간 디버깅용): 각 서버 <code class="language-plaintext highlighter-rouge">stdout</code> (표준 출력)을 Loki가 수집, Grafana에서 실시간 스트리밍 및 필터링. (영구 보관 목적 아님)</strong></li>
          <li><strong>RabbitMQ -&gt; Files (영구 감사용): 서비스가 직접 발행하는 비즈니스 중요 로그(감사, 중요 에러)를 MQ를 통해 유실 없이 수신, <code class="language-plaintext highlighter-rouge">Logging 서버</code>가 구독하여 파일로 영구 저장. (장기 보관 및 감사 추적 목적)</strong>
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  각 서버
├→ stdout (표준 출력) → Loki → Grafana (실시간 조회)
└→ RabbitMQ 로 전달 -&gt; Logging 서버 → Files (영구 보관)
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Schedule 서버
    <ul>
      <li><strong>오케스트레이터 역할 선택 이유:</strong>
        <ul>
          <li>배치 작업의 가시성과 제어권 중앙 집중화를 위한 전략</li>
          <li>“누가 언제 무엇을 실행하는가” 한눈에 파악 가능</li>
          <li>각 서버는 비즈니스 로직을 소유, 스케줄만 Schedule 서버가 트리거</li>
          <li>반복작업의 증대 및 복잡도 증가로 각 서버가 책임을 다해야할 시 해당 서버로 스케줄 이관 가능 (유연성 확보)</li>
          <li>단 필요한 기능이 있을 때만 쓸 것이므로 일단 기획만 해줄 것</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="프론트엔드">프론트엔드</h5>
<ul>
  <li>프론트엔드 구성은 3가지로 구성됨
    <ol>
      <li>기술블로그에 올라가는 정적인 챗봇 컴포넌트</li>
      <li>챗봇 컴포넌트에서 시작하여 SSR로 동작하는 챗봇 내부 UI 컴포넌트(SPA)</li>
      <li>챗봇 설정을 위한 대시보드</li>
    </ol>
  </li>
  <li>미니 프로젝트(테스트 프로젝트)
    <ul>
      <li>심리 테스트를 AI 로 돌리는 것을 수행할 예정</li>
      <li>간단한 UX 로 구현 + AI 이미지 에셋으로 완성시키기</li>
      <li>gpt-oss-120b 모델을 활용하여 API 사용 비용을 최소화 시킬 예정</li>
      <li>Big-Five 심리 테스트 방법론 + 판타지, SF 등을 활용해 재미있는 네러티브 테스트</li>
      <li>회원가입 기능(간단 이메일, 알림 전달 용, 유저의 기록 저장및 검색용)</li>
    </ul>
  </li>
</ul>

<h5 id="msa-아키텍쳐-및-통신-방법">MSA 아키텍쳐 및 통신 방법</h5>

<ul>
  <li>k8s 를 사용하고, 내부에 대한 DNS 처리가 용이한 만큼, 내부에서 동작하는 DNS url 기반으로 동작하게 만들 것이다. 단 이때, 비동기적으로 동작해야 하는 경우, 혹은 FAF(Fire and Forget) 방식으로 마이크로 서비스로 전달해도 되는 것에 대해서는 RabbitMQ를 기반으로 하는 메시지 방식을 접목한다.</li>
</ul>

<ol>
  <li>동기식 통신 (Synchronous): HTTP
    <ul>
      <li><strong>“질문/응답(Request/Response)”</strong> 방식의 통신으로, 요청자는 응답을 받을 때까지 기다린다. API Gateway, Auth 서버, User 서버 간의 정보 조회 등 즉각적인 응답이 필수적인 모든 곳에서 HTTP를 사용한다.</li>
    </ul>
    <ul>
      <li><strong>외부 진입 (External):</strong>
        <ul>
          <li>모든 외부 클라이언트 트래픽은 <strong><code class="language-plaintext highlighter-rouge">Host Nginx</code></strong>를 통해 <strong><code class="language-plaintext highlighter-rouge">API Gateway</code></strong>로 진입한다.</li>
          <li><code class="language-plaintext highlighter-rouge">API Gateway</code>는 인증/인가(<code class="language-plaintext highlighter-rouge">Auth 서버</code> 호출), 사용량 제한 등 공통 정책을 중앙에서 처리한다.</li>
        </ul>
      </li>
      <li><strong>내부 통신 (Internal):</strong>
        <ul>
          <li><strong>“정책 A: 내부 간 직접 호출 허용”</strong>을 채택한다.</li>
          <li>서비스 간(예: <code class="language-plaintext highlighter-rouge">User 서버</code> -&gt; <code class="language-plaintext highlighter-rouge">Chat 서버</code>)의 동기 호출은 <code class="language-plaintext highlighter-rouge">API Gateway</code>를 거치지 않고, <strong>k8s 내부 네트워크(Service Discovery, 예: <code class="language-plaintext highlighter-rouge">http://chat-service</code>)</strong>를 통해 직접 통신한다.</li>
          <li><strong>근거:</strong> 게이트웨이를 우회하여 내부 통신 성능(Low Latency)을 극대화하고, <code class="language-plaintext highlighter-rouge">API Gateway</code>의 부하를 줄인다.</li>
          <li><strong>v2 경험:</strong> 이 정책은 <code class="language-plaintext highlighter-rouge">User 서버</code>와 같은 호출자(Caller)가 <code class="language-plaintext highlighter-rouge">Chat 서버</code>의 장애에 대비한 <strong>서킷 브레이커(Circuit Breaker)</strong> 및 <strong>재시도(Retry)</strong> 로직을 직접 구현해야 함을 의미하며, 이는 v2의 핵심 경험 목표와 일치한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<hr />

<ol>
  <li>비동기식 통신 (Asynchronous): RabbitMQ
    <ul>
      <li><strong>“발행/구독(Publish/Subscribe)”</strong> 방식의 통신으로, 요청자는 작업을 “명령”하고 즉시 응답을 받는다(Fire-and-Forget). 서비스 간의 결합도를 완벽히 분리(Decoupling)하고 장애가 전파되는 것을 막기 위해 사용한다.</li>
    </ul>
    <ul>
      <li><strong>RAG 처리 파이프라인 (교차 스택 통신):</strong>
        <ul>
          <li><strong>흐름:</strong> <code class="language-plaintext highlighter-rouge">Chat 서버</code> (NestJS) -&gt; <strong>RabbitMQ</strong> -&gt; <code class="language-plaintext highlighter-rouge">AI 서버</code> (FastAPI)</li>
          <li><strong>목적:</strong> 사용자의 빠른 파일 업로드(HTTP 응답)와 시간이 오래 걸리는 AI 임베딩 처리(MQ 작업)를 완벽하게 분리한다.</li>
        </ul>
      </li>
      <li><strong>비동기 알림:</strong>
        <ul>
          <li><strong>흐름:</strong> <code class="language-plaintext highlighter-rouge">Chat 서버</code> / <code class="language-plaintext highlighter-rouge">User 서버</code> -&gt; <strong>RabbitMQ</strong> -&gt; <code class="language-plaintext highlighter-rouge">Noti 서버</code></li>
          <li><strong>목적:</strong> Discord/Email 등 외부 API의 지연이나 장애가 <code class="language-plaintext highlighter-rouge">Chat 서버</code>와 같은 핵심 서비스에 영향을 주지 않도록 격리한다.</li>
        </ul>
      </li>
      <li><strong>영구/감사 로그 수집:</strong>
        <ul>
          <li><strong>흐름:</strong> 모든 서비스 -&gt; <strong>RabbitMQ</strong> -&gt; <code class="language-plaintext highlighter-rouge">Logging 서버</code></li>
          <li><strong>목적:</strong> 실시간 디버깅용 <code class="language-plaintext highlighter-rouge">stdout</code> (Loki)과는 별개로, 비즈니스 중요 로그(감사, 중요 에러)를 유실 없이 <code class="language-plaintext highlighter-rouge">Logging 서버</code>에 안정적으로 전달하여 영구 보관(Files)한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>k8s 관리 확정사항
    <ol>
      <li>Kubernetes 배포판: MicroK8s
        <ul>
          <li>A5(Main) 및 Centre(Sub) 서버의 Ubuntu 환경에 k8s 클러스터를 구축하기 위한 배포판으로 <strong>MicroK8s</strong>를 채택한다.</li>
          <li><strong>선택 근거:</strong>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">microk8s enable &lt;addon&gt;</code> 명령어를 통해 Ingress, DNS, Prometheus 등 필수 애드온을 손쉽게 활성화할 수 있다.</li>
              <li>k3s와 달리 etcd 등 표준 Kubernetes 컴포넌트를 거의 그대로 사용하여, 향후 EKS, GKE 등 매니지드 서비스로의 이전에 필요한 경험적 일관성을 확보하는 데 유리하다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>게이트웨이 전략: 이중(Dual) 게이트웨이
        <ul>
          <li>인프라 레벨과 애플리케이션 레벨의 게이트웨이를 명확히 분리하여, 각자의 역할에 집중하는 현대적 아키텍처를 구성한다.</li>
          <li><strong>(1) 인프라 게이트웨이 (건물의 “정문”): <code class="language-plaintext highlighter-rouge">K8s Gateway API</code></strong>
      - <code class="language-plaintext highlighter-rouge">ingress-nginx</code>의 지원 종료(2026년 예정)에 대응하여, 차세대 표준인 <strong><code class="language-plaintext highlighter-rouge">Gateway API</code></strong>를 도입한다. Nginx Gateway Fabric(NGF) 등 <code class="language-plaintext highlighter-rouge">Gateway API</code> 표준 구현체를 사용한다.
      - <strong>역할:</strong> SSL/TLS 인증서 처리, 도메인/경로 기반 라우팅(예: <code class="language-plaintext highlighter-rouge">api.my-domain.com</code> -&gt; <code class="language-plaintext highlighter-rouge">Spring Cloud Gateway</code>) 등 클러스터의 “북-남(North-South)” 트래픽을 담당한다.</li>
          <li><strong>(2) 애플리케이션 게이트웨이 (건물의 “안내 데스크”): <code class="language-plaintext highlighter-rouge">Spring Cloud Gateway</code></strong>
      - V2 기획안의 <code class="language-plaintext highlighter-rouge">API Gateway</code> 서버 역할을 그대로 수행한다.
      - <strong>역할:</strong> “정문”을 통과한 트래픽에 대해 JWT 인증/인가, 서비스별 사용량 제한(Rate Limiting), 서킷 브레이커, 비즈니스 로직 기반의 정교한 라우팅을 처리한다.</li>
        </ul>
      </li>
      <li>리포지토리 전략: GitOps를 위한 분리 모델
        <ul>
          <li>CI(Jenkins)와 CD(ArgoCD)의 역할을 명확히 분리하기 위해 리포지토리 유형을 3가지로 표준화한다.</li>
          <li><strong>(1) 템플릿 리포지토리 (<code class="language-plaintext highlighter-rouge">project-protostar-back</code>)</strong>
            <ul>
              <li>신규 마이크로서비스 생성 시 사용할 “설계 원본” 리포지토리이다.</li>
              <li>Spring, NestJS, FastAPI 등 스택별로 최적화된 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 템플릿과 공통 <code class="language-plaintext highlighter-rouge">.gitignore</code>, <code class="language-plaintext highlighter-rouge">.prettierrc</code> 설정 등을 보관한다.</li>
              <li>이 리포는 CI/CD가 감시하지 않으며, 오직 개발자가 새 서비스 레포 생성 시에만 참조한다.</li>
            </ul>
          </li>
          <li><strong>(2) 애플리케이션 소스 리포지토리 (App Repos)</strong>
            <ul>
              <li><strong>명명 규칙:</strong> <code class="language-plaintext highlighter-rouge">project-protostar-{service-name}</code> (예: <code class="language-plaintext highlighter-rouge">project-protostar-auth-service</code>)</li>
              <li><strong>관리 방식:</strong> <strong>Polyrepo</strong>. 서비스별로 독립된 소스 코드 리포지토리를 가진다.</li>
              <li><strong>담당:</strong> <strong>Jenkins(CI)</strong>가 이 레포들을 감시한다.</li>
              <li><strong>구성:</strong> 실제 애플리케이션 소스 코드와, (1)번 템플릿에서 복사해 온 <strong>자신만의 <code class="language-plaintext highlighter-rouge">Dockerfile</code></strong>을 포함한다.</li>
            </ul>
          </li>
          <li><strong>(3) K8s 설정 리포지토리 (Config Repo)</strong>
            <ul>
              <li><strong>명명 규칙:</strong> <code class="language-plaintext highlighter-rouge">project-protostar-k8s-config</code></li>
              <li><strong>관리 방식:</strong> <strong>Monorepo</strong>. k8s 클러스터의 모든 상태를 정의하는 단일 리포지토리이다.</li>
              <li><strong>담당:</strong> <strong>ArgoCD(CD)</strong>가 오직 이 리포지토리만 감시한다.</li>
              <li><strong>구성:</strong>
                <ul>
                  <li>모든 App Repo 서비스의 <code class="language-plaintext highlighter-rouge">Deployment</code>, <code class="language-plaintext highlighter-rouge">Service</code>, <code class="language-plaintext highlighter-rouge">HTTPRoute</code> YAML.</li>
                  <li>k8s 클러스터 내부에 배포될 인프라(PostgreSQL, RabbitMQ, Redis)의 YAML .</li>
                </ul>
              </li>
              <li><strong>제외:</strong> Centre 서버에서 별도 운영되는 <code class="language-plaintext highlighter-rouge">MinIO</code> 관련 설정은 이 리포지토리에서 제외한다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>CI/CD 자동화 워크플로우
        <ul>
          <li><strong>(1) CI (Jenkins):</strong> <code class="language-plaintext highlighter-rouge">App Repo</code>의 코드 변경을 감지 -&gt; <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 이용해 빌드 및 컨테이너 이미지 푸시 -&gt; <code class="language-plaintext highlighter-rouge">Config Repo</code>를 <code class="language-plaintext highlighter-rouge">clone</code>하여 해당 서비스의 <code class="language-plaintext highlighter-rouge">Deployment.yaml</code> 내 이미지 태그를 새 버전으로 수정한 뒤 <code class="language-plaintext highlighter-rouge">commit</code> &amp; <code class="language-plaintext highlighter-rouge">push</code>한다.</li>
          <li><strong>(2) CD (ArgoCD):</strong> <code class="language-plaintext highlighter-rouge">Config Repo</code>의 변경 사항(Jenkins가 푸시한 커밋)을 감지(<code class="language-plaintext highlighter-rouge">OutOfSync</code>) -&gt; k8s 클러스터로 변경 사항을 <code class="language-plaintext highlighter-rouge">pull</code>하여 배포(Sync)를 자동 수행한다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="혼자서-그리고-왜">혼자서, 그리고 왜?</h3>

<p><img src="/assets/images/posts/2025-11/20251124-040.png" alt="" /></p>
<blockquote>
  <p>2023년 300명 규모의 개발자 커뮤니티 행사 WASSSUP 당시, 실무진으로…</p>
</blockquote>

<p><img src="/assets/images/posts/2025-11/20251124-039.png" alt="" /></p>
<blockquote>
  <p>Peer 개발 총괄로 MT</p>
</blockquote>

<p><img src="/assets/images/posts/2025-11/20251124-041.png" alt="" /></p>
<blockquote>
  <p>Peer 개발 프로젝트가 처음인 신입들을 위한 Final Mission 행사</p>
</blockquote>

<p><img src="/assets/images/posts/2025-11/20251124-042.png" alt="" /></p>
<blockquote>
  <p>gemgem theraputics 팀 , 사업 확장 차 뉴욕 방문 당시</p>
</blockquote>

<p>3년 간 개발자로 살면서 정말 많은 일들이 있었다. 42서울에서는 동료 학습을 배웠고, 정신이 없었다. 
그러는 와중에도 Peer라는 귀한 이들을 만나, 개발자 다운 성장, 프로젝트의 어려움을 해결해보려고 노력했다. 그 과정에서 행사도 만들어보고, 개발도 해보고, 기획과 리딩도 해보면서 정말 많은 일들을 했고, 그 마지막에 1년이란 시간을 gemgem theraputics 에서 성장할 수 있는 기회를 얻었다.</p>

<p>다소 아쉬움도 있었다. 몸 건강을 잘 유지하지 못하고 고무줄 처럼 늘어난 몸무게(…)는 쉽지 않았고, 현재는 약 20kg 정도 감량하고, 더 감량하면서 이 프로젝트를 하고 있다.</p>

<p>누군가는 이렇게 이야기 했다. 돈 벌고, 모은 돈 써가며 왜 시간을 쓰냐. 그냥 이직해도 되지 않냐? 더 공부할 필요 뭐 있냐. 하면서 배우면 되지.</p>

<p>음, 틀린 말은 아니라고 생각한다. 
하지만 나의 인생, 많은 실패 속에서 얻어온 것들을 기반으로 얻은 내 생각은 조금, 다소 다르다.</p>

<p>돈도 중요하고, 경험도 중요하다. 무엇보다 중요한건 시대가 뭘 필요시 하냐? 에 대해 제대로 물을 줄 아는 태도와 제대로 답할 줄 아는 태도가 아닐까 싶다. AI가 등장하고 정말 편리한 개발이 되게 되었고, 개발 뿐 아니라 모든 영역이 그렇게가 가능해졌다. 하지만 그 결과 우리는 이제 엄청난 기술격차와 싸우게 되었고, 또 반대 급부로 어지간한 일은 다 할 수 있게 되었다.</p>

<p>문제는 도구를 어떻게 쓰냐, 어떤 철학, 방법론을 알고 있냐에 따라 AI 를 부리는 사람으로 평가 받을 수도 있고, 반대로 AI에게 부림 받는 경우를 맞이할 지도 모르겠다.</p>

<p>그러다보니 몸이 아프고, 쉼이 필요한 시점이자 동시에 이 프로젝트를 고안하고, 스스로의 힘으로 해결해보려고 하는 것은. 어쩌면 지금 나의 시대를 주체적으로 준비하고, 제대로 돈도 벌고, 제대로 기회도 얻고, 제대로 전문가의 그 길 위에 서기 위한 준비의 기간이라고, 자기 투자의 기간이라고 나는 생각한다.</p>

<p>그러니 1년 차지만, 3년차를 목표로 생각하며, 3년차는 경험하지 못할 AI의 가속도를 경험하고 싶다. 그것이 어쩌면 솔직한 내 상황이리라 싶다.</p>

<h3 id="결론-지평선-넘어를-보기-위해">결론, 지평선 넘어를 보기 위해</h3>

<p>기술적 복잡도, 기술적 구현해야할 양 많은 것이 사실이다. 
몰입해야 하고, 시간을 미친듯이 쏟아 넣고 있다. Obsidian에 온갖 AI 기반 프롬프트로 문제를 해결해나가고, n8n 기반으로 자동화된 소식통을 통해 현재의 ai 트랜드, 기술의 발전 경향을 탐독하고 있다.</p>

<p>Protostar는 만나는 구조적 문제들에 밤을 새어가면서 만들고 있는데, 덕분에 건강 챙기기는 약간 딜레이(?) 가 생여 신경 써야할 것 같다.</p>

<p>하지만 언덕 넘어를 보고 싶다는 마음 하나는 명확하다. Project Protostar는 이를 위한 한계를 뛰어넘는 발판이 되도록 만들고 싶으며, 만들고난 뒤엔 클로즈 테스트, 만약 잘되면 지속적인 서비스로 조그맣게 운영해볼 마음도 있다.</p>

<p>달리자.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="Backend" /><category term="AI" /><category term="프로젝트" /><category term="DevOps" /><summary type="html"><![CDATA[Project Protostar 를 소개합니다]]></summary></entry><entry><title type="html">n8n 개념 정리하기</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/01-introduction-n8n.html" rel="alternate" type="text/html" title="n8n 개념 정리하기" /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/01-introduction-n8n</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/01-introduction-n8n.html"><![CDATA[<h2 id="n8n-자동화-도구-소개">n8n 자동화 도구 소개</h2>

<p>이 글은 n8n이라는 자동화 도구에 대한 기본적인 개념을 정리한 내용이다. ‘심심풀이’ 프로젝트를 진행하며 n8n을 처음 접하는 개발자들에게 이 도구가 무엇이며, 어떤 핵심 개념을 가지고 있는지 명확히 전달하는 것이 목적이다.</p>

<p>n8n(Nodemation)은 워크플로우 자동화 도구로, Zapier나 Make와 유사한 기능을 제공하지만 몇 가지 차별점을 가진다. 가장 주목할 만한 특징은 <strong>셀프 호스팅(Self-hosting)</strong>이 가능하다는 점이다. 이는 Docker 등을 활용하여 직접 서버에 설치함으로써 비용을 절감하고 데이터 통제권을 확보할 수 있다는 점에서, 특히 개인 프로젝트나 민감한 데이터를 다루는 환경에서 큰 이점을 제공한다.</p>

<p>n8n의 핵심적인 작동 방식은 <strong>노드 기반 시각화(Node-based visualization)</strong>에 있다. 모든 자동화 과정은 ‘노드(Node)’라는 블록으로 표현되며, 이 노드들을 시각적으로 연결하여 전체 자동화 흐름, 즉 <strong>워크플로우(Workflow)</strong>를 구성한다. 워크플로우는 자동화 작업의 전체 단위이며, PRD에서 정의한 콘텐츠 수집부터 기록까지의 선형적인 과정을 하나의 워크플로우로 구현할 수 있다.</p>

<p>n8n은 <strong>개발자 친화적(Developer-friendly)</strong>이라는 점도 강점이다. 기본 제공되는 다양한 노드만으로도 복잡한 자동화를 구현할 수 있지만, 필요에 따라 <code class="language-plaintext highlighter-rouge">Code</code> 노드를 통해 Node.js 기반의 JavaScript로 직접 로직을 작성하거나 외부 라이브러리를 연동하는 것이 가능하다. 이는 기존 도구에서 제공하지 않는 특정 기능을 구현해야 할 때 유용하다.</p>

<p>n8n을 이해하기 위한 네 가지 핵심 구성 요소는 다음과 같다.</p>

<h3 id="1-워크플로우-workflow">1. 워크플로우 (Workflow)</h3>
<p>자동화 작업의 전체적인 단위이자, 노드들이 배치되는 ‘캔버스’ 역할을 한다.</p>

<h3 id="2-노드-node">2. 노드 (Node)</h3>
<p>워크플로우를 구성하는 최소 작업 단위이다.</p>
<ul>
  <li><strong>트리거 노드 (Trigger Nodes):</strong> 워크플로우를 시작시키는 역할을 한다. <code class="language-plaintext highlighter-rouge">Schedule</code> (예약 실행), <code class="language-plaintext highlighter-rouge">Webhook</code> (외부 시스템 호출), <code class="language-plaintext highlighter-rouge">Manual</code> (수동 실행) 등이 대표적이다.</li>
  <li><strong>일반 노드 (Regular Nodes):</strong> 실제 작업을 수행하는 노드들이다. 데이터를 가져오거나, 가공하거나, 전송하는 등의 역할을 담당하며, <code class="language-plaintext highlighter-rouge">HTTP Request</code>, <code class="language-plaintext highlighter-rouge">Google AI</code>, <code class="language-plaintext highlighter-rouge">Discord</code>, <code class="language-plaintext highlighter-rouge">Git</code>, <code class="language-plaintext highlighter-rouge">Code</code> 등이 이에 해당한다.</li>
</ul>

<h3 id="3-데이터-흐름-data-flow--json">3. 데이터 흐름 (Data Flow &amp; JSON)</h3>
<p>n8n의 가장 핵심적인 개념으로, 모든 데이터는 노드 간에 <strong>JSON 배열(Array of JSON objects)</strong> 형태로 전달된다. 앞선 노드의 출력이 다음 노드의 입력이 되는 방식으로, 데이터 구조는 보통 <code class="language-plaintext highlighter-rouge">[ { "data": "value" } ]</code> 형태를 가진다.</p>

<h3 id="4-표현식-expressions">4. 표현식 (Expressions)</h3>
<p>이전 노드의 데이터를 현재 노드에서 참조하는 방식이다. n8n은 `` 형태의 표현식을 사용하며, <code class="language-plaintext highlighter-rouge">$node["Node Name"].json.data</code> 와 같이 특정 노드의 출력 데이터를 참조하는 것이 일반적이다.</p>

<h3 id="5-자격-증명-credentials">5. 자격 증명 (Credentials)</h3>
<p>Google AI API 키, GitHub PAT, Discord Webhook URL 등 민감한 정보를 n8n에 안전하게 저장하고 관리하는 기능이다. 노드 설정 시 실제 키 값 대신 등록된 자격 증명을 선택하여 보안을 유지한다.</p>

<p>이러한 n8n의 특징과 구성 요소를 이해하는 것은 자동화 프로젝트를 성공적으로 수행하는 데 필수적이다.</p>

<h2 id="왜-쓰는가">왜 쓰는가?</h2>
<p>이제 AI 를 Agent 처럼 구축할 필요가 있다..!
그런데 프레임워크 기반의 서버로 구축하긴 너무 오래 걸리는데, 이때 n8n 은 아주 완벽한 PoC 용 툴이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="Automation" /><category term="AI" /><category term="Google" /><category term="n8n" /><summary type="html"><![CDATA[n8n 자동화 도구 소개]]></summary></entry><entry><title type="html">TIL - n8n 으로 뉴스 피드 자동화 해서 Discord 레터 받아보기(feat AI)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/02-til-n8n.html" rel="alternate" type="text/html" title="TIL - n8n 으로 뉴스 피드 자동화 해서 Discord 레터 받아보기(feat AI)" /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/02-til-n8n</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/02-til-n8n.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>주말엔 본 목적을 위한 작업을 하는것은 너무 머리 아픈 일이다. 가뜩이나 DevOps 는 하나 하나 하다보면서 알게되는게 너무 많았다. 그래서 평상시에도 꼭 배우리라 생각했던 n8n 기반의 자동화, 비로소 작업해보았다…!</p>

<h2 id="0단계---connection-lost--응-1">0단계 - connection lost … 응? (1)</h2>

<p>n8n 을 다른 서버에서 사용하는 것도 가능은 하다. 하지만 이왕 하는거 셀프 호스팅을 도전해보았다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-013.png" alt="" /></p>
<blockquote>
  <p>Node 를 Create 했는데 우상단에 <code class="language-plaintext highlighter-rouge">Connection lost</code> 가 보임</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blocked GET /assets/npsSurvey.store-B7_iNEDS.js <span class="k">for</span> <span class="s2">"Mozilla/5.0 (compatible; archive.org_bot; Wayback Machine Live Record; +http://archive.org/details/archive.org_bot)"</span>

Pruning old insights data

Pruning old insights data

Pruning old insights data

ValidationError: The <span class="s1">'X-Forwarded-For'</span> header is <span class="nb">set </span>but the Express <span class="s1">'trust proxy'</span> setting is <span class="nb">false</span> <span class="o">(</span>default<span class="o">)</span><span class="nb">.</span> This could indicate a misconfiguration which would prevent express-rate-limit from accurately identifying users. See https://express-rate-limit.github.io/ERR_ERL_UNEXPECTED_X_FORWARDED_FOR/ <span class="k">for </span>more information.

    at Object.xForwardedForHeader <span class="o">(</span>/usr/local/lib/node_modules/n8n/node_modules/.pnpm/express-rate-limit@7.5.0_express@5.1.0/node_modules/express-rate-limit/dist/index.cjs:187:13<span class="o">)</span>

    at Object.wrappedValidations.&lt;computed&gt; <span class="o">[</span>as xForwardedForHeader] <span class="o">(</span>/usr/local/lib/node_modules/n8n/node_modules/.pnpm/express-rate-limit@7.5.0_express@5.1.0/node_modules/express-rate-limit/dist/index.cjs:398:22<span class="o">)</span>

    at Object.keyGenerator <span class="o">(</span>/usr/local/lib/node_modules/n8n/node_modules/.pnpm/express-rate-limit@7.5.0_express@5.1.0/node_modules/express-rate-limit/dist/index.cjs:671:20<span class="o">)</span>

    at /usr/local/lib/node_modules/n8n/node_modules/.pnpm/express-rate-limit@7.5.0_express@5.1.0/node_modules/express-rate-limit/dist/index.cjs:724:32

    at /usr/local/lib/node_modules/n8n/node_modules/.pnpm/express-rate-limit@7.5.0_express@5.1.0/node_modules/express-rate-limit/dist/index.cjs:704:5 <span class="o">{</span>

  code: <span class="s1">'ERR_ERL_UNEXPECTED_X_FORWARDED_FOR'</span>,

  <span class="nb">help</span>: <span class="s1">'https://express-rate-limit.github.io/ERR_ERL_UNEXPECTED_X_FORWARDED_FOR/'</span>

<span class="o">}</span>

<span class="o">[</span>license SDK] license renewal failed: Connection Error: Unexpected token <span class="s1">'B'</span>, <span class="s2">"Bad Gateway"</span> is not valid JSON

Failed to renew license: Connection Error: Unexpected token <span class="s1">'B'</span>, <span class="s2">"Bad Gateway"</span> is not valid JSON

<span class="o">[</span>license SDK] license successfully renewed
</code></pre></div></div>
<blockquote>
  <p>AI 의 친절한 조언에 따라 docker logs 를 확인하니, 문제가 뭔지 바로 파악 가능했다.</p>
</blockquote>

<p>핵심은 n8n 이 리버스 프록시 뒤에서 실행 중인데, 보안의 문제로 이에 대한 신뢰 설정이 필요하단 점이었다.</p>

<p>해결 방법은 가능하다. 환경 변수에 <code class="language-plaintext highlighter-rouge">N8N_TRUST_PROXY=1</code>를 추가하면 된다. 컨테이너 화든 셀프 호스팅이든 자신의 환경에 맞춰 추가하면 된다. 본인은 Docker container 기반으로 해두었기에 yml 파일에 env 변수를 추가해주었다.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="c1"># - N8N_SECURE_COOKIE=false # 1. HTTPS가 아니어도 쿠키 사용 허용 # 프록시 있으니 해제</span>
      <span class="pi">-</span> <span class="s">WEBHOOK_URL=https://n8n.paulryu93.ddns.net</span> <span class="c1"># 2. n8n의 공개 주소 설정</span>
      <span class="pi">-</span> <span class="s">N8N_TRUST_PROXY=1</span> <span class="c1"># 리버스 프록시 신뢰 설정 </span>
      <span class="pi">-</span> <span class="s">TZ=Asia/Seoul</span> <span class="c1"># 시간 설정 </span>
      <span class="pi">-</span> <span class="s">NODE_FUNCTION_ALLOW_EXTERNAL=cheerio,axios</span> <span class="c1"># 외부 모듈 설치 요청</span>
      <span class="pi">-</span> <span class="s">EXECUTIONS_DATA_PRUNE=true</span> <span class="c1"># 로깅 데이터 저장 및 자동 삭제 활성화</span>
      <span class="pi">-</span> <span class="s">EXECUTIONS_DATA_MAX_AGE=168</span> <span class="c1"># 로깅 데이터 저장 기간 7일로 지정</span>
</code></pre></div></div>

<p>이제 재시작하면 된다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span> <span class="nt">--force-recreate</span>
</code></pre></div></div>

<h2 id="0단계---또-다른-connection-lost-2">0단계 - 또 다른 connection lost (2)</h2>
<p>분명히 가이드 문서를 찾아봐도 이걸로 해결 되는 거였다. 근데 안됨. 뭐지? 하고 찾아보니 ‘n8n 에디터’는 웹소켓으로 실시간 통신을 한다고 되어 있고, 해당 기능이 설정되어야 한다고 했다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-014.png" alt="" /></p>
<blockquote>
  <p>Websockets Support 옵션을 켜면</p>
</blockquote>

<p><img src="/assets/images/posts/2025-11/20251111-015.png" alt="" /></p>
<blockquote>
  <p>짠, 해결 완료 되었다.</p>
</blockquote>

<p>결국 n8n의 환경 변수 설정 + Socket 통신 허용을 해줘야만 n8n 에디터를 제대로 셀프 호스팅이 가능하다.</p>

<h2 id="새로운-문제">새로운 문제…</h2>

<p>알고 보니 Connection Lost 에러와</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  code: <span class="s1">'ERR_ERL_UNEXPECTED_X_FORWARDED_FOR'</span>,

  <span class="nb">help</span>: <span class="s1">'https://express-rate-limit.github.io/ERR_ERL_UNEXPECTED_X_FORWARDED_FOR/'</span>
</code></pre></div></div>
<p>이 에러는 실질 다른 문제가 있었다. 
이는 현재 메인 서비스를 위한 HTTPS 할당과 별도로 TLS L4 레이어 기반으로 우회를 하여 공인 IP 를 지나, 서브 서버의 443 포트로 전송 되는 문제로 발생한 이슈였다.</p>

<p>이 에러가 문제시 되는 이유는, 현재 설정이 꼬여 IP 가 하나로 들어오는 것처럼 처리 된다는 점이다.</p>

<p>문제의 핵심은 정리해보니… stream 블록으로 우회하는 데, 이 우회 프로토콜을 NPM Plus 는 제대로 아직 인식이 안된다.</p>

<p>즉, Sub-Server 에 Nginx 를 추가하고 HTTPS 를 다시 인증 받아야한다는점이다(…)</p>
<h2 id="1단계---n8n-워크플로우-생성-및-rss-데이터-가져오기">1단계 - n8n 워크플로우 생성 및 RSS 데이터 가져오기</h2>
<p><img src="/assets/images/posts/2025-11/20251111-016.png" alt="" /></p>
<ul>
  <li>n8n 은 대단히 직관적이었다. 기본적으로 자동화 툴이다보니 기본적으로 <code class="language-plaintext highlighter-rouge">create Workflow</code>를 통해 사용이 가능했고, 만들어진 창의 모습도 직관적이었다.</li>
</ul>

<h2 id="2단계---trigger-설정하기">2단계 - trigger 설정하기</h2>
<p><img src="/assets/images/posts/2025-11/20251111-017.png" alt="" /></p>
<ul>
  <li>설명이랄 것도 없이, 바로 시작하면 각 단위는 ‘노드’ 라고 하는데 최초의 자동화 동작을 뭘로 할 지를 정할 수 있다.</li>
  <li>수동 혹은 app 이벤트, 스케쥴 등 생각할만한 다양한 방법은 존재하며, 심지어 file changes 까지 있는거 보면, 이건 필요한 자동화 마다 골라서 설정하면 된다.</li>
</ul>

<h2 id="3단계---노드-설정">3단계 - 노드 설정</h2>
<p><img src="/assets/images/posts/2025-11/20251111-018.png" alt="" /></p>
<ul>
  <li>이 다음 부터는 사실상 러닝커브다. 각 노드들은 기능들이 있고, 기능들은 수십가지가 있으며, AI 관련해서도 대응이 되어 있다.필요한건 핵심 로직을 어떻게 짤지 해놓고 거기에 필요한 적절한 설정에 따라 데이터를 가공하고, 합치고, 어레이로 정리하거나 하면 된다.</li>
  <li>단 여기서 주의 해야 할 것은 통신 과정에서 json 기반으로 동작하고, Code 노드의 경우 js나 Python 으로 직접 변수 형태로 접근하여 사용이 가능하다. 여기 부분에 바이브 코딩을 같이 얹어주면 직접인 데이터 가공, 저장, 그리고 검색 등을 포함한 serverless 서버까지도 넘겨 볼 수 도있다. (물론 난이도가 올라가지만, 코드를 짜는거에 비하면 양반이긴 하니까…)</li>
</ul>

<h2 id="4단계---ai-활용하기">4단계 - AI 활용하기</h2>
<p><img src="/assets/images/posts/2025-11/20251111-019.png" alt="" /></p>
<ul>
  <li>n8n 을 써봐야 하고 써보면서 알아두려고 했던 영역이 바로 이것. 바로 AI 기능이 내부에 내장되어 있다는 것이다. 원래 API 등에 따라 웹훅, 혹은 다양한 트리깅으로 자동화 자체에만 집중했다면 n8n 은 AI 기능들을 추가함으로써 AI 빌더가 되었다고 보여진다.</li>
  <li>기본적으로 자체적으로 제공해주는 기능도 있기에 <code class="language-plaintext highlighter-rouge">credentials</code>만 설정하면 손쉽게 사용이 가능하다.</li>
  <li>특히 주의 깊게 본 것은 기본 노드 뿐만 아니라 ‘AI Agent’ 노드 였다.  mcp, 메모리용 DB 등 연결이 가능하고, 직접적으로 조절이 되면서 모델을 마음데로 바꿀 수 있었다. 또한 그 외에도 AI 를 위한 파서나, Text classifier, chain 등 배워두면 도움이 아주 될 것이란 생각이 들었다. (그만한 시간을 들여야 겠지만)</li>
</ul>

<hr />

<h2 id="결론">결론</h2>

<p><img src="/assets/images/posts/2025-11/20251111-020.png" alt="" /></p>

<p><img src="/assets/images/posts/2025-11/20251111-021.png" alt="" /></p>

<ul>
  <li>
    <p>현재는 나에게 도움이되는 기사들, DevOps, AI, Backend 관련된 영역에 대한 기사들의 스크래핑 자동화를 만들었고, 여러 조건을 고려한 결과, 일단 현재 가장 최선으로 md 파일 형식으로 정리해주는 것으로 끝을 내었다.</p>
  </li>
  <li>
    <p>n8n 으로 만들어보다 보니 확실히 아이디어가 샘솟는다. 더욱이 Agent 노드는 생각이상으로 구성이 충실하다. 전에 대충 알아본 것에 비하면 확실히 왜 n8n 을 자동화 도구로 쓰는지, 그걸로 뭘 하고 싶어하는지, 실제 수입화의 주요 도구로 쓰는 사람들의 이유는 확실히 있어 보인다. 특히 Obsidian 이나 지식 저장, 블로그 자동화 등 AI 까지 합쳐진 상태에서 얻을 수 있는 건 확실히 많아 보여 앞으로 지속적으로 써보려고 한다.## 요약 내용</p>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="DevOps" /><category term="Docker" /><category term="n8n" /><category term="Automation" /><category term="AI" /><summary type="html"><![CDATA[Introduction 주말엔 본 목적을 위한 작업을 하는것은 너무 머리 아픈 일이다. 가뜩이나 DevOps 는 하나 하나 하다보면서 알게되는게 너무 많았다. 그래서 평상시에도 꼭 배우리라 생각했던 n8n 기반의 자동화, 비로소 작업해보았다…!]]></summary></entry><entry><title type="html">TIL - Opal 로 실전 AI 응용 앱을 만들어보자 - 직무 역량 평가 앱</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/03-til-opal.html" rel="alternate" type="text/html" title="TIL - Opal 로 실전 AI 응용 앱을 만들어보자 - 직무 역량 평가 앱" /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/03-til-opal</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/03-til-opal.html"><![CDATA[<p><img src="/assets/images/posts/2025-11/20251111-022.png" alt="" /></p>

<h2 id="introduce">Introduce</h2>

<p>이 <a href="https://paul2021-r.github.io/tools/2025/10/09/02-Opal-instroduction.html">글</a>을 작성하면서 Opal 이란 도구의 베타버전을 간단하게 써보았다. 하지만 주말, 토이 프로젝트 느낌으로 진행해보면 좋겠다! 싶어서 n8n 을 만지작 거리다가 AI 특화로 있던 도구, Opal 이 생각이 나서 이번엔 제대로 써보게 되었다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-023.png" alt="" /></p>

<h3 id="기본-개념은">기본 개념은…</h3>

<p>사실 이걸 앱을 만드는 개발 도구라고 보기엔 대단히 아쉬운 점이 많다. 기본적으로 로우코드, 노코드 툴, AI 애플리케이션 빌더- 라고 거창하게 말할 수 있겠지만… share 만 가능하고, 에디터에서 테스트가 되긴 하지만, 세세하게 뭔가 되는 느낌은 아니다. 코드 작업이 되는 것도 아니므로 n8n 에 비하면 커스터마이징이 실질 AI 를 위한 프롬프팅 정도만 가능하다는 단점이 있다. 그럼에도 특징들을 종합하면 <strong>AI 워크플로우 구축에 특화 플랫폼</strong> 이라고 정의 내릴 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">User Input</code> 항목은 사용자 입력을 받을 수 있으며 옵션에 따라 멀티 모달이 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">Generate</code> 는 Gemini 의 생성형 AI 모델들을 골라서 수행이 가능하며, 여기엔 텍스트 모델 말고도 Nano Banana나 Veo 와 같은 생성형 AI 모델들을 선택하는 것도 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">Output</code> 은 결과물에 대해 선을 연결하게 되면, 그것을 어떤 옵션으로 출력을 할지를 결정해준다. Google Docs, Slides, Sheets와 같은 Google Workspace 애플리케이션이나 웹 페이지 등으로 연결하여 출력 형식을 지정할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Add Assets</code> 라는 항목은 각종 자료들을 추가할 수 있도록 되어 있다.</p>

<h2 id="생각보다-좋다">생각보다 좋다…?</h2>

<p>이왕 이리 된거 간단한 걸 만들어보고자 생각이 들었고, 뭘 해볼까 고민해보았다.</p>

<p>목표는 다음과 같았다. 이직 준비를 꾸준하게 하고 있고, 가장 궁극적인 목표는 개발자로 내가 할 수 있는 <code class="language-plaintext highlighter-rouge">가속도</code>를 제대로 붙게 만드는게 나에게 필요한 시점이었다. 그리고 그걸 위해 가장 실질적으로 지금 필요한게 뭘까? 라는 생각에 내 결론은 <code class="language-plaintext highlighter-rouge">내가 목표로 삼는 연차 이상의 기술력(경험)을 확보하자</code> 라는 것이었다.</p>

<p>그런데 그럴 거면 무엇이 필요한가?</p>

<p>맞다. 시장에서 요구하는 <code class="language-plaintext highlighter-rouge">연차별 성공적인 케이스 수준의 개발력</code> 스펙으로 알아둬야 하는 기술들, 경험들이 뭔지를 이해도 하는 것이 필요했다. 그렇기에 3년차 수준의 공통된 실무 경험치 기준, 필수, 그리고 권장을 정확히 이해하길 원했다. 그 스펙들에 따라 내 현재 이력서를 확인해보고 얼마나 채웠는가? 를 알아보려고 했다. 그러려면 다음과 같은 로직이 필요하다고 느꼈다.</p>

<ol>
  <li>분석의 기본 데이터 소스를 채용 공고를 활용한다.</li>
  <li>해당 회사에 대한 Deep Research(심층 조사) 기능을 기반으로 회사 자료, 회사의 수준을 신빙성있는 자료를 준비한다. 이 자료는 회사의 배경 조사를 겸하고, 추가적인 데이터 역할을 한다.</li>
  <li>공고, 회사에 대한 배경 지식을 기반으로 필수 역량과 권장 역량을 구분하고 추출해낸다.</li>
  <li>베이스는 준비 되었으니, 개인의 이력서, 경력 자료를 수집하고, 이 데이터 기반으로 종합하여 개인의 이력의 평가를 요청한다.</li>
  <li>분석한 데이터들의 종합으로 회사를 소개하고, 역량치를 정리하고, 정리 아래에 개인 이력에 대한 평가를 수행한다.</li>
</ol>

<p>그리하여… 이렇게 내용을 러프하게 적어 처음에는 ‘Suggest an edit’이란 프롬프트로 알아서 만들어 달라고 해보았다. 하지만 막상 이게 생각보다 애매한감이 있었다. 이유는 막상 작성 된 내용을 기반으로 또 다시 결과물이 나오고 그걸 다시 평가하고 수정하고… 이런 반복은 시간이 아깝다고 생각했다. 구조도 파악했으니, 차라리 간단하게 내가 만들자! 라는 생각을 해서 직접 만들어 보았다.</p>

<p>그리하여 만들고나니 의외로 좋은 점들을 발견할 수 있었다.</p>

<ol>
  <li><strong>병렬 처리(Parallel Processing)가 된다.</strong> 
 전형적인 AI 기본 모델들은 알다시피 모든 일이 ‘요청’ -&gt; ‘수행’ 이라는 선형 구조를 취하고 있다. 하지만 선형이란 건 직관적이고 순서를 보기엔 편하다. 하지만 시간도 오래 걸릴 뿐만 아니라, 중간에 필요한 작업들이나 요청 사항등을 결국 선형으로 기다리면서 작성한다는 건 효율적이지 못하다. 
 하지만 역시 구글, 그럴 일을 줄이기 위해서일까, <code class="language-plaintext highlighter-rouge">User Input</code>은 바로 즉각적으로 순서대로 받게 되어 있었고, 여러 일을 AI 에게 분담을 하면 동일 단계라면 동시에 처리하도록 되었고, 결과적으로 여러 일들이 있었지만, 끝난 시간은 Deep Research 하나 수행한 정도만에 해결이 되었다.</li>
</ol>

<p><img src="/assets/images/posts/2025-11/20251111-037.png" alt="" />
	&gt; 한꺼번에 AI 는 하나의 일을 하도록 시킨다. 그만큼 정확도가 올라가고, 작업 자체에 대한 정밀성을 올릴 수 있으니 아주 좋다.</p>
<ol>
  <li><strong>프롬프트에 직접적으로 어떤 자료를 어디에 쓸 것인지 지정하는 것이 가능하다.</strong> 
이 장점은 기술적인 면 보단 사용자 경험(UX) 의 승리라고 생각이 든다. 웹 챗봇, Cursor 같은 IDE, 그 외에 클라이언트형 AI 도구 등 다양한 AI 도구들은 요즘은 어지간하면 멘션기능을 가진다. 이를 통해 데이터들을 링크 시키고, 파이프라인을 형성한다.
그런데 이때, 아쉬운 점은 <strong>직관성</strong>일 것이다. 워크 플로우를 만들거나, 자동화를 시켜 ‘하기 싫은 일’을 수행 시킬 순 있지만, 결국 핵심은 AI 에게 맡긴 일이 잘 되어가는지? 그리고 안된다면 어딜 고쳐야하지? 에 대한 직관성이 필요한 것이다.
하지만 이런걸 기존 툴들은 일단 <code class="language-plaintext highlighter-rouge">@파일명</code> 이정도로 표현하는 정도에 그친다. 이러다보니 여러 워크플로우를 만들면, 어디서 결과가 이상하게 나오는지 추적하기도 어렵다. 하지만 Opal 은 이에 대한 데이터를 멘션을 하고, 그것이 자연어 사이에 직접적으로 타겟화 시켜서 마치 함수의 인자를 직관적으로 볼 수 있게 했다.
뿐만 아니라 프롬프트를 작성할 때 이 자료가 뭐다- 라는 걸 직접적으로 지칭하고, 자연어 내부에 섞어서 쓸 수 있게 했다. 멘션 기능이 있으면 가능하다고 볼 수 있겠지만 그럼에도 사용 시 가장 편리했던 도구는 단연코 Opal 의 그것이 아니었나 생각이 들었다. 
<img src="/assets/images/posts/2025-11/20251111-024.png" alt="" />
    <blockquote>
      <p>확실히 자료에 대해 구체적이고 직관적인 전달. 내가 의도한 데로 움직이게 만드는데, 심지어전후로 구조적인 이해가 가능하다.</p>
    </blockquote>
  </li>
</ol>

<p>물론 아쉬움이 없나? 그건 아니다.</p>

<ol>
  <li><strong>로우 레벨의 접근 제한</strong> 
처음에 먼저 자동화를 n8n 으로 만들고, 여기에 다가도 AI 를 섞어서 만들었다. 그리고 이는 머리 아픈 과정이긴 했지만, n8n 은 Code 노드가 존재하고, Python 도 지원을 앞두고 있다. Opal은 없다. 이 모든 자잘하고 세세한 설정을 할 수 있는데 못하는게 아니라, 아무리 봐도 의도적으로 막아둔 것으로 보인다. 
이 점은 효율성과 연결이 되는데, 데이터의 아주 로우한 접근, json 화 시켜서 변수화 시킨 다던지, AI 가 필요 없는 작업을 당연히 PC 의 작은 리소스만으로 해결하는데 톡톡한 역할을 해줄 텐데… 여기선 그런 사소한 작업까지도 AI에게 요청해야 했다. 물론 다른 대안으로 모델을 flash-lite 와 같은 걸로 하면, 훨씬 빠르고 간편하게 해준다는 점을 생각해보면..?
Opal 자체는 확실히 GUI 기반에, 뭔가 인스턴트하게 AI 에게 맡기고 싶다! 라는 니즈 자체에 집중한 것이라고 납득이 안되진 않았다. 이를 통해 ‘인스턴트 앱’ 또는 ‘숏앱(Short App)’이라 불리는 신속한 프로토타이핑 환경을 제공하려는 의도가 엿보인다.</li>
  <li><strong>외부 플러그인이 부족하다</strong>
위의 내용과는 반대로 풍부함 역시 부족하다는 생각이 들었다. n8n 은 파일의 저장, 읽기, 쓰기, DB 연결을 비롯해서 광범위한 기능들을 쓸 수 있다. Code node 는 JS 기반이라 관련 라이브러리도 쓸 수 있다. 아직 베타지만 Python 까지 들어간다면? 정말 n8n 자체로 할수 있는 일은 엄청나다고 말 할 수 있다. 정말 깊게 파면, 서버 프레임워크 코드 한줄 없이 서비스용 서버리스 서버도 구현이 가능할 정도다. 
반면 Opal은 Google Drive, Google Workspace, HTML 페이지 등 Google 생태계 내의 서비스 연동에 국한되어 있어, 외부 플러그인 및 서비스 연동성이 부족하다는 점이 아쉽다. (베타 버전임을 감안하더라도 파일명 수정 기능 부재 등은 개선이 필요해 보인다.) 베타라지만 이정돈 해줄수 있을텐데 말이다. 
개인적으론 알림을 보내는 기능, 메일 보내는 기능 정도는 있으면 어떨까 싶었다. 정말 그 정도만 되도 만들어 볼만한 기능들은 엄청날텐데 말이다.</li>
</ol>

<p>완성을 하고 자료가 착착 나오는 걸 보니 꽤나 쉽다는 생각, 역시 AI는 이런 작업은 최고라는 생각을 할 수 있었다. 다행히 프롬프트를 구체적으로 적을 수록 구분이 되고, 프롬프트 내부에서 일종의 조건문 식으로 처리 하는 것도 가능하니 그걸 기반으로 디테일 버전, 간단버전, 혹은 인용한 사이트 정보 취사 선택 여부 등을 추가로 넣어보기도 했다. 방법은 확실히 있다고 느껴진다.</p>

<hr />

<h2 id="일반인들을-위한-ai-자동화-도구-글쎄">일반인들을 위한 AI 자동화 도구… 글쎄</h2>

<p><img src="/assets/images/posts/2025-11/20251111-025.png" alt="" />
<img src="/assets/images/posts/2025-11/20251111-026.png" alt="" /></p>

<p>Google 의 Deep Research 는 이미 전부터 엄청나다고 호평이었다. 그리고 자료, 로직을 추가할 수 있게 되니 정말 만드는데 1시간, 데이터 수집 및 AI에게 일 시켜놓기 30분. 기다리고나니 4개의 업체와 업체의 현재 근황, 재정 상황 분석, 해당 시장 특성, 그리고 나의 역량이 도움이 될지. 부족한 점이 뭔지를 정리해주는 것이 가능했다. 정말 숏 앱이라는 개념에 부합하는 여러 서비스가 있었지만, 가장 안정적이면서도 정확한 서비스는 구글이란 생각을 새삼 안할 수가 없다고 느낀다.</p>

<p>특히나 영악하게도 모든 서비스는 구글의 서비스와 연동이되고, 문서 하나 구글을 벗어나지 않는다는 점은… 처음엔 구글이 AI 의 등장으로 휘청이니 뭐니 했지만, 실상 10년 전부터 준비하던 구글의 엄청난 저력. 그리고 이 모든 것이 2.5 flash 에 프롬프트만으로 충분히 나온다는 지점은….</p>

<p>하지만 쓰면 쓸 수록 한 가지 분명하게 이해되는건 ‘이게 과연 일반인들을 위한 도구가 될 수 있을까?’ 에 대한 생각이다. 물론 자연어를 쓸 수 있고, 시스템적 사고가 가능한 사람들이라면 충분히 도전해볼만 하다. 해볼 사람은 도전해보길 추천한다. 프롬프트를 작성하는 방법에 대해서, AI 의 특성에 대해 간단히 이해만 한다면, 충분히 해봄직 하긴 하다.</p>

<p>하지만 AI를 접하고, 소개하고, 써보길 이야기 할 때 느낄 수 있는 건 생각보다 이러한 접근방법, 생각하는 방법은 배우지 않곤 쓰기 어렵다는 점이다. 엔드 유저에게 AI 가 더 대중화 되지 못하고 있는 이유는 결국 ‘결론’을 지향하는 사고가 기본적으로 효율적이고, 그렇게 사람들이 존재하기 때문에, 막상 로직을 분석하고 로직적으로 논리성을 쌓는 절차를 굳이 해야 하나? 라고 하면 안할 사람들이 많지 않을까?</p>

<p>뿐만 아니라 오히려 격차가 커지겠구나! 하는 생각을 하게 되었다. 특히 자연어를 쓴다고 했지 코딩이랑 실질 다르지 않은 구조이기 때문에, 결국 더욱 개발자나 쓰기 좋고, 만약 지금보다 더 일반인이 쓰길 원한다면 정말 ‘한 마디 문장’을 기반으로 AI 가 자체적으로 판단, 기획, 스텝을 나누고 개발을 해내는 것을 아주 정교하게 만들어야 할텐데. 지금 당장은 아직까진 애매하단 생각이 들었다.</p>

<p>물론 Google의 행보를 보면 명확하다. 아마 5년 안짝이면 그정도는 구현 가능해지리라 생각은 든다. 하지만 정보의 격차, 생각하는 방식의 구체화, 로직화 등등… 어쩌면 인간의 기본 능력치가 앞으로 더 인문학적, 사고적 깊이감이 없다면 이런 모든 상황에서 이겨내고 자기만의 일을 찾을 수 있을까? 란 생각은 든다. 무섭긴 하지만 기대도 되고, 기대가 되니 더 앞으로 가봐야겠다.</p>

<p>만들어본 데모 앱은 써볼 수 있도록 열어 놓겠습니다.</p>

<p><a href="https://opal.google/?flow=drive:/191E1UU8no6s5G_LUaJxwJTKAzZmH6uF_&amp;shared&amp;mode=app">공고글 및 개인 역량 분석기</a></p>

<p><strong>당부사항</strong></p>
<ul>
  <li>해당 앱의 정보는 모두 구글에서 처리 되는 것이며, 저 개인의 서버 등에 저장되지 않습니다.</li>
  <li>또한 리포트는 구글 드라이브 내에 <code class="language-plaintext highlighter-rouge">Opal</code> 폴더가 생성되고 해당 폴더 내에 문서로 저장됩니다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="DevOps" /><category term="Docker" /><category term="n8n" /><category term="Automation" /><category term="AI" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL - MVP 구축을 위한 AI 모델 분석</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/04-til-AI-for-MVP.html" rel="alternate" type="text/html" title="TIL - MVP 구축을 위한 AI 모델 분석" /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/04-til-AI-for-MVP</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/09/04-til-AI-for-MVP.html"><![CDATA[<p><img src="/assets/images/posts/2025-11/20251111-027.png" alt="" /></p>

<h2 id="ai-모델-분석-보고서-ai-기반-심리-테스트-mvp-개발">AI 모델 분석 보고서: ‘AI 기반 심리 테스트’ MVP 개발</h2>

<h3 id="1-프로젝트-개요-및-목표">1. 프로젝트 개요 및 목표</h3>

<p>프로젝트를 진행하기 위한 ‘발사대’가 필요하다!</p>

<p>그게 처음 이 고민의 시작이었다. AI 의 RAG 기반 프로젝트를 진행할 것이지만. 그리고 거기서 DevOps 와 Backend 가 살아 숨쉬는 프로젝트를 해보고 싶지만…! 그걸 바로 목표 지향점으로 가져가기엔 아무래도 어렵다는 생각. 그 생각이 있었기에 그 중간에 뭘 하면 좋을까? 이것이 야심한 11월 10일, 빼빼로 데이 전날 새벽 4시의 고민이었다.</p>

<p>그러다가 번뜩, 데모로 만들만한 것을 찾던 도중 ‘AI 기반 심리 테스트’ MVP(Minimum Viable Product)를 개발해볼까? 하는 생각을 했다. 이유는 간단하다. (1) 진지한 도구나, 거창한 도구는 만들 상황이 안된다. (2) 트래픽을  유도하고, 사람들의 호기심을 끌어야 이용자 수를 볼 수 있고, 만든 서버의 처리 능력을 테스트 해볼 수 있다. (3) 겸사 겸사 모니터링 데이터가 필요하다(?) 그리하여 어그로를 끌어야 하는데… 여기서 중요한건 역시나 AI 로 테스트 결과 리포트를 받는 것이었다.</p>

<p>gemini 2.5 pro 를 기반으로 했을 땐 상당히 흥미 진진하고, 사람들이 관심 가져볼 것 같았다…. 결론적으로 프로젝트를 위한 중간에 계단 역할을 하기엔 최고라는 판단이 섰다. 하지만 알다시피 프로젝트로, 구조적으로, 경험적으로 너무나 괜찮은 경험인 것은 맞지만, 결정적으로 문제가 있다는 사실을 발견했다. 그것은 바로 ‘비용’.</p>

<p>알다시피 AI 는 돈 빨이다. GPU 따위 구할 수도 없는 일개 백수에게 핵심은 결국 어딘가에서 빌려서 AI 를 쓰는 수밖에 없고… 그렇기에 나는 불쑥 생각이 난 플랫폼으로 들어가게 되었다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-028.png" alt="" /></p>

<p>이 플랫폼은, 정말 말 그대로 API 제공 + 다양한 AI 업체들을 연결시켜주는 역할을 하는데, 특히나 좋은 점은 ‘동일한 프롬프트’를 기준으로 여러 모델들을 테스트 해볼 수 있다는 점이며, <strong>‘품질(Quality)’, ‘비용(Cost)’, ‘속도(Speed)’</strong> 세 가지 측면에서 가장 최적화된 대규모 언어 모델(LLM)을 선정해보고자 했다.</p>

<p>본 MVP의 핵심 목표는 다음과 같다.</p>

<ul>
  <li>단순한 객관식(점수제) 테스트를 넘어, 사용자의 <strong>주관식 텍스트 답변</strong>을 AI가 심층 분석하는 고차원적인 경험을 제공하는지 판단해본다.</li>
  <li>분석 결과를 ‘판타지 게임의 설정’ 스타일의 스탯과 서사를 포함한 <strong>‘개인화된 내러티브 리포트’</strong> 로 생성해본다.</li>
  <li>최종적으로 1만 명 규모의 트래픽을 감당하는 <strong>‘DevOps 기술 포트폴리오’</strong> 에 쓸 AI, 즉 머리로 활용해보자.</li>
</ul>

<h3 id="2-분석-및-연구-과정">2. 분석 및 연구 과정</h3>

<p>최적의 모델을 선정하기 위해, OpenRouter 서비스를 활용하여 다양한 모델에 동일한 테스트(판타지 시나리오 질문 및 주관식 답변)를 수행했다. 이때 다음 방식으로 진행했다.</p>

<ol>
  <li>내 의도, 기획을 이해한 gemini 2.5 pro 기반으로 저작권 문제가 없는(…) Big Five 방식의 질문지 데모를 생성했다.</li>
  <li>이에 대한 답변을 객관식(1 ~ 15번) 까지 답변했고, 객관식으로 4 문항에 대해서 주관식으로 한줄 추가했다.</li>
  <li>마지막으로 이 데이터들로 해야할 일이 뭔지를 정리해 보았다.</li>
</ol>

<p>아래의 내용은 실제 동일하게 넣었던 내용이다.</p>

<pre><code class="language-plain">### 🛡️ 모험가 성향 분석 (총 15문항)

당신은 미지의 대륙을 탐험하는 모험가입니다. 아래의 여러 상황을 상상하며, 당신의 생각이나 행동과 가장 가까운 정도를 **1점에서 5점까지**로 답해주세요.

&gt; **[점수 기준]**
&gt; **1점:** 전혀 그렇지 않다
&gt; **2점:** 대체로 그렇지 않다
&gt; **3점:** 보통이다 (그럴 때도 있고 아닐 때도 있다)
&gt; **4점:** 대체로 그렇다
&gt; **5점:** 매우 그렇다

---

**[질문 리스트]**

1.  당신은 숲 속에서 고대에 사라진 문명의 빛나는 유적을 발견했다. 위험할 수도 있지만, 이 미지의 기술을 탐구하고 싶은 강한 호기심을 느낀다.
2.  퀘스트를 마치고 마을의 시끌벅적한 여관에 도착했다. 당신은 모르는 사람들과도 어울려 모험담을 나누고 축배를 드는 것을 즐긴다.
3.  "드래곤의 산"으로 떠나기 전, 당신은 식량, 물약, 장비, 지도를 하나하나 꼼꼼하게 점검하고 목록을 만든다.
4.  당신의 일행이 부상당한 고블린을 생포했다. 당신은 정보를 얻는 것도 중요하지만, 그를 불필요하게 고문하거나 학대하는 것에 반대한다.
5.  어두운 던전에서 복도를 걷던 중, 갑자기 멀리서 함정이 발동하는 소리가 들렸다. 당신은 '다음은 내 차례일지도 모른다'는 생각에 즉시 불안해지고 심장이 뛴다.
6.  마법사 길드는 '불의 주문'을 배우라고 했지만, 당신은 금지된 서고에 있는 '영혼 마법'에 대한 고문서에 더 마음이 끌린다.
7.  파티가 갈림길에서 망설일 때, 당신은 "이쪽 길이 맞는 것 같다! 나를 따르라!"라며 적극적으로 의견을 내고 일행을 이끄는 편이다.
8.  당신은 파티의 재무 담당이다. 퀘스트 보상을 분배할 때, 1골드까지 정확하게 계산해서 공평하게 나누어야 직성이 풀린다.
9.  한 마을 주민이 "우리 아이가 아픈데 약초가 필요해요"라며 애원한다. 비록 당신의 주된 임무는 아니지만, 그를 돕기 위해 기꺼이 시간을 사용한다.
10. 당신의 강력한 마법 공격이 거대 트롤에게 빗나갔다. 당신은 "역시 난 안돼"라며 순간적으로 자신감을 잃고 위축된다.
11. "모든 예언은 정해진 운명이다"라는 말보다, "예언은 해석하기 나름이며, 운명은 개척할 수 있다"는 생각을 더 선호한다.
12. 지루한 야영지에서 불침번을 서는 것보다, 차라리 정찰대를 자원하여 새로운 동료와 함께 미지의 지역을 탐색하는 것이 좋다.
13. 당신의 마법서나 무기고는 항상 완벽하게 정돈되어 있다. 필요한 물건은 언제든 즉시 찾을 수 있어야 한다.
14. 파티원 중 한 명이 실수를 해서 모두가 위험에 빠졌다. 당신은 그를 비난하기보다, "누구나 실수할 수 있다"며 감싸주고 다음 계획을 세우는 데 집중한다.
15. 왕궁에서 중요한 임무를 브리핑받을 때, 당신은 '내가 만약 실패하면 어떡하지?'라는 걱정 때문에 발표 내용에 집중하기 어렵다.

---

### 🔮 분석해 드릴 내용

답변을 주시면, 저는 이 15개의 응답을 Big Five 모델(OCEAN)의 5가지 특성에 대입하여 분석해 드립니다.

1.  **개방성 (Openness): 미지의 탐험가**
    * (질문 1, 6, 11)
    * 새로운 경험, 금지된 마법, 추상적인 예언 등에 대해 얼마나 열려 있는지를 봅니다.
2.  **성실성 (Conscientiousness): 왕국의 기사**
    * (질문 3, 8, 13)
    * 퀘스트 준비, 보상 분배, 장비 관리 등에서 얼마나 체계적이고 책임감이 강한지를 봅니다.
3.  **외향성 (Extraversion): 여관의 음유시인**
    * (질문 2, 7, 12)
    * 파티의 중심에서 에너지를 얻는지, 리더십을 발휘하는지, 사교성을 봅니다.
4.  **우호성 (Agreeableness): 치유의 성직자**
    * (질문 4, 9, 14)
    * 동료나 약자를 대하는 태도, 파티의 조화를 얼마나 중요하게 생각하는지를 봅니다.
5.  **신경성 (Neuroticism) / 정서적 안정성:**
    * (질문 5, 10, 15)
    * 함정, 실수, 실패의 압박감 속에서 얼마나 쉽게 불안을 느끼거나 감정적으로 흔들리는지를 봅니다.

---

여기의 답변 (객관식, 주관식 작성한 내용)
1. 5
2. 3
3. 5
4. 5
5. 3
6. 3
7. 4
8. 4
9. 5
10. 1
11. 3
12. 4
13. 4
14. 5
15. 1
16. 그것이 아주 큰 위험이 아니라, 내가 돈이나, 재료를 통해 충분히 제어 가능하면서 연구 가능하다면 연구를 적극적으로 해보고 싶다!!
17. 파티의 갈림길에서 빠르게 결정하는게 필요한 순간이라면 모를까, 그런게 아니라면 파티원들을 존중하고, 무엇보다 두 길의 리스크와 이점을 이해할 수 있는지를 본다. 그런 게 부족하면 일단 갈거다. 
18. 현실과 상황은 분명 한계를 만들어내기 때문에, 이걸 인정하지 않을수는 없다. 하지만 인정하고 철저하게 더 정확하게 분석적으로 태도를 취하는게 좋고, 그렇게 기회를 잡는게 필요하다고 본다. 그리고 그게 운명의 의미라고 생각한다.
19. 중요 임무를 브리핑 받는다? 이건 기회다! 라고 생각하고, 당연히 걱정이 다소 들겠지만 평소의 나라면 충분히 해결하거나, 부족하면 반드시 날 도울 사람이 옆에 있다고 난 생각함!
---

위의 내용을 가지고 심리 분석하여 판타지 소설의 개요처럼 이 사람을 분석한 리포트를 만들고, 랜덤 기술 2가지를 포함해서 성격 분석 리포트를 만들어줘 볼래? 스텟도 추가해서 민첩 A 이런 식으로 표현해줘. 이건 심리테스트 결과지를 만드는 거야.
</code></pre>

<p><img src="/assets/images/posts/2025-11/20251111-029.png" alt="" /></p>
<blockquote>
  <p>OpenRouter 는 크레딧 충전만 하면 손쉽게 여러모델을 동시에 비교가 가능하다.</p>
</blockquote>

<h4 id="1단계-초기-모델-탐색-및-문제점-식별-a-b-c-d안">1단계: 초기 모델 탐색 및 문제점 식별 (A, B, C, D안)</h4>

<p>12B~20B급의 4가지 주요 모델을 대상으로 초기 벤치마킹을 수행했다. 이 단계에서 ‘품질’과 ‘신뢰성’의 명확한 한계점을 발견했다.</p>

<ul>
  <li><strong>A안 (<code class="language-plaintext highlighter-rouge">gemma 3 12B</code>):</strong>
    <ul>
      <li><strong>평가:</strong> 생성된 리포트(A안)는 안정적이었다. 의도를 이해했고, 나름의 내용이 잘 담겨 있었다. 하지만 창의성이나 깊이 없이 매우 건조하고(dry) 재미가 부족했다. 사용자의 흥미를 유발해야 하는 본 MVP의 목적에 부합하지 않아 초기 스크리닝에서 탈락했다.</li>
    </ul>
  </li>
  <li><strong>B안 (<code class="language-plaintext highlighter-rouge">Llama 4 Maverick 17B</code>):</strong>
    <ul>
      <li><strong>평가 :</strong> 모델이 사용자의 핵심 페르소나를 파악하는 데 <strong>완전히 실패했다.</strong></li>
      <li><strong>근거:</strong> 사용자의 주관식 답변은 ‘통제’, ‘분석’, ‘신뢰’, ‘기회’ 등 <strong>‘전략가적’</strong> 성향을 명확히 드러냈으나, B안(“용기의 탐험가”)은 이를 무시하고 ‘용기’라는, 입력된 의도와 상반되는 <strong>제네릭(Generic)한 템플릿</strong>을 생성했다. 텍스트 분석 기능이 사실상 작동하지 않았다. <del>솔직히 가장 실망한 모델이다</del></li>
    </ul>
  </li>
  <li><strong>C안 (<code class="language-plaintext highlighter-rouge">Qwen3 14B</code>):</strong>
    <ul>
      <li><strong>평가</strong>: 가장 요구한 내용들에 대한 구조적인 이해도가 뛰어났다. 내용의 재미나 창의성도 괜찮았다. 그러나 가장 치명적인 <strong>‘신뢰도’와 ‘논리적 오류’</strong> 문제를 노출했다.</li>
      <li><strong>근거 1 (지시 불이행):</strong> “스킬 2개로 제한”이라는 명확한 지시를 “섹션당 2개”로 오해하여 총 10개의 스킬을 생성하는 등, <strong>지시사항 준수(Instruction Following)에 실패</strong>했다.</li>
      <li><strong>근거 2 (맥락 오류):</strong> 한 섹션의 주관식 답변(Q15)을 전혀 상관없는 다른 섹션(Q7)에 복사-붙여넣기하는 <strong>심각한 맥락 파괴(Context Error)</strong> 를 일으켰다. 이는 복잡한 프롬프트의 안정적인 실행이 불가능함을 의미했다.</li>
    </ul>
  </li>
  <li><strong>D안 (<code class="language-plaintext highlighter-rouge">gpt-oss-20b</code>):</strong>
    <ul>
      <li><strong>평가(비판):</strong> 의도에 대한 이해도는 높았고, 컨텐츠로 작성한 내용도 꽤나 준수하긴 했다. 하지만 문제는 이상할 정도로 기본 상태에선 설명이 건조하고, 축약 되어 토큰이 아껴지는 것을 볼 수 있었다. 결론적으로 정리 자체가 아쉬운 건 아니었다.</li>
    </ul>
  </li>
</ul>

<h4 id="2단계-마스터-프롬프트의-발견-c안">2단계: ‘마스터 프롬프트’의 발견 (C+안)</h4>

<p>초기 1단계의 실패(특히 C안의 오류)를 나오고 보니 아쉬움이 생겼다. 분명 기재할만한 내용은 적었지만, 여전히 부족하다는 생각. 특히 모델의 성능에만 의존할 수 없음을 깨달았다. 구조에서 누락하고 읽는 거라던가, 인용이 빠진다거나 하는 지점들을 보완하는게 필요하겠단 생각을 하게 되었다. 일종의 추론 스텝을 임의적으로 추가하는 것이다. 이에 가성비가 괜찮은걸로 알고 있던 <code class="language-plaintext highlighter-rouge">Gemini 2.5 Flash-lite</code> 모델의 구조를 기준으로, AI의 역할을 정의하고 리포트의 구조, 논리, 근거 제시 방식을 꼼꼼하게 설계한 <strong>‘로직 가이드라인 프롬프트’</strong> 를 개발했다. 사실 개발이라고 해도 별거 아니다 ㅋ</p>

<p><code class="language-plaintext highlighter-rouge">이 모든 프롬프트를 위한 의도를 파악하고, 이 프롬프트를 더 정확하게 표현하기 위한 로직 프롬프트를 짜줘</code></p>

<p>라고 추가하여, 기존 프롬프트를 함께 넣어 준 것이었다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-030.png" alt="" /></p>
<blockquote>
  <p>그 결과 다음과 같이 개선 및 AI 가 맥락을 이해할 수 있도록 대폭 강화하는 프롬프트를 생성해냈다.</p>
</blockquote>

<p>일단 1차적으로 flash-lite 가 생각 이상으로 훌륭하구나! 라는 걸 느꼈다.</p>

<p>이 가이드라인을 각 모델 별로 넣어 보았고, 특히 핵심 일부가 누락된 가장 아쉬운 모델 <code class="language-plaintext highlighter-rouge">Qwen 14B</code> 모델에 재적용한 결과(C+안), 이전의 오류가 사라지고 ‘질서의 현자’라는 99점 수준의 재미도 있고, 흥미진진하며, 보는 맛이 있는 리포트를 생성했다. 😂 이는 <strong>모델의 성능 만큼 가이드 ‘프롬프트의 꼼꼼함’이 이 프로젝트의 핵심 기술(IP)</strong> 임을 증명하는 첫 번째 순간이었다.</p>

<h4 id="3단계-최종-후보군-압축-및-s-tier-품질-검증">3단계: 최종 후보군 압축 및 S-Tier 품질 검증</h4>

<p>하지만 그렇게 나온 결론으로 정리를 한 상태에서 ‘가격’ 에 대한 점검을 수행했다.  이유는 간단하다. 트래픽을 위해선 서버를 이용해야 하고, 다행이 서버 까지는 온프레미스로 구축할 수 있었다. 그러나 AI 는 별도다. 현재 예상하는 심리테스트 계열은 좀 알아보니 조회수 기준 1만회에서 10만회 사이로 유행이 될 것이고, 내가 잠시 막아둔다고 해도 필요하다면 다소 지속적으로 열어 둬야 하지 않겠는가? 그러므로 AI 로 간단하게 서비스 1회 요청 시 얼마의 토큰이 달것이고, 그러면 100명, 1천명, 1만명 요청시 과연 얼마나 드느가? 에 대한 예상이 필요했다.</p>

<p>처음 비교는 Google 에서의 모델들 끼리 비교 였다.</p>

<table>
  <thead>
    <tr>
      <th>**비교 항목**</th>
      <th>**Gemini 2.5 Flash-Lite**</th>
      <th>**Gemini 2.5 Flash**</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**입력 비용** (1백만 토큰당)</td>
      <td>$0.10</td>
      <td>$0.30</td>
    </tr>
    <tr>
      <td>**출력 비용** (1백만 토큰당)</td>
      <td>$0.40</td>
      <td>$2.50</td>
    </tr>
    <tr>
      <td>**1인당 예상 비용 (USD)**</td>
      <td>**$0.0018**</td>
      <td>**$0.008**</td>
    </tr>
    <tr>
      <td>(1인당 원화 환산)</td>
      <td>(약 2.5원)</td>
      <td>(약 10.8원)</td>
    </tr>
    <tr>
      <td>**1만 명 총 예상 비용 (USD)**</td>
      <td>**$18.00**</td>
      <td>**$80.00**</td>
    </tr>
    <tr>
      <td>**1만 명 총 예상 비용 (KRW)**</td>
      <td>**약 24,300원**</td>
      <td>**약 108,000원**</td>
    </tr>
  </tbody>
</table>

<p>10, 10만원…ㄷㄷ 2.5 flash 는 프롬프트만 잘 먹이면 2.5 pro 수준은 된다는 걸 알고 있었고, pro 는 의도 파악, 추론에서 아주 괜찮지만 비용이 너무 비싸므로 lite 와 비교했다. flash-lite 성능 분석 표까지 검색해보고 얻은 결론은 ‘flash-lite 가 좋겠네’ 였다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-031.png" alt="" /></p>
<blockquote>
  <p>출처 : Artificial Analysis</p>
</blockquote>

<p>그런데 응? 성능도 그렇고 가격도 아주 착한 녀석이 하나 더 보였다. 그것이 바로 <code class="language-plaintext highlighter-rouge">gpt-oss-120b</code> 모델이었다.</p>

<p><img src="/assets/images/posts/2025-11/20251111-032.png" alt="" /></p>
<blockquote>
  <p>출처 : OpenRouter</p>
</blockquote>

<p>gpt-oss 모델은 오픈소스, MoE 구조로 꽤나 괜찮은 모델임은 알았고, 20B 모델은 실제로 양자화 시킨 걸로 내 컴퓨터에서 구동을 했었다. 그런데 알고보니 120b 모델이 존재하며, 이걸 라우팅 해주는 업체들이 있는 걸 알게 된 것이다. 그리하여 넣어서 비교해본 결과… 정리하면 아래와 같았다.</p>

<p>‘마스터 프롬프트’를 기반으로 가장 유력한 두 후보 모델을 심층 비교 결과, 두 모델 모두 <strong>‘마스터 프롬프트’</strong> 를 완벽하게 수행하며 ‘S-Tier’ 품질의 리포트(최종 A안, B안)를 생성하는 데 성공했다.</p>

<ul>
  <li><strong>후보 1: <code class="language-plaintext highlighter-rouge">Google: Gemini 2.5 Flash-lite</code></strong></li>
  <li><strong>후보 2: <code class="language-plaintext highlighter-rouge">OpenAI: gpt-oss-120b</code></strong></li>
</ul>

<p><img src="/assets/images/posts/2025-11/20251111-033.png" alt="" /></p>
<blockquote>
  <p>후보 1 - flash-lite 프롬프트 가이드 + flash-lite 프롬프트</p>
</blockquote>

<p><img src="/assets/images/posts/2025-11/20251111-034.png" alt="" /></p>
<blockquote>
  <p>후보 2 -  flash-lite 프롬프트 가이드 + gpt-oss-120b</p>
</blockquote>

<h3 id="4-최종-후보군-상세-평가">4. 최종 후보군 상세 평가</h3>

<p>두 S-Tier 모델은 품질은 동등했으나, ‘스타일’과 ‘비용 구조’에서 명확한 차이를 보였다.</p>

<h4 id="41-후보-1-google-gemini-25-flash-lite-a안">4.1. 후보 1: <code class="language-plaintext highlighter-rouge">Google: Gemini 2.5 Flash-lite</code> (A안)</h4>

<ul>
  <li><strong>품질 (S-Tier): “융합적 분석가”</strong>
    <ul>
      <li>A안(“균형 잡힌 지혜의 맹세자”)은 모델의 <strong>고급 추론 및 합성(Synthesis)</strong> 능력을 증명했다.</li>
      <li><strong>핵심 강점:</strong> 단순히 답변을 나열하는 것을 넘어, ‘행동 예시 재구성’ 섹션에서 <code class="language-plaintext highlighter-rouge">(Q3, Q1, 주관식 W1)</code>처럼 <strong>여러 질문(체계성+탐구심+통제 가능성)을 융합</strong>하여 “유적 탐사 시 이렇게 행동할 것이다”라는 <strong>하나의 새로운 시나리오로 ‘재창조’</strong> 했다. AI가 ‘똑똑한 분석가’처럼 행동했다.</li>
    </ul>
  </li>
  <li><strong>속도 (압도적 우위): <code class="language-plaintext highlighter-rouge">217.8 t/s</code></strong>
    <ul>
      <li>1만 명 트래픽 대응 시, 사용자 경험(UX) 측면에서 가장 큰 강점이 있다고 예상했다. 사용자가 거의 기다림 없이 리포트를 받을 수 있음을 의미한다.</li>
    </ul>
  </li>
  <li><strong>비용 (치명적 약점): <code class="language-plaintext highlighter-rouge">입력 $0.10 / M 토큰</code></strong>
    <ul>
      <li>본 MVP는 ‘마스터 프롬프트’가 길고 정교하기 때문에 ‘입력 비용’에 매우 민감하다. Flash-lite의 입력 비용은 <code class="language-plaintext highlighter-rouge">gpt-oss-120b</code> 대비 2.5배 비싸, DevOps의 ‘비용 통제’ 목표에 불리하게 작용한다.</li>
    </ul>
  </li>
</ul>

<h4 id="42-후보-2-openai-gpt-oss-120b-b안">4.2. 후보 2: <code class="language-plaintext highlighter-rouge">OpenAI: gpt-oss-120b</code> (B안)</h4>

<ul>
  <li><strong>품질 (S-Tier): “투명한 가이드”</strong>
    <ul>
      <li>B안(“지식-조화의 수호자”)은 <strong>‘분석의 투명성’</strong> 을 극대화했다.</li>
      <li><strong>핵심 강점:</strong> ‘행동 예시’ 섹션에서 <strong>15개 문항 전체</strong>를 하나도 빠짐없이 “이렇게 해석했다”라고 전부 리스트업했다. 사용자는 자신의 어떤 답변도 무시되지 않았음을 즉각적으로 알 수 있다. 이는 벤치마크 61점(Flash-lite 30점)이라는 <strong>더 높은 지적 능력</strong>이 ‘마스터 프롬프트’를 오류 없이 꼼꼼하게 수행했기 때문으로 분석된다.</li>
    </ul>
  </li>
  <li><strong>속도 (경쟁력 확보): <code class="language-plaintext highlighter-rouge">176.2 t/s</code></strong>
    <ul>
      <li>Flash-lite보다는 느리지만, 1만 명의 동시 요청이 아닌 이상, 사용자가 체감하기에 ‘충분히 빠른’ 경쟁력 있는 속도였다. 심지어 제공해주는 프로바이더에 따라 차이가 났는데, 최대 170.2tps 수준인 경우도 보였고, 이정도면 gemini 2.5 flash-lite 와 비등한 속도까지도 나와주었다.</li>
    </ul>
  </li>
  <li><strong>비용 (결정적 우위): <code class="language-plaintext highlighter-rouge">입력 $0.04 / M 토큰</code></strong>
    <ul>
      <li><strong>이것이 승리의 결정타이다.</strong> 본 MVP의 아키텍처(긴 프롬프트)에 완벽하게 부합한다. Flash-lite 대비 2.5배 저렴한 입력 비용은, 1만 명 트래픽 시나리오에서 <strong>총비용을 30% 이상 절감</strong>시킬 수 있는 핵심 요소이다.</li>
    </ul>
  </li>
</ul>

<h4 id="43-비용-비교표-1만-명-트래픽-시뮬레이션">4.3. 비용 비교표 (1만 명 트래픽 시뮬레이션)</h4>

<p>DevOps 포트폴리오의 핵심인 ‘비용 통제’ 목표를 검증하기 위해, 보수적인 ‘최대 시나리오’(1인당 입력 10k, 출력 2k 토큰 가정)를 기준으로 1만 명의 트래픽을 시뮬레이션했다. (환율 1,350원 기준)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">비교 항목</th>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">Gemini 2.5 Flash-lite</code></th>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">gpt-oss-120b</code></th>
      <th style="text-align: left">절감 효과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**입력 비용** (10k * 10,000)</td>
      <td style="text-align: left">$1.0 (약 1,350원)</td>
      <td style="text-align: left">**$0.4 (약 540원)**</td>
      <td style="text-align: left">**60% 절감**</td>
    </tr>
    <tr>
      <td style="text-align: left">**출력 비용** (2k * 10,000)</td>
      <td style="text-align: left">$0.8 (약 1,080원)</td>
      <td style="text-align: left">$0.8 (약 1,080원)</td>
      <td style="text-align: left">동일</td>
    </tr>
    <tr>
      <td style="text-align: left">**1인당 평균 비용**</td>
      <td style="text-align: left">약 2.5원</td>
      <td style="text-align: left">**약 1.7원**</td>
      <td style="text-align: left">**32% 절감**</td>
    </tr>
    <tr>
      <td style="text-align: left">**1만 명 총 예상 비용**</td>
      <td style="text-align: left">약 25,000원</td>
      <td style="text-align: left">**약 17,000원**</td>
      <td style="text-align: left">**약 8,000원 절감**</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/posts/2025-11/20251111-035.png" alt="" /></p>
<blockquote>
  <p>출처 : OpenRouter</p>
</blockquote>

<p><img src="/assets/images/posts/2025-11/20251111-036.png" alt="" /></p>
<blockquote>
  <p>출처 : OpenRouter</p>
</blockquote>

<p>MVP 로 작게 만들어보려고 하는 이번 프로젝트는 이미지 생성이나 다른 부가 기능이 필요하지 않았다. 하물며 프롬프트를 입력시 가이드를 세세하게 주는 걸 제외하곤 기본 텍스트 모델이면 충분했다. 특히나 Provider 에 따라 차이가 있었지만, 토큰 숫자도 오히려 더 많이 나오는데 1/10… 지적능력의 포텐셜을 생각하면 결론은 명백해 보였다.</p>

<hr />

<h3 id="5-최종-결론-gpt-oss-120b-채택">5. 최종 결론: <code class="language-plaintext highlighter-rouge">gpt-oss-120b</code> 채택</h3>

<p>본 MVP의 최종 모델로 <strong><code class="language-plaintext highlighter-rouge">OpenAI: gpt-oss-120b</code></strong> 를 선정했다.</p>

<p>‘gemini 2.5 flash-lite’가 압도적인 속도를 보여주긴 했다. 거기다 곰곰히 생각해보면 안정성 측면을 고려시 google 의 서버, vertex 기반으로 안정적으로 돌아갈 걸 생각한다면? 사실 gemini 가 정답일지도 모르겠다. 하지만 <code class="language-plaintext highlighter-rouge">gpt-oss-120b</code>는 <strong>더 높은 지적 능력(61점)</strong> 을 바탕으로 S-Tier 품질(투명성)을 달성하면서도, 본 프로젝트의 핵심 비용인 <strong>‘입력 비용’이 2.5배 더 저렴하다.</strong> 이 경쟁력은 지금과 같이 안정성 + 서비스의 목표 구현을 양 쪽으로 고려시 최선의 선택이 되리라 느꼈다.</p>

<p>1만 명 트래픽 시뮬레이션 결과, 총비용을 <strong>30% 이상 절감</strong>할 수 있고, ‘1만 명 트래픽’을 목표로 하는 DevOps 포트폴리오에서, 176 t/s는 ‘충분히 빠른’ 속도이며, 이 속도를 유지하면서 비용 절감까지 증명해낸 <code class="language-plaintext highlighter-rouge">gpt-oss-120b</code>가 가장 합리적이고 전략적인 선택이다. 또한 이 과정에서 가이드, 맥락 파악을 위한 프롬프트를 또 작성해 주는 것이 오히려 모델들의 잠재력을 끌어올릴 수 있다는 인사이트는 대단히 인상적이었다.</p>

<p>본 프로젝트의 성공은 <strong>‘AI 모델’</strong> 자체에 달린 것이 아니라, <strong>‘꼼꼼한 프롬프트’</strong> 로 <strong>‘저렴하고 똑똑한 AI(gpt-oss-120b)’</strong> 를 통제하는 개발자의 역량에 달려 있다는… 그런 내용이 아니었나 싶다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="DevOps" /><category term="Docker" /><category term="n8n" /><category term="Automation" /><category term="AI" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL - monitoring server 구축기 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/05/til-monitoring-server-2.html" rel="alternate" type="text/html" title="TIL - monitoring server 구축기 (2)" /><published>2025-11-05T00:00:00+00:00</published><updated>2025-11-05T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/05/til-monitoring-server-2</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/05/til-monitoring-server-2.html"><![CDATA[<h2 id="2025-11-05--monitoring-서버-구축하기">2025-11-05 : Monitoring 서버 구축하기</h2>

<p>드디어 모든 문제를 해결하였다.
HTTPS 를 통한 종단암호화를 마쳤으며
네트워크를 선행 구축하여 통로로 연결될 수 있도록 설정하였다. 
이제 남은 단 하나… 모니터링…!!</p>

<hr />

<h2 id="서버-아키텍쳐-구조도">서버 아키텍쳐 구조도</h2>

<p><img src="/assets/images/assets/project-monitoring-diagram.png" alt="" /></p>

<h2 id="핵심-설정-과정-및-트러블슈팅-qa">핵심 설정 과정 및 트러블슈팅 (Q&amp;A)</h2>

<p>구축 과정에서 몇 가지 중요한 개념과 문제를 마주했으며, 이를 해결하는 과정이 이번 TIL의 핵심이다.</p>

<h3 id="핵심-네트워크구조">핵심 네트워크구조</h3>

<p>네트워크의 설정이 난해했지만, 결국 핵심은 ‘외부’와 ‘내부’에 대한 명료함이다.</p>

<ol>
  <li><strong>내부 통신 (Docker Network):</strong> 모니터링 서버 <em>내부</em> 의 컨테이너들(e.g., <code class="language-plaintext highlighter-rouge">centre-prometheus</code>, <code class="language-plaintext highlighter-rouge">centre-grafana</code>, <code class="language-plaintext highlighter-rouge">NPM</code>)은 docker의 가상 네트워크를 통해 컨테이너 이름으로 통신한다. 이 통신은 Docker가 내부 DNS를 통해 처리하므로 외부 포트가 필요 없다.
    <ul>
      <li><strong>예시:</strong> NPM 프록시 설정 시 Grafana의 주소는 <code class="language-plaintext highlighter-rouge">http://centre-grafana:3000</code>이 된다.</li>
    </ul>
  </li>
  <li><strong>외부 통신 (Physical LAN):</strong> 모니터링 서버가 <em>다른</em> 물리적 서버에 접근할 때는 이 가상 네트워크를 쓸 수 없다. 반드시 외부 서버의 물리적 IP 주소와 <code class="language-plaintext highlighter-rouge">service-exporters</code>에서 <code class="language-plaintext highlighter-rouge">ports</code>로 외부에 노출시킨 포트(<code class="language-plaintext highlighter-rouge">9100</code>, <code class="language-plaintext highlighter-rouge">8081</code>)를 사용해야 한다.</li>
</ol>

<h3 id="restart-정책으로-always-대신-unless-stopped를-써야-한다"><code class="language-plaintext highlighter-rouge">restart</code> 정책으로 <code class="language-plaintext highlighter-rouge">always</code> 대신 <code class="language-plaintext highlighter-rouge">unless-stopped</code>를 써야 한다</h3>

<p>사실 항상 restart 의 정책이 어떻게 되는지 정확하게 알고 있지 못했기에 이번 기회에 알아보았다. 두 정책 모두 시스템 재부팅 시 컨테이너를 자동 재시작해준다. 하지만 결정적인 차이가 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">restart: always</code>: 관리자가 유지보수를 위해 <code class="language-plaintext highlighter-rouge">docker stop</code> 명령으로 컨테이너를 <em>수동 정지</em> 해도, Docker 데몬이 재시작되거나 시스템이 재부팅되면 컨테이너를 다시 켜버린다.</li>
  <li><code class="language-plaintext highlighter-rouge">restart: unless-stopped</code>: 관리자의 수동 정지 명령을 “존중”한다. 즉, 수동으로 정지된 컨테이너는 관리자가 명시적으로 다시 시작(<code class="language-plaintext highlighter-rouge">docker start</code>)하기 전까지는 꺼진 상태를 유지한다.</li>
</ul>

<p>이러한 결정적인 차이 때문에 유지보수 및 예측 가능성 측면에서 <code class="language-plaintext highlighter-rouge">unless-stopped</code>가 훨씬 안전한 정책이기에 향후엔 <code class="language-plaintext highlighter-rouge">unless-stopped</code>를 쓰려고 한다.</p>

<h3 id="prometheus_data-grafana_data를-gitignore에-추가해야-하는가"><code class="language-plaintext highlighter-rouge">prometheus_data</code>, <code class="language-plaintext highlighter-rouge">grafana_data</code>를 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 추가해야 하는가?</h3>

<p>설정을 찾아보다 보니, 볼륨의 연결이 필요했다. 이에 진행하면서, 해당 볼륨의 특성을 보았다. 처음엔 생성되는 것들이 git 으로 버전 관리되는걸로 하면 권한 문제가 생길 수 있다고 판단했었다. 하지만… <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 <strong>Named Volume</strong> (<code class="language-plaintext highlighter-rouge">grafana_data:/var/lib/grafana</code>)을 사용하기에 그럴 필요가 없다는 것을 배웠다.</p>

<ul>
  <li><strong>Named Volume:</strong> Docker가 관리하는 별도의 시스템 경로( <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/...</code>)에 데이터를 저장한다. Git 리포지토리 폴더 내에 파일이 생성되지 않으므로 <code class="language-plaintext highlighter-rouge">.gitignore</code>가 필요 없다.</li>
  <li><strong>Bind Mount:</strong> 만약 프로젝트 폴더에 직접 데이터를 저장하는 방식 (<code class="language-plaintext highlighter-rouge">./grafana_data:/var/lib/grafana</code>)을 사용했다면, 이 폴더는 Git이 추적하게 되므로 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 반드시 추가해야 했을 것이다.</li>
</ul>

<h3 id="prometheus와-grafana의-cpu메모리-제한은">Prometheus와 Grafana의 CPU/메모리 제한은?</h3>

<p>제한된 온프레미스 서버. 최적화된 설정을 위해 Docker 의 리소스 관리 기능을 활용하려고 생각하고, AI 와 이야기하며 현실적인 수준을 파악해보았다. 현재 설정된 리소스(Prometheus 0.5 CPU/512M, Grafana 0.3 CPU/256M)는 2대의 서버(호스트 2개 + 컨테이너 수십 개)를 모니터링하기에 충분히 넉넉하다는 판단 하에 설정하였다.</p>

<p>다만, 처음엔 이정도가 맞는가? 라는 의문은 가지고 있었다. 아무리 생각해도 이정도는 하고, 윈도우 95 시절인줄 알았지만…. AI가 제시한 의도를 보고 파악할 수 있었다. 이 리소스 제한의 주 목적은 성능 자체가 아니라, 만약의 버그나 매우 복잡한 쿼리로 인해 모니터링 컨테이너 하나가 서버의 전체 리소스를 고갈시켜, 모니터링 시스템은 물론 서버 전체를 다운시키는 것을 방지하는 ‘안전벽(safety wall)’ 역할을 하고, 그렇게 볼때 다소의 보수적인 설정은 충분히 설득력이 있었다.</p>

<h2 id="최종-설정-파일">최종 설정 파일</h2>

<p>위의 모든 과정을 거쳐 완성된 최종 설정 파일들이다.</p>

<h3 id="1-메인-서비스-서버-a5-server">1. 메인 서비스 서버 (A5 Server)</h3>

<p><code class="language-plaintext highlighter-rouge">service-exporters/docker-compose.yml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># main server watcher for monitoring structure 

services:
  #########################################################
  #  NodeExporter_Svc: 호스트 지표 (CPU, RAM, Disk)
  #########################################################
  node-exporter:
    image: prom/node-exporter:latest
    container_name: a5-node-exporter
    restart: unless-stopped
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
    pid: host
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: '64M'
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  #########################################################
  #  cAdvisor_Svc: 컨테이너 지표 (Docker)
  #########################################################
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: a5-cadvisor
    restart: unless-stopped
    ports:
      - "8081:8080" 
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    devices:
      - /dev/kmsg
    deploy:
      resources:
        limits:
          cpus: '0.15'
          memory: '128M'
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
</code></pre></div></div>

<h3 id="2-모니터링-서버-centre-server">2. 모니터링 서버 (Centre Server)</h3>

<p><code class="language-plaintext highlighter-rouge">monitoring-stack/docker-compose.yml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># monitoring structure + sub server watcher

services:
  #########################################################
  #  Prometheus: The core data collection service
  #########################################################
  prometheus:
    image: prom/prometheus:latest
    container_name: centre-prometheus
    restart: unless-stopped
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: '512M'

  #########################################################
  #  Grafana: The data visualization dashboard
  #########################################################
  grafana:
    image: grafana/grafana:latest
    container_name: centre-grafana
    restart: unless-stopped
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.3'
          memory: '256M'

  #########################################################
  #  NodeExporter_Mon: Host metrics for THIS server
  #########################################################
  node-exporter-mon:
    image: prom/node-exporter:latest
    container_name: centre-node-exporter
    restart: unless-stopped
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
    pid: host
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: '64M'

  #########################################################
  #  cAdvisor_Mon: Container metrics for THIS server
  #########################################################
  cadvisor-mon:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: centre-cadvisor
    restart: unless-stopped
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    devices:
      - /dev/kmsg
    networks:
      - my-central-proxy-network
    deploy:
      resources:
        limits:
          cpus: '0.15'
          memory: '128M'

#########################################################
#  Shared Volumes and Networks
#########################################################
volumes:
  prometheus_data:
  grafana_data:

networks:
  my-central-proxy-network:
    external: true
    name: my-central-proxy-network 
</code></pre></div></div>

<h3 id="3-모니터링-두뇌-prometheus-config">3. 모니터링 “두뇌” (Prometheus Config)</h3>

<p><code class="language-plaintext highlighter-rouge">monitoring-stack/prometheus/prometheus.yml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>global:
  scrape_interval: 15s # How often to scrape targets

scrape_configs:
  # 1. Monitor Prometheus itself (Internal)
  - job_name: 'prometheus'
    static_configs:
      - targets: ['centre-prometheus:9090']

  # 2. Monitor the monitoring server's HOST (Internal)
  - job_name: 'monitoring_host'
    static_configs:
      - targets: ['centre-node-exporter:9100']

  # 3. Monitor the monitoring server's CONTAINERS (Internal)
  - job_name: 'monitoring_containers'
    static_configs:
      # cAdvisor's default port inside the container is 8080
      - targets: ['centre-cadvisor:8080']

  # 4. Monitor the REMOTE main service server's HOST (External)
  - job_name: 'service_host'
    static_configs:
      # A5 Server's physical IP and exposed port
      - targets: ['192.168.0.37:9100']

  # 5. Monitor the REMOTE main service server's CONTAINERS (External)
  - job_name: 'service_containers'
    static_configs:
      # A5 Server's physical IP and exposed port
      - targets: ['192.168.0.37:8081']
</code></pre></div></div>

<h3 id="4-gitignore">4. <code class="language-plaintext highlighter-rouge">.gitignore</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.DS_Store
Thumbs.db
.env
*.env.local
docker-compose.override.yml
</code></pre></div></div>

<h2 id="결과">결과</h2>

<p>모든 설정이 완료되고, Grafana에서 <code class="language-plaintext highlighter-rouge">https://grafana.paulryu93.ddns.net</code>에서 모든걸 볼 수 있었다.</p>

<p><img src="/assets/images/posts/2025-11/20251105-008.png" alt="" /></p>

<p><strong>Node Exporter (monitoring_host) 대시보드:</strong>
<img src="/assets/images/posts/2025-11/20251105-009.png" alt="" />
<img src="/assets/images/posts/2025-11/20251105-010.png" alt="" /></p>

<p><strong>cAdvisor (monitoring_containers) 대시보드:</strong>
<img src="/assets/images/posts/2025-11/20251105-011.png" alt="" />
<img src="/assets/images/posts/2025-11/20251105-012.png" alt="" /></p>

<p>이제 두 서버의 모든 호스트 및 컨테이너 지표를 중앙에서 실시간으로 모니터링할 수 있게 되었다!</p>

<hr />

<p>아직 알람 기능이라거나, 디테일한 접근은 되지 않았다. 
그러나</p>
<ul>
  <li>G/B 방식의 무중단 배포와 이를 위한 CI/CD Jenkins 파이프라인 구축</li>
  <li>Next.js 기반의 SPA 어플리케이션 서버</li>
  <li>MSA 방식의 NestJS 와 AI를 위한 FastAPI 서버</li>
  <li>이 모든것을 감시하는 Monitoring의 Grafana + Prometheus 설정
은 앞으로 더욱 흥미 진진한 제대로 된 스케일러블 서비스 구축의 ingnition 이 될 것같다…ㅎ</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><category term="Monitoring" /><category term="Grafana" /><category term="Prometheus" /><summary type="html"><![CDATA[2025-11-05 : Monitoring 서버 구축하기]]></summary></entry><entry><title type="html">TIL - monitoring server 구축기 &amp;amp; 지옥같은 네트워크 문제 해결기..</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-monitoring-server.html" rel="alternate" type="text/html" title="TIL - monitoring server 구축기 &amp;amp; 지옥같은 네트워크 문제 해결기.." /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-monitoring-server</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-monitoring-server.html"><![CDATA[<h2 id="2025-10-31--2025-11-03--monitoring-서버-구축하기--네트워크-문제-해결하기">2025-10-31 ~ 2025-11-03 : Monitoring 서버 구축하기 &amp; 네트워크 문제 해결하기</h2>

<p>구축하고 있는 NextJS 와, MSA 백엔드 서비스, AI 에이전트를 위한 모니터링 시스템을 구축하고 이를 기반으로 지속적으로 서비스의 상태를 확인하며 프로젝트를 진행해 나가려고 한다.</p>

<hr />

<h2 id="서버-아키텍쳐-구조도">서버 아키텍쳐 구조도</h2>

<p><img src="/assets/images/assets/project-monitoring-diagram.png" alt="" /></p>

<h3 id="아키텍처-구성-요소-및-역할">아키텍처 구성 요소 및 역할</h3>

<h4 id="1-사용자-users">1. 사용자 (Users)</h4>
<ul>
  <li><strong>Admin (관리자):</strong> ‘모니터링 서버’의 <code class="language-plaintext highlighter-rouge">Nginx_Mon</code>을 통해 Grafana 대시보드에 접속하여 전체 서버 인프라의 상태를 확인한다.</li>
  <li><strong>Public User (일반 사용자):</strong> ‘메인 서비스 서버’의 <code class="language-plaintext highlighter-rouge">Frontend</code> 애플리케이션에 접속하여 실제 모니터링 되고 있는 내용 중 일부를 볼 수 있다.</li>
</ul>

<hr />

<h4 id="2-모니터링-서버-ryzen-3400g">2. 모니터링 서버 (Ryzen 3400G)</h4>
<ul>
  <li><strong>Nginx_Mon (HTTPS 프록시):</strong> Admin의 Grafana 접속 요청을 받아 HTTPS 암호화 통신을 처리하고, 내부의 Grafana 컨테이너로 요청을 전달(리버스 프록시)하는 게이트웨이이다.</li>
  <li><strong>Grafana (데이터 시각화):</strong> Prometheus에 저장된 모든 지표(메트릭) 데이터를 가져와 관리자가 한눈에 볼 수 있도록 다양한 대시보드를 시각화한다.</li>
  <li><strong>Prometheus (데이터 수집/저장):</strong> 모니터링의 핵심이다. 두 서버의 모든 Exporter로부터 주기적으로 지표를 수집(Scrape)하고 시계열 데이터베이스(TSDB)에 저장한다.</li>
  <li><strong>NodeExporter_Mon (호스트 지표):</strong> 모니터링 서버 자체의 CPU, 메모리, 디스크, 네트워크 사용량 등 하드웨어 자원 지표를 Prometheus에 제공한다.</li>
  <li><strong>cAdvisor_Mon (컨테이너 지표):</strong> 모니터링 서버에서 실행 중인 Docker 컨테이너(Prometheus, Grafana 등)들의 개별 리소스 사용량 지표를 Prometheus에 제공한다.</li>
</ul>

<hr />

<h4 id="3-메인-서비스-서버-모니터링-대상">3. 메인 서비스 서버 (모니터링 대상)</h4>

<ul>
  <li><strong>App_1 (Frontend):</strong> Public User에게 보여지는 웹 애플리케이션(Project Mini Frontend)이다.</li>
  <li><strong>App_2 (Backend):</strong> 서비스의 비즈니스 로직을 처리하는 NestJS 및 FastAPI 기반의 MSA 백엔드 API 서버이다.</li>
  <li><strong>NodeExporter_Svc (호스트 지표):</strong> 메인 서비스 서버 자체의 하드웨어 자원 지표(CPU, RAM 등)를 Prometheus에 제공한다.</li>
  <li><strong>cAdvisor_Svc (컨테이너 지표):</strong> 메인 서비스 서버에서 실행 중인 모든 서비스 컨테이너(App_1, App_2 등)의 리소스 사용량 지표를 Prometheus에 제공한다.</li>
</ul>

<h2 id="프로세스">프로세스</h2>

<ol>
  <li>
    <p><strong>1단계: GitHub 리포지토리 구조 설계 및 초기화</strong></p>

    <ul>
      <li>단일 리포지토리 내에 <strong>모니터링 스택</strong>(Prometheus, Grafana)과 <strong>Exporter 스택</strong>(Node Exporter, cAdvisor)의 구성을 분리할 디렉터리 구조를 설계합니다.</li>
      <li><em>예시 구조:</em>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /monitoring-infra
  ├── monitoring-stack/          # [모니터링 서버(Ryzen 3400G)용]
  │   ├── docker-compose.yml
  │   └── prometheus/
  │       └── prometheus.yml     # Prometheus 설정 파일
  └── service-exporters/         # [메인 서비스 서버용]
      └── docker-compose.yml
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>2단계: ‘service-exporters’ 구성 파일 작성</strong>
    <ul>
      <li>모니터링 대상 서버(메인 서비스 서버)에서 실행될 <code class="language-plaintext highlighter-rouge">service-exporters/docker-compose.yml</code> 파일을 작성합니다.</li>
      <li>이 파일은 <strong>Node Exporter</strong>와 <strong>cAdvisor</strong> 컨테이너를 실행하는 내용을 포함합니다.</li>
    </ul>
  </li>
  <li><strong>3단계: ‘monitoring-stack’ 구성 파일 작성</strong>
    <ul>
      <li>모니터링 서버(Ryzen 3400G)에서 실행될 <code class="language-plaintext highlighter-rouge">monitoring-stack/docker-compose.yml</code> 파일을 작성합니다.</li>
      <li>이 파일은 <strong>Prometheus</strong>와 <strong>Grafana</strong> 컨테이너를 실행하는 내용을 포함합니다.</li>
      <li>동시에 <code class="language-plaintext highlighter-rouge">monitoring-stack/prometheus/prometheus.yml</code> 설정 파일을 작성합니다. 이 파일에는 2단계에서 실행될 Exporter들(메인 서비스 서버의 IP)을 수집 대상으로 지정합니다.</li>
    </ul>
  </li>
  <li><strong>4단계: 각 서버에 배포 실행</strong>
    <ul>
      <li><strong>[메인 서비스 서버에서]</strong>
        <ol>
          <li>프로젝트 리포지토리를 <code class="language-plaintext highlighter-rouge">git pull</code> 합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">service-exporters</code> 디렉터리로 이동합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">docker-compose up -d</code>를 실행하여 Exporter들을 활성화합니다.</li>
        </ol>
      </li>
      <li><strong>[모니터링 서버(Ryzen 3400G)에서]</strong>
        <ol>
          <li>프로젝트 리포지토리를 <code class="language-plaintext highlighter-rouge">git pull</code> 합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">monitoring-stack</code> 디렉터리로 이동합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">docker-compose up -d</code>를 실행하여 Prometheus와 Grafana를 활성화합니다.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>5단계: Grafana 대시보드 구성</strong>
    <ul>
      <li>웹 브라우저로 Grafana에 접속합니다.</li>
      <li>Prometheus를 데이터 소스로 추가합니다.</li>
      <li>Node Exporter 및 cAdvisor 용 대시보드를 Import하여 모니터링을 시작합니다.</li>
    </ul>
  </li>
</ol>

<h2 id="문제-해결-및-개선-절차">문제 해결 및 개선 절차</h2>

<h3 id="1-초기-스택-배포">1. 초기 스택 배포</h3>
<ul>
  <li>Docker Compose를 활용하여 모니터링 스택(Prometheus, Grafana) 및 Exporter(Node Exporter, cAdvisor) 컨테이너의 기본 배포를 성공적으로 완료하였다.</li>
  <li>Jenkins 서버 이전을 대비한 Nginx 리버스 프록시 기본 구성을 완료하였다.</li>
</ul>

<h3 id="2-온프레미스-네트워크-다중화-구성">2. 온프레미스 네트워크 다중화 구성</h3>
<p>신규 모니터링 서버(Ryzen 3400G) 도입에 따라 발생한 네트워크 문제를 해결하는 과정이다.</p>
<h4 id="21-443-포트-점유-및-ddns-라우팅-이슈">2.1. 443 포트 점유 및 DDNS 라우팅 이슈</h4>
<ul>
  <li><strong>문제:</strong> 단일 공유기 환경에서는 443 포트(HTTPS)를 메인 서버와 모니터링 서버로 동시에 포트 포워딩할 수 없는 문제가 발생하였다.</li>
  <li><strong>분석:</strong> DDNS 서비스는 도메인을 공인 IP에 매핑할 뿐, 포트 레벨의 라우팅을 지원하지 않는다. 포트 분배는 라우터(NAT)의 역할이다.</li>
  <li><strong>1차 해결:</strong> 물리적 네트워크 분리를 위해 2번째 공유기와 USB 이더넷 어댑터를 도입하였다. 각 공유기에 별도의 공인 IP를 할당받아 443 포트 점유 문제를 해결하고자 시도하였다.</li>
</ul>

<h4 id="22-게이트웨이-및-서브넷-충돌">2.2. 게이트웨이 및 서브넷 충돌</h4>
<ul>
  <li><strong>문제:</strong> 두 공유기가 동일한 기본 서브넷(예: <code class="language-plaintext highlighter-rouge">192.168.0.x</code>)을 사용함에 따라 게이트웨이 충돌이 발생하였고, 이로 인해 서브 공유기의 관리 페이지 접근이 불가한 현상이 나타났다.</li>
  <li><strong>2차 해결:</strong> 서브 공유기의 LAN 및 DHCP 설정을 <code class="language-plaintext highlighter-rouge">192.168.10.x</code>와 같이 고유한 서브넷 대역으로 변경하여 네트워크를 논리적으로 분리하였다.</li>
</ul>

<h3 id="3-isp-제약-및-아키텍처-변경">3. ISP 제약 및 아키텍처 변경</h3>
<p>1, 2차 해결책이 ISP단의 제약으로 인해 새로운 문제에 직면하였다.</p>
<h4 id="31-공인-ip-다중-할당-제한">3.1. 공인 IP 다중 할당 제한</h4>
<ul>
  <li><strong>문제:</strong> ISP(KT) 모뎀에서 두 개의 공인 IP 할당 요청을 비정상적인 트래픽으로 간주, 특정 MAC 주소의 연결을 차단하는 문제가 발생하였다. 2.1에서 시도한 물리적 네트워크 분리(공유기 2대 사용)가 무효화되었다.</li>
  <li><strong>3차 해결 (아키텍처 변경):</strong>
    <ol>
      <li><strong>클라우드 프록시 도입:</strong> 단일 진입점(Single Entry Point)으로 GCP 가상 인스턴스(VM)를 배치하였다.</li>
      <li><strong>L4 프록시 전환:</strong> GCP의 Nginx를 L7(HTTP) 프록시가 아닌 L4(TCP) 프록시 모드로 설정하여 트래픽을 단순 전달(forwarding)하도록 하였다.</li>
      <li><strong>SSL Passthrough 적용:</strong> 클라우드 프록시는 SSL/TLS 암호화를 복호화하지 않고, 암호화된 트래픽(TCP)을 그대로 온프레미스 서버로 전달한다.</li>
      <li><strong>종단간 암호화 유지:</strong> SSL Termination (암호화 복호화)은 최종 목적지인 온프레미스 Nginx 서버에서 직접 처리하도록 구성하여 종단간 암호화를 유지한다.</li>
      <li><strong>Client IP 보존:</strong> <strong>Proxy Protocol</strong>을 활성화하여 L4 프록시 환경에서 유실될 수 있는 원본 클라이언트 IP를 백엔드 서버로 전달하였다.</li>
    </ol>
  </li>
  <li><strong>결과:</strong> GCP 인스턴스를 경유하여 온프레미스 서버의 특정 포트(8888, 8889 등)로 트래픽을 성공적으로 포워딩하는 것을 확인하였다.</li>
</ul>

<h3 id="4-현재-블로킹-이슈-물리적-인프라-장애국내-dhcp-환경의-특징---가정용만인듯">4. 현재 블로킹 이슈: 물리적 인프라 장애(국내 DHCP 환경의 특징 - 가정용만인듯?)</h3>
<ul>
  <li><strong>문제:</strong> ISP 모뎀 자체의 노후화 또는 물리적 결함으로 추정되는 인터넷 신호의 간헐적 끊김 현상이 발생하였다.</li>
  <li><strong>영향:</strong> 온프레미스 환경의 모든 서버(메인 서비스, 모니터링)가 외부에서 접근 불가능한 상태(unreachable)가 되었다.</li>
  <li><strong>현황:</strong> 모뎀 하드웨어 문제 해결 전까지 모든 서버 배포 및 설정 작업이 중단(Blocked)되었다. 현재는 문제 해결 과정을 문서화하며 대기 중이다. (후… KT)</li>
  <li><strong>분석 및 결론:</strong> 핵심 문제는 DHCP 관련된 문제였다고 발견되었다. 모뎀을 교체하여 신상으로 했는데도 동일 증상(붙었다 끊어졌다)가 반복 되었다. 
거기다 주기적으로 붙었다 떨어지는것, 공유기는 이상이 없는 것을 발견하였다.</li>
  <li>결국 설정을 뒤지다가 문제의 핵심이 ‘고정IP’ 라는 결론에 다다르게 된다. 
<img src="/assets/images/posts/2025-11/20251104-001.png" alt="" />
<img src="/assets/images/posts/2025-11/20251104-002.png" alt="" /></li>
  <li><strong>고정할당 문제:</strong> ISP 는 공인 IP 주소 풀을 독접 관리하고, 사용자에게 필요시 해당 IP 를 제공하는 방식을 사용한다. 그런데 여기서 기본적으로 임대를 해주는 개념이고 결과적으로 L2 레이어에서 요청-응답-승인-갱신 절차를 거친다. 문제는 거기서 내가 뭣도 모르고, 공유기를 ‘고정IP 방식’으로 했다. 내 의도는 내 공인 IP 를 그대로 유지해달라! 는 요청이었는데, 이건 제공하는 쪽과 수신하는 쪽, 사이에서 고정 할당을 해주고, 그 뒤에 고정 할당을 했을 때 문제가 없는 것이다..!</li>
  <li><strong>DHCP 규약:</strong> 일방적으로 설정해두면, 공유기는 더이상 승인요청을 하지 않고, 갱신 요청을 보내지 않게 된다….ㅠㅠ 결과적으로 최초에 설정하거나, 연결이 끊어진 직후에 인터넷 시그널을 보내면 처음 성공한 상태에서 사용 가능한 시점까지만 제공 =&gt; 갱신없음 =&gt; 공유기에서 인터넷 패킷이 들어오지 않음 의 연속이었던 것이다(….)</li>
  <li>고정 IP 로 변경이 DHCP 규약을 안따르겠다(갱신 안함)라는 의도를 포함한 설정이란 걸 몰랐기에 생긴 문제였다.</li>
  <li>KT 의 경우 ISP 에서 기본적으로 Sticky IP 정책을 쓰기 때문에 DHCP 프로토콜 규약은 지키지만, 어지간하면 IP 가 안바뀌고, 개인 프로젝트라면 문제가 없는 것으로 판단하고 유동IP 방식으로 변경하였다.</li>
</ul>

<h3 id="5-https-인증서-발급-certbot과-nginx-사이에-400-bad-request-오류-발생">5. HTTPS 인증서 발급 Certbot과 Nginx 사이에 <code class="language-plaintext highlighter-rouge">400 Bad Request</code> 오류 발생</h3>

<p>GCP(Google Cloud Platform) VM에 Nginx를 설치하여 프록시 서버로 구성했다. 목적은 443 포트(TLS)와 80 포트(HTTP)로 들어오는 트래픽을 내부망에 있는 ‘Centre 서버’로 전달(proxy pass)하는 것이다.</p>

<p>이후 HTTPS 인증서를 발급받기 위해 Centre 서버에서 Certbot을 실행했으나, <code class="language-plaintext highlighter-rouge">400 Bad Request</code> 오류가 발생하며 인증이 계속 실패했다.</p>

<p>브라우저 개발자 도구로 확인 결과, 이 <code class="language-plaintext highlighter-rouge">400</code> 오류는 최종 목적인 Centre 서버가 아닌, 요청의 맨 앞단인 <strong>GCP 프록시 서버(<code class="language-plaintext highlighter-rouge">35.197.5.162</code>)</strong>가 직접 반환하는 것을 확인했다.</p>

<p>이번 문제의 핵심은 서로 다른 원인을 가진 두 개의 <code class="language-plaintext highlighter-rouge">400</code> 오류가 겹쳐 있었던 것이다.</p>

<h4 id="1-gcp-서버-stream과-http-모듈-충돌-핵심-원인">1. GCP 서버: <code class="language-plaintext highlighter-rouge">stream</code>과 <code class="language-plaintext highlighter-rouge">http</code> 모듈 충돌 (핵심 원인)</h4>

<ul>
  <li>
    <p><strong>원인:</strong> GCP 서버의 Nginx 설정(<code class="language-plaintext highlighter-rouge">nginx_target.conf</code>)이 443 포트와 80 포트 모두를 <code class="language-plaintext highlighter-rouge">stream</code> (TCP) 모듈로 처리하도록 되어 있었다.</p>
  </li>
  <li>
    <p><strong>충돌:</strong> Certbot과 브라우저는 80 포트에 <code class="language-plaintext highlighter-rouge">http</code> (<code class="language-plaintext highlighter-rouge">GET /...</code>) 요청을 보냈다. Nginx의 <code class="language-plaintext highlighter-rouge">stream</code> 모듈은 <code class="language-plaintext highlighter-rouge">http</code> 문법을 이해하지 못하므로, 이를 ‘형식에 맞지 않는 요청’으로 간주하여 <code class="language-plaintext highlighter-rouge">400</code> 오류를 반환했다.</p>
  </li>
  <li>
    <p><strong>해결:</strong> GCP 서버 Nginx 설정을 ‘하이브리드’ 모드로 수정했다. 443 포트는 <code class="language-plaintext highlighter-rouge">stream</code> 블록(TCP 프록시)으로 유지하되, 80 포트는 <code class="language-plaintext highlighter-rouge">http</code> 블록으로 분리하여 <code class="language-plaintext highlighter-rouge">proxy_pass</code> (HTTP 프록시)로 Centre 서버에 정상 전달되도록 조치했다.</p>
  </li>
</ul>

<h4 id="2-centre-서버-server_name-해시-버킷-제한">2. Centre 서버: <code class="language-plaintext highlighter-rouge">server_name</code> 해시 버킷 제한</h4>

<ul>
  <li>
    <p><strong>원인:</strong> Centre 서버의 Nginx 설정(<code class="language-plaintext highlighter-rouge">nginx_init.conf</code>)은 4개의 긴 도메인 이름을 하나의 <code class="language-plaintext highlighter-rouge">server_name</code> 지시어에 모두 나열했다. 이는 Nginx의 기본 <code class="language-plaintext highlighter-rouge">server_names_hash_bucket_size</code> (이름 처리 메모리) 제한을 초과하여 <code class="language-plaintext highlighter-rouge">400</code> 오류를 유발할 수 있는 잠재적 문제였다.</p>
  </li>
  <li>
    <p><strong>해결:</strong> <code class="language-plaintext highlighter-rouge">http</code> 블록 자체의 메모리(<code class="language-plaintext highlighter-rouge">server_names_hash_bucket_size 64;</code>)를 늘리는 대신, <code class="language-plaintext highlighter-rouge">server</code> 블록을 4개로 분리하여 각 블록이 1개의 <code class="language-plaintext highlighter-rouge">server_name</code>만 처리하도록 구조를 변경함으로써 문제를 우회하고 해결했다.</p>
  </li>
</ul>

<hr />

<h4 id="현상황-duckdns-네임서버-응답-대기">현상황: DuckDNS 네임서버 응답 대기</h4>

<p>GCP 서버와 Centre 서버의 Nginx 설정이 모두 완료되었다.</p>

<ul>
  <li>
    <p><strong>검증:</strong> 브라우저로 80 포트 접속 시, 의도했던 대로 GCP 프록시를 거쳐 Centre 서버의 Nginx가 <code class="language-plaintext highlighter-rouge">404 Not Found</code>를 정상적으로 반환한다.</p>
  </li>
  <li>
    <p><strong>로그:</strong> Centre 서버의 Nginx 로그에도 Certbot의 <code class="language-plaintext highlighter-rouge">.well-known</code> 경로 접근이 <code class="language-plaintext highlighter-rouge">200 OK</code>로 성공 처리된 것이 확인되었다.</p>
  </li>
  <li>
    <p><strong>현재 문제:</strong> Nginx 설정은 완벽하지만, Certbot은 <code class="language-plaintext highlighter-rouge">DNS problem: SERVFAIL</code> 오류를 반환하며 여전히 실패한다.</p>
  </li>
  <li>
    <p><strong>원인:</strong> <code class="language-plaintext highlighter-rouge">SERVFAIL</code>은 로컬 Nginx 설정 문제가 아니다. Let’s Encrypt 인증 서버가 <strong>DuckDNS 네임서버</strong>에 DNS 조회를 시도했으나, DuckDNS 서버가 불안정하여 “서버 실패(Server Failure)” 응답을 반환한 것이다.</p>
  </li>
  <li>
    <p><strong>상태:</strong> 모든 로컬 및 프록시 설정은 완료되었으며, DuckDNS 네임서버가 안정화되고 Let’s Encrypt의 ‘실패 캐시’가 만료되기를 <strong>대기 중</strong>이다.</p>
  </li>
</ul>

<h3 id="6-nginx-jenkins-n8n-서버-구축">6. Nginx, Jenkins, n8n 서버 구축</h3>
<p>우선 안된 HTTPS 를 연결할 수 없으니 일단 HTTP 상태에서 세팅을 해보았다.</p>
<h4 id="1-nginx">1. Nginx</h4>
<ul>
  <li><strong>설정 파일 수정</strong> :
    <div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">server</span> {
      <span class="n">listen</span> <span class="m">80</span>;
      <span class="n">server_name</span> {도메인};

      <span class="c"># Certbot 인증 경로
</span>      <span class="c"># 흑흑 얼른 되라고...
</span>      <span class="n">location</span> /.<span class="n">well</span>-<span class="n">known</span>/<span class="n">acme</span>-<span class="n">challenge</span>/ {
          <span class="n">root</span> /<span class="n">var</span>/<span class="n">www</span>/<span class="n">certbot</span>;
      }

      <span class="n">location</span> / {
          <span class="c"># Docker 이미지의 기본 Host 가 정해진다. 
</span>          <span class="c"># n8n 의 경우 http://n8n-server:5678 이다
</span>          <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">jenkins</span>-<span class="n">server</span>:<span class="m">8080</span>; 
          <span class="n">proxy_set_header</span> <span class="n">Host</span> $<span class="n">host</span>;
          <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span> $<span class="n">remote_addr</span>;
          <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">For</span> $<span class="n">proxy_add_x_forwarded_for</span>;
          <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">Proto</span> $<span class="n">scheme</span>;
      }
  }
</code></pre></div>    </div>
  </li>
  <li><strong>네트워크 공유:</strong>
    <ul>
      <li>도커 네트워크를 연결해야 한다. 하지만 개별 프로젝트로 관리되고 있는 상황에서 이걸 일일히 다시 하나의 Docker-compose 파일로 모으는 건 비효율적이라고 생각. 각자 사용하게 만들기 위해선 다음과 같이 하면된다.
        <ol>
          <li><code class="language-plaintext highlighter-rouge">docker network create {명칭}</code>: 해당 명령어로 네트워크를 미리 사전에 설정해둔다.</li>
          <li>각각의 컴포즈 파일에 <code class="language-plaintext highlighter-rouge">network</code> 항목에 해당 네트워크 명칭을 작성, <code class="language-plaintext highlighter-rouge">networks</code> 항목에 해당 항목을 기재하고 <code class="language-plaintext highlighter-rouge">external: true</code> 라고 넣으면 된다.
            <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="s">... 전략</span>
			
     <span class="na">networks</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="s">my-central-proxy-network</span>

 <span class="na">networks</span><span class="pi">:</span>
   <span class="na">my-central-proxy-network</span><span class="pi">:</span>
     <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div>            </div>
          </li>
          <li>제대로 proxy 전달에 대해서만 가리키고 있다면, 이것으로 HTTP 접속은 구현된다.
            <h4 id="2-jenkins-서버-백업-및-복구">2. Jenkins 서버 백업 및 복구</h4>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>백업하기:</strong>
    <ul>
      <li>기본적으로 Jenkins 는 jenkins_home 이라는 폴더 내부 데이터를 통째로 옮기면 백업과 복원이 용이한 구조다. 이를 위해 볼륨도 호스트와 공유하도록 설정했다면, 손쉽게 통째로 백업 및 복원하면 된다.</li>
      <li><code class="language-plaintext highlighter-rouge">tar -pczvf [압축파일명] [압축 대상 폴더]</code>: p 가 중요한데, 단순히 진행하게 되면 소유권 문제가 발생할 수 있다(시스템의 유저명칭 등이 같더라도 UID, GID 등의 불일치 문제가 발생할 수 있으므로) 이때 해당 옵션을 추가시 해당 기록까지 그대로 가져가준다.</li>
    </ul>
  </li>
  <li><strong>복원하기:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tar -xzvf [대상 압축파일명]</code>: jenkins_home 동일하게 진행해주면 되고, 젠킨스 컨테이너를 재시작하면 완벽하게 복원된다.</li>
    </ul>
  </li>
  <li><strong>문제상황:</strong> DooD 권한실패…!
    <ul>
      <li>DooD 구조를 하다보니 GID 가 같지 않으면 안되는데, 이게 아무래도 확실히 다를 수 밖에 없었다. 기존 메인 서버의 임시 Jenkins 서버는 1001 번이었지만, 이번 서버는 998번(…)</li>
      <li>자동으로 스크립트로 따오게 만들기도 가능하겠지만, 시간관계상 일단 하드코딩으로 Dockerfile에서 이를 설정해주는 작업을 해주었다.
        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ARG DOCKER_GID=984
  RUN groupadd -g ${DOCKER_GID} docker
  RUN usermod -aG docker jenkins
</code></pre></div>        </div>
      </li>
      <li>DooD 랑 호스트의 도커 시스템을 마운트하여도커 컨테이너 내부에서 호스트를 이용해 빌드를 하는 방식이다. 이를 통해 호스트 자원을 그대로 가져다 쓰고, 제어만 커테이너가 하게 된다. 단, 권한 문제를 비롯 제어시 민감한 부분들을 설정을 잘 해줄 필요가 있다.
        <h4 id="3-n8n-서버-http-상에서-열어주기">3. n8n 서버 HTTP 상에서 열어주기</h4>
      </li>
    </ul>
  </li>
  <li><strong>환경변수 설정:</strong> HTTP 환경에선 쓰지 못하게 하는 것이 기본이다. 당연히 종단간 암호화가 안된 상태에서 이걸 진행하게 되면 누군가가 볼 가능성이 당연히 너무 크고, 따라서 중간 탈취를 막아야 하기 때문이다. 그러나 부득불 공개를 해야 한다 or 해도 된다면(내부망 사용 등) 환경 변수를 설정하면된다.
    <pre><code class="language-docker-compose.yml">      environment:
        - GENERIC_TIMEZONE=${GENERIC_TIMEZONE}
        - N8N_SECURE_COOKIE=false # 1. HTTPS가 아니어도 쿠키 사용 허용
        - WEBHOOK_URL=${WEBHOOK_URL} # 2. n8n의 공개 주소 설정
</code></pre>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><category term="Monitoring" /><summary type="html"><![CDATA[2025-10-31 ~ 2025-11-03 : Monitoring 서버 구축하기 &amp; 네트워크 문제 해결하기]]></summary></entry><entry><title type="html">TIL - HTTPS 인증 받기, 그리고 NPM 도입</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-npm-plus-server.html" rel="alternate" type="text/html" title="TIL - HTTPS 인증 받기, 그리고 NPM 도입" /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-npm-plus-server</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/11/04/til-npm-plus-server.html"><![CDATA[<h2 id="2025-11-04--https-인증-받기-그리고-npm-도입">2025-11-04 : HTTPS 인증 받기, 그리고 NPM 도입</h2>

<p>다시 HTTPS 인증을 받으려고 해보았다. 이젠 서버에 등록도 되었겠지. Fail 캐싱도 해결되서 문제 없겠지 라는 생각으로 해보았다.</p>

<p><img src="/assets/images/posts/2025-11/20251104-003.png" alt="" /></p>
<blockquote>
  <p>으아ㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㄱㄱㄱㄱㄱㄱㄱㄱㄱㄱ</p>
</blockquote>

<p>내 시간을 도대체 얼마나 잡아 먹을 생각인가 DuckDNS!!! 라는 생각을 하고 검색으로 문제 해결 방법을 조사해보았다.</p>

<p>그러다 알게된 유사한 경험의 <a href="https://www.reddit.com/r/selfhosted/comments/1j2nkmv/dns_challenge_with_duckdnsorg_timeouts_and/">Reddit 글</a>. 답변을 확인해보니 다음과 같았다.</p>

<ol>
  <li>DNSSE 쿼리 처리가 걍 영구적으로 문제 있음</li>
  <li>HTTPS 인증 요청하면 아마 답 자체를 안하게 됨.</li>
  <li>그러면 님 무조건 timeout 발생함</li>
</ol>

<p>(….)</p>

<p>DuckDNS 의 영구적 문제가 있다는 걸 발견하자 오히려 마음이 편해졌다. 그리하여 NoIP 의 서비스를 구매. 어차피 쓸꺼 하고 화끈하게 2년치 구매를 해버렸다…내 십만원..흑흑 앞으로도 서비스를 만들수도 있으니..</p>

<p>어쨌든 그렇게 하고 보니 NPM 서비스라는 것을 발견하여 해당 방식을 적용 후기이다. <del>가즈아</del></p>

<hr />

<h2 id="nginx-proxy-manager-npm란-무엇인가">Nginx Proxy Manager (NPM)란 무엇인가?</h2>

<p>Nginx Proxy Manager(NPM)는 오픈소스 프로젝트 중 하나로, 강력한 웹 서버인 <strong>Nginx</strong>를 기반으로 한다.
Nginx의 핵심 기능 중 하나인 ‘리버스 프록시’를 누구나 쉽게 사용할 수 있도록 <strong>웹 기반의 그래픽 사용자 인터페이스(GUI)</strong> 를 제공하는 데 목적이 있다.
터미널에 접속하여 복잡한 <code class="language-plaintext highlighter-rouge">.conf</code> 설정 파일을 직접 작성하는 대신, 사용자는 웹 브라우저로 NPM 관리자 페이지(예: <code class="language-plaintext highlighter-rouge">http://서버IP:81</code>)에 접속하여 마우스 클릭과 폼 입력만으로 모든 설정을 완료할 수 있다.</p>

<h2 id="npm의-핵심-기능">NPM의 핵심 기능</h2>

<p>NPM이 제공하는 주요 기능은 크게 세 가지로 나눌 수 있다.</p>

<h3 id="1-리버스-프록시-reverse-proxy-관리">1. 리버스 프록시 (Reverse Proxy) 관리</h3>

<ul>
  <li><strong>호스트 기반 라우팅:</strong> 단일 공인 IP 주소와 80/443 포트를 사용하더라도, <code class="language-plaintext highlighter-rouge">jenkins.yourdomain.com</code>, <code class="language-plaintext highlighter-rouge">n8n.yourdomain.com</code> 등 서로 다른 도메인/서브도메인 요청을 받아, 내부의 각기 다른 서비스(예: <code class="language-plaintext highlighter-rouge">localhost:8080</code>, <code class="language-plaintext highlighter-rouge">localhost:5678</code>)로 정확하게 연결(전달)해준다.</li>
  <li><strong>간편한 설정:</strong> GUI의 ‘Proxy Hosts’ 메뉴에서 도메인 이름, 내부 IP 주소, 내부 포트만 입력하면 즉시 리버스 프록시 설정이 완료된다.</li>
</ul>

<h3 id="2-ssl-인증서-자동화-lets-encrypt">2. SSL 인증서 자동화 (Let’s Encrypt)</h3>

<ul>
  <li><strong>원클릭 SSL:</strong> Let’s Encrypt와 완벽하게 연동되어, GUI에서 스위치 하나만 켜면 자동으로 SSL 인증서를 발급받고 Nginx에 적용한다.</li>
  <li><strong>인증서 자동 갱신:</strong> 발급받은 인증서가 만료되기 전에 자동으로 갱신(Renew)하여 HTTPS가 중단되지 않게 한다.</li>
  <li><strong>DNS-01 챌린지 지원:</strong> (한솔의 현재 상황에 핵심) NoIP, Cloudflare 등 주요 DNS 서비스의 API를 지원한다. GUI에 API 키(또는 계정 정보)를 입력하면, <strong>와일드카드 인증서(<code class="language-plaintext highlighter-rouge">*.yourdomain.com</code>)</strong>를 복잡한 과정 없이 자동으로 발급받을 수 있다.</li>
</ul>

<h3 id="3-기타-편의-기능">3. 기타 편의 기능</h3>

<ul>
  <li><strong>접근 제어 (Access Lists):</strong> 특정 도메인에 대해 IP 기반 접근 제한 또는 사용자 로그인(HTTP Basic Auth)을 쉽게 설정할 수 있다.</li>
  <li><strong>리디렉션 (Redirection):</strong> 특정 주소로 들어온 요청을 다른 주소로 강제 이동(예: HTTP를 HTTPS로)시키는 규칙을 쉽게 생성한다.</li>
</ul>

<h2 id="왜-nginx-대신-npm을-사용하는가">왜 Nginx 대신 NPM을 사용하는가?</h2>

<ul>
  <li><strong>압도적인 편의성:</strong> Nginx 원본(Raw Nginx)은 모든 설정을 텍스트 파일(<code class="language-plaintext highlighter-rouge">nginx.conf</code>)로 관리한다. 문법이 복잡하고, 서비스 하나를 추가할 때마다 SSH 접속, 파일 수정, 문법 검사(<code class="language-plaintext highlighter-rouge">nginx -t</code>), 서비스 재시작(<code class="language-plaintext highlighter-rouge">reload</code>) 과정을 거쳐야 한다. NPM은 이 모든 것을 웹 GUI의 ‘저장’ 버튼 하나로 끝낸다.</li>
  <li><strong>SSL 설정의 간소화:</strong> 원본 Nginx에서 Let’s Encrypt를 쓰려면 ‘Certbot’이라는 별도 도구를 설치하고, Nginx와 연동하는 복잡한 명령어를 실행하며, 갱신을 위한 <code class="language-plaintext highlighter-rouge">cron</code> 작업을 수동으로 등록해야 한다. NPM은 이 모든 과정을 내부적으로 자동화했다.</li>
  <li><strong>낮은 진입 장벽:</strong> Nginx에 대한 깊은 지식이 없어도, NPM의 직관적인 GUI를 통해 누구나 강력한 리버스 프록시 환경을 구축할 수 있다.
<img src="/assets/images/posts/2025-11/20251104-004.png" alt="" /></li>
</ul>

<hr />
<h2 id="문제-해결-과정">문제 해결 과정</h2>
<h3 id="wildcard-ddns-실패">wildcard DDNS 실패</h3>
<ul>
  <li>NoIP 기준 wildcard 방식으로 url 을 설정하는 것이 가능하다.</li>
  <li>이렇게 설정하면 다행이(?) DNS 자리를 줄일 수 있었다. 
<img src="/assets/images/posts/2025-11/20251104-005.png" alt="" /></li>
</ul>

<blockquote>

  <ul>
    <li>그런데 이경우 HTTPS 설정을 해야 하는데, 이때는 방식 두 가지 중 하나로 가능하다.
      <ul>
        <li><strong>HTTP-01 방식:</strong> 개별 URL에 대해서 처리하는 방식</li>
        <li><strong>DNS-01 챌린지 방식:</strong> 특정 사이트 URL 이 소유주가 있음을 인정하여 직접 제어하고, 해당 도메인을 아예 인정해버리는 것. =&gt; 이걸 활용해야 원래는 wildcard 방식의 도메인 접근가능</li>
      </ul>
    </li>
    <li>하필이면… NoIP 는 DNS 프로바이더로  없었다. DNS-01 방식은 공용 포트도 불필요, 와일드카드를 위한 인증서용인데 어쩔수 없이 기본적인 HTTP-01 방식으로 마무리 했다. 
<img src="/assets/images/posts/2025-11/20251104-006.png" alt="" /></li>
    <li>HTTP-01 방식은 전통적인 nginx 의 설정을 그대로 옮긴다고 보면 되었다. 
<img src="/assets/images/posts/2025-11/20251104-007.png" alt="" /></li>
  </ul>
</blockquote>

<hr />

<p>하.. DNS-01 방식으로 삽질을 했다. 그런데 안된다는 걸 깨닫고 빠르게 하니 거의 10분? 이 안걸렸다.</p>

<p>다음부턴 NPM + 쉽게 연결하기로 해결해야지 ㅠ..</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><category term="Monitoring" /><summary type="html"><![CDATA[2025-11-04 : HTTPS 인증 받기, 그리고 NPM 도입]]></summary></entry><entry><title type="html">TIL - NextJS 데모 페이지 구축 (001)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/29/til-nextjs.html" rel="alternate" type="text/html" title="TIL - NextJS 데모 페이지 구축 (001)" /><published>2025-10-29T00:00:00+00:00</published><updated>2025-10-29T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/29/til-nextjs</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/29/til-nextjs.html"><![CDATA[<h2 id="2025-10-29--nextjs-프론트엔드-핵심-개념들">2025-10-29 : Next.js 프론트엔드 핵심 개념들</h2>

<p>오늘은 Next.js와 React를 사용한 프론트엔드 개발을 진행하고 몇 가지 핵심 개념을 살펴보았다. 백엔드 개발자에게 생소할 수 있는 개념들을 위주로 더 자세히 정리하고 코드 예시를 포함했다.</p>

<hr />

<h2 id="-백엔드-개발자가-알아두면-좋은-프론트엔드-개념">💡 백엔드 개발자가 알아두면 좋은 프론트엔드 개념</h2>

<h3 id="1-컴포넌트-렌더링-서버-컴포넌트-vs-클라이언트-컴포넌트-️-vs-">1. 컴포넌트 렌더링: 서버 컴포넌트 vs 클라이언트 컴포넌트 🖥️ vs 💻</h3>

<p>Next.js는 컴포넌트를 <strong>서버</strong>에서 그릴지(HTML 완성) <strong>클라이언트(브라우저)</strong> 에서 그릴지(JavaScript 사용) 결정할수 있다. 이는 백엔드의 서버 사이드 렌더링(SSR) vs 프론트엔드의 클라이언트 사이드 렌더링(CSR) 개념과 유사합니다.</p>
<ul>
  <li><strong>컴포넌트</strong> :
    <ul>
      <li><strong>개념</strong> : 사용자 인터페이스에서 재사용, 독립적인 조각으로 나누어 개발하는 방식으로 생성되는 대상.
        <ul>
          <li>Next.js 는 React를 기반으로 하여, React의 컴포넌트 개념을 그대로 따라간다.</li>
        </ul>
      </li>
      <li><strong>종류</strong> :
        <ul>
          <li><strong>함수 컴포넌트</strong> :
            <ul>
              <li>일반적인 형태</li>
              <li><code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>와 같은 React 훅을 사용하여 상태와 생명주기 기능을 활용 가능</li>
            </ul>
          </li>
          <li><strong>클래스 컴포넌트</strong>
            <ul>
              <li>ES6클래스로 작성됨.</li>
              <li>최신 React 개발에선 함수형을 권장함 .</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>Next.js에서 컴포넌트를 사용하는 이유</strong>
        <ul>
          <li>코드 구조화 및 관리 용이성</li>
          <li>개발 생산성 향상</li>
          <li>성능 최적화</li>
          <li>모듈화</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>서버 컴포넌트 (Server Component, RSC - 기본값):</strong>
    <ul>
      <li><strong>개념:</strong> 컴포넌트 코드가 서버에서 실행되어 최종 HTML로 변환된 후 브라우저로 전송된다. NestJS에서 <code class="language-plaintext highlighter-rouge">EJS</code>나 <code class="language-plaintext highlighter-rouge">Handlebars</code> 같은 템플릿 엔진을 사용해 HTML을 완성해서 보내는 것과 비슷하다.</li>
      <li><strong>장점:</strong>
        <ul>
          <li><strong>초기 로딩 속도:</strong> 브라우저는 완성된 HTML을 바로 보여줄 수 있어 초기 로딩이 빠르다.</li>
          <li><strong>SEO:</strong> 검색 엔진 봇이 완성된 HTML 컨텐츠를 쉽게 수집할 수 있다.</li>
          <li><strong>서버 자원 접근:</strong> DB 조회, 파일 시스템 접근 등 서버에서만 가능한 작업을 직접 수행할 수 있다.</li>
          <li><strong>번들 크기 감소:</strong> 서버에서만 실행되므로 브라우저로 보내는 JavaScript 양이 줄어든다.</li>
        </ul>
      </li>
      <li><strong>제한:</strong> 사용자와의 상호작용(클릭, 입력 등)이나 브라우저 상태(예: <code class="language-plaintext highlighter-rouge">window</code> 객체)에 구조적으로 접근할 수 없다. 즉, <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">onClick</code> 등을 사용할 수 없다.</li>
    </ul>
  </li>
  <li><strong>클라이언트 컴포넌트 (Client Component):</strong>
    <ul>
      <li><strong>개념:</strong> 파일 맨 위에 <code class="language-plaintext highlighter-rouge">"use client";</code> 지시어를 추가하여 명시하면 사용이 가능해짐. 이 컴포넌트의 JavaScript 코드는 브라우저로 다운로드되고 실행된다. 우리가 흔히 아는 React 컴포넌트.</li>
      <li><strong>장점:</strong>
        <ul>
          <li><strong>상호작용:</strong> <code class="language-plaintext highlighter-rouge">useState</code> (상태 관리), <code class="language-plaintext highlighter-rouge">useEffect</code> (라이프사이클 관리), <code class="language-plaintext highlighter-rouge">onClick</code> (이벤트 핸들링) 등을 사용하여 동적인 사용자 인터페이스를 만들 수 있다.</li>
          <li><strong>브라우저 API 접근:</strong> <code class="language-plaintext highlighter-rouge">localStorage</code>, <code class="language-plaintext highlighter-rouge">window</code> 객체 등 브라우저 환경에서만 사용 가능한 API를 활용할 수 있다.</li>
        </ul>
      </li>
      <li><strong>단점:</strong>
        <ul>
          <li><strong>초기 로딩:</strong> 브라우저가 JavaScript 파일을 다운로드하고 실행해야 컴포넌트가 그려지므로, 서버 컴포넌트보다 초기 로딩이 느릴 수 있다(Hydration 과정 필요).</li>
          <li><strong>번들 크기 증가:</strong> 브라우저로 보내는 JavaScript 양이 늘어나고 이는 트래픽이다.</li>
        </ul>
      </li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx 맨 위에 추가하여 클라이언트 컴포넌트임을 명시
  "use client";
    
  import { useState } from 'react';
    
  export default function MyInteractiveComponent() {
    const [count, setCount] = useState(0);
    
    return (
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt; // 버튼 이벤트 
                Count: {count}
      &lt;/button&gt;
    );
  }
</code></pre>
  </li>
</ul>

<h3 id="2-상태state-관리와-리렌더링-usestate-훅-">2. 상태(State) 관리와 리렌더링: <code class="language-plaintext highlighter-rouge">useState</code> 훅 🔄</h3>

<p>React 컴포넌트는 UI에 영향을 미치는 <strong>상태(State)</strong> 를 가질 수 있다. <code class="language-plaintext highlighter-rouge">useState</code>는 함수 컴포넌트에서 상태를 추가하고 관리하기 위한 <strong>훅(Hook)</strong> 이다.</p>
<ul>
  <li><strong>훅(Hook):</strong> 함수 컴포넌트에서 React의 기능(상태 관리, 라이프사이클 등)을 “연결(hook into)”할 수 있게 해주는 특별한 함수들이다. <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useContext</code> 등이 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">useState</code> 사용법:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">const [stateVariable, setStateFunction] = useState(initialState);</code></li>
      <li><code class="language-plaintext highlighter-rouge">stateVariable</code>: 현재 상태 값을 저장하는 변수 (읽기 전용).</li>
      <li><code class="language-plaintext highlighter-rouge">setStateFunction</code>: 이 상태 값을 <strong>업데이트하는 함수</strong>. 이 함수를 호출해야만 React가 컴포넌트를 <strong>리렌더링(Re-render)</strong> 하여 변경된 상태를 화면에 반영한다.</li>
      <li><code class="language-plaintext highlighter-rouge">initialState</code>: 상태의 초기값. 컴포넌트가 처음 렌더링될 때 사용하다.</li>
    </ul>
  </li>
  <li><strong>백엔드와의 비교:</strong>
    <ul>
      <li>상태는 DB에 저장되는 영구 데이터와는 다르게 컴포넌트 인스턴스가 살아있는 동안만 유지되는 <strong>메모리상의 임시 데이터</strong>이다 (NestJS 서비스의 멤버 변수와 유사)</li>
      <li>가장 큰 차이점은 React는 <code class="language-plaintext highlighter-rouge">setStateFunction</code> 호출을 통해 상태 변경을 감지하고, <strong>선언적으로(declaratively)</strong> UI를 업데이트한다는 점이다 . 개발자는 “상태를 이렇게 바꿔줘”라고만 명령하면, React가 알아서 DOM을 효율적으로 조작하여 화면을 변경한다.</li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx
  "use client";
    
  import { useState } from 'react';
    
  // ... (projects 배열 정의)
    
  export default function Home() {
    // isProjectsOpen: 현재 프로젝트 목록이 열려있는지 여부 (true/false)
    // setIsProjectsOpen: isProjectsOpen 값을 변경하는 함수
    // useState(false): 초기값은 false (닫힌 상태)
    const [isProjectsOpen, setIsProjectsOpen] = useState(false);
    
    // 버튼 클릭 시 호출될 함수
    const toggleProjects = () =&gt; {
      // 현재 isProjectsOpen 값의 반대값으로 상태를 업데이트 (일종의 업데이트 )
      setIsProjectsOpen(!isProjectsOpen);
    };
    
    return (
      // ... (생략)
      &lt;button
        onClick={toggleProjects} // 버튼 클릭 시 toggleProjects 함수 실행
        aria-expanded={isProjectsOpen}
      &gt;
        {/* ... SVG 아이콘 ... */}
      &lt;/button&gt;
      // ...
      {isProjectsOpen &amp;&amp; ( // isProjectsOpen이 true일 때만 하위 목록 렌더링
        &lt;ul&gt;
          {/* ... 프로젝트 링크 목록 ... */}
        &lt;/ul&gt;
      )}
      // ...
    );
  }
    
</code></pre>
  </li>
</ul>

<h3 id="3-스타일링-tailwind-css-유틸리티-우선-접근법-">3. 스타일링: Tailwind CSS 유틸리티 우선 접근법 🎨</h3>

<p>Tailwind CSS는 미리 정의된 수많은 <strong>유틸리티 클래스</strong>를 제공한다. 개발자는 이러한 클래스들을 HTML 요소의 <code class="language-plaintext highlighter-rouge">className</code> 속성에 직접 조합하여 스타일을 적용 할 수 있다.</p>

<ul>
  <li><strong>유틸리티 우선(Utility-First):</strong> <code class="language-plaintext highlighter-rouge">button-primary</code> 같은 <strong>의미론적(semantic)</strong> 클래스 대신, <code class="language-plaintext highlighter-rouge">bg-blue-600</code>, <code class="language-plaintext highlighter-rouge">py-3</code>, <code class="language-plaintext highlighter-rouge">font-semibold</code> 같이 <strong>시각적 기능</strong>에 집중된 작은 클래스들을 조합한다.</li>
  <li><strong>작동 방식:</strong>
    <ol>
      <li>개발자가 <code class="language-plaintext highlighter-rouge">className="text-center font-bold"</code>라고 작성한다</li>
      <li>빌드 시 Tailwind CSS가 프로젝트 내의 모든 <code class="language-plaintext highlighter-rouge">className</code>을 스캔한다.</li>
      <li>사용된 유틸리티(<code class="language-plaintext highlighter-rouge">text-center</code>, <code class="language-plaintext highlighter-rouge">font-bold</code>)에 해당하는 CSS 규칙(<code class="language-plaintext highlighter-rouge">.text-center { text-align: center; }</code>, <code class="language-plaintext highlighter-rouge">.font-bold { font-weight: 700; }</code>)을 생성해준다.</li>
      <li>이 생성된 CSS를 <code class="language-plaintext highlighter-rouge">globals.css</code> 파일에 주입한다.</li>
      <li>브라우저는 HTML의 <code class="language-plaintext highlighter-rouge">class</code> 속성과 CSS 파일의 규칙을 매칭하여 스타일을 적용한다.</li>
    </ol>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">tailwind.config.ts</code>:</strong> 테마(색상, 글꼴 크기 등) 커스터마이징, 플러그인 추가, <code class="language-plaintext highlighter-rouge">darkMode</code> 전략 설정 등을 위한 설정 파일이다.</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">globals.css</code>:</strong> Tailwind의 기본 스타일(<code class="language-plaintext highlighter-rouge">@tailwind base;</code>), 컴포넌트 스타일(<code class="language-plaintext highlighter-rouge">@tailwind components;</code>), 유틸리티 스타일(<code class="language-plaintext highlighter-rouge">@tailwind utilities;</code>)을 주입하는 역할과, 직접 작성한 커스텀 CSS 클래스를 추가하는 역할을 한다.</p>

    <pre><code class="language-TypeScript">  // login/page.tsx 예시
  &lt;div className="flex min-h-screen items-center justify-center bg-gray-100"&gt;
    {/* flex: display: flex;
      min-h-screen: min-height: 100vh;
      items-center: align-items: center;
      justify-center: justify-content: center;
      bg-gray-100: 배경색 지정
    */}
    &lt;div className="w-full max-w-md rounded-lg bg-white p-8 shadow-md"&gt;
      {/*
        w-full: width: 100%;
        max-w-md: max-width: 28rem;
        rounded-lg: border-radius: 0.5rem;
        bg-white: background-color: white;
        p-8: padding: 2rem;
        shadow-md: box-shadow 적용
      */}
      &lt;h1 className="mb-6 text-center text-3xl font-bold text-gray-800"&gt;
        로그인
        {/*
          mb-6: margin-bottom: 1.5rem;
          text-center: text-align: center;
          text-3xl: font-size: 1.875rem; line-height: 2.25rem;
          font-bold: font-weight: 700;
          text-gray-800: 글자색 지정
        */}
      &lt;/h1&gt;
      {/* ... */}
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>
  </li>
</ul>

<h3 id="4-nextjs-특화-컴포넌트-link와-image-">4. Next.js 특화 컴포넌트: <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code>와 <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> ✨</h3>

<p>성능 향상을 위해 Next.js는 표준 HTML 태그의 기능을 확장한 자체 컴포넌트를 제공한다. 따라서 표준 HTML 태그가 아닌 태그들을 써야 하는 경우가 있다.</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> 컴포넌트:</strong>
    <ul>
      <li><strong>역할:</strong> 페이지 간 이동을 처리한다. 내부적으로 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 태그를 렌더링하지만, 동작 방식이 다르다.</li>
      <li><strong>핵심 기능 (클라이언트 사이드 라우팅):</strong>
        <ul>
          <li>클릭 시 브라우저가 페이지 전체를 새로고침하지 않는다.</li>
          <li>대신, JavaScript를 사용하여 URL을 변경하고 필요한 페이지만 동적으로 로드하여 교체한다 (SPA처럼 동작).(레이아웃 기반으로 최초 접근 위치에서 자식만 교체 한다던가…)</li>
          <li>결과로서 매우 빠르고 부드러운 페이지 전환 경험을 제공한다.</li>
        </ul>
      </li>
      <li><strong>프리페칭(Prefetching):</strong> 기본적으로 <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code>가 화면에 보이면, 해당 링크가 가리키는 페이지의 코드를 백그라운드에서 미리 다운로드한다. 사용자가 클릭했을 때 거의 즉시 페이지가 로드된다.</li>
      <li><strong>사용법:</strong> <code class="language-plaintext highlighter-rouge">href</code> 속성으로 이동할 경로를 지정한다.</li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx 예시
  import Link from 'next/link';
    
  &lt;Link href="/login" className="text-blue-600 hover:underline"&gt;
    Login Page
  &lt;/Link&gt;
</code></pre>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 컴포넌트:</strong>
    <ul>
      <li><strong>역할:</strong> 이미지를 표시합니다. 내부적으로 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 태그를 렌더링하지만, 강력한 최적화 기능을 추가한다.</li>
      <li><strong>핵심 기능 (자동 이미지 최적화):</strong>
        <ul>
          <li><strong>사이즈 최적화:</strong> 다양한 화면 크기(데스크탑, 모바일 등)에 맞는 이미지 크기를 자동으로 생성하고 제공한다.</li>
          <li><strong>포맷 최적화:</strong> 브라우저가 지원하는 경우, 이미지를 WebP나 AVIF 같은 최신 포맷으로 자동 변환하여 용량을 최적화 시킨다.</li>
          <li><strong>지연 로딩 (Lazy Loading):</strong> 기본적으로 이미지가 사용자의 뷰포트(화면 영역)에 들어올 때까지 로딩을 지연시켜 초기 페이지 로딩 속도를 향상시킵니다. (<code class="language-plaintext highlighter-rouge">priority</code> 속성으로 비활성화 가능, 필요한 경우 즉시 로딩을 요청할 수 있다.)</li>
          <li><strong>CLS(Cumulative Layout Shift) 방지:</strong> <code class="language-plaintext highlighter-rouge">width</code>와 <code class="language-plaintext highlighter-rouge">height</code> 속성을 필수로 요구하여, 이미지가 로드되기 전에 해당 공간을 미리 확보함으로써 레이아웃이 갑자기 변경되는 현상을 방지한다.</li>
        </ul>
      </li>
      <li><strong>사용법:</strong> <code class="language-plaintext highlighter-rouge">src</code>, <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, <code class="language-plaintext highlighter-rouge">alt</code> 속성이 필수(이걸 몰라서 왜 에러가 뜨지? 하고 한참 해맸다.). <code class="language-plaintext highlighter-rouge">src</code>는 <code class="language-plaintext highlighter-rouge">public</code> 폴더 기준의 절대 경로 또는 외부 URL을 사용한다.</li>
    </ul>

    <pre><code class="language-TypeScript">  // page.tsx 예시
  import Image from 'next/image';
    
  &lt;Image
    src="/main.png" // public 폴더의 main.png
    alt="메인 비주얼"
    width={800}    // 이미지 원본 너비
    height={800}   // 이미지 원본 높이
    priority       // 이 이미지는 중요하므로 먼저 로드
  /&gt;
</code></pre>
  </li>
</ul>

<hr />

<h2 id="-질문-목록-qa">❓ 질문 목록 (Q&amp;A)</h2>

<h3 id="q1-맨-위에-use-client의-역할은">Q1: 맨 위에 <code class="language-plaintext highlighter-rouge">"use client"</code>의 역할은?</h3>

<p><strong>A:</strong> 해당 파일(모듈)이 <strong>클라이언트 컴포넌트</strong>임을 명시하는 지시어다. <code class="language-plaintext highlighter-rouge">"use client"</code>가 선언된 파일과 그 파일에서 import하는 모든 모듈은 클라이언트 번들에 포함되어 브라우저에서 실행된다. 이는 <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code> 같은 React 훅이나 <code class="language-plaintext highlighter-rouge">onClick</code> 같은 브라우저 이벤트를 사용하기 위해 필수적이다. 반대로, 이 지시어가 없으면 기본적으로 <strong>서버 컴포넌트</strong>로 간주되므로 클라이언트 사이드의 이벤트에 대해서 인식이 불가능하다.</p>

<h3 id="q2-usestatefalse는-기본값을-선정하는-건가-isprojectsopen과-setisprojectsopen-두-가지의-역할과-차이는">Q2: <code class="language-plaintext highlighter-rouge">useState(false)</code>는 기본값을 선정하는 건가? <code class="language-plaintext highlighter-rouge">isProjectsOpen</code>과 <code class="language-plaintext highlighter-rouge">setIsProjectsOpen</code> 두 가지의 역할과 차이는?</h3>

<p><strong>A:</strong></p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">useState()</code>의 인자로 전달된 값(<code class="language-plaintext highlighter-rouge">false</code> 등)은 해당 상태 변수의 <strong>초기값(initial state)</strong>. 컴포넌트가 처음 마운트될 때 이 값으로 상태가 초기화된다.(해당 코드에선 접혀있는 상태로 시작해야 하므로 false를 넣고, 대신 statetFunction에서 not 처리를 해준다.)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">isProjectsOpen</code>: <strong>현재 상태 값</strong>을 담고 있는 변수. JSX 내에서 이 값을 읽어 UI를 조건부로 렌더링하거나 표시할 수 있다. 이 변수는 직접 수정할 수 없다 (예: <code class="language-plaintext highlighter-rouge">isProjectsOpen = true;</code> 불가).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">setIsProjectsOpen</code>: <code class="language-plaintext highlighter-rouge">isProjectsOpen</code> 상태를 <strong>업데이트하는 함수</strong>다. 이 함수에 새로운 상태 값을 전달하여 호출하면 (<code class="language-plaintext highlighter-rouge">setIsProjectsOpen(true);</code> 또는 <code class="language-plaintext highlighter-rouge">setIsProjectsOpen(prev =&gt; !prev);</code>), React는 상태 변경을 감지하고 컴포넌트를 리렌더링하여 UI를 갱신한다. 이것이 전형적인 React에서 상태를 변경하는 방법이다.</p>
  </li>
</ul>

<h3 id="q3-const-toggle로-화살표-함수는-usestate에-사용하기-위해-설정해주는-일종의-변수형-메서드인-건가">Q3: <code class="language-plaintext highlighter-rouge">const toggle~</code>로 화살표 함수는 <code class="language-plaintext highlighter-rouge">useState</code>에 사용하기 위해 설정해주는 일종의 변수형 메서드인 건가?</h3>

<p><strong>A:</strong> “일종의 변수형 메서드” 또는 더 정확히는 <strong>이벤트 핸들러 함수</strong>라고 볼 수 있다. <code class="language-plaintext highlighter-rouge">useState</code> 자체에 필요한 것은 아니다. 단, 상태를 변경하는 로직(예: <code class="language-plaintext highlighter-rouge">setIsProjectsOpen(!isProjectsOpen)</code>)을 <code class="language-plaintext highlighter-rouge">&lt;button&gt;</code>의 <code class="language-plaintext highlighter-rouge">onClick</code> 속성에 직접 넣는 대신, 별도의 함수(<code class="language-plaintext highlighter-rouge">toggleProjects</code>)로 분리하여 정의한 것이다. 이렇게 하면 코드가 더 깔끔해지고, 로직이 복잡해질 경우 관리하기 용이하며, 필요하다면 다른 곳에서 재사용할 수도 있다.</p>

<pre><code class="language-TypeScript">// 이벤트 핸들러 함수 정의
const toggleProjects = () =&gt; {
  setIsProjectsOpen(prevState =&gt; !prevState); // 이전 상태를 기반으로 토글
};

// JSX에서 이벤트 핸들러로 함수 연결
&lt;button onClick={toggleProjects}&gt;...&lt;/button&gt;
</code></pre>

<h3 id="q4-nextjs에서-주로-사용한다는-html이-아닌-자체-태그들link라던가이-있는데-왜-이걸-써야-하고-안-쓰면-안-되는-이유가-있는지">Q4: Next.js에서 주로 사용한다는 HTML이 아닌 자체 태그들(<code class="language-plaintext highlighter-rouge">Link</code>라던가)이 있는데, 왜 이걸 써야 하고, 안 쓰면 안 되는 이유가 있는지?</h3>

<p><strong>A:</strong> <strong>성능 최적화와 향상된 사용자 경험</strong>을 위해서 Next.js의 자체 컴포넌트 사용이 강력히 권장한다. 안 쓴다고 해서 앱이 작동하지 않는 것은 아니지만, Next.js를 사용하는 핵심 이점들을 놓치게 된다.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> vs <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>:</strong> <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code>는 <strong>클라이언트 사이드 라우팅</strong>을 구현하여 페이지 전환 시 전체 새로고침 없이 변경된 부분만 업데이트한다. 이는 훨씬 빠르고 부드러운 사용자 경험(SPA와 유사)을 제공합니다. 또한, <strong>프리페칭</strong> 기능으로 미리 다음 페이지를 로드하여 전환 속도를 더욱 높인다. 일반 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 태그는 전통적인 서버 방식의 페이지 이동(전체 새로고침)을 만들고, 당연히 동작은 하나 전체를 새로 그려야 한다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> vs <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>:</strong> <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code>는 <strong>자동으로 이미지를 최적화</strong>한다(사이즈 조절, WebP 변환, 지연 로딩 등). 이는 페이지 로딩 속도를 크게 개선하고 대역폭 사용량을 줄여준다. 또한 <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>를 강제하여 레이아웃 쉬프트(CLS) 문제를 예방한다. 일반 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 태그는 이러한 최적화 기능을 제공하지 않고 직접 처리해야 한다.</p>
  </li>
</ul>

<h3 id="q5-button-컴포넌트의-svg-태그에서--안에-넣으면-일종의-함수로-동작하는-건지-그리고-fill-stroke와-같은-classname에-안-들어간-별도의-요소들은-그냥-svg-태그의-요소들인-건지">Q5: <code class="language-plaintext highlighter-rouge">button</code> 컴포넌트의 <code class="language-plaintext highlighter-rouge">svg</code> 태그에서 <code class="language-plaintext highlighter-rouge">${}</code> 안에 넣으면 일종의 함수로 동작하는 건지? 그리고 <code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">stroke</code>와 같은 <code class="language-plaintext highlighter-rouge">className</code>에 안 들어간 별도의 요소들은 그냥 <code class="language-plaintext highlighter-rouge">svg</code> 태그의 요소들인 건지?</h3>

<p><strong>A:</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">${...}</code>: 이것은 함수 호출이 아니라, JavaScript의 <strong>템플릿 리터럴(Template Literal)</strong> 내에서 <strong>표현식 삽입(Expression Interpolation)</strong> 을 사용하는 문법이다. 백틱(<code class="language-plaintext highlighter-rouge">`</code>)으로 감싸진 문자열 안에서 <code class="language-plaintext highlighter-rouge">${}</code>를 사용하면, 중괄호 안의 JavaScript 코드가 평가되고 그 결과값이 문자열의 해당 위치에 삽입한다. 예시 코드에서는 <code class="language-plaintext highlighter-rouge">isProjectsOpen</code> 상태에 따라 <code class="language-plaintext highlighter-rouge">rotate-180</code> 클래스를 조건부로 추가하여 아이콘의 회전 상태를 제어한다.</p>

    <pre><code class="language-JavaScript">  // className 속성에 템플릿 리터럴 사용
  &lt;svg
    className={`h-5 w-5 transition-transform ${ // 백틱(`)으로 시작
      isProjectsOpen ? 'rotate-180' : '' // ${} 안에 삼항 연산자 표현식
    }`} // 백틱(`)으로 끝
    // ... (SVG 속성들)
  &gt;
    {/* ... */}
  &lt;/svg&gt;
</code></pre>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">stroke</code>, <code class="language-plaintext highlighter-rouge">viewBox</code>, <code class="language-plaintext highlighter-rouge">xmlns</code>, <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">strokeLinecap</code>, <code class="language-plaintext highlighter-rouge">strokeLinejoin</code>, <code class="language-plaintext highlighter-rouge">strokeWidth</code>:  이 속성들은 <code class="language-plaintext highlighter-rouge">className</code>과는 별개로 <strong>SVG(Scalable Vector Graphics) 표준 명세에 정의된 고유한 속성(attributes)</strong> 이다. 벡터 그래픽의 모양, 색상, 선 스타일 등을 정의하는 데 사용됩니다. Tailwind CSS 클래스와는 직접적인 관련이 없다.</p>
  </li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025-10-29 : Next.js 프론트엔드 핵심 개념들]]></summary></entry><entry><title type="html">TIL - Prettier &amp;amp; ESLint 적용</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-prettier-eslint.html" rel="alternate" type="text/html" title="TIL - Prettier &amp;amp; ESLint 적용" /><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-prettier-eslint</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-prettier-eslint.html"><![CDATA[<h2 id="2025-10-28--prettier--eslint-설정-in-nextjs-project">2025-10-28 : Prettier &amp; ESLint 설정 in Next.js Project</h2>

<p>오늘은 Next.js 프로젝트 (<code class="language-plaintext highlighter-rouge">project-mini-frontend/app</code>)에 코드 포매터인 <strong>Prettier</strong>와 린터인 <strong>ESLint</strong>를 설정하고, 두 도구가 충돌 없이 협력하도록 연동을 적용하고 개념에 대해 학습했다.</p>

<hr />

<h3 id="1-prettier-설정-">1. Prettier 설정 💅</h3>

<p>코드 스타일의 일관성을 자동으로 유지하기 위해 Prettier를 도입했다.</p>

<ul>
  <li><strong>설치:</strong> <code class="language-plaintext highlighter-rouge">pnpm</code>을 사용하여 <code class="language-plaintext highlighter-rouge">prettier</code>와 ESLint와의 충돌 방지용 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code>를 개발 의존성으로 설치했다.
    <pre><code class="language-Bash">  cd app
  pnpm add -D prettier eslint-config-prettier
</code></pre>
    <p><img src="/assets/images/til/25-10/251031-001.png" alt="" /></p>
    <blockquote>
      <p>프로젝트 구조 때문에 app 에 들어가서 해야 하는게 귀찮다…</p>
    </blockquote>
  </li>
  <li><strong>설정 파일 (<code class="language-plaintext highlighter-rouge">.prettierrc.json</code>):</strong> 프로젝트 루트(<code class="language-plaintext highlighter-rouge">app/</code>)에 설정 파일을 생성하여 팀의 코드 포매팅 규칙(세미콜론, 따옴표, 줄 바꿈 등)을 정의했다. 우선은 가장 추천하는 설정값을 그대로 적용시켰다.
    <pre><code class="language-JSON">  // .prettierrc.json
  {
    "semi": true, // 끝에 세미 콜론으로 종료 표시 
    "trailingComma": "all", // 객체, 배열의 여러줄로 나열 시 마지막 항목 뒤에도 쉼표 붙이기 
    "singleQuote": true,// 자스에서 문자열은 무조건 작은따옴표로 통일 
    "printWidth": 80, // 코드 한줄의 최대 길이를 80자로 제어 
    "tabWidth": 2, // 들여쓰기는 스페이스 2칸 
    "endOfLine": "auto" // 줄바꿈 스타일을 OS에 맞춰 자동화 
  }
</code></pre>
    <p><img src="/assets/images/til/25-10/251031-004.png" alt="" /></p>
  </li>
  <li><strong>무시 파일 (<code class="language-plaintext highlighter-rouge">.prettierignore</code>):</strong> <code class="language-plaintext highlighter-rouge">node_modules</code>, <code class="language-plaintext highlighter-rouge">.next</code> 등 포매팅 대상에서 제외할 파일 및 폴더를 지정하는 파일을 생성했다. 설정을 안하니 빌드된 결과물까지도 판단하기에 특히 dist, build 폴더 등은 반드시 해둬야 한다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      # .prettierignore
      node_modules
      .next
      .pnpm-store
      dist
      build
      public
</code></pre></div>    </div>
    <p><img src="/assets/images/til/25-10/251031-005.png" alt="" />
  <img src="/assets/images/til/25-10/251031-006.png" alt="" /></p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">package.json</code> 스크립트 추가:</strong> 코드 포매팅을 실행(<code class="language-plaintext highlighter-rouge">format</code>)하거나 검사(<code class="language-plaintext highlighter-rouge">format:check</code>)하는 스크립트를 추가했다. CI에서는 주로 <code class="language-plaintext highlighter-rouge">format:check</code>를 사용한다. 특히 <code class="language-plaintext highlighter-rouge">format:check</code>의 추가는 Jenkins 기반의 무중단 배포 전 테스트를 위한 용도이다.
    <pre><code class="language-JSON">  // package.json scripts
  "scripts": {
    // ...
    "format": "prettier --write .",
    "format:check": "prettier --check ."
  },
</code></pre>
    <p><img src="/assets/images/til/25-10/251031-007.png" alt="" />
  <img src="/assets/images/til/25-10/251031-008.png" alt="" /></p>
    <blockquote>
      <p>깔끔하게 에러 체킹이 되는것 까지 확인하였고, Jenkins 무중단 배포에서 해당 검사 기능을 추가하였다.</p>
    </blockquote>
  </li>
</ul>

<hr />

<h3 id="2-eslint와-prettier-연동-">2. ESLint와 Prettier 연동 🤝</h3>

<p>ESLint(코드 품질)와 Prettier(코드 스타일)는 일부 규칙(예: 줄 길이, 따옴표)이 겹쳐 충돌할 수 있다. 이를 해결하기 위해 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code>를 사용하여 ESLint의 스타일 관련 규칙을 비활성화하고, 스타일링은 전적으로 Prettier에게 맡기는 걸로 수정하였다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">eslint.config.mjs</code> 설정:</strong> ESLint 설정 파일(<code class="language-plaintext highlighter-rouge">app/eslint.config.mjs</code>)에서 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code>를 <code class="language-plaintext highlighter-rouge">import</code>하고, 설정 배열의 <strong>맨 마지막</strong>에 추가하여 Prettier와 충돌하는 ESLint 규칙을 껐다.
    <pre><code class="language-JavaScript">  // eslint.config.mjs
  import prettierConfig from 'eslint-config-prettier';
    
  export default [
    // ... (기존 ESLint 설정들)
    
    // 맨 마지막에 추가하여 스타일 규칙 충돌 방지
    prettierConfig, 
  ];
</code></pre>
  </li>
  <li><strong>역할 분담:</strong> 자꾸 헷갈리는 부분이기에 정리해보면…
    <ul>
      <li><strong>ESLint:</strong> 코드의 논리적 오류, 잠재적 버그, 안티 패턴 등 <strong>코드 품질</strong>에 집중.</li>
      <li><strong>Prettier:</strong> 들여쓰기, 줄 바꿈, 따옴표 등 오직 <strong>코드 스타일</strong>만 관리.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="3-eslint-검사-범위-설정-ignoring-files-">3. ESLint 검사 범위 설정 (Ignoring Files) 🚫</h3>

<p>ESLint가 불필요한 파일(예: 빌드 결과물)을 검사하지 않도록 설정했다.</p>

<ul>
  <li>
    <p><strong>문제:</strong> 기본 설정에서는 <code class="language-plaintext highlighter-rouge">pnpm lint</code> 실행 시 Next.js의 빌드 폴더인 <code class="language-plaintext highlighter-rouge">.next/</code> 내부까지 검사하는 문제가 있다.</p>
  </li>
  <li>
    <p><strong>해결 (<code class="language-plaintext highlighter-rouge">eslint.config.mjs</code>):</strong> ESLint의 최신 설정 방식(Flat Config)에서는 <code class="language-plaintext highlighter-rouge">.eslintignore</code> 파일 대신, <code class="language-plaintext highlighter-rouge">eslint.config.mjs</code> 파일 내부에 <code class="language-plaintext highlighter-rouge">ignores</code> 속성을 사용하여 무시할 경로를 직접 지정 가능하다. 설정 배열의 <strong>앞부분</strong>에 추가하여 전역적으로 적용했다.</p>

    <pre><code class="language-JavaScript">  // eslint.config.mjs
  import prettierConfig from 'eslint-config-prettier';
    
  export default [
    // ignores 설정을 배열 앞부분에 추가
    {
      ignores: [
        'node_modules/**', // node_modules 폴더
        '.next/**',        // Next.js 빌드 폴더
        'public/**',       // public 폴더 (선택 사항)
      ],
    },
    
    // ... (기존 설정들)
    prettierConfig,
  ];
    
</code></pre>
  </li>
</ul>

<hr />

<h2 id="질문-정리">질문 정리</h2>
<h3 id="eslint와-prettier의-관계-및-연동할-필요가-있을까">ESLint와 Prettier의 관계 및 연동할 필요가 있을까?</h3>

<p>ESLint와 Prettier는 현대 웹 개발 환경에서 코드의 일관성과 품질을 유지하기 위해 사용되는 핵심 도구이다. 두 도구는 목적이 다르지만, 일부 기능 영역이 겹쳐 충돌이 발생할 수 있다고 한다. 따라서 이 둘을 올바르게 연동하여 각자의 역할을 명확히 분리하는 것이 중요하고 그래서 차이를 이해해야 한다.</p>

<hr />

<h4 id="각-도구의-핵심-역할">각 도구의 핵심 역할</h4>

<h5 id="eslint-린터-linter">ESLint (린터, Linter)</h5>

<p>ESLint는 코드의 <strong>품질(Quality)</strong> 을 검사하는 도구다. 주요 목적은 잠재적인 버그나 안티 패턴을 찾아내어 코드의 논리적 오류를 방지하는 것이다.</p>
<ul>
  <li><strong>주요 기능</strong>:
    <ul>
      <li>문법 오류 검사</li>
      <li>사용되지 않는 변수 탐지</li>
      <li><code class="language-plaintext highlighter-rouge">React Hooks</code>의 잘못된 사용 등 프레임워크 규칙 검사</li>
      <li>논리적 안티 패턴 식별</li>
    </ul>
  </li>
</ul>

<h5 id="prettier-코드-포매터-code-formatter">Prettier (코드 포매터, Code Formatter)</h5>

<p>Prettier는 코드의 <strong>스타일(Style)</strong> 을 통일하는 도구이다. 코드가 어떻게 “보이는지”에만 집중하며, 매우 ‘독단적인(Opinionated)’ 규칙을 적용하여 모든 개발자가 동일한 코드 서식을 갖도록 강제한다.</p>

<ul>
  <li><strong>주요 기능</strong>:
    <ul>
      <li>들여쓰기 (예: 2칸 공백)</li>
      <li>문자열 따옴표 통일 (예: 작은따옴표)</li>
      <li>줄 바꿈 (예: 80자 초과 시)</li>
      <li>세미콜론(;) 자동 추가 또는 제거</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="연동의-필요성-규칙의-충돌">연동의 필요성: 규칙의 충돌</h4>

<p>문제는 ESLint의 규칙 중에도 코드 스타일을 다루는 부분이 있다는 것이다. (예: <code class="language-plaintext highlighter-rouge">max-len</code> (최대 줄 길이), <code class="language-plaintext highlighter-rouge">semi</code> (세미콜론 사용 여부), <code class="language-plaintext highlighter-rouge">quotes</code> (따옴표 종류) 등)</p>

<p>만약 두 도구를 별다른 설정 없이 함께 사용하면, 동일한 코드 스타일에 대해 서로 다른 규칙을 강요하며 충돌하게 된다.</p>

<ul>
  <li><strong>충돌 예시</strong>:
    <ul>
      <li><strong>ESLint 규칙</strong>: “한 줄은 최대 100자까지 허용한다.”</li>
      <li><strong>Prettier 규칙</strong>: “한 줄은 80자가 넘으면 무조건 줄 바꿈한다.”</li>
      <li><strong>결과</strong>: 개발자가 90자 코드를 작성하면, Prettier는 강제로 줄을 바꾸고, ESLint는 이 변경이 불필요하다고 판단하거나 그 반대의 상황이 발생하여, 저장 시마다 코드가 계속 변경되거나 에러가 발생한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="해결-방안-eslint-config-prettier">해결 방안: <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code></h4>

<p>이 충돌을 해결하기 위해 <code class="language-plaintext highlighter-rouge">eslint-config-prettier</code> 패키지를 사용한다.</p>

<p>이 패키지의 유일한 역할은 <strong>ESLint의 규칙 중 Prettier와 겹치는 모든 스타일 관련 규칙을 비활성화(off)</strong> 하는 것이다.</p>

<p>이를 통해 코드 스타일에 대한 제어권은 100% Prettier에게 위임하고, ESLint는 오직 코드 품질 검사에만 집중하도록 역할을 명확히 분리할 수 있다.</p>

<hr />

<h4 id="최종-역할-분담">최종 역할 분담</h4>

<p>올바르게 연동된 환경에서의 최종 역할은 다음과 같다.</p>

<ul>
  <li><strong>ESLint</strong>: 코드의 <strong>논리적 품질</strong>만 검사한다.
    <ul>
      <li>(예: “이 변수는 사용되지 않았습니다.”, “React Hook의 의존성 배열이 잘못되었습니다.”)</li>
    </ul>
  </li>
  <li><strong>Prettier</strong>: 코드의 <strong>시각적 스타일</strong>만 관리한다.
    <ul>
      <li>(예: “들여쓰기는 2칸입니다.”, “문자열은 작은따옴표로 통일합니다.”)</li>
    </ul>
  </li>
</ul>

<h4 id="그렇게-좋은데-기본-설정이-아닌-이유는-">그렇게 좋은데… 기본 설정이 아닌 이유는 ?</h4>

<ol>
  <li><strong>목적의 차이</strong>: ESLint(품질)는 버그 방지를 위해 필수적이지만, Prettier(스타일)는 팀의 ‘선택’ 사항이다.</li>
  <li><strong>도구의 독립성</strong>: 두 도구는 서로 다른 목적을 위해 별개로 개발된 독립적인 프로젝트이다.</li>
  <li><strong>스타일의 주관성</strong>: Prettier는 매우 ‘독단적인’ 스타일을 강제한다. 모든 개발팀이 이 스타일에 동의하는 것은 아니며, 다른 포매터(dprint 등)를 선택할 수도 있다. 따라서 프레임워크가 특정 스타일을 기본으로 강제하지 않는다.</li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025-10-28 : Prettier &amp; ESLint 설정 in Next.js Project]]></summary></entry></feed>