<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-06-03T02:59:32+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">NestJS 컴파일러 성능 비교 - tsc vs SWC</title><link href="http://localhost:4000/backend/2025/06/01/compiler-comparson.html" rel="alternate" type="text/html" title="NestJS 컴파일러 성능 비교 - tsc vs SWC" /><published>2025-06-01T00:00:00+00:00</published><updated>2025-06-01T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/06/01/compiler-comparson</id><content type="html" xml:base="http://localhost:4000/backend/2025/06/01/compiler-comparson.html"><![CDATA[<h2 id="introduce">introduce</h2>
<p>Node 계열 프레임워크에서 TypeScript 언어 방식으로 개발을 하게 되면, 잘 알듯 JavaScript 로의 변환의 과정이 반드시 필요하다. 타입 체크를 비롯한 TypeScript의 강력한 기능으로 한 번 더 래핑된 상태라, JS 로의 변환 과정은 필수인 것이다.</p>

<h3 id="tsc-기본-컴파일러">tsc 기본 컴파일러</h3>
<p>TypeScript 컴파일러는 ms 에서 강력한 정적 분석과 엄격한 타입을 관리한다는 철학을 기반으로 만들어져 있다. 매우 큰 커뮤니티를 통해 안정성, 신뢰성, 쉽게 이용 가능하다는 기본적인 특징들은 이미 충분히 라이브서비스에 쓸만하다고 볼 수 있다. 그런 점에서 NestJS 프로젝트를 시작하면 시작과 동시에 기본 값으로 설정 되어 있는 것은 이러한 부분을 증명해주는 것이리라.</p>

<p>하지만 라이브 서비스로 쓰다보면 약간 답답함을 경험하게 될 것이다. 비교적 충분히 빠르긴 하지만, 프로젝트가 커지면 성능 병목은 어쩔 수 없이 필요하게 되고, 특히나 다중 타입 등이 많아질 수록, 포괄적인 검사는 엄청난 병목으로 다가온다. 제네릭스 타입이나, 타입의 수단계를 거친 복잡한 타입의 인스턴스화는 개발경험, CI 속도에 영향을 느끼게 된다.</p>

<p>특히나 AWS 에서 개발 환경이 존재하는 경우에도 문제가 있다. 감시모드를 켜게 되면 tsc 는 초기에는 메모리가 낮은 편이지만, 파일 변경으로 재 컴파일 트리거가 발동하면 메모리 사용량이 급격히 증가하게 된다. 피크 수준이 200 ~ 300mb 수준을 차지하게 되는데, 문제는 리소스가 부족한 서버를 갖고 있거나, 리소스에 맞춰진 수준의 dev 서버를 구동한다고 하면 피크 메모리 점유율로 인해 AWS 인스턴스가 멈추는 경우가 발생하게 된다.</p>

<h3 id="nestjs-의-swcspeedy-web-compiler">NestJS 의 SWC(Speedy Web Compiler)</h3>

<p>이러한 점들을 경험하고 나면 살짝 불편함을 느끼게 되고, 검색을 하게 된다. 그러다보면 마치 군대에서 ‘사제’를 찾듯이(?) 사제 컴파일러가 그렇게 좋다더라~ 하는 소문을 듣게 되고, 나름의 대안을 찾아 보게된다. 그 중에 하나가 <code class="language-plaintext highlighter-rouge">SWC</code> 라는 컴파일러. 러스트 기반이자, 트랜스파일링 프로세스를 최적화 시켜 Babel 의 직접적인 대체제라는 평가를 가진 컴파일러이다.</p>

<p><img src="https://i.namu.wiki/i/lESG3ZnlLtV8zKQbWkUT8BMOhfdB150eNx3kL4UgcF7JpgiZcc4a71PM0tPrvfeg7hyAJtgBPBGs8URwIS1vhMQf6eJa0OanfRs_XQU1LI3jwe22GUND1TuQlxUSRQBgksnj1r1wvWNiSw85F2voog.svg" alt="SWC로고" /><br /></p>

<p><a href="https://swc.rs/">공식 사이트</a><br /></p>

<p><a href="https://github.com/swc-project/swc?tab=readme-ov-file">공식 깃허브</a></p>

<p>SWC는 NestJS v10에서 공식으로 통합이 도입되었고, <code class="language-plaintext highlighter-rouge">@swc/cli</code>, <code class="language-plaintext highlighter-rouge">@swc/core</code> 패키지를 통해 사용이 가능하다. <code class="language-plaintext highlighter-rouge">nest-cli.json</code> 에서 컴파일러 옵션의 builder 를 swc 로 넣어주면 SWC 컴파일러를 사용할 수 있다.</p>

<p>이러한 SWC 의 근본적인 목적은 Babel(tsc)의 기본적인 타입 검사를 수행하지 않고, 고속변환에 포커스를 맞추고 있다는 점이다. 그럼에도 왜 써야 하는가? 라고 하면 다음과 같이 정리 할 수 있다.</p>

<ul>
  <li>
    <p>기본적으로 SWC의 벤치 내용은 <a href="https://swc.rs/docs/benchmarks">여기</a>를 참조하면 기본적으로 제공해주는 것을 알 수 있다. 프로젝트마다 다를 순 있지만, 기본적으로 평균 20배 내외의 성능을 나타낸다는 결과를 보여주었다.</p>

    <p>실제로 사내 메인 서비스의 NestJS 서버의 경우 단순 빌드 작업만 수행한다고 할 때, 기본 컴파일러 상태에서 총 4930ms가 수행되었으나, SWC 적용할 경우 2700ms 가 소요되었다. 약 82% 성능 향상을 보는 것이다(뒤에서 언급하기도 하겠지만, 현재는 SWC, TSC 의 병행 구조이다보니 파일 복사 과정이 포함되어 있고, 해당 부분을 공통으로 제외하면 훨씬 높은 성능을 보여주는 것이다).</p>
  </li>
  <li>
    <p>1번과 함께 HMR(Hot Module Replacement)가 이루어져서, 대단히 생산적인 워크 플로우를 짤 수 있다. 시간이 중요한 상황에서 이러한 즉각적인 피드백은 개발의 반복 속도, 테스팅 속도 등을 줄여주니, 그만큼 생산성에 직결된다고 볼 수 있다.</p>
  </li>
</ul>

<h2 id="swc-사용-후기는-그래서">SWC 사용 후기는 그래서?</h2>

<h3 id="빌드시간-비교">빌드시간 비교</h3>
<p>공식자료들을 기반으로 정리해 보면, 약 6000 줄의 코드 구성의 소규모 NestJS 프로젝트는 tsc의 경우 약 5.2 초의 빌드가, SWC 의 경우 0.38초가 걸렸다. 이러한 수치는 트랜스파일링 단계의 속도 향상에 대한 내용이 주를 이루며, 타입 검사는 해당하지 않는다.</p>

<p>공식 내용을 정리한 표를 보면 더욱 이 차이는 명백해진다.</p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>1 코어, 동기</th>
      <th>4 Promise</th>
      <th>100 Promise</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>swc (es3)</td>
      <td>616 ops/sec</td>
      <td>1704 ops/sec</td>
      <td>2199 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2015)</td>
      <td>677 ops/sec</td>
      <td>1688 ops/sec</td>
      <td>1911 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2016)</td>
      <td>1963 ops/sec</td>
      <td>3948 ops/sec</td>
      <td>5580 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2017)</td>
      <td>1971 ops/sec</td>
      <td>3948 ops/sec</td>
      <td>6259 ops/sec</td>
    </tr>
    <tr>
      <td>swc (es2018)</td>
      <td>2555 ops/sec</td>
      <td>4884 ops/sec</td>
      <td>8108 ops/sec</td>
    </tr>
    <tr>
      <td>swc-optimize (es3)</td>
      <td>645 ops/sec</td>
      <td>1716 ops/sec</td>
      <td>1860 ops/sec</td>
    </tr>
    <tr>
      <td>babel (es5)</td>
      <td>34.05 ops/sec</td>
      <td>27.28 ops/sec</td>
      <td>32 ops/sec</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>단위: <strong>ops/sec (operations per second)</strong><br />
참고: 수치가 높을수록 더 빠름</p>
</blockquote>

<p>더불어 자원이 풍부하지 않은 회사도 있을 수 있으므로(…) 메모리 소비도 분석하면 다음과같은 패턴이 보여진다. 아래 수치는 외부 오버헤드 최소화를 위하여, <code class="language-plaintext highlighter-rouge">node_modules</code>에서 직접 명령어를 실행 했을 때 수치다.</p>

<table>
  <thead>
    <tr>
      <th>컴파일러/설정</th>
      <th>시작 시 메모리</th>
      <th>파일 변경 시 메모리</th>
      <th>1분 비활성 후 메모리</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>tsc</td>
      <td>~50</td>
      <td>~200</td>
      <td>~60</td>
    </tr>
    <tr>
      <td>tsc (without –noCheck)</td>
      <td>~200</td>
      <td>~300</td>
      <td>~65</td>
    </tr>
    <tr>
      <td>SWC</td>
      <td>~310</td>
      <td>변화 없음</td>
      <td>변화 없음</td>
    </tr>
    <tr>
      <td>SWC (with –workers 1)</td>
      <td>~195</td>
      <td>변화 없음</td>
      <td>변화 없음</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>참고: <code class="language-plaintext highlighter-rouge">변화 없음</code>은 감지 가능한 메모리 증감이 없음을 의미함</p>
</blockquote>

<p>tsc 는 일반적으로 낮은 기본 메모리 사용량을 보여준다. 그러나 피크 시의 경우 상당한 변화량을 가지는데, 여기서 좀 특이한 경험을 했었다.</p>

<p><a href="https://g-db.tistory.com/entry/AWS-EC2-%EB%A8%B9%ED%86%B5-%EB%A9%88%EC%B6%A4-%ED%98%84%EC%83%81-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95">AWS EC2 먹통, 멈춤 현상 해결방법</a>, 이 글이 아마 가장 명확한 이유일 것으로 보이는데,… AWS는 인스턴스의 다른 리소스보다 메모리에 민감한 것으로 보여진다. 특히나 순간적으로 치솟는 경우 AWS 인스턴스 자체가 멈추는 경우가 있고, 이 때는 AWS 의 CloudWatch 가 먹통이 되는 데, 이로인해 모니터링도 에러라고 핸들링을 못하고, SSH 접속도 안되고, 재부팅도 빠르게 이루어지지 않는다. 서버가 타임아웃하는 문제가 발생하는 것이다. 정말 열 받는 부분인데(…) 한술 더 떠 개발들 위하여 사용하는 VSC IDE 의 SSH 접속 도 메모리를 매우 많이 먹는 다는 점이다.</p>

<p>이 두 가지 조건이 합쳐지고, tsc 로 HMR 를 수행하게 되면 서버는 정말 랜덤 확률로 터지고, 터진 뒤에도 터졌는지를 전혀 모르는 (…) 상황이 발생할 수 있다. 계속 값을 바꾸면서, 세팅에 따른 백엔드의 서빙 특성을 조사하거나 해야 할 때는 1변경 1리붓을 경험할 수 도 있다.(리소스가 적으면 어쩔 수 없다…)</p>

<p>이를 개선하기 위해 스왑 메모리 등을 설정하는 방법도 있지만, 특성 상 이러한 임시 대비책을 사용하면 안되는 서버도 있기 때문에, 이러한 방법 만으론 온전하게 해결되었다고 보기도 좀 문제가 있다.</p>

<p>따라서 dev 환경 등엣 SWC를 적용하고 –watch 모드를 켠 상태로 접속하여 사용 및 코드 수정 -&gt; 빌드 -&gt; 다시 테스트 이 환경을 히먄 tsc 로 컴파일을 할 때보다 월등히 안정적인 작업, 빠른 변경이 가능해진다.</p>

<h3 id="개발-환경의-최적화는-좋다-하지만">개발 환경의 최적화는 좋다.. 하지만</h3>

<p>tsc 는 오래 걸리며, 메모리가 피크 되는 순간마다 인스턴스는 죽을 걱정(?)을 해야 할 수 있다. 제일 문제는 수 초 씩 걸리는 과정이 은근히 하고 있던 작업의 맥을 끊거나 흐름을 끊는 역할을 한다는 점이고, 이는 집중하여 개발하는 과정을 도와주기 보단 버퍼를 자꾸 일으키는 방해 요소가 된다. <del>그러라고 성능 좋은 로컬 환경이 필요한 거다</del></p>

<p>SWC의 도입은 이러한 점에서 충분히 훌륭하다. 이러한 파격적인 성능, 개발 시의 안정성을 제공해주는 것은 좋았지만, 한가지 결정적인 문제는 계속 언급되는 ‘타입 체크’ 의 부재이다.</p>

<p><img src="/assets/images/posts/2025-06/2025-06-02-0001.png" alt="" /></p>
<blockquote>
  <p>동일한 브랜치에서 tsc 컴파일러로 빌드를 했을 때</p>
</blockquote>

<p><img src="/assets/images/posts/2025-06/2025-06-02-0002.png" alt="" /></p>
<blockquote>
  <p>동일한 브랜치에서 SWC 컴파일러로 빌드를 했을 때</p>
</blockquote>

<p>타입체크는 TypeScript의 근본이다. JS의 막무가내 스럽고, 당혹스러울 정도의 ‘강력함’을 정리하고 다듬어서, 에러를 최소화 시키기 위한 패러다임이 TypeScript이다. 아무리 욕을 먹거나, TS를 배제하려고 해도 여전히 TypeScript가 배제되지 않는 것은 JS가 가진 한계를 매우 유용하게 보완해주기 때문이다.</p>

<p>그런데 SWC는 이를 가볍게 무시해준다. 같은 환경이지만, 수 많은 타입 에러를 무시해버린다. 심지어 그런 문제를 갖고 있는 데도 구동되고 일정하게 서벅 ‘실행된다’. 이건 매우 큰 문제였다. dev 환경에서 SWC 를 기반으로 작업을 하고 테스트 할 때는 전혀 문제가 아닌 기능들이, 막상 production 환경에 올려놓고 보면 다른데서 터지거나 하는 일이 발생하고 그제서야 서버가 뻗을 수 있다. 왜냐면 타입이 제대로 지정이 안되거나 버그가 있지만, 내가 작업하던 곳, 내지는 SWC 상태에서는 어떻게든 돌려버리는 것이다.</p>

<p>몇 번이나 CTO에게 이 부분을 지적받고 난 이후, SWC 없이 작업하기 너무 싫다고 생각은 하지만, 동시에 내가 만능이 아닌 이상 TypeError에 대한 두려움, 확신이 없는 상태로 괜찮은가? 라고 생각했다. 그렇기에 반드시 검사 내지는 tsc 를 활용한 완벽한 타입 체킹이 필요하다고 생각했다. (참고로 SWC도 설정을 켜서 할 수 있으나, 완벽하지 않다.)</p>

<h2 id="그렇기에">그렇기에..</h2>

<p>SWC 는 개발하기에 매우 편안한 환경을 구현해준다. 하지만 결정적으로 급박하게 개발하는 과정이라고 해도, 빨라서 편하다고 해도, Type 에러 발생, 라이브 서버 폭발이라는 사태는 정말 막아야 한다. 나름대로의 대안이 필요했다. 따라서 초기에는 이를 위한 해결 방법을 고안했다.</p>

<h3 id="초기다-알지-못할-때">초기(다 알지 못할 때)</h3>
<p>tsc / SWC 를 컨버팅하는 script를 제작, 해당 스크립트를 package.json 에서 동작하도록 설정하였었다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c">#9 설정 파일 교체 함수</span>
update_config_files<span class="o">(){</span>
    <span class="nb">echo</span> <span class="s2">"Updating configuration files..."</span>
    <span class="k">if</span> <span class="o">!</span> <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$BUILDER_CONFIG_FILE</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$NEST_CLI_FILE</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span>error_handler <span class="s2">"Failed to update </span><span class="nv">$NEST_CLI_FILE</span><span class="s2">"</span>
    <span class="k">fi
    if</span> <span class="o">!</span> <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$TSCONFIG_CONFIG_FILE</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$TSCONFIG_FILE</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span>error_handler <span class="s2">"Failed to update </span><span class="nv">$TSCONFIG_FILE</span><span class="s2">"</span>
    <span class="k">fi

    </span><span class="nb">echo</span> <span class="s2">"Successfully updated </span><span class="nv">$NEST_CLI_FILE</span><span class="s2"> and </span><span class="nv">$TSCONFIG_FILE</span><span class="s2"> with </span><span class="nv">$BUILDER_TYPE</span><span class="s2"> Compiler."</span>
<span class="o">}</span>

<span class="nb">.</span>
<span class="nb">.</span>
<span class="nb">.</span>


<span class="c"># 11 메인 로직 </span>
main<span class="o">()</span> <span class="o">{</span>
    <span class="c"># 로깅 설정</span>
    setup_logging

    <span class="c"># 로깅 설정 후 원래의 에러 핸들러 설정</span>
    <span class="nb">trap</span> <span class="s1">'error_handler "Line ${LINENO}: $BASH_COMMAND" '</span> ERR
    
    validate_input <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    </span>check_files
    create_backup
    update_config_files
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    </span>cleanup_backup

    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    case</span> <span class="s2">"</span><span class="nv">$BUILDER_TYPE</span><span class="s2">"</span> <span class="k">in</span>
        <span class="s2">"swc"</span><span class="p">)</span>
            <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="nb">echo</span> <span class="s2">"✨ SWC compiler does not need to clear cache"</span>
            <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="p">;;</span>
        <span class="s2">"origin"</span><span class="p">)</span>
            yarn cache clean <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Warning: yarn cache clean failed, ignoring."</span>
            <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
            </span><span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="nb">echo</span> <span class="s2">"✨ Clear Yarn Cache"</span>
            <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
    <span class="nb">sleep </span>1
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi

    if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
    <span class="nb">echo</span> <span class="s2">"✨ Compiler is switched </span><span class="nv">$BUILDER_TYPE</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"----------------------------------------"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-t</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then </span>clear<span class="p">;</span> <span class="k">fi</span>
<span class="o">}</span>

main <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="nb">exit </span>0
</code></pre></div></div>

<p>전체 코드를 다 올리지 못하고 부분만 올렸지만, 핵심은 빌드를 담당하는 tsconfig.json 과 nest-cli.json을 교체하는 방식이다. 매우 무식하지만(?) 확실하게 변경이 되었고, 원하면 각 상황마다 다른 옵션을 추가할 수 있다는 점에선 아주 괜찮았다.</p>

<h3 id="현재-개선-방향">현재 개선 방향</h3>

<p>현재는 컴파일러를 공부하면서 타입 체크 기능만 구동할 수 있다는 것을 알게 되면서, <del>나의 무지함을 이해했다(…).</del>
그러나 막상 확인해보니, 단순히 타입 체킹만을 tsc 에게 넘기는 것 만으로는 완벽하게 기본값의 환경을 만들진 못했다.</p>

<p>대표적으로 debug 모드, vsc 디버그 모드를 사용하는 입장에선 SWC 상태론 지원이 정상적이지 못하여 대체가 불가능했다. (결국 컴파일러를 이중으로 쓰기 + 짧게 필요할 땐 타입 검사만 의 구조를 차용해야 한다.) 혹시나 이것에 대한 조언을 해줄 수 있는 분이 있다면 좋을것 같다…😂</p>

<h4 id="환경별-정리">환경별 정리</h4>
<ol>
  <li>개발 환경 + Dev 환경 =&gt; 빠른 체킹 &amp; 테스팅을 위해 SWC 기반의 타입체킹 배제</li>
  <li>debug 환경 =&gt; SWC 로 구동하기 어려울 수 있음. 에러 핸들링을 포함해 아직 호환이 안되므로 tsc 를 그대로 사용할 것</li>
  <li>Prod, Staging 환경 =&gt; lint 포함, 타입 체킹 사전 진행 =&gt; 미 통과시 배포 중단 및 알림</li>
</ol>

<h4 id="환경별-스크립트">환경별 스크립트</h4>
<ol>
  <li>
    <p>간단하게 빌드 전 테스팅 방법</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c"># tsc 타입 검사 성공 시 build 를 수행(SWC)</span>
 yarn tsc <span class="nt">--noEmit</span> <span class="o">&amp;&amp;</span> yarn build:fast
</code></pre></div>    </div>
  </li>
  <li>
    <p>husky 를 활용하여</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/sh</span>
 <span class="c"># husky / pre-push 문서 </span>

 <span class="c"># run_command 는 로깅을 포함한 함수 실행부로 공통으로 명령어를 대신 수행하는 함수 스크립트</span>

 <span class="c"># 공통 함수 로드</span>
 <span class="nb">.</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$0</span><span class="s2">"</span><span class="si">)</span><span class="s2">/common.sh"</span>

 <span class="c"># 명령어 실행</span>
 run_command <span class="s2">"lint"</span> <span class="s2">"yarn lint --max-warnings=0"</span> <span class="o">||</span> <span class="nb">exit </span>1

 <span class="c"># type checking </span>
 run_command <span class="s2">"type-check"</span> <span class="s2">"yarn typecheck"</span> <span class="o">||</span> <span class="nb">exit </span>1
 <span class="c"># run_command "build" "yarn build:external" || exit 1</span>
 <span class="c"># 깃 최상위 위치 체크, 이동하여서 항상 dist 폴더가 삭제 되도록 함</span>
 <span class="c"># run_command "clean dist" "git rev-parse --show-toplevel &amp;&amp; cd \$(git rev-parse --show-toplevel) &amp;&amp; rm -rf dist" || exit 1</span>

 <span class="nb">echo</span> <span class="s2">"🚀 All checks passed! Pushing..."</span>

</code></pre></div>    </div>
  </li>
</ol>

<h2 id="마치며">마치며</h2>
<p>Rust 는 이런 영역에서 점점 빛을 발하고 있다는게 느껴진다. Rust 기반 백엔드 성능도 상당하다고 들었지만, 컴파일러로의 SWC 는 개발 생산성 향상에서 정말 괜찮은 도구이며, 다소 아쉬움은 있지만, 빌드의 시간이 정말 ‘월등히’ 빨라지기 때문에 확실히 초반부터 도입하고 사용하는 것을 기본으로 깔고 가는 것이 좋다.</p>

<p>단, 부재의 제목처럼, 한계가 작게 있고, 작긴 한데 그 작은 한계가 매우 위험 할 수 있다는 것은 주의가 필요해 보인다. 타입체킹이 안되고, 이에 대해 고려하지 않으면 타입 문제가 발생할 수 있다. 또한 어디까지나 확실한 영역은 아니지만 최신의 언어나 프레임워크까지 가버리면 SWC 의 트랜스파일링의 결과물이 tsc 의 그것과 다를 수 있다는 평가도 있다는 점은, 반드시 이에 대한 안전망을 확보하는 것을 최 우선으로 필요하다고 보며, 개발 환경자체에서 어렵다면 CICD 파이프라인 속에 해당 절차를 넣어두는 것이 좋아 보인다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="Backend" /><category term="Node" /><category term="NestJS" /><category term="TypeScript" /><category term="Programming" /><summary type="html"><![CDATA[introduce Node 계열 프레임워크에서 TypeScript 언어 방식으로 개발을 하게 되면, 잘 알듯 JavaScript 로의 변환의 과정이 반드시 필요하다. 타입 체크를 비롯한 TypeScript의 강력한 기능으로 한 번 더 래핑된 상태라, JS 로의 변환 과정은 필수인 것이다.]]></summary></entry><entry><title type="html">AI에게 답을 찾는 새로운 방법 ‘Slow Think’</title><link href="http://localhost:4000/ai/2025/05/31/slow-think.html" rel="alternate" type="text/html" title="AI에게 답을 찾는 새로운 방법 ‘Slow Think’" /><published>2025-05-31T00:00:00+00:00</published><updated>2025-05-31T00:00:00+00:00</updated><id>http://localhost:4000/ai/2025/05/31/slow-think</id><content type="html" xml:base="http://localhost:4000/ai/2025/05/31/slow-think.html"><![CDATA[<h2 id="ai-에게도-생각할-시간이-필요하다--slow-thinking">AI 에게도 생각할 시간이 필요하다 : Slow Thinking</h2>
<p>LLM 과 관련하여 AI를 사용하다보면 답을 정확하게 준다고 생각이 들긴 하지만, 그럼에도 여전히 할루시에이션(hallucination)이 발생하는 경우를 느끼거나, 데이터가 오염되었다고 느끼는 경우가 발생한다. 그러는 와중에 이런 영상을 발견하게 되었다.</p>

<p><a href="https://www.youtube.com/watch?v=mN6FXDeSfAc&amp;t=3s"><img src="https://i.ytimg.com/vi/mN6FXDeSfAc/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&amp;rs=AOn4CLA44jSpAlGNEUistYs9DJaIgH4gXQ" alt="GPT/클로드/..." /></a></p>

<p>프롬프팅에 대한 내용은 AI에 익숙한 사람들이라면 이미 충분히 알고 있을 만한 단어일 것이며, 그렇지 않다고 하더라도 ‘명령’이 왜 내가 하면 제대로 답을 못하는지를 한 번이라도 생각해봤다면 ‘어떤 식으로 명령을 내리면 ‘더 잘 답을 한다’’ 라는 이야기를 들어 봤을 것이다.</p>

<h3 id="ai-는-확률의-문제다">AI 는 확률의 문제다.</h3>

<p>LLM 모델의 구조가 방대한 양의 3차원 축으로 데이터의 ‘연관성의 맵’을 구성하고, 거기서 어떤 질문이 들어올 때 그 ‘답’이라는 것은 소위 ‘연관성’ 이라는 것과 연결되는 것이다.</p>

<p>그렇기에 질문을 할 때, ‘연관성’을 잘 살려내는가 아닌가가 매우 중요해진다. 하지만 <strong>컴퓨터의 연산은 이 확률 계산에서 항상 동일한 값을 얻어내지 못한다</strong> 그리고 이러한 부분은 놀랍게도 마치 사람처럼, 같은 내용의 요청에 같은 답을 너무나 쉽게 내뱉던 기계가, 같은 내용의 답을 ‘매번 다를 수 있게’ 만드는 매우 신비로운 특성을 만들어냈고, 이러한 결과는 매우 훌륭한 도구임에도 치명적인 단점을 만들어낸다.</p>

<blockquote>
  <p>서비스는 일관성이 있어야한다.</p>
</blockquote>

<p>무형에서 유형까지, 우리가, 사회가 약속하고 있는 많은 것들이 있는데, 그런 것들 중 하나의 가치는 당연히 ‘재화를 제공한 서비스는 그 재화 만큼이라고 ‘느낄 수 있는’ 동일한 서비스를 재화를 들인 모두에게 제공해야 한다’ 라는 특성이다.</p>

<p>이러한 일관성이란 특성은 산업마다 그 편차는 있겠지만, 결국 상품이라는 근본적 성격에는 존재해야 한다는 게 우리의 문화속에, 가치 속의 근본적 성질이다.</p>

<p>빙 돌아왔지만, 다시 AI에 대해 돌아오면, 이러한 특성을 고려하게 될 때 매우 치명적인 단점을 AI 로부터 얻을 수 있다. 즉, 1만원을 내고도 어떤 사람의 AI는 유능해 보이지만, 어떤 사람의 AI는 그렇게 보이지 않게 될 수 밖에 없고, 이러한 편차가 존재 하기에 AI 프롬프팅 엔지니어링에 대한 이야기가 나올 수 밖에 없는 것이다. (물론 예전보단 지금은 덜 필요시 되긴 한다.)</p>

<p>서론이 길었지만, 어쨌든, 결론적으로 AI 는 그렇기에 ‘정답’에 가깝게 끌어낼 줄 아는가, 일관된 결과를 정확히 도출할 수 있는가? 는 매우 중요한 AI의 성능 지표가 된 것이다.</p>

<h3 id="새로운-프롬프팅-slow-thinking">새로운 프롬프팅 ‘Slow Thinking’</h3>

<p>기존에는 Chain of Thought 라는 방식이 굉장한 파장을 가져왔고, 많은 대형 모델들이 차례차례 방식을 기본값으로 넣으면서, 그 강화된 형태들을 통해 성능의 극대화를 끌어왔다. ‘Let’s Think Step by Step(단계별로 생각해보자)’ 라는 아주 기초적인 프롬프팅 문구일 텐데, 그럼에도 이러한 방식은 유효했다.</p>

<p>하지만 ‘slow thinking’ 이라는 프롬프팅 문구</p>

<p>‘Take a deep breath and work through this carefully.</p>

<p>This is a complex strategic decision that requires examining our assumptions…’</p>

<p>라는 문구를 넣으면서 다음 수준의 성능 향상이 있었다고 한다.</p>

<ul>
  <li>GPT Slow thinking 적용 시 Chain of Thought 보다 최소 4 ~ 10% 더 정확한 결과를 제공한다.</li>
  <li>클로드는 100점 만점 기준 4점의 성과</li>
  <li>제미나이 역시 8점 높은 결과를 제공함</li>
</ul>

<p>해당 내용을 찾아보면, 이러한 결과가 나온 이유는 ‘관점의 전환’ 이라는 차원으로 설명을 했다. 속도보다 정확성을 우선하고, 체계적인 접근을 유도하고, 복잡성의 인식 및 가정 검증을 이야기 하여 사실과 주장을 분해하며, 다층적 분석 유도의 키워드가 포함되어 단순히 단계별로 이미 ‘결정된 듯’ 한 사고 패턴에서 벗어날 수 있었기 때문이다.</p>

<h2 id="ai에게-프롬프팅의-의미하는-바는-뭘까">AI에게 프롬프팅의 의미하는 바는 뭘까?</h2>
<p>프롬프팅을 보면 볼 수록, AI가 언제 잘 이해하는가? AI는 언제 자신의 포텐셜을 100% 활용하는가? 그것은 사람이 어떤 문제, 어떤 상황, 어떤 조건을 어떻게 온전하게 이해하고 있는가?를 ‘외재화’ 시킨 형태와 유사하다는 생각이 든다.</p>

<p>좀 어렵게 표현 되었는데… 말 그대로 객관적으로 한 사람이 어떤 것들에 대해 온전히 ‘이해했다’ 는 상태를 외부적으로 나타낼 때의 특성이 고려 된게 아닐까? 하는 생각이 드는 것이다.</p>

<p>사람이 무언가를 이해할 때는, 단계적으로 이해할 때도 있고, 어떨 때는 인과관계를 기반으로 이해할 때도 있으며, 복합적인 다층 관계로 지식 자체도 일종의 구조화를 달성하여 이해하기도 한다. 이러한 뇌내의 정렬 상태는 외부적으로는 ‘이해했다’ 라고 표현할 수 있는 상태가 되고, 이를 기반으로 지식을 설명하거나 공유가 가능하다.</p>

<p>그런데 이러한 언어와 사고의 구조를 설명하는 표현을 LLM의 프롬프터로 넣어줌으로써 그 형태를 AI에게 요구하고, 그러한 구조적 형태가 잡히니 확률의 싸움인 LLM에게 보다 명확한 결과를 도출하는 보정의 작용을 하는게 아닐까?</p>

<p>그렇다면 앞으로의 AI를 다루는 사람, 혹은 AI를 다루는 도구의 방식은 더더욱 사람, 인류가 쌓아올린 지적 재산, 지적 철학과 방법론을 누가 더 세밀하게 적용하냐, 보정을 정밀하게 해내냐의 싸움이 아닐까? 라는 생각을 하게 된다.</p>

<h2 id="프롬프팅-가이드">프롬프팅 가이드</h2>
<p>부록 느낌이다. 공유해주신 분의 내용에서 발췌했다…</p>

<h3 id="프롬프팅-적용-방법">프롬프팅 적용 방법</h3>

<table>
  <thead>
    <tr>
      <th>분류</th>
      <th>문구 (Phrase)</th>
      <th>효과 (Effect)</th>
      <th>사용 시점 (When to Use)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.단계적 사고 (CoT 기반)</td>
      <td>"Let’s think step by step."</td>
      <td>복잡한 문제를 단계별로 명확하게 사고하게 함 (CoT의 기본)</td>
      <td>수학 문제, 로직 설명, 계획 및 전략 설계, 복잡한 지시 이해</td>
    </tr>
    <tr>
      <td>1.단계적 사고 (CoT 기반)</td>
      <td>"Show all your reasoning before you answer."</td>
      <td>사고 과정을 투명하게 드러내어 논리적 오류를 줄이고, 사용자가 검토 용이하게 함</td>
      <td>중간 과정의 논리가 중요한 문제<br />(예: 과학적 추론, 법률적 판단 근거, 디버깅)</td>
    </tr>
    <tr>
      <td>2.신중함 및 정확성 강조</td>
      <td>"Take a deep breath and work on this carefully."</td>
      <td>AI가 서두르지 않고 신중하게 정보를 처리하고 답변하도록 유도</td>
      <td>오류가 잦거나 민감한 정보를 다룰 때,<br />정밀한 판단이나 높은 정확도가 요구될 때</td>
    </tr>
    <tr>
      <td>2.신중함 및 정확성 강조</td>
      <td>"Let’s take it slow and go through this logically, ensuring each step is sound."</td>
      <td>논리적 흐름을 따라 차분히 문제를 해결하도록 유도하며, 각 단계의 타당성을 강조</td>
      <td>논증 구성, 토론 준비, 복잡한 시스템 분석,<br />의사결정 로직 수립 시</td>
    </tr>
    <tr>
      <td>2.신중함 및 정확성 강조</td>
      <td>"Take a deep breath and let’s work this out in a step-by-step way to be sure we have the right answer." (결합형)</td>
      <td>신중함과 단계적 분석을 동시에 강조하여, 복잡하고 중요한 문제에 대한 답변의 정확성과 신뢰도를 극대화</td>
      <td>매우 복잡하거나 결과의 파급효과가 큰 중요한 판단 문제, 여러 조건이 얽힌 문제</td>
    </tr>
    <tr>
      <td>3.전문가 관점 및 역할 부여</td>
      <td>"Think through this like a top expert in [분야] would. Consider all relevant factors and methodologies they would use."</td>
      <td>특정 분야 최고 전문가의 심층적이고 체계적인 사고방식과 지식 체계를 적용하도록 유도</td>
      <td>고난이도 전문분야 질문, 특정 역할<br />(예: 의사, 변호사, 과학자)의 관점에서 문제 해결 필요 시</td>
    </tr>
    <tr>
      <td>4.불확실성 관리 및 정직성</td>
      <td>"If you are unsure about any part of your answer, please state your uncertainty clearly and explain the reasons for it."</td>
      <td>AI가 자신의 지식 한계를 인지하고, 불확실한 정보에 대해 솔직하게 표현하며 그 근거를 제시하도록 유도</td>
      <td>최신 정보가 반영되지 않았을 가능성이 있거나, 정보의 모호성이 존재할 때, AI가 환각(hallucination)을 일으킬 가능성이 우려될 때</td>
    </tr>
    <tr>
      <td>5.심층 분석 및 다각적 고려</td>
      <td>"Let’s analyze this issue from multiple perspectives (e.g., economic, social, ethical). What are the pros and cons from each viewpoint?"</td>
      <td>단일 관점에서 벗어나 여러 각도에서 문제를 종합적으로 분석하고 평가하도록 유도</td>
      <td>사회적 이슈 분석, 정책 결정, 복잡한 딜레마 상황, 전략 수립 시 다양한 이해관계 고려</td>
    </tr>
    <tr>
      <td>5.심층 분석 및 다각적 고려</td>
      <td>"Before proposing a solution, let’s first identify the root causes of this problem and any underlying assumptions."</td>
      <td>피상적인 해결책이 아닌, 문제의 근본 원인을 파악하고 숨겨진 가정을 점검하여 더 본질적인 해결책을 찾도록 유도</td>
      <td>문제 해결 시나리오, 원인 분석이 중요한 과제,<br />장기적인 해결책 모색</td>
    </tr>
    <tr>
      <td>6.Step-Back Prompting</td>
      <td>"Before answering [구체적 질문 X], let’s first consider the general principles or concepts related to [더 넓은 주제 Y]."</td>
      <td>구체적인 문제에 매몰되기 전에, 관련된 일반 원칙이나 배경 지식을 먼저 활성화하여 문제 해결의 맥락과 깊이를 더함</td>
      <td>특정 사례에 대한 판단, 역사적 사건 분석, 새로운 개념 이해, 복잡한 이론 적용 시</td>
    </tr>
    <tr>
      <td>7.자기 비판 및 개선</td>
      <td>"Draft an initial response. Then, critically review your own response for any potential biases, inaccuracies, or areas for improvement. Finally, provide a revised and improved response."</td>
      <td>AI가 스스로 생성한 답변을 비판적으로 검토하고 개선하는 과정을 통해 답변의 질을 높임 (자기 교정 능력 향상)</td>
      <td>보고서 초안 작성, 주장 개발, 창의적 글쓰기, 코드 생성 후 디버깅 등 완성도 높은 결과물이 필요할 때</td>
    </tr>
    <tr>
      <td>8.문제 분해 및 구조화</td>
      <td>"This is a complex problem. Let’s break it down into [3-5] smaller, manageable sub-problems. Address each sub-problem systematically."</td>
      <td>큰 문제를 작고 다루기 쉬운 부분으로 나누어 체계적으로 접근함으로써 해결 가능성을 높임</td>
      <td>프로젝트 계획, 대규모 시스템 설계, 복잡한 연구 질문 해결, 장문의 글 구성</td>
    </tr>
  </tbody>
</table>

<h3 id="️-효과성-등급표">⚡️ 효과성 등급표</h3>

<table>
  <thead>
    <tr>
      <th>등급</th>
      <th>기법</th>
      <th>정확도 향상</th>
      <th>사용 난이도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>S급</td>
      <td>2번 (결합형), 7번</td>
      <td>매우 높음</td>
      <td>중간</td>
    </tr>
    <tr>
      <td>A급</td>
      <td>1번, 3번, 8번</td>
      <td>높음</td>
      <td>낮음</td>
    </tr>
    <tr>
      <td>B급</td>
      <td>5번, 6번</td>
      <td>중간-높음</td>
      <td>중간-높음</td>
    </tr>
    <tr>
      <td>C급</td>
      <td>4번</td>
      <td>중간</td>
      <td>낮음</td>
    </tr>
  </tbody>
</table>

<h3 id="-상황별-권장-기법">🎯 상황별 권장 기법</h3>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>권장 기법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>📊 수학/계산 문제</td>
      <td>1번 → 2번</td>
      <td>"Let’s think step by step" → "Take a deep breath and work carefully"</td>
    </tr>
    <tr>
      <td>🔬 전문적 분석</td>
      <td>3번 + 5번 + 4번</td>
      <td>전문가 관점 + 다각적 고려 + 불확실성 관리</td>
    </tr>
    <tr>
      <td>💼 복잡한 의사결정</td>
      <td>2번(결합) + 6번 + 7번</td>
      <td>신중함 강조 + Step-Back + 자기 비판</td>
    </tr>
    <tr>
      <td>🏗️ 대규모 프로젝트</td>
      <td>8번 + 5번 + 1번</td>
      <td>문제 분해 + 근본 원인 분석 + 단계적 사고</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="etc" /><category term="AI" /><category term="prompting" /><summary type="html"><![CDATA[AI 에게도 생각할 시간이 필요하다 : Slow Thinking LLM 과 관련하여 AI를 사용하다보면 답을 정확하게 준다고 생각이 들긴 하지만, 그럼에도 여전히 할루시에이션(hallucination)이 발생하는 경우를 느끼거나, 데이터가 오염되었다고 느끼는 경우가 발생한다. 그러는 와중에 이런 영상을 발견하게 되었다.]]></summary></entry><entry><title type="html">백엔드 개발자의 이직 커리어 준비 연구</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/31/t-backend-developper-career-preparing.html" rel="alternate" type="text/html" title="백엔드 개발자의 이직 커리어 준비 연구" /><published>2025-05-31T00:00:00+00:00</published><updated>2025-05-31T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/31/t-backend-developper-career-preparing</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/05/31/t-backend-developper-career-preparing.html"><![CDATA[<h2 id="introduce">Introduce</h2>
<p>백엔드 개발자로 생존한지 1년차… 
이제는 AI가 등장하면서 개발자의 위치는 지속적인 블러핑의 대상(?) 이 되어버렸다.</p>

<p>생각해보면 AI 덕에 엄청 편해졌지만, 그게 결국 오히려 ‘들킨’ 게 되어 버린걸까. 성장하지 않고 발전하지 않는 개발자들의 종말이라는 듯이.. 수 많은 회사들은 필요하지 않은 개발자들을 배제하기 시작했다.</p>

<p>끔찍하지만, 그래도 뭐 별수 있나. 이러한 일들이 수 차례 있어왔고 저항한다고 돈, 재화, 분배의 기준은 결국 기원 전이나 기원 후나 동일하다. 약육강식이 아니길 바라는 것은 사람의 본성일지 몰라도, 약육강식 아닌 방식이 완벽하게 정착할 수 없는 건 어쩌면 자연계가 정한 물리적 환경인데.</p>

<p>오히려 기술을 배우고 조금이라도 할 수 있게 된 내가 될수 있었단 점은 감사하다. 심지어 무언가를 만들 수 있다는 점은, 무언가를 다시 배우거나 생산해 낼 수 있다는 것이므로, 그것이 주는 안도감은 부정할 수 없다.</p>

<p>그런 점에서 이제 신입이지만… 필요한건 결국 길이다. 재직 중인 회사에서 백엔드는 나 혼자이고, 그러한 점은 내가 해야 할 일들과, 그러는 와중에 성장하기 위해 무얼 해야할지 알려주지도 가르쳐주지도 않는다. 뿐만 아니라 누군가가 말해주지 않아도 전문가가 되기 위해서는 단순한 것들은 최대한 AI에게 맡기고, 내가 할 일은 계속해서 더 어렵고, 더 복잡한 것들을 더 빠르게 해낼 수 있게 되는 것이다.</p>

<p>그러기 위해서 필요한 것은 길이다. 방향성이다. 트렌드를 읽고, 내 부족한 전문 지식을 채우는 것이다. 그렇기에 AI를 활용해 분석한 글을 그냥 올리는게 아니라 읽고, 소화하고, 해석해서, 내것으로 만든다. 이 글의 목적은 그것이다.</p>

<h2 id="백앤드-개발자-1--3년차-요구사항-분석-내용">백앤드 개발자 1 ~ 3년차 요구사항 분석 내용</h2>

<h3 id="조사-기반">조사 기반</h3>

<p>국내 개발자 채용시장의 인지도, 공고 수 등을 기반으로 높은 플랫폼을 선정하고, 이를 AI에게 크롤링을 맡겼다. 그리하여 선정한 플랫폼은 아래와 같다.</p>

<ul>
  <li>원티드 : 너무나 잘 아는, IT 스타트업 채용 공고가 꽤 많이 올라옴.</li>
  <li>프로그래머스 : 코드 중심의 개발자 채용 지향. 당연히 코테로도 유명하고, 플랫폼을 제공해주므로 주시해야 하는 사이트.</li>
  <li>점핏 : 사람인에서 만든 개발자 중심의 채용 플랫폼</li>
  <li>로켓펀치 : 스타트업 정보 공유 및 채용 플랫폼.</li>
  <li>잡코리아 / 사람인 : 이젠 레거시라고 불러도 될만한, 전형적인 구인구직 플랫폼</li>
  <li>랠릿 : 인프런이 만든 구인구짓 플랫폼</li>
</ul>

<p>각 플랫폼 검색에서 키워드들을 조합해서 경력 요건을 필터링하여 공고 수집을 요청했고 2.5 Gemini Pro 기반으로 수행되었다.</p>

<h3 id="전반적인-시장-동향">전반적인 시장 동향</h3>

<p>예상은 했지만, 1 ~ 3년차 백엔드 개발자 채용 공고는 역시나 AI 키워드가 눈에 띌 정도로 증가 했다. AI 기능은 기계적, 코딩으로 해결하지 못하는 것들을 해결하기 시작했고, 특히나 AI 기반 새로운 서비스는 정말 초고속으로 증가되는 만큼, 백엔드 인프라 구축의 필요성을 인지하고 있다고 AI 는 분석했다.</p>

<p>단, 여기서 AI 역량이라는 키워드가 주로 등장했다. 이는 AI 서비스에 대한 수요에 맞춰 백엔드 개발이 필요하지만, 그에 대한 이해도가 있진 않기에 이에 대한 이해, 활용 경험, 서빙 경험 등의 전반적인 경험치가 있으면 이를 중요시 하지만, 이에 비해 확립된 기술체계가 아직 정돈이 안되어 있다는 것을 보여주는 대목이라고 느꼈다.</p>

<p>당연히, 그러는 와중에도 비교적 AI 에 대해 자세하고 세세하게 언급하는 케이스들도 있다는 점에서 그냥 어떤 AI 든 Okay 이런 느낌은 아니니 주의가 필요해 보인다.</p>

<p>그러나 어쨌든 AI 의 분석 왈, 백엔드 개발 능력 위에 AI 라는 키워드가 추가적으로 요구되며, 이에 대해 정확히 파악하고 어떤 전략으로 구체적으로 AI를 어떻게 활용하였는가 라는 점을 중점적으로 생각할 필요가 있음을 보여주었다.</p>

<h3 id="필수-자격-요건">필수 자격 요건</h3>

<p>AI 가 분석한 핵심 백엔드 개발자들의 평균적인 필수 자격 요건은 다음 정도로 정리했다.</p>

<ul>
  <li>핵심 프로그래밍 언어 및 프레임워크:
    <ul>
      <li>NestJS 스택: Node.js, TypeScript에 대한 이해를 바탕으로 NestJS 프레임워크를 활용한 실무 개발 경험이 필수적으로 요구됩니다.</li>
      <li>Java 스택: Java 언어와 Spring Boot, Spring Framework(MVC 등)에 대한 깊이 있는 이해 및 이를 활용한 실무 개발 경험이 중요합니다.</li>
      <li>일부 공고에서는 NestJS와 Java/Spring 기술 스택을 함께 언급하며, 둘 중 하나에 대한 능숙한 활용 능력 또는 양쪽 모두에 대한 경험을 요구하기도 합니다.</li>
    </ul>
  </li>
  <li>데이터베이스 기술:
    <ul>
      <li>RDBMS (MySQL, PostgreSQL 등) 사용 경험과 SQL 작성 능력은 기본적인 요구사항입니다.</li>
      <li>NoSQL (MongoDB, Redis 등) 데이터베이스 사용 경험 또한 많은 공고에서 찾아볼 수 있으며, 특히 Redis는 캐싱, 비동기 처리 등 다양한 목적으로 활용될 수 있음을 명시하는 경우가 있습니다.</li>
    </ul>
  </li>
  <li>API 설계 및 개발:
    <ul>
      <li>RESTful API 설계 원칙에 대한 이해와 실제 개발 경험은 대부분의 백엔드 개발자에게 필수적으로 요구됩니다.</li>
      <li>API 문서화 도구(e.g., Swagger/OpenAPI) 사용 경험을 명시하는 공고도 있습니다.</li>
    </ul>
  </li>
  <li>버전 관리 시스템:
    <ul>
      <li>Git 및 Github (또는 유사 플랫폼) 사용 경험은 협업을 위한 기본적인 역량으로 간주됩니다.</li>
    </ul>
  </li>
  <li>기본적인 AI/ML 이해도:
    <ul>
      <li>AI/ML 관련 주요 용어 및 기본 개념에 대한 이해가 요구될 수 있습니다. 이는 명시적으로 자주 언급되지는 않으나, AI 역량을 요구하는 공고에서는 암묵적으로 포함되는 경우가 많습니다.</li>
      <li>AI 관련 프로젝트 경험이 없더라도, AI 기술에 대한 학습 의지나 높은 관심을 표명하는 것이 긍정적으로 작용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<p>분석한 내용에서 분명하게 드러나는 것은 다음과 같다.</p>

<p>1) 탄탄한 백엔드적 기술 능력은 필수 중에 필수. 언어나 프레임워크의 중요도는 당연히 Java 중심. 그러나 Node, NestJS 가 안되는 건 아님 
2) AI 와 관련된 언급은 필수적으로 등장하지만, 이는 우대적으로 언급됨.
3) 결론적으로 AI 역량을 더하더라도 NestJS, Java 등의 백엔드 기술 숙련도는 절대 놓치지 말아야 할 영역이다.</p>

<h3 id="평균-권장--우대-자격-요건">평균 권장 / 우대 자격 요건</h3>
<p>필수에서는 빠졌으나, 상당히 많이 요구된 것으로 정리된 키워드들이다.</p>

<ul>
  <li>프로그래밍 언어 (AI 관련):
    <ul>
      <li>Python: AI 및 머신러닝 분야의 사실상 표준 언어입니다. NestJS 또는 Java 개발자 채용 공고에서도 Python 사용 경험이나 학습 의지를 우대 조건으로 명시하는 경우가 많습니다.</li>
    </ul>
  </li>
  <li>AI/ML 프레임워크 및 도구:
    <ul>
      <li>TensorFlow, PyTorch, Scikit-learn 등 주요 머신러닝 라이브러리 및 프레임워크 사용 경험. (직접적인 언급 빈도는 낮으나, AI 프로젝트 경험을 우대하는 경우 관련 기술 포함 가능성 높음)</li>
      <li>Langchain, OpenAI API 등 LLM(거대 언어 모델) 관련 기술 활용 경험.</li>
    </ul>
  </li>
  <li>클라우드 플랫폼 경험:
    <ul>
      <li>AWS, GCP, Azure 등 주요 클라우드 서비스 사용 경험은 매우 빈번하게 요구됩니다. 특히 AI/ML 관련 서비스(e.g., AWS SageMaker, Google Vertex AI, Azure Machine Learning) 사용 경험은 큰 장점으로 작용합니다.</li>
    </ul>
  </li>
  <li>컨테이너화 및 오케스트레이션:
    <ul>
      <li>Docker, Kubernetes 사용 경험은 애플리케이션 배포 및 확장성 확보에 중요하게 고려됩니다.</li>
    </ul>
  </li>
  <li>메시지 큐 시스템:
    <ul>
      <li>Kafka, RabbitMQ 등 메시지 큐 시스템 사용 경험. 이는 대용량 데이터 처리 및 비동기 통신 아키텍처 구현에 중요합니다.</li>
    </ul>
  </li>
  <li>CI/CD 경험:
    <ul>
      <li>Jenkins, GitLab CI, GitHub Actions 등 CI/CD 파이프라인 구축 및 운영 경험은 개발 생산성 및 안정성 향상에 기여합니다.</li>
    </ul>
  </li>
  <li>대용량 트래픽/데이터 처리 경험:
    <ul>
      <li>대규모 사용자 요청을 효율적으로 처리하거나, 대용량 데이터를 분석하고 처리하는 시스템 개발 경험을 우대합니다.</li>
    </ul>
  </li>
  <li>AI 관련 프로젝트 수행 경험:
    <ul>
      <li>실제 AI 모델을 활용한 서비스 개발 프로젝트 또는 AI 관련 기능을 구현한 프로젝트 참여 경험은 직접적인 역량 증명으로 이어집니다.</li>
      <li>MLOps(Machine Learning Operations) 관련 경험 또는 이에 대한 높은 관심도 긍정적으로 평가될 수 있습니다. (단, 해당 공고는 4년 이상 경력 대상)</li>
    </ul>
  </li>
  <li>기타:
    <ul>
      <li>MSA (Microservices Architecture) 설계 및 개발 경험.</li>
      <li>테스트 코드 작성 능력 및 TDD(Test-Driven Development) 경험.</li>
    </ul>
  </li>
</ul>

<p>내용을 종합해보자면 여전히 백엔드라는 기둥에 AI 라는 장식이라는 구성에 가깝다. 내용적으로는 마치 DevOps 적 특성이 강하게 묻어나오는데, 이러한 특성은 내용을 생각해보면 짐작해볼 수 있을 것이다.</p>

<p>AI 서비스는 강력한 컴퓨팅 성능이 필요하다. 여전히 그 능력은 고성능 모델에 촛점이 맞춰져 있고, 최적화나, 가격 경쟁을 하기엔 여전히 실험적인 영역이 있다는 점은 부정할 수 없다. 그리고 이러한 점에서 서버에서 처리해 내는 것들은 당연히 필요하고, 온디바이스 컴퓨팅, 엣지 컴퓨팅은 아직은 갈길이 멀다. 이러한 점에서 클라우드 플랫폼 위에서 제공되는 다양한 기술을 서빙할 수 있어야하고, 그걸 위해서 알아야하는 백엔드 기술들은 자연스럽게 키워드에 녹아들어 있다.</p>

<p>비동기 IO 처리, 메시지 큐, 데이터베이스, 컨테이너, MSA 등 많은 요소들이 결국 클라우드 상에서 개발과 운영의 통합, 서비스의 전체적인 라이프사이클의 통합 및 체계화를 말하게 된다. 즉, DevOps 역량이 매우매우 중요하다는 것이다.</p>

<h2 id="데이터를-기반으로-정리해보면">데이터를 기반으로 정리해보면</h2>

<p>AI 의 대두는 기존에 웹 프로바이저닝을 해주던 업체, 플랫폼들의 방향에 나름의 파문을 일으켰다. 기존에 클라우드 플랫폼들은 서버리스, RDB서비스 등을 통해 백엔드라는 절차를 신경쓰지 않아도 되게 만든다던가, 다양한 서비스를 제공하여 결론적으로 백엔드 개발의 범위를 좁히고, 더 줄이는 역할을 하려는 서비스들 쪽으로 귀결되고 있었다.</p>

<p>하지만 AI는 발전되는 과정에서 하드웨어에 대한 성능 요구값을 매우 크게 끌어올렸고, 특히나 GPU 리소스의 필요를 끌어올리는 등을 포함하여 기존 클라우드 플랫폼의 노선에 부담을 주었다는 생각이 든다. 즉, 자원이 다시 한정적이게 만들었고, 그 만큼 백엔드 개발이나, 성능의 분배, 대용량 처리라는 전통적인 영역에 대한 더 큰 수요를 불러낸것 같다는 것이다.</p>

<p>그 결과 DevOps 의 중요성은 더욱 키워가는 게 아닌가 싶고, 그 과정에서 개발이 필요한 업체들은 자연스럽게 DevOps 기능을 포함한 클라우드 플랫폼 역량, 그리고 거기에 AI를 얹은 역량치를 요구하게 자연스럽게 흘러가고 있는게 보인다.</p>

<p>넓게 보면 오히려 AI가 백엔드의 가치나, 기회를 늘린 것이기도 하다는 생각도 ? 할 수 있는게 아닐까.</p>

<h3 id="nestjs-백엔드-개발자에-대한-ai-역량-심층-분석">NestJs 백엔드 개발자에 대한 AI 역량 심층 분석</h3>

<p>이 부분은 제미나이의 분석 과정에서 나온 내용인데, 학습의 키워드가 될 수 있으리라 생각되어 간단히 정리해보면 다음과 같다.</p>

<ul>
  <li>A. NestJS 백엔드 개발자의 기본 역량
    <ul>
      <li>TypeScript 및 Node.js 생태계에 대한 깊은 이해: NestJS는 TypeScript를 기반으로 하며 Node.js 런타임 환경에서 동작함. 따라서 TypeScript의 타입 시스템, 비동기 처리 방식, Node.js의 이벤트 루프, 모듈 시스템 등에 대한 충분한 이해가 필요.</li>
      <li>NestJS 프레임워크의 핵심 개념 숙달: 모듈(Modules), 컨트롤러(Controllers), 서비스(Services), 프로바이더(Providers), 의존성 주입(Dependency Injection), 미들웨어(Middleware), 파이프(Pipes), 가드(Guards), 인터셉터(Interceptors) 등 NestJS의 핵심 아키텍처 구성 요소에 대한 명확한 이해와 활용 능력이 요구.</li>
      <li>비동기 프로그래밍 및 이벤트 기반 아키텍처 이해: Node.js의 특성상 비동기 프로그래밍(Promise, async/await)에 능숙해야 하며, 이벤트 기반 아키텍처에 대한 이해는 실시간 서비스나 복잡한 데이터 흐름을 다룰 때 중요.</li>
      <li>Express.js 또는 Fastify 경험: NestJS는 내부적으로 Express.js (기본값) 또는 Fastify를 HTTP 서버 프레임워크로 사용함. 이들 프레임워크에 대한 기본적인 이해나 사용 경험은 NestJS를 더 깊이 있게 활용하는 데 도움이 된다.</li>
    </ul>
  </li>
  <li>B. NestJS 와 AI의 접점. 어떤 업무를 연관지어 해봐야 할까?
    <ul>
      <li>AI 모델 서빙 API 개발: Python 등 다른 언어로 개발된 AI 모델의 예측 기능을 외부 또는 내부 시스템에서 사용할 수 있도록 RESTful API 또는 GraphQL API 형태로 노출하는 역할을 담당.   </li>
      <li>외부 AI 서비스 연동: OpenAI API(ChatGPT, DALL-E 등), Google AI Platform API, AWS AI 서비스 API 등 이미 상용화된 외부 AI 서비스를 호출하고, 그 응답을 가공하여 애플리케이션의 특정 기능에 통합하는 작업을 해봐야 한다.</li>
      <li>데이터 전처리/후처리 API 개발: AI 모델에 입력될 데이터를 정제하거나 특정 형식으로 변환하는 전처리 과정, 또는 AI 모델로부터 나온 결과값을 사용자에게 보여주기 적합한 형태로 가공하는 후처리 과정을 담당하는 API를 개발해본다.</li>
      <li>실시간 AI 서비스 백엔드 개발: WebSocket 등을 활용하여 실시간으로 사용자 입력에 따라 AI 모델과 상호작용하는 서비스(예: AI 챗봇, 실시간 개인화 추천)의 백엔드 로직을 NestJS로 구현해본다.   </li>
      <li>AI 애플리케이션을 위한 인프라 지원: AI 모델의 학습 데이터 수집, 학습된 모델 관리, 모델 버전 관리, 배포 파이프라인과의 연동 등을 지원하는 백엔드 시스템 및 API를 구축하는 역할도 포함될 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="기술-면접-준비-방향">기술 면접 준비 방향</h3>

<ul>
  <li>A. 분석된 자격 요건 기반의 핵심 기술면접 주제 리스팅
    <ul>
      <li>NestJS/NodeJS 또는 Java/Spring 핵심 개념
        <ul>
          <li>NestJS: 모듈(Module), 컨트롤러(Controller), 서비스(Service), 프로바이더(Provider), 의존성 주입(DI), 데코레이터(Decorator), 파이프(Pipe), 가드(Guard), 인터셉터(Interceptor), 미들웨어(Middleware) 등 프레임워크의 핵심 구성 요소와 작동 원리에 대한 질문, TypeScript 및 Node.js 비동기 처리 방식에 대한 이해도</li>
          <li>Java/Spring: JVM(메모리 구조, GC), OOP(SOLID 원칙), 컬렉션 프레임워크, 동시성(멀티스레딩, Thread-safe), Spring Core(IoC 컨테이너, DI, Bean의 생명주기 및 스코프), Spring MVC(DispatcherServlet 동작 방식, 요청 처리 과정), Spring Boot(자동 설정, Actuator), JPA(영속성 컨텍스트, N+1 문제), Spring Data, AOP, Spring Security 기본 원리 등에 대한 질문</li>
        </ul>
      </li>
      <li>데이터베이스:
        <ul>
          <li>SQL 작성 능력(JOIN, 서브쿼리, 집계함수 등) 및 최적화.</li>
          <li>데이터베이스 Index의 원리와 효과적인 사용법.</li>
          <li>Transaction의 개념과 ACID 원칙, 격리 수준(Isolation Level).</li>
          <li>정규화(Normalization)의 개념과 장단점.</li>
          <li>Sharding과 Replication의 차이점 및 사용 사례.RDBMS와 NoSQL 데이터베이스의 차이점 및 각각의 적합한 사용 사례.</li>
        </ul>
      </li>
      <li>API 설계:
        <ul>
          <li>RESTful API 설계 원칙 (자원 표현, HTTP Method 활용, 상태 코드의 적절한 사용).</li>
          <li>API 보안 (인증/인가 방식: JWT, OAuth2 등).</li>
          <li>API 버전 관리 전략.</li>
        </ul>
      </li>
      <li>네트워크 기초:
        <ul>
          <li>TCP/IP 프로토콜 스택 및 계층별 역할.</li>
          <li>HTTP/HTTPS 프로토콜의 특징 및 차이점 (SSL/TLS 핸드셰이크 과정 포함).</li>
          <li>CORS(Cross-Origin Resource Sharing)의 개념과 해결 방법.</li>
        </ul>
      </li>
      <li>운영체제 기초:
        <ul>
          <li>프로세스(Process)와 스레드(Thread)의 차이점 및 컨텍스트 스위칭.</li>
          <li>동기(Synchronous)와 비동기(Asynchronous) 처리 방식의 차이.</li>
          <li>데드락(Deadlock) 발생 조건 및 해결 방법.</li>
        </ul>
      </li>
      <li>자료구조 및 알고리즘:
        <ul>
          <li>주요 코딩 테스트 플랫폼(프로그래머스, 백준 등)의 Level 2~3 수준 문제 해결 능력.</li>
          <li>자주 출제되는 유형: 배열, 문자열 처리, 정렬, 탐색(이진 탐색, DFS, BFS), 그래프 이론 기초, 동적</li>
          <li>프로그래밍(DP), 구현 중심 문제.</li>
        </ul>
      </li>
      <li>클라우드 및 컨테이너:
        <ul>
          <li>AWS, GCP, Azure 등 주요 클라우드 플랫폼의 핵심 서비스(컴퓨팅, 스토리지, 데이터베이스, 네트워킹)에 대한 이해 및 사용 경험.</li>
          <li>Docker 컨테이너의 기본 개념, 이미지 생성 및 관리, 컨테이너 실행 경험.</li>
          <li>Kubernetes의 기본 개념 및 필요성에 대한 이해 (1~3년차에게는 심층적인 운영 경험보다는 개념 이해 수준을 묻는 경우가 많음).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>B. AI 통합 역량에 관련된 예상 면접 질문 리스트
    <ul>
      <li>“AI/ML 관련 프로젝트 경험이 있다면 자세히 설명해주세요. 어떤 역할을 하셨고, 어떤 기술을 사용했으며, 결과는 어떠했나요?”</li>
      <li>“AI 모델을 서빙하기 위한 API를 설계한다면 어떤 점들을 고려해야 할까요?”</li>
      <li>“대용량 데이터를 AI 모델 학습에 사용하기 위해 백엔드에서 어떤 처리를 할 수 있을까요? 혹은 어떤 지원을 할 수 있을까요?”</li>
      <li>“AI 모델을 실제 서비스에 배포하고 운영할 때 백엔드 개발자로서 겪을 수 있는 어려움은 무엇이라고 생각하며, 이를 어떻게 해결하거나 기여할 수 있을까요?”</li>
      <li>“최근 관심 있게 보고 있는 AI 기술이나 트렌드가 있나요? 이를 현재 담당하고 있거나 앞으로 개발하고 싶은 백엔드 시스템에 어떻게 적용해볼 수 있을지 아이디어를 제시해주세요.”</li>
      <li>“AI 개발 도구(예: ChatGPT, GitHub Copilot)를 실제 개발 업무에 활용해본 경험이 있다면, 어떤 방식으로 효과적으로 사용했고, 사용하면서 느낀 한계점은 무엇이었는지 설명해주세요.”</li>
      <li>“머신러닝의 기본적인 개념(예: 지도학습과 비지도학습의 차이, 회귀와 분류 문제의 정의, 주요 알고리즘 한두 가지 예시)에 대해 간략히 설명해주실 수 있나요?”</li>
    </ul>
  </li>
  <li>C. 포트폴리오 프로젝트의 중여성 및 AI 역량 어필 전략
    <ul>
      <li>AI 관련 역량을 효과적으로 어필하기 위해서는 실제 프로젝트 경험을 포트폴리오에 잘 담아내는 것이 매우 중요할 것이다. 단순히 “AI 모델을 사용해봤다”는 수준을 넘어, <strong>어떤 구체적인 문제를 해결하기 위해 AI 기술을 도입했고, 그 과정에서 백엔드 개발자로서 어떤 기술적 고민을 하고 어떤 노력을 통해 문제를 해결했는지를 명확하고 설득력 있게 전달해야 한다는 점은 면접의 기본 중의 기본이리라.</strong></li>
      <li>GitHub 등을 통해 프로젝트 코드와 함께 README 파일을 체계적으로 관리하는 것이 좋다. README에는 프로젝트의 목표, 사용된 AI 기술 및 백엔드 기술 스택, 본인이 담당한 역할과 기여도, 그리고 프로젝트를 통해 얻은 정량적/정성적 성과를 명확히 명시해야 한다. 예를 들어, “AI 챗봇 응답 속도 개선을 위해 Redis 캐싱 전략을 도입하여 평균 응답 시간을 X% 단축” 또는 “사용자 이탈 방지를 위해 AI 기반 개인화 추천 API를 개발하고, A/B 테스트 결과 클릭률 Y% 증가”와 같이 구체적인 수치를 제시하면 더욱 효과적이다.</li>
      <li>AI 관련 기술 면접에서는 “왜 이 AI 기술을 선택했는가?” 그리고 “그 기술 도입을 통해 어떤 실질적인 가치를 창출했는가?” 에 대한 질문이 핵심적으로 나올 수 있다. 기업은 단순히 새로운 기술을 사용해 본 경험이 있는 개발자보다는, 기술을 통해 실제 문제를 해결하고 비즈니스 가치를 만들어낼 수 있는 인재를 선호하기 때문이다. 따라서 AI 기술 선택의 배경과 타당성, 그리고 그로 인해 얻어진 구체적인 효과를 명확하게 설명하는 것이 중요다.</li>
      <li>또한, 코딩 테스트 외에 CS(Computer Science) 기본 지식에 대한 테스트가 포함될 수 있으며 , 1~3년차 개발자에게 AI 관련 질문은 주로 프로젝트 경험이나 기본 개념 이해 수준에서 출제될 가능성이 높다. AI 모델의 복잡한 수학적 원리나 알고리즘을 직접 구현하는 것을 요구하기보다는, AI 시스템을 구성하는 백엔드 요소(데이터 처리, API 설계, 인프라 구축)에 대한 이해도와 실제 적용 경험을 더 중요하게 평가할 것이다. 물론, CS 기본기는 모든 개발 분야의 바탕이 되므로 꾸준한 학습과 준비가 필요하다.</li>
      <li>결론적으로, 기술 면접을 준비할 때는 자신이 참여했던 AI 관련 프로젝트의 전체 아키텍처, 데이터 흐름, 사용한 AI 기술의 구체적인 역할, 그리고 프로젝트 진행 과정에서 겪었던 트러블슈팅 경험과 해결 과정을 명확하게 설명할 수 있도록 철저히 준비해야 한다. 더불어 기본적인 머신러닝 용어와 개념, 그리고 자신이 주로 사용하는 백엔드 기술과의 연관성을 깊이 있게 숙지하는 것이 성공적인 면접의 핵심이 될 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="결론">결론</h2>
<p>어우 할 것도 많다. 사실 이걸 다 완벽하게 채울 수 있을까? 그럴리가. 시간도 돈도, 능력도 부족한게 사람인데 말이다… 😂 아픈 몸, 해야할 일 들 사이에서 얼마나 죽지 않고 버틸 수 있냐, 그렇게 해서 내 위치를 잡아내냐… 거의 인생 줄타기라는 생각이 새삼 든다.</p>

<p>그럼에도 Docker로 컨테이너화 하여 모듈화 시켜서 완벽하게 동작하는 서버를 볼 때 기분이 좋고, 이런 서비스를 만들어 보면 어떨까? 할 때 내 나름의 두근거림이 있다는 점에서, 역시나 백엔드가 맞았구나 라는 생각을 종종 해왔는데, 정리한 내용을 보면 더더욱 그렇게 느껴지는 것 같다.</p>

<p>Cursor, ContinueAI 를 시작으로 HuggingFace 를 써보고 Ollama를 써보고, 내가 원하는 AI 서비스를 만들어 보고자 노력하고, 그 과정에서 틈틈히 MSA 구축이나, Docker, Jenkins 를 통한 파이프라인 구축의 과정은 다행이도 1년이란 시간, 헛되지 않았음을 보여주는 귀한 경험들이었구나 하는 생각이다</p>

<p>오히려 사수가 없으니, 내마음대로 할 수 있었다고 해야 하려나? ㅋㅋㅋ….</p>

<p>앞으로 더 노력해야지. 이제 현 프로젝트의 대망의 꽃 CICD 구축을 필두로하여 신규 플젝 마무리까지 달려보자.</p>

<h2 id="참고자료">참고자료</h2>
<p>내가 본것 및 AI가 분석을 위해 자동으로 크롤링한 자료들이다</p>
<ol>
  <li><a href="https://blog.naver.com/jj601400/223108054162?viewType=pc">개발자 채용 공고 사이트 5선 모음 - 네이버 블로그</a></li>
  <li><a href="https://groupby.careers/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%B1%84%EC%9A%A9-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9%EC%82%AC%EC%9D%B4%ED%8A%B8-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%B6%94%EC%B2%9C/">스타트업채용 개발자 채용사이트 플랫폼 추천 - 그룹바이 블로그</a></li>
  <li><a href="https://www.jobkorea.co.kr/Search/?stext=NestJs">‘NestJs’ 관련 채용공고 - 총 70건의 검색결과 - 잡코리아</a></li>
  <li><a href="https://jumpit.saramin.co.kr/position/49520">AI연관 백엔드 개발자 (경력 3년이상) - 점핏</a></li>
  <li><a href="https://zighang.com/recruitment/31c6d1d0-758b-47a2-9184-42f788413d3a">로켓에이아이 채용 - Express &amp; ts-node 백엔드 개발자 - 직행</a></li>
  <li><a href="https://zighang.com/recruitment/68a9c26f-8954-4e17-8835-811ad7690dd2">외식인 채용 - Java(Spring) 백엔드 개발자 - 직행</a></li>
  <li><a href="https://www.jobkorea.co.kr/Recruit/GI_Read/46907671">(주)토리에듀핀 : Nest.Js/Next.Js /TypeScript 경력자 채용 - 잡코리아</a></li>
  <li><a href="https://www.wanted.co.kr/wd/218914">[빅웨이브로보틱스] 주니어 백엔드 개발자 (4년 이하) - 원티드</a></li>
  <li><a href="https://jumpit.saramin.co.kr/position/20607">백엔드 개발자 - NestJs (2년 이상) / 연봉 최소 5,000 - 점핏</a></li>
  <li><a href="https://www.wanted.co.kr/wd/227117">[살린] 백엔드 개발자 (Node.js, Nestjs) - 원티드</a></li>
  <li><a href="https://zighang.com/recruitment/72061315-8193-4bbf-9430-561d6b7b3f62">텐 채용 - MLOps 플랫폼 백엔드 개발자 (자바/4년 이상) - 직행</a></li>
  <li><a href="https://www.rallit.com/positions/89/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88-saas-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90">월간해킹 [정보보안 SaaS] 백엔드 개발자 - 랠릿</a></li>
  <li><a href="https://zighang.com/recruitment/fd435d07-ed0f-4cec-993c-ad2ad759881e">도슨티 채용 - AI engineer (prompt engineer) - 직행</a></li>
  <li><a href="https://www.wanted.co.kr/wd/273991">[에고이즘] 미뇽맨션 앱 개발자 (신입 3년 이하) - 원티드</a></li>
  <li><a href="https://www.jobkorea.co.kr/Search/?stext=nest%20JS">‘nest JS’ 관련 채용공고 - 총 66건 - 잡코리아</a></li>
  <li><a href="https://www.wanted.co.kr/wd/150445">[미리디] 백엔드 개발자 - 이미지 프로세싱 - 원티드</a></li>
  <li><a href="https://www.wanted.co.kr/wd/241717">[미리디] 백엔드 개발자 / 이미지 프로세싱 - 원티드</a></li>
  <li><a href="https://www.finalroundai.com/blog/backend-developer-interview-questions">The 25 Most Common Backend Developers Interview Questions - FinalRoundAI</a></li>
  <li><a href="https://roadmap.sh/questions/backend">50 Popular Backend Developer Interview Questions and Answers - roadmap.sh</a></li>
  <li><a href="https://www.reddit.com/r/dataengineering/comments/17ve0jc/what_are_the_fundamental_questions_in_a_data/?tl=ko">데이터 엔지니어링 면접 질문 모음 - Reddit</a></li>
  <li><a href="https://github.com/villainscode/tech-interview-for-junior">GitHub - tech-interview-for-junior - villainscode</a></li>
  <li><a href="https://www.interviewbit.com/system-design-interview-questions/">Top System Design Interview Questions (2025) - InterviewBit</a></li>
  <li><a href="https://igotanoffer.com/blogs/tech/system-design-interviews">System Design Interview Q&amp;A - IGotAnOffer</a></li>
  <li><a href="https://velog.io/@jx7789/%EC%8B%A0%EC%9E%85-AI%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A4%80%EB%B9%84%ED%95%98%EB%8A%94-30%EA%B0%80%EC%A7%80-ML%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5">신입 AI개발자 면접 기초 개념 30가지 - velog</a></li>
  <li><a href="https://github.com/boost-devs/ai-tech-interview">GitHub - ai-tech-interview - boost-devs</a></li>
  <li><a href="https://velog.io/@jx7789/%EC%8B%A0%EC%9E%85-AI%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A4%80%EB%B9%84%ED%95%98%EB%8A%94-30%EA%B0%80%EC%A7%80-Python-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5">신입 AI개발자 Python 면접 기초 개념 30가지 - velog</a></li>
  <li><a href="https://programmers.co.kr">프로그래머스 공식 홈페이지</a></li>
  <li><a href="https://m.blog.naver.com/codeitofficial/223431910683">신입 개발자 면접 단골 질문 가이드 - 네이버 블로그</a></li>
  <li><a href="https://bagyun.tistory.com/73">NodeJS/NestJS 신입 질문 모음 - 빠균’s 개발노트</a></li>
  <li><a href="https://velog.io/@jaegeunsong_1997/NestJS-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8">NestJS 면접 질문 정리 - velog</a></li>
  <li><a href="https://github.com/gasangw/NestJS-Interview-Questions-And-Answers">GitHub - NestJS Interview Questions - gasangw</a></li>
  <li><a href="https://dev-coco.tistory.com/153">신입 자바 기술면접 질문 정리 - 슬기로운 개발생활</a></li>
  <li><a href="https://study-easy-coding.tistory.com/145">주니어 JAVA 백엔드 면접 질문 - 개발 개맛집</a></li>
  <li><a href="https://devsurimlee.tistory.com/50">백엔드 면접 질문 리스트 - 개발새발 블로그</a></li>
  <li><a href="https://www.baeldung.com/spring-interview-questions">Top Spring Framework Interview Questions - Baeldung</a></li>
  <li><a href="https://www.geeksforgeeks.org/spring-interview-questions/">Spring Interview Q&amp;A - GeeksforGeeks</a></li>
  <li><a href="https://zero-base.co.kr/event/media_BE_school_qna">신입 백엔드 면접 질문 사례 - 제로베이스</a></li>
  <li><a href="https://ddooroong.tistory.com/entry/%EC%B7%A8%EC%A4%80-%EA%B8%B0%EB%A1%9D-%EC%8B%A0%EC%9E%85-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%ED%9B%84%EA%B8%B0-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%9D%B8%EC%84%B1%EB%A9%B4%EC%A0%91-%EC%B5%9C%EC%A2%85%EB%A9%B4%EC%A0%91">신입 백엔드 면접 후기 (기술/인성/최종) - ddooroong 블로그</a></li>
  <li><a href="https://m.blog.naver.com/jnh02215/223669963273">3년 차 백엔드 면접 후기 (2024) - 네이버 블로그</a></li>
  <li><a href="https://velog.io/@lifeisbeautiful/%EC%9E%90%EC%A3%BC-%EB%B4%90%EC%95%BC%ED%95%A0-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%EC%9C%A0%ED%98%95-%EB%B0%8F-%EC%A0%95%EB%A6%AC">코딩테스트 문제 유형 및 정리 - velog</a></li>
  <li><a href="https://katfun.tistory.com/226">프로그래머스 코딩테스트 전략 - katfun.tistory</a></li>
  <li><a href="https://www.wanted.co.kr/events/22_11_s01_b15">코딩테스트 가이드 (원티드)</a></li>
  <li><a href="https://hoons-dev.tistory.com/66">2023 카카오 코딩테스트 후기 - 1차</a></li>
  <li><a href="https://hoons-dev.tistory.com/71">2023 카카오 코딩테스트 후기 - 2차</a></li>
  <li><a href="https://kimtaesoo99.tistory.com/265">삼성 SW 역량테스트 B형 후기 - 김태수 블로그</a></li>
  <li><a href="https://algosketch.tistory.com/187">팀네이버 신입공채 후기 (2024) - 알고스케치</a></li>
  <li><a href="https://blog.naver.com/skbalm/221695335862?viewType=pc">백엔드 주니어 면접 후기 총정리 - 네이버 블로그</a></li>
  <li><a href="https://mand2.github.io/others/interviews/">면접 질문 정리 - 고라니의 개발일기</a></li>
  <li><a href="https://github.com/ksundong/backend-interview-question">GitHub - 백엔드 인터뷰 질문 모음 - ksundong</a></li>
  <li><a href="https://velog.io/@spamdong/%EB%A9%B4%EC%A0%91-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8">데이터 엔지니어 면접 질문 - velog</a></li>
  <li><a href="https://velog.io/@minsgy/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%ED%95%99%EC%8A%B5%EB%82%B4%EC%9A%A9">백엔드 면접 학습내용 정리 - velog</a></li>
  <li><a href="https://m.hanbit.co.kr/channel/view.html?cmscode=CMS9960904389">경력별 면접 준비 도서 추천 5권 - 한빛+</a></li>
  <li><a href="https://haesoo9410.tistory.com/351">코딩테스트 준비 - Harry’s diary</a></li>
  <li><a href="https://sophuu.tistory.com/89">코딩테스트 플랫폼 비교 - sophuu.tistory</a></li>
  <li><a href="https://nbcamp.spartacodingclub.kr/blog/2025-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%EB%AC%B8%EC%A0%9C%EC%9D%80%ED%96%89-%EB%A9%B4%EC%A0%91-%EA%BF%80%ED%8C%81%EA%B3%BC-%EC%98%88%EC%83%81-%EC%A7%88%EB%AC%B8-top-25-47008">백엔드 개발자 면접 문제은행 (2025) - Spartan</a></li>
  <li><a href="https://techdevguide.withgoogle.com/paths/interview/">Interview Prep - Google Tech Dev Guide</a></li>
  <li><a href="https://interviewkickstart.com/courses/back-end-engineering-interview-masterclass">Backend Developer Interview Course - InterviewKickstart</a></li>
  <li><a href="https://m.blog.naver.com/khaiblog/222520897031">면접에서 인재 찾기 힘들 때 - 네이버 블로그</a></li>
  <li><a href="https://www.codestates.com/blog/content/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EC%8B%A0%EC%9E%85-%EB%A9%B4%EC%A0%91-tip">IT 스타트업 신입 면접 준비 가이드 - 코드스테이츠</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><category term="이직" /><category term="Backend" /><summary type="html"><![CDATA[Introduce 백엔드 개발자로 생존한지 1년차… 이제는 AI가 등장하면서 개발자의 위치는 지속적인 블러핑의 대상(?) 이 되어버렸다.]]></summary></entry><entry><title type="html">백엔드 개발자, 2025년 트렌드 정리하기</title><link href="http://localhost:4000/backend/2025/05/25/00-backend-developper-issues.html" rel="alternate" type="text/html" title="백엔드 개발자, 2025년 트렌드 정리하기" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/25/00-backend-developper-issues</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/25/00-backend-developper-issues.html"><![CDATA[<h2 id="1-백엔드-왜-지금-이-변화를-주목하려고-하는가">1. 백엔드, 왜 지금 이 변화를 주목하려고 하는가?</h2>
<p>백엔드는 더 이상 단순히 데이터를 처리하고 저장하는 ‘뒷단’이 아니다. 서비스의 확장성, 안정성, 그리고 궁극적으로 사용자 경험의 질을 결정하는 핵심 두뇌이자 심장부이다. 기업들은 갈수록 더 빠르고, 더 유연하며, 더 비용 효율적인 시스템을 요구하고 있으며, 이러한 요구는 백엔드 아키텍처와 기술 스택의 끊임없는 진화를 촉진한다.</p>

<p>최신 트렌드를 이해하는 것은 단순히 유행을 쫓는 것이 아니라, 더 나은 아키텍처를 설계하고, 문제를 해결하며, 궁극적으로 더 가치 있는 서비스를 만들어내는 데 필수적이다. 더불어 점점 가속화되고 바이브 코딩이라는 말이 나올 정도로 개발의 사이클이 변화하고 있고, 이는 비즈니스적 문화와 가치 역시 바뀌고 있다는 것을 말하고 있으며, 이러한 상황은 인력시장의 개편 역시 당연한 말이지만 영향이 있다는 점을 새삼 느끼고 있다.</p>

<p>그렇기에 이러한 점들을 종합하여, AI의 성능, 능력을 봄과 함께 나의 백엔드 개발자로의 역량을 위하여 정리해본다.</p>

<h2 id="2-2025-백엔드-시장의-핵심-트랜드-5가지">2. 2025 백엔드 시장의 핵심 트랜드 5가지</h2>
<p>백엔드 시장의 변화를 주도하는 주요 기술 트렌드를 여러분의 시선으로 함께 살펴본다.</p>

<p><strong>2.1 클라우드 네이티브 &amp; 서버리스 아키텍처의 확산</strong>
서버리스 컴퓨팅은 인프라 비용 절감과 확장성 향상을 위해 기업들이 점차 더 많이 채택하고 있으며, AWS Lambda, Google Cloud Functions, Azure Functions와 같은 플랫폼이 이러한 추세를 주도한다. 서버리스 컴퓨팅 시장은 2024년부터 2029년까지 연평균 15.3% 성장하여 447억 달러에 이를 것으로 예상된다. 이러한 아키텍처의 핵심 이점은 서버 관리가 필요 없고, 수요에 따라 자동으로 확장되며, 사용량 기반 과금으로 비용 효율적이라는 점이다. 이러한 변화는 광범위한 디지털 전환 노력과 하이브리드 작업 환경의 증가에 의해 더욱 가속화된다.  </p>

<p>클라우드 네이티브 기술의 채택은 컨테이너화의 발전을 이끌고 있으며, 조직들은 마이크로서비스와 클라우드의 확장성 및 민첩성을 적극적으로 활용한다. Kubernetes는 컨테이너화된 애플리케이션의 배포, 관리, 확장을 자동화하여 클라우드 전환을 가속화하는 데 핵심적인 역할을 한다. 서버리스 및 클라우드 네이티브 아키텍처의 광범위한 도입은 백엔드 개발의 근본적인 변화를 의미하며, 인프라 관리에서 코드 및 서비스 관리로 초점이 이동한다. 서버리스 컴퓨팅의 주요 이점은 서버를 관리할 필요가 없다는 점이며 , Docker와 Kubernetes를 통한 컨테이너화 및 오케스트레이션은 배포, 관리, 확장을 자동화하고 , 인프라 계층을 추상화한다. 이러한 점진적인 추상화는 개발자들이 기저 하드웨어에 대한 걱정을 덜고 애플리케이션 로직, 서비스 계약, 분산 환경 내 서비스 상호작용에 더 집중하게 만든다. 이는 백엔드 개발에서 더 높은 수준의 관심사로의 전환을 의미하며, 운영 부담을 덜어줌으로써 개발자 생산성을 향상시킨다.  </p>

<p>그러나 이러한 광범위한 도입에도 불구하고, Kubernetes 구성의 내재된 복잡성은 여전히 중요한 과제로 남아있으며, 특히 보안 및 비용 최적화 측면에서 두드러진다. 57%의 조직이 컨테이너 권한 조정(rightsizing)을 효과적으로 관리하지만, 43%는 여전히 개선이 필요하며 이는 클라우드 비용에 직접적인 영향을 미친다. 또한, 이미지 취약점과 오래된 컨테이너 이미지는 증가하는 우려 사항이다. 이는 Kubernetes가 강력한 기능을 제공함에도 불구하고, 기본 보안 설정이 견고하지 않고 사용자 정의 가능성이 오작동으로 이어질 수 있음을 시사한다. 따라서 조직은 지속적인 모니터링, 권한 조정, 취약점 스캔을 위한 전문 기술과 자동화된 도구에 투자하여 컨테이너화의 이점을 완전히 실현하면서도 위험을 완화해야 한다.  </p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0002.png" alt="" /></p>

<blockquote>
  <p>클라우드 환경에서 서버리스 함수, 컨테이너, 그리고 Kubernetes 클러스터가 상호작용하는 모습을 보여주는 아키텍처 다이어그램.(출처 - <a href="https://www.researchgate.net/figure/In-the-test-platform-serverless-functions-are-deployed-in-a-Kubernetes-cluster-using-the_fig1_348914380">ResearchGate</a>)</p>
</blockquote>

<p><strong>2.2 AI 기반 개발의 가속화</strong>
인공지능(AI)은 백엔드 개발 효율성을 높이는 데 통합되고 있으며, GitHub Copilot, Cursor, ChaGPT Codex, Claude Code 와 같은 AI 코드 어시스턴트, OtterTune과 같은 AI 기반 데이터베이스 쿼리 최적화 도구, Postman AI와 같은 자동화된 API 문서화 도구가 활용된다. AI는 개발자를 대체하기보다는 반복적인 작업을 자동화하여 개발자의 업무를 용이하게 하는 데 기여한다. AI 알고리즘은 마이크로서비스의 확장성과 성능을 최적화하여 추가 하드웨어 및 인프라 비용을 절감할 수 있다. AI는 예측 분석 및 실시간 의사결정을 통해 애플리케이션 성능을 향상시키며, 서버리스 환경에서도 자동화와 결합되어 효율성을 증대시킨다. 2024년에는 콘텐츠 생성 및 통찰력 제공을 넘어 실제 행동을 수행할 수 있는 ‘Agentic AI’의 등장은 매우 핫하였고 2025년은 그러한 관심과 노력의 결실들이 대거 쏟아지고 있다.  </p>

<p>AI의 역할은 백엔드 개발에서 단순한 지원을 넘어 소프트웨어 전달 수명 주기 전반에 걸쳐 자동화 및 자율적 의사결정에 적극적으로 참여하는 방향으로 진화하고 있다. 초기에는 AI가 코드 지원 및 API 문서화와 같은 도구로 인식되었지만 , 이제는 마이크로서비스를 최적화하고 , 예측 알고리즘을 통해 애플리케이션 성능을 향상시키며 , 심지어 ‘Agentic AI’로서 행동을 수행하는 단계에 이르렀다. 이러한 발전은 AI가 백엔드 시스템 내에서 자율 최적화 및 운영이 가능한 내장된 능동적 구성 요소가 되고 있음을 시사한다. 따라서 <strong>백엔드 개발자들은 AI 에이전트와 통합되거나 잠재적으로 AI 에이전트에 의해 관리되는 시스템을 설계하는 방법을 이해해야 하며, 이는 AI 모델 통합 및 윤리적 AI 고려 사항에 대한 새로운 기술을 요구한다.</strong></p>

<p>AI가 백엔드 시스템 전반에 걸쳐 통합이 증가함에 따라, 효과적인 AI 활용을 위한 기본 요구 사항으로서 데이터 품질 및 통합 데이터 제어에 대한 더 큰 초점이 필요하다. AI는 “올바른 데이터가 없으면 지능형 애플리케이션으로서의 가치를 얻을 수 없다”고 명시하며 , 데이터에 대한 “통합 제어”의 필요성을 강조한다. 이는 백엔드 시스템에서 AI로부터 얻는 가치(예: 최적화, 지능형 애플리케이션)가 AI 모델에 공급되는 데이터의 품질, 접근성 및 거버넌스에 직접적으로 비례한다는 점을 강조한다. 따라서 백엔드 개발자와 데이터 아키텍트들은 강력한 데이터 파이프라인, 실시간 데이터 처리 능력 , 그리고 강력한 데이터 거버넌스를 우선시하여 AI 모델이 신뢰할 수 있고 잘 관리된 데이터로 작동하도록 해야 한다.  </p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0003.png" alt="" /></p>
<blockquote>
  <p>The AI Code Editor 를 표방하는 <strong>Cursor</strong>(출처 - <a href="https://www.cursor.com/">커서 공식 사이트</a>)</p>
</blockquote>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0004.png" alt="" /></p>
<blockquote>
  <p>백엔드 기술에 특화를 표방한 VSC 확장 프로그램 <strong>Workik</strong>(출처 - <a href="https://workik.com/">Workik. 공식 사이트</a>)</p>
</blockquote>

<p><strong>2.3 마이크로서비스 및 컨테이너화의 진화</strong>
마이크로서비스 아키텍처는 <code class="language-plaintext highlighter-rouge">DevOps</code> 엔지니어에게 복잡한 분산 시스템 관리를 용이하게 하여 확장 가능하고 효율적인 애플리케이션 구축에 집중할 수 있도록 돕는다. 이는 애자일 방법론과 결합하여 협업, 유연성, 배포 속도를 향상시키며, 각 팀이 독립적으로 작업할 수 있게 한다. 마이크로서비스가 증가함에 따라 서비스 메시는 서비스 간 통신, 관찰성, 보안, 트래픽 관리 등을 위한 전용 인프라 계층을 제공하여 복잡성을 완화한다. <code class="language-plaintext highlighter-rouge">GitOps</code>는 Git을 단일 진실 공급원(SSOT)으로 사용하여 인프라 및 애플리케이션을 선언적으로 관리함으로써 DevOps 관행을 혁신하고, 배포 프로세스를 투명하고 자동화하며 협업적으로 만든다.  </p>

<p>서비스 메시와 GitOps에 의해 지원되는 마이크로서비스의 진화는 분산 시스템 관리에서 추상화 및 자동화의 증가로 이어지고 있으며, 개발자의 초점을 저수준 오케스트레이션에서 비즈니스 로직 및 애플리케이션 설계와 같은 고수준 관심사로 이동시킨다. 서비스 메시는 “서비스 간 통신을 촉진하는 전용 인프라 계층을 제공하여 이러한 과제를 완화”하고 “서비스 검색, 장애 복구, 로드 밸런싱, 메트릭”을 처리하여  개발자들이 “핵심 비즈니스 생산성 향상에 집중”할 수 있도록 한다. GitOps는 “모든 배포를 자동화하고 기존 인프라를 효율적으로 관리”한다. 이는 마이크로서비스에 내재된 운영 복잡성이 전용 도구와 방법론에 의해 점차 관리되고 있음을 나타내며, 개발자들을 수동 구성 및 문제 해결에서 해방시킨다. 이는 “플랫폼 엔지니어링” 으로의 강력한 추진을 의미하며, 내부 플랫폼이 “황금 경로(golden paths)”와 개발자 친화적인 인터페이스를 제공하여 개발자 생산성을 더욱 향상시키고 시장 출시 시간을 단축한다. 결국 결론은 자동화와 단일화되고 보다 섬세하게 가속화된 것들이 개발의 속도를 더욱 가속화시킨다고 볼 수 있다. </p>

<p>그러나 모듈성과 확장성의 이점에도 불구하고, 분산 시스템의 내재된 복잡성, 특히 데이터 일관성 및 연쇄적 장애와 관련하여 여전히 중요한 아키텍처적 과제로 남아있으며, 개발자들이 적극적으로 해결해야 한다. 마이크로서비스 아키텍처에서 “복잡성은 개별 기능의 상호 연결로 이동”하며, “아키텍처적 과제에는 비동기 통신, 연쇄적 장애, 데이터 일관성 문제, 서비스 검색 및 인증 처리가 포함된다”고 명시되어 있다. <strong>서비스 메시가 통신 및 검색에 도움이 되지만, 독립적인 서비스 간 데이터 일관성을 보장하고 장애의 파급 효과(연쇄적 장애)를 관리하는 문제는 완전히 추상화되지 않는다.</strong> 이는 고급 도구가 있더라도 백엔드 개발자들은 특히 중요한 데이터를 다룰 때 탄력적이고 일관성 있으며 내결함성 있는 마이크로서비스를 설계하기 위해 분산 시스템 원리에 대한 깊은 이론적 이해가 필요하다는 것을 의미한다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0005.png" alt="" /></p>
<blockquote>
  <p>GitOps 프로세스 도식(출처 - <a href="https://saramin.github.io/2020-05-01-k8s-cicd/">사람인 기술 블로그</a>)</p>
</blockquote>

<p><strong>2.4 API 경제의 확장과 보안강화</strong>
API는 거의 모든 소프트웨어 개발의 핵심이며, 사용자 경험, 파트너 생태계, 내부 아키텍처를 지원한다. <code class="language-plaintext highlighter-rouge">RESTful API</code>가 여전히 지배적이지만, <code class="language-plaintext highlighter-rouge">GraphQL</code>은 유연한 데이터 페칭과 단일 요청으로 여러 API 호출을 줄이는 이점 때문에 복잡한 애플리케이션에서 대안으로 성장하고 있다. GraphQL은 필요한 데이터만 가져오고 여러 API 호출을 단일 요청으로 줄여 모바일 및 마이크로서비스에 적합하다. <code class="language-plaintext highlighter-rouge">gRPC</code>는 마이크로서비스 환경에서 고속 통신을 지원한다.  </p>

<p>사이버 위협이 정교해짐에 따라 <strong><a href="https://cloud.google.com/learn/what-is-zero-trust?hl=ko">Zero Trust 보안 모델</a></strong>이 백엔드 인증 및 API 보안에 필수적이다. 2024년에는 API에 대한 공격이 49% 급증했으며, 비효율적인 인증/인가가 주요 원인이다. API의 보편성과 증가하는 공격 표면은 반응적 보안 조치에서 개발 수명 주기 전반에 걸쳐 통합된 사전 예방적 “보안 설계” 원칙으로의 근본적인 전환을 요구한다. API는 “대부분의 소프트웨어 개발의 핵심”이며 , 2023년 1분기부터 2024년 1분기 사이에 애플리케이션 및 API에 대한 웹 공격이 49% 급증했으며, “비효율적인 API 인증 및 권한 부여”가 주요 원인이다. 이러한 직접적인 상관관계는 API가 더 이상 단순한 통합 지점이 아니라 중요한 보안 경계임을 의미한다. 따라서 “백엔드 개발에서 보안은 더 이상 부차적인 고려 사항이 아니라 핵심 요구 사항”이다. 개발자들은 Zero Trust 보안 모델 을 채택하고, CI/CD 파이프라인에 “자동화된 보안 테스트” 를 통합하며, 초기 설계 단계부터 강력한 인증/권한 부여 메커니즘 을 우선시해야 한다.  </p>

<p>이러한 흐름에서 API 프로토콜(REST, GraphQL, gRPC)의 다양화는 특정 사용 사례에 대한 최적화된 데이터 가져오기 및 고성능 통신 요구에 의해 주도되는 아키텍처 성숙도의 증가를 반영하지만, 각 설명이 이렇게 길어지는 만큼 당연히 실제 API 관리의 복잡성도 가중시킨다. 따라서 GraphQL은 “정확히 필요한 데이터”를 가져오고 “여러 API 호출을 줄여”  “마이크로서비스 및 모바일 애플리케이션에 더 적합”하다. gRPC는 “마이크로서비스 환경에서 고속 통신”을 지원한다. 이는 API 프로토콜 선택이 단순한 선호를 넘어 성능 및 데이터 유연성 요구 사항에 의해 주도되는 미묘한 결정이 되고 있음을 나타낸다. <strong>백엔드 개발자들은 여러 API 패러다임에 능숙하고 각 패러다임의 장단점을 이해하며, 멀티 클라우드 환경에서 다양한 프로토콜을 처리할 수 있는 “클라우드 중립적”이고 “범용 API 관리 솔루션” 을 설계할 수 있어야 한다.</strong></p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0006.png" alt="" /></p>
<blockquote>
  <p>각 통신 방식에 대한 요약 이미지(출처 - <a href="https://blog.stackademic.com/choosing-between-grpc-rest-and-graphql-for-designing-and-implementing-apis-25df124848dc/">Ian Kiprono</a>)</p>
</blockquote>

<p><strong>2.5 데이터 아키텍처의 현대화</strong>
2024년 데이터 아키텍처는 실시간 데이터 처리를 위한 인프라 현대화와 AI/ML 기능 활성화에 중점을 둔다. IoT 장치 및 소셜 미디어 피드와 같은 스트리밍 데이터 소스의 증가는 실시간 분석을 통한 효율적인 통찰력 확보를 요구한다. 분산 데이터 아키텍처는 실시간 데이터 처리, 데이터 접근 시간 단축, 중복성 제공, 유연성 증대 등의 이점을 제공한다. Oracle, SQL Server, IBM Db2와 같은 데이터베이스는 AI 기반 자동 인덱싱 및 지능형 워크로드 관리 기능을 포함하고 있다. AI는 데이터베이스 관리의 일상적인 작업을 자동화하고 데이터 분석 기능을 향상시킨다. 데이터 품질 문제가 기술 예산의 상당 부분을 차지하므로, 분산 아키텍처 구현 시 데이터 거버넌스에 신중한 접근이 필요하다.  </p>

<p>실시간 데이터 요구 사항과 AI 통합의 융합은 현대 데이터 아키텍처의 성공적인 구현과 실행 가능한 통찰력을 위해 강력한 데이터 품질과 책임 있는 데이터 거버넌스를 중요하게 만든다. 보고서들은 “운영 실시간 분석을 늘리고 AI 및 ML 기능을 활성화하기 위해 데이터 아키텍처를 현대화”할 필요성을 강조한다. AI는 “자율 데이터베이스 운영” 및 “향상된 데이터 분석”을 통해 데이터베이스 관리를 혁신하고 있다. 그러나 “데이터에 대한 신뢰가 없으면 어떤 분산 아키텍처도 ‘감탄하고 분석할 수는 있지만 실행할 수 없는’ 귀중한 보석에 불과할 것”이라는 경고가 반복된다. 이는 고급 분석 및 AI 기능이 낮은 데이터 품질에 의해 병목 현상을 겪는다는 중요한 의존성을 강조한다. 따라서 백엔드 개발자와 데이터 아키텍트들은 “책임 있는 데이터 거버넌스” 와 강력한 데이터 파이프라인을 우선시하여 이러한 고급 시스템에 공급되는 데이터가 신뢰할 수 있고 잘 관리되도록 해야 한다</p>

<p><strong>2.6 엣지 컴퓨팅 및 분산 시스템의 중요성 증대</strong>
5G 및 IoT의 부상으로 인해 엣지 컴퓨팅은 백엔드 서비스를 사용자에게 더 가깝게 실행하여 속도와 효율성을 향상시키는 데 필수적이다. Cloudflare, Akamai와 같은 CDN 제공업체는 엣지 컴퓨팅 기능을 확장하고 있으며, FaunaDB, Cloudflare D1과 같은 데이터베이스는 전역 분산 스토리지를 제공한다. 실시간 애플리케이션(게임, AR/VR, IoT)이 엣지 컴퓨팅의 가장 큰 이점을 얻는다. 분산 시스템 아키텍처 중 셀 기반 아키텍처는 복원력을 강조하고 “블래스트 반경”을 최소화하여 시스템의 한 부분이 실패하더라도 다른 부분에 미치는 영향을 제한한다.  </p>

<p>5G 및 IoT에 의해 촉진되는 초저지연 및 향상된 복원력에 대한 요구는 백엔드 서비스가 설계되고 배포되는 방식을 근본적으로 변화시키며, 컴퓨팅과 데이터를 사용자에게 더 가까운 엣지로 이동시킨다. 엣지 컴퓨팅은 백엔드 서비스를 “사용자에게 더 가깝게 실행하여 속도와 효율성을 향상”시키며 , 특히 “실시간 애플리케이션(게임, AR/VR, IoT)”에 중요하다. 이는 밀리초가 중요한 5G 및 IoT의 요구 사항에 대한 직접적인 응답이다. 동시에 “셀 기반 아키텍처는 복원력과 블래스트 반경 최소화를 강조하며 주목받고 있다”. 이는 중앙 집중식 모놀리식 배포에서 로컬 처리 및 데이터 저장이 핵심인 고도로 분산되고 내결함성 있는 시스템으로의 전략적 전환을 나타낸다. 따라서 백엔드 개발자들은 “엣지 환경을 위한 API 및 데이터 저장 방식”을 재고하고 , 네트워크 지연, 간헐적 연결, 로컬 의사결정을 고려하는 아키텍처 패턴을 수용해야 한다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0007.png" alt="" /></p>
<blockquote>
  <p>Edge Computing 구조도 (출처 - <a href="https://maddevs.io/blog/everything-you-need-to-know-about-edge-computing/">“Everything You Need to Know About Edge Computing” - Roman Panarin</a>)</p>
</blockquote>

<p><strong>2.7 새로운 프로그래밍 언어 및 프레임워크의 부상</strong>
Rust는 Node.js와 Go를 넘어 성능이 중요한 백엔드 시스템에서 선호되는 언어로 부상하고 있다. Rust는 메모리 안전성, Node.js 및 Go보다 빠른 성능, 보안성 등의 이점을 제공한다. Axum 및 Actix와 같은 Rust 백엔드 프레임워크의 성장이 예상된다. Python, JavaScript (Node.js), Java, PHP, Golang은 여전히 주요 백엔드 언어로 사용되고 있으며 , Django, Spring Boot, Laravel, Express.js 등 다양한 프레임워크가 개발 효율성, 보안, 확장성을 제공한다.  </p>

<p>기존 언어와 프레임워크가 백엔드 환경에서 여전히 지배적이지만, Rust의 인기가 높아지는 것은 특히 성능에 민감하고 안전한 인프라 구성 요소에 대해 고성능과 메모리 안전성을 모두 제공하는 언어에 대한 업계의 수요가 증가하고 있음을 의미한다. Python, Node.js, Java는 가독성, 광범위한 생태계 및 다용성으로 인해 주요 백엔드 언어로 나열되어 있다. 그러나 Rust는 “메모리 안전성”, “성능”, “보안” 덕분에 “성능에 민감한 백엔드 시스템을 위한 언어”로 빠르게 자리 잡고 있다. 이는 모든 것을 대체하는 추세라기보다는, 기존의 가비지 컬렉션 언어가 오버헤드를 유발할 수 있는 고성능, 보안 및 리소스 효율적인 시스템에 대한 특수화된 요구를 나타낸다. 따라서 조직은 단일 언어 스택을 고수하기보다는 특정 비기능적 요구 사항(예: 지연 시간, 보안, 리소스 사용량)에 따라 최적의 도구를 선택하는 다중 언어 프로그래밍(polyglot programming)으로 나아가고 있다. 이는 개발자들이 특수 작업을 위해 새로운 언어를 배우고 채택하는 데 개방적이어야 함을 의미한다.</p>

<p>물론 한국의 상황을 고려한다면, 이러한 가치가 중요시 되는 것이 국제적 트렌드는 되지만, 그렇지 않은 것도 사실이다. 하지만 과거 대비 Java 스타트 사업 및 글로벌 서비스가 확대되는 상황에서 이러한 대안의 등장은 비즈니스 특성에 따라 따라가거나 대비되어야 할 영역이리라 생각된다. 특히나 AI 서비스를 비롯하여 점차 서비스를 위한 대용량 처리가 더욱 강조되고, AI 확산에 따라 생겨나는 무수한 보안 공격을 비롯한 AI 기반의 크롤링 수법의 진화 등은 보다 안전하고, 보다 성능이 뛰어난 백엔드 인프라의 중요성을 더욱 부각시킨다고 볼 수 있다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0008.png" alt="" /></p>
<blockquote>
  <p>Rust Backend (출처 - <a href="https://www.youtube.com/watch?v=Rnw-x21kGaA">“How to Build A Rust Backend with Actix Web and SurrealDB (Full Tutorial)” - White Sponge</a>)</p>
</blockquote>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0009.png" alt="" /></p>
<blockquote>
  <p>2023년 stack overflow 조사로 84.66% 로 가장 인기 있는 언어로 나타났다.  (출처 - <a href="https://strapi.io/blog/rust-vs-other-programming-languages-what-sets-rust-apart">Munir Adavize Abdullahi</a>)</p>
</blockquote>

<h2 id="3-미래를-위한-백엔드-개발자의-핵심-역량">3. 미래를 위한 백엔드 개발자의 핵심 역량</h2>

<p>변화하는 백엔드 시장에서 개발자들이 경쟁력을 유지하고 성장하기 위해서는 다음과 같은 핵심 역량과 전략을 갖춰야 한다.</p>

<ul>
  <li><strong>아키텍처 및 설계 역량 강화</strong>: 수평적 확장성(stateless services, load balancers, sharding), 마이크로서비스(loosely coupled, message queues, API gateways), 이벤트 기반 아키텍처(asynchronous processing, event sourcing)에 대한 깊은 이해와 설계 능력이 필수적이다.  </li>
  <li><strong>클라우드 및 컨테이너 기술 숙달</strong>: AWS, Azure, GCP 등 주요 클라우드 플랫폼의 서비스와 Docker, Kubernetes와 같은 컨테이너 및 오케스트레이션 도구 활용 능력이 핵심이다. Terraform, CloudFormation, Pulumi와 같은 인프라 자동화 도구를 통해 환경을 코드로 정의하고 관리하는 능력이 요구된다.  </li>
  <li><strong>데이터 관리 및 최적화</strong>: SQL (MySQL, PostgreSQL) 및 NoSQL (MongoDB, DynamoDB) 데이터베이스에 대한 이해와 함께, 캐싱 (Redis, Memcached), 읽기 복제본, 데이터 샤딩을 통한 성능 최적화 능력이 중요하다. AI 기반 데이터베이스 관리 및 쿼리 최적화 도구의 활용도 고려해야 한다.  </li>
  <li><strong>보안 의식 및 실천</strong>: API 보안(RBAC, OAuth 2.0, TLS, JWT), 데이터 암호화(전송 및 저장), 취약점 관리(정기 감사 및 침투 테스트), Zero Trust 모델 구현이 필수적이다. 보안은 더 이상 부차적인 고려사항이 아니라 핵심 요구사항이며, 개발 초기 단계부터 보안을 통합하는 DevSecOps 접근 방식이 중요해진다.  </li>
  <li><strong>자동화 및 운영 효율성</strong>: CI/CD 파이프라인을 통한 테스트 및 배포 자동화, 인프라 자동화 (Infrastructure as Code), GitOps (Git 기반 인프라 관리)를 통한 운영 효율성 향상 능력이 요구된다. DevOps는 대규모 시스템 관리에 중요한 역할을 하며, 자동 스케일링 및 모니터링 시스템 구축이 포함된다.  </li>
  <li><strong>AI/ML 도구 활용 및 이해</strong>: AI 코드 어시스턴트, AI 기반 쿼리 최적화 도구 등 AI/ML 도구를 개발 워크플로우에 통합하고, AI 모델과의 API 연동 방식을 이해하는 것이 중요하다. AI는 개발자의 생산성을 높이고 반복 작업을 자동화하는 데 기여한다.  </li>
  <li><strong>지속적인 학습 및 적응</strong>: 빠르게 변화하는 기술 환경에 대한 유연한 대응과 지속적인 학습이 가장 중요하다. 새로운 언어, 프레임워크, 아키텍처 패턴, 보안 위협에 대한 최신 정보를 습득해야 한다. 기술 스택의 다양화와 복잡성 증가는 끊임없는 자기 계발을 요구한다.  </li>
</ul>

<h2 id="마무리하며--변화는-기회다">마무리하며 : 변화는 기회다</h2>
<p>지난 5월 13일 마이크로소프트는 인공지능의 적극적인 도입으로 엔지니어링 개발자, 회사 인력의 3%에 해당하는 6800명을 감원하였다. 이러한 모습들은 개발자의 ‘용도’와 ‘필요’가 이제 변화하고 있다는 사실을 이야기 한다. AI 를 통해 지능적으로 바뀌는 온갖 보안문제, 그에 비해 발생하는 엄청난 효율성과 자동화 영역에 대한 AI의 개발자 대체 가능성 등, 이 글에서 언급하지 않았지만 LLM 을 필두로 발생한 AI의 파동은 더욱 피부 속을 파고들 정도로 체감되기 시작했다.</p>

<p>그러한 상황에서 백엔드 개발자, 아울러 개발자라는 직군은 다른 포지셔닝이 필요하게 되었으며, 그러한 포지셔닝, 가치의 재정립은 이러한 트랜드를 이해하며, 숨쉬듯 AI 를 자신의 또 다른 뇌, 또 다른 자아처럼 다룰 수 있어야 함을 요구한다. 그런 상황에서 구체적인 역할이, 명료하게 자리 잡아야만 AI가 사람을 대체할 수 있어지는 이 시대에서의 개발자의 역할을 할 수 있으리라 보인다.</p>

<p>이러한 변화에 발맞춰 분산 시스템 설계, 클라우드 및 컨테이너 기술, 데이터 관리, 그리고 보안에 대한 깊은 이해를 갖춰야 한다. 또한, AI 도구를 적극적으로 활용하고 DevOps 및 GitOps 원칙을 내재화하여 효율성을 극대화해야 한다. 백엔드 시스템의 복잡성과 규모가 증가함에 따라 자동화는 선택이 아닌 필수 전략이 되고 있으며, 데이터 품질과 거버넌스는 AI 기반 시스템의 성공을 위한 필수적인 기반이 된다. 궁극적으로, 끊임없는 학습과 적응력은 이 역동적인 환경에서 성공적인 커리어를 위한 핵심 열쇠가 될 것이다. 이러한 것들을 의미는 무엇인가? <strong>결국 AI 를 진두지휘하는 커맨더적 개발자의 대두가 반드시 필요하며, 그러한 백엔드 개발자가 되지 못한다는 것은 더 빠른 시장에서의 퇴출 내지는 시장에서의 퇴보를 의미할 것이다.</strong></p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0010.png" alt="" /></p>
<blockquote>
  <p>이미지 프롬프팅 (출처 - 제미니 2.5 Flash)</p>
</blockquote>

<h2 id="진짜-마무리-이-글을-쓰기-위한-ai와-나의-노력">진짜 마무리, 이 글을 쓰기 위한 AI와 나의 노력</h2>
<p>구글 IO 2025 에서 사실 많은 사람들은 Flow 나 Whisk, veo3 등에 열광 했을지 모르겠다. 하지만 내가 가장 주목한 건 사실 다른 무엇보다 제미니 2.5 였다. 제미니는 2.0 부터 점차 두각을 드러내기 시작했다. 데이터의 양이나 플랫폼의 수준을 생각하면 사실 ChatGPT 나 Claude 가 사실 범접할 수준이 아니기에, 그 시작은 Google이 아닐지 모르지만, 그 끝은 Google 이 아닐까? 라는 생각을 했다.</p>

<p>그리고 그 결과, 나의 생각은 역시나 틀리지 않았다. 구글은 처음에는 후발 주자와 같은 미숙함이 보였지만, 데이터를 어떻게 다루면 되는지를 알며, 무엇보다 그러한 데이터의 정제를 위한 AI 적 사고가 어떻게 되면 되는지를 여실없이 보여주었다(….)</p>

<p>대충이라도 재어 본 결과, 위의 글의 살을 거의 완성시키는데 걸린 시간은 고작 10분이었고, 읽어보고 개선하고 하는데 걸린시간은 30분. 전체 글을 다 쓰는데 현재 3시간 남짓이 걸렸다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0011.png" alt="" /></p>
<blockquote>
  <p>최초 연구 요청</p>
</blockquote>

<p>물론, 첨삭이 필요하긴 했다. 하지만 나의 요청에 제미니는 말 그대로 연구의 목적과 이를 위한 사고를 보여주었고, 그 사고의 과정의 기법은 매우 체계적일 뿐 아니라 ‘자연어’ 스러웠다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-25-0012.png" alt="" /></p>
<blockquote>
  <p>사과정의 기록이 보여주는 구글의 AI 철학은 인문학과 과학, 그 어딘가를 논하지 않을 수 없다고 생각이 든다.</p>
</blockquote>

<p>AI는 많이 두려운 존재인 것은 사실이다. 생각해보면 AI의 등장은 더 이상 ‘어중간한 존재’들이 필요없다는 식의 매우 냉랭한 말을 세상이 더더욱 말하고 있는 것이란 생각이 든다. No Code Low Code 라는 키워드가 흥할 때부터 이러한 낌새는 보였다. 점점 발전하고 감싸지면서 쉬워지는 프레임워크들, 그것을 1 나노초라도 더 빨리 구동하기 위해 구현되고 있는 하드웨어들, 이러한 상황 속에서 어중간한 실력과 어중간한 안목을 가진 개발자들, 아니 어쩌면 그러한 사람들의 소멸이나 사형선고가 아닐까 하는 무서운 상상도 든다.</p>

<p>하지만, 그런 과정 속에서도 나는 이런 생각을 하게 된다. 제미니의 이러한 수준은 사진에서도 다소 나오지만, 단순한 하드웨어나 데이터셋의 문제가 아니라는 점을 느끼게 만든다. CoT 프롬프팅, 지식 그래프 및 상징적 AI, 뇌신경-상징적 AI 패턴, 검색 증강 생성을 비롯한 고도의 인간의 고차원적 사고 패턴을 기계가 이용 가능하도록 형태를 변화 시킨것들의 접목된 결과가 이것이 아닐까?</p>

<p>인간만큼 뛰어나지는 것은 무엇 때문인가? 그것은 바로 인간의 고도화된 사고, 논리, 철학, 그러한 기준들의 존재가 있고 그것이 확률성과 붙었을 때, 비로소 LLM 이라는 형태로 인간의 확률성을 나타내는 것이 되고, AI라는 도구화 되어 확실한 두각을 내 비치는게 아닐까?</p>

<p>젠슨황의 말 처럼, 이젠 진짜 인문사회학과 과학, 그 사이 어딘가에서 창조적 가치, 그리고 인간만이 가능한 고등한 더 넓거나 더 고도의 사고체계를 구축하여, 물질세계에 구현해내는 작업들을 해낸다면 그것이 곧 AI의 성능 향상으로 끌어올리는게 아닐까 생각이 들고, 그러한 작업이 이제 인간의 업이 되는게 아닌가 조심스레 예상해본다. 그리고 그런 상황에서 개발자들은 단순하게 만든다의 의미에서 ‘가치’를 부여한다는 의미를 보다 되새길 수 있는 테크니션 리더가 되어야 하는게 아닌가 생각한다.</p>

<h2 id="참고-문헌">참고 문헌</h2>
<ol>
  <li>8 Trends In Backend Development You Can’t Ignore In 2025, <a href="https://arunangshudas.com/blog/8-trends-in-backend-development-you-cant-ignore-in-2025/">https://arunangshudas.com/blog/8-trends-in-backend-development-you-cant-ignore-in-2025/</a></li>
  <li>Serverless Computing Market Size &amp; Trends, Growth Analysis …, <a href="https://www.marketsandmarkets.com/Market-Reports/serverless-computing-market-217021547.html">https://www.marketsandmarkets.com/Market-Reports/serverless-computing-market-217021547.html</a></li>
  <li>Latest Microservices Architecture Trends in 2024 - Cloud Destinations, <a href="https://clouddestinations.com/blog/evolution-of-microservices-architecture.html">https://clouddestinations.com/blog/evolution-of-microservices-architecture.html</a></li>
  <li>How GitOps is Revolutionizing DevOps Practices in 2024 …, <a href="https://coffeebeans.io/blogs/how-gitops-is-revolutionizing-devops-practices-in-2024">https://coffeebeans.io/blogs/how-gitops-is-revolutionizing-devops-practices-in-2024</a></li>
  <li>Top K8s Workload Trends in the 2024 Kubernetes Benchmark …, <a href="https://cloudnativenow.com/features/top-k8s-workload-trends-in-the-2024-kubernetes-benchmark-report/">https://cloudnativenow.com/features/top-k8s-workload-trends-in-the-2024-kubernetes-benchmark-report/</a></li>
  <li>Docker and Containerization Trends in 2024 - Slashdev, <a href="https://slashdev.io/-docker-and-containerization-trends-in-2024">https://slashdev.io/-docker-and-containerization-trends-in-2024</a></li>
  <li>The Best Backend Frameworks for Speed, Scalability, and Power in 2025 - Fively, <a href="https://5ly.co/blog/best-backend-frameworks/">https://5ly.co/blog/best-backend-frameworks/</a></li>
  <li>Key Trends from 2024: Cell-Based Architecture, DORA &amp; SPACE …, <a href="https://www.infoq.com/podcasts/2024-year-review/">https://www.infoq.com/podcasts/2024-year-review/</a></li>
  <li>AI and event driven architecture – the perfect partnership to make …, <a href="https://vmblog.com/archive/2024/02/02/ai-and-event-driven-architecture-the-perfect-partnership-to-make-the-connected-enterprise-a-reality-2024.aspx">https://vmblog.com/archive/2024/02/02/ai-and-event-driven-architecture-the-perfect-partnership-to-make-the-connected-enterprise-a-reality-2024.aspx</a></li>
  <li>Data Architecture Trends in 2024 - DATAVERSITY, <a href="https://www.dataversity.net/data-architecture-trends-in-2024/">https://www.dataversity.net/data-architecture-trends-in-2024/</a></li>
  <li>A Stroll Through API Economy Trends - Nordic APIs, <a href="https://nordicapis.com/a-stroll-through-api-economy-trends/">https://nordicapis.com/a-stroll-through-api-economy-trends/</a></li>
  <li>Top API Trends that will Change the World Beyond 2025 - ImpactQA, <a href="https://www.impactqa.com/infographics/top-api-trends-that-will-change-the-world-beyond/">https://www.impactqa.com/infographics/top-api-trends-that-will-change-the-world-beyond/</a></li>
  <li>7 Best Practices for API Security in 2024 - GeeksforGeeks, <a href="https://www.geeksforgeeks.org/api-security-best-practices/">https://www.geeksforgeeks.org/api-security-best-practices/</a></li>
  <li>Database trends of 2025: Rankings, new technologies and changes in the industry, <a href="https://www.baremon.eu/database-trends-of-2025/">https://www.baremon.eu/database-trends-of-2025/</a></li>
  <li>Database Trends and Innovations: A Comprehensive Outlook for 2025 - Rapydo, <a href="https://www.rapydo.io/blog/database-trends-and-innovations-a-comprehensive-outlook-for-2025">https://www.rapydo.io/blog/database-trends-and-innovations-a-comprehensive-outlook-for-2025</a></li>
  <li>Top 11 Backend Programming Languages in 2025 - Webandcrafts, <a href="https://webandcrafts.com/blog/backend-languages">https://webandcrafts.com/blog/backend-languages</a></li>
  <li>Most Popular Backend Frameworks: Top 10 in 2025 - Netguru, <a href="https://www.netguru.com/blog/backend-frameworks">https://www.netguru.com/blog/backend-frameworks</a></li>
  <li>7 Essential Tips For Scalable Backend Architecture, <a href="https://blog.arunangshudas.com/7-essential-tips-for-scalable-backend-architecture/">https://blog.arunangshudas.com/7-essential-tips-for-scalable-backend-architecture/</a></li>
  <li>What Is Event-Driven Architecture? Comprehensive Guide 2024 …, <a href="https://estuary.dev/blog/event-driven-architecture/">https://estuary.dev/blog/event-driven-architecture/</a></li>
  <li>How to Become a Backend Developer in 2025 - GeeksforGeeks, <a href="https://www.geeksforgeeks.org/back-end-developer-roadmap/">https://www.geeksforgeeks.org/back-end-developer-roadmap/</a></li>
  <li>2024 Cloud Service Providers: Comparison &amp; Guide (Top Choices) - TechAhead, <a href="https://www.techaheadcorp.com/blog/2024-cloud-service-providers-comparison-guide-top-choices/">https://www.techaheadcorp.com/blog/2024-cloud-service-providers-comparison-guide-top-choices/</a></li>
  <li>Key Skills for Successful DevOps Engineers in 2024 - Creole Studios, <a href="https://www.creolestudios.com/key-skills-for-successful-devops-engineer-2024/">https://www.creolestudios.com/key-skills-for-successful-devops-engineer-2024/</a></li>
  <li>2024 Cloud Computing Spending Trends: AWS, Azure, GCP Insights - DEV Community, <a href="https://dev.to/ssojet/2024-cloud-computing-spending-trends-aws-azure-gcp-insights-5fg1">https://dev.to/ssojet/2024-cloud-computing-spending-trends-aws-azure-gcp-insights-5fg1</a></li>
  <li>Caching Best Practices: Boost Performance in 2024 - Eyer.ai, <a href="https://www.eyer.ai/blog/caching-best-practices-boost-performance-in-2024/">https://www.eyer.ai/blog/caching-best-practices-boost-performance-in-2024/</a></li>
  <li>Top 8 Skills Required in DevOps Engineer for 2024 - Softqube Technologies, <a href="https://www.softqubes.com/blog/top-8-skills-required-in-devops-engineer-for-2024/">https://www.softqubes.com/blog/top-8-skills-required-in-devops-engineer-for-2024/</a></li>
  <li>Best Certifications for Backend Developers in 2025 (Ranked) - Teal, <a href="https://www.tealhq.com/certifications/backend-developer">https://www.tealhq.com/certifications/backend-developer</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="AI" /><category term="GitOps" /><category term="Google" /><category term="Gemini" /><summary type="html"><![CDATA[1. 백엔드, 왜 지금 이 변화를 주목하려고 하는가? 백엔드는 더 이상 단순히 데이터를 처리하고 저장하는 ‘뒷단’이 아니다. 서비스의 확장성, 안정성, 그리고 궁극적으로 사용자 경험의 질을 결정하는 핵심 두뇌이자 심장부이다. 기업들은 갈수록 더 빠르고, 더 유연하며, 더 비용 효율적인 시스템을 요구하고 있으며, 이러한 요구는 백엔드 아키텍처와 기술 스택의 끊임없는 진화를 촉진한다.]]></summary></entry><entry><title type="html">NestJS Deep Dive</title><link href="http://localhost:4000/backend/2025/05/25/01-NestJS-Deep-Dive.html" rel="alternate" type="text/html" title="NestJS Deep Dive" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/25/01-NestJS-Deep-Dive</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/25/01-NestJS-Deep-Dive.html"><![CDATA[<h2 id="1-서론-nestjs-왜-선택해야-할까">1. 서론: NestJS, 왜 선택해야 할까?</h2>
<p>NestJS는 Node.js 환경에서 효율적이고 확장 가능한 서버 사이드 애플리케이션을 구축하기 위한 진보적인 프레임워크다. 이 프레임워크는 Angular의 아키텍처에서 영감을 받아 개발되었으며, TypeScript를 기본 언어로 적극 지원한다는 특징을 가집니다. TypeScript의 강력한 타입 시스템은 개발 과정에서 발생할 수 있는 잠재적인 오류를 미연에 방지하고, 코드의 가독성과 안정성을 크게 향상시킨다.  </p>

<p>백엔드 개발에서 NestJS의 강점은 여러 면에서 확인할 수 있다.</p>

<ul>
  <li>
    <p>첫째, 모듈식 아키텍처를 채택하여 유연한 확장성을 제공하며, 다른 라이브러리와의 통합이 용이하다. 이는 대규모 프로젝트에서 코드의 재사용성을 높이고, 개발 과정을 체계적으로 관리할 수 있게 한다.</p>
  </li>
  <li>
    <p>둘째, 객체 지향 프로그래밍(OOP)의 캡슐화 특성을 적극 활용하여 유사한 기능을 하는 컨트롤러와 서비스 등을 모듈 단위로 묶어 관리함으로써 코드의 응집도를 높이고 유지보수를 용이하게 한다.</p>
  </li>
  <li>
    <p>셋째, 의존성 주입(DI) 시스템을 내장하여 컴포넌트 간의 결합도를 낮추고 테스트 용이성을 극대화한다.</p>
  </li>
</ul>

<p>이러한 특성들은 NestJS가 국내외, 특히나 빠른 대응이 필요한 스타트업에서 기존 Node 나 Express 기반의 프로젝트 대비 빠르게 인기를 얻으며 다양한 회사에서 프로젝트에 적용되는 주요 원인이 되고 있다.</p>

<p>전체 내용을 한 번 정리해가 된 이유는 다음과 같다.</p>

<ol>
  <li>
    <p>NestJS 를 기반으로 하는 현재의 라이브 서비스를 보다 레퍼런스 철학에 맞는 형태로 유지하기 위하여, NestJS 개발 철학을 체득화하고 싶다.</p>
  </li>
  <li>
    <p>라이프 사이클에 대해 좀더 고심하여 기존의 비즈니스 로직, 라우팅 과정 등에서 비즈니스 로직과 전 후처리에 대한 결합도를 낮추고 싶다.</p>
  </li>
  <li>
    <p>위의 목표들을 위하여 심도있는 학습 전 빠르게 NestJS 에 대한 기초를 복습하고 싶다.</p>
  </li>
</ol>

<p>이러한 이유로 정리해본다.</p>

<h2 id="2-nestjs-핵심-구조-및-설계-원리">2. NestJS 핵심 구조 및 설계 원리</h2>
<p>NestJS는 모듈(Module), 컨트롤러(Controller), 프로바이더(Provider)의 세 가지 핵심 구성 요소를 기반으로 애플리케이션을 구조화한다. 이들은 각각의 명확한 역할을 가지며 유기적으로 상호작용하여 견고하고 유지보수 가능한 백엔드 시스템을 구축할 수 있도록 돕는다.</p>

<h3 id="21-모듈-애플리케이션의-빌딩-블록">2.1 모듈: 애플리케이션의 빌딩 블록</h3>
<p>모듈은 NestJS 애플리케이션을 구성하는 빌딩 블록이자 기능들을 조합하여 작성한 응집체이다. 각 모듈은 관련된 컨트롤러, 서비스 등을 하나의 단위로 묶어 애플리케이션의 구조를 모듈화한다. 예를 들어, 사용자 관리 기능을 담은 모듈은 UserModule로, 게시판 기능은 BoardModule로 구성할 수 있다.</p>

<p>모듈의 주요 역할은 애플리케이션의 기능을 그룹화, 코드의 재사용성 및 유지보수성을 높이는 것이다. <code class="language-plaintext highlighter-rouge">@Module()</code> 데코레이터는 NestJS가 애플리케이션 구조를 구축하는 데 사용하는 메타데이터를 제공한다. 이 메타데이터에는 다음과 같은 핵심 속성들이 포함된다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">imports</code>: 현재 모듈에서 사용할 다른 모듈들의 목록이다. 이를 통해 모듈 간의 의존성을 명시적으로 관리할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">controllers</code>: 이 모듈에서 사용하는 컨트롤러들의 목록이다.</li>
  <li><code class="language-plaintext highlighter-rouge">providers</code>: 이 모듈에서 사용하는 서비스나 프로바이더들의 목록이다.</li>
  <li><code class="language-plaintext highlighter-rouge">exports</code>: 이 모듈에서 제공하며, 이 모듈을 가져오는 다른 모듈에서 사용할 수 있도록 공개할 프로바이더들의 목록이다.</li>
</ul>

<p>NestJS 애플리케이션은 반드시 하나의 루트 모듈(AppModule)을 가지며, 이 루트 모듈은 다른 기능별 모듈들을 포함하여 애플리케이션을 실행하는 데 필요한 모든 요소를 구성한다. 모듈 구성 전략으로는 도메인 주도 설계(DDD) 기반의 접근법이 권장된다. 이는 비즈니스 도메인을 먼저 모델링한 후, 해당 도메인에 따라 모듈을 분리하는 방식이다. 예를 들어, blog, user, auth와 같은 다른 도메인 이름을 가진 폴더를 생성하고 각 폴더 내에 해당 모듈 파일을 생성하는 방식이다.또한, DB 연결이나 Swagger API 생성과 같이 개발자 도메인에만 속하는 공통 기능은 common 폴더를 생성하여 모듈로 관리할 수 있다.</p>

<p>모듈 시스템의 장점은 명확하다. 1) 어떤 모듈이든 가져와 다른 곳에서 재사용할 수 있어 코드 중복을 방지하고 모듈성을 향상시킨다. 2) 강력한 의존성 주입(DI) 시스템을 제공하여 컴포넌트 간의 결합도를 낮춘다. 3) 기능에 문제가 있을 때 작업해야 하는 코드를 빠르게 찾을 수 있어 디버깅 및 유지보수가 용이하다. 4) 마지막으로, NestJS의 모듈 시스템은 개발자를 서비스 지향적 사고의 방향으로 이끌어 주어, 각 기능의 책임을 명확히 분리하고 응집도를 높이는 데 기여한다.</p>

<h3 id="22-컨트롤러-controllers-요청-처리의-관문">2.2 컨트롤러 (Controllers): 요청 처리의 관문</h3>
<p>컨트롤러는 클라이언트로부터 들어오는 요청을 처리하고 적절한 응답을 반환하는 역할을 한다. Express 프레임워크의 라우터(Router)와 유사하게, 컨트롤러는 라우팅 메커니즘을 이용하여 특정 URL 엔드포인트에 대한 요청을 구분하고 매칭한다.</p>

<p>컨트롤러 클래스는 <code class="language-plaintext highlighter-rouge">@Controller()</code> 데코레이터를 사용하여 정의된다. 이 데코레이터는 클래스를 필요한 메타데이터와 연결하고 라우터 기능을 활성화한다. @Controller() 데코레이터 내부에 인자값을 넣어 경로를 설정할 수 있으며, @Get(), @Post(), @Put(), @Delete()와 같은 HTTP 메서드 데코레이터를 사용하여 특정 HTTP 요청에 대한 핸들러 메서드를 정의한다.</p>

<p>컨트롤러는 직접적으로 복잡한 비즈니스 로직을 처리하지 않는다. 대신, 요청을 받아 서비스 계층으로 위임하고, 서비스에서 처리된 결과를 받아 클라이언트에 응답을 반환하는 역할을 수행한다. 이러한 역할 분리는 단일 책임 원칙(SRP)을 준수하며, 코드의 가독성과 유지보수성을 높이는 데 기여한다.</p>

<h3 id="23-프로바이더-providers--서비스-services-비즈니스-로직의-심장">2.3 프로바이더 (Providers) &amp; 서비스 (Services): 비즈니스 로직의 심장</h3>
<p>프로바이더는 NestJS의 근본적인 개념으로, <code class="language-plaintext highlighter-rouge">서비스(Service)</code>, <code class="language-plaintext highlighter-rouge">리포지토리(Repository)</code>, <code class="language-plaintext highlighter-rouge">팩토리(Factory)</code>, <code class="language-plaintext highlighter-rouge">헬퍼(Helper)</code> 등 NestJS의 많은 기본 클래스들이 프로바이더로 취급된다. 프로바이더의 핵심 아이디어는 의존성 주입(DI)을 통해 다른 컴포넌트에 주입될 수 있다는 것이다. NestJS 프레임워크는 내부적으로 IoC(Inversion of Control) 컨테이너를 만들어 이 프로바이더들을 관리한다.</p>

<p><code class="language-plaintext highlighter-rouge">서비스</code>는 프로바이더의 가장 흔한 형태로, 애플리케이션의 핵심 비즈니스 로직을 처리하는 역할을 한다. 데이터 생성, 조회, 변경, 삭제와 같은 데이터 가공 작업이 서비스 계층의 책임이다. 여러 컨트롤러에서 재사용되는 로직은 서비스로 분리하여 코드 중복을 피하고 유지보수성을 높일 수 있다.</p>

<p>서비스 클래스는 <code class="language-plaintext highlighter-rouge">@Injectable()</code> 데코레이터를 사용하여 정의된다. 이 데코레이터는 해당 클래스가 NestJS IoC 컨테이너에 의해 관리될 수 있는 주입 대상임을 NestJS에 알린다. @Injectable() 데코레이터가 붙은 서비스는 모듈의 providers 배열에 ‘등록’되어야 컨트롤러에서 의존성 주입을 통해 사용할 수 있게 된다.</p>

<p>프로바이더와 서비스, 그리고 컨트롤러의 관계는 공급자-제품-소비자 비유로 쉽게 이해할 수 있다. 서비스가 ‘제품’이라면, 프로바이더는 이 제품을 ‘공급’하는 역할을 하며, 컨트롤러는 이 제품을 ‘소비’하는 주체이다. 공급자가 제품을 제공해야 소비자가 사용할 수 있듯이, 프로바이더에 서비스가 등록되어야 컨트롤러에서 주입받아 사용이 가능하다. 이러한 구조는 비즈니스 로직과 통신 계층의 관심사를 명확하게 분리하여 유연하고 지속 가능한 아키텍처를 제공한다.</p>

<h3 id="24-의존성-주입-dependency-injection-di-제어의-역전">2.4 의존성 주입 (Dependency Injection, DI): 제어의 역전</h3>
<p>의존성 주입(DI)은 NestJS의 핵심 개념 중 하나이자 제어의 역전(IoC) 기술의 구체적인 구현체이다. 제어의 역전이란 개발자가 직접 제어해야 할 영역을 프레임워크에 위임하는 것을 의미하며, DI는 개발자가 필요한 외부 자원(클래스, 함수 등)을 직접 생성하는 대신 프레임워크로부터 제공받을 수 있도록 하는 방식이다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-26-0001.png" alt="" /></p>

<p>예를 들어, 아이가 냉장고에서 스스로 물건을 꺼내는 대신 부모님에게 필요한 것을 말하면 부모님이 대신 가져다주는 상황과 유사하다. 이는 아이(소비자)가 냉장고 문을 열고 물건을 찾는 복잡한 과정(의존성 생성 및 관리)을 직접 처리하는 대신, 부모님(프레임워크)에게 그 일을 위임하여 필요한 것을 공급받는 것과 같다. NestJS에서는 이처럼 프레임워크가 주체가 되어 필요한 클래스 인스턴스들을 대신 관리하고 주입해준다.</p>

<p>NestJS에서 의존성 주입은 주로 생성자 주입(Constructor Injection) 방식을 통해 이루어진다. 컨트롤러 클래스의 생성자 매개변수로 필요한 서비스 인스턴스를 선언하면, NestJS는 해당 서비스의 타입을 인지하고 자동으로 인스턴스를 주입한다. 이 덕분에 별도의 import 작업 없이도 주입된 서비스의 메서드를 호출할 수 있다. 필드 위에 @Inject() 데코레이터를 사용하는 프로퍼티 스타일 주입도 가능하지만, NestJS 공식 문서에서는 생성자 주입을 권장한다.</p>

<p><strong>DI의 이점은 다음과 같다:</strong></p>

<ul>
  <li>
    <p><strong>결합도 감소</strong>: 컴포넌트들이 서로의 구체적인 구현에 직접 의존하지 않고 추상화(인터페이스)에 의존하게 되어, 컴포넌트 간의 결합도가 낮아진다. 이는 코드 변경 시 다른 부분에 미치는 영향을 최소화한다. 각 영역에 대해 필요한 변화나, 개선이 필요시 각기 규역이 맞는다는 전제하에 변화가 용이하다.</p>
  </li>
  <li>
    <p><strong>테스트 용이성</strong>: 의존성을 외부에서 주입받으므로, 단위 테스트 시 실제 의존성 대신 모의(Mock) 객체를 쉽게 주입하여 테스트 환경을 고립시킬 수 있다.</p>
  </li>
  <li>
    <p><strong>코드 단순화 및 재사용성</strong>: 필요한 자원을 프레임워크가 관리해주므로 개발자는 비즈니스 로직에 더 집중할 수 있으며, 동일한 객체를 여러 곳에서 재사용하기 용이해진다.</p>
  </li>
  <li>
    <p><strong>유연성 및 확장성 향상</strong>: 의존성 관계가 명확해지고 느슨해지므로, 새로운 기능을 추가하거나 기존 기능을 변경할 때 유연하게 대처할 수 있다.</p>
  </li>
</ul>

<h3 id="25-데코레이터-decorators-nestjs의-마법-지팡이">2.5 데코레이터 (Decorators): NestJS의 마법 지팡이</h3>
<p>데코레이터는 NestJS에서 매우 중요한 개념이다. 클래스, 속성, 메서드, 매개변수에 추가 기능을 쉽게 적용할 수 있도록 돕는 문법이다. C#의 어트리뷰트와 유사하며, JavaScript에서는 @ 기호를 앞에 붙여 사용한다. NestJS는 데코레이터를 통해 클래스나 메서드에 메타데이터를 추가하거나 특정 동작을 부여할 수 있다.</p>

<p>NestJS에서 자주 사용되는 주요 내장 데코레이터는 다음과 같다:</p>

<p><code class="language-plaintext highlighter-rouge">@Controller()</code>: 클래스를 컨트롤러로 정의하고 라우팅 기능을 부여한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Injectable()</code>: 클래스를 의존성 주입의 대상으로 선언하고 IoC 컨테이너가 관리할 수 있도록 한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Get(), @Post(), @Put(), @Delete()</code>: HTTP 요청 메서드에 해당하는 라우트 핸들러를 정의한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Body()</code>: HTTP 요청 본문(body)에서 데이터를 추출하여 매개변수에 할당한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Param()</code>: URL 경로 매개변수에서 값을 추출한다 (예: /users/:id에서 id 값).</p>

<p><code class="language-plaintext highlighter-rouge">@Query()</code>: URL 쿼리 파라미터에서 값을 추출한다 (예: /users?name=Alice에서 name 값).</p>

<p>NestJS는 개발자가 직접 커스텀 데코레이터를 만들 수 있는 기능도 제공한다. <code class="language-plaintext highlighter-rouge">createParamDecorator</code> 함수를 사용하여 사용자 정의 데코레이터를 생성할 수 있으며, 이는 특정 요청에서 사용자 객체를 가져오거나, 특정 메타데이터를 설정하는 등 반복적인 로직을 추상화하여 코드의 재사용성과 가독성을 높이는 데 유용하다.</p>

<h2 id="3-nestjs-애플리케이션-라이프사이클-심층-분석">3. NestJS 애플리케이션 라이프사이클 심층 분석</h2>
<p>NestJS 애플리케이션은 시작부터 종료, 그리고 요청 처리 과정에 이르기까지 명확한 라이프사이클을 가진다. 이 흐름을 이해하는 것은 애플리케이션의 동작 방식을 파악하고 문제를 해결하는 데 필수적이다.</p>

<h3 id="31-애플리케이션-부트스트랩bootstrap-과정">3.1 애플리케이션 부트스트랩(Bootstrap) 과정</h3>
<p>NestJS 애플리케이션의 진입점은 일반적으로 main.ts 파일이다. 이 파일에서 NestFactory.create() 메서드를 사용하여 NestJS 애플리케이션 인스턴스를 생성하고 초기화한다. 이후 app.listen() 메서드를 호출하여 애플리케이션이 들어오는 HTTP 요청을 수신 대기하도록 한다.</p>

<pre><code class="language-TypeScript">// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT?? 3000);
}
bootstrap();
</code></pre>
<p>이 부트스트랩 과정은 애플리케이션의 모든 모듈과 프로바이더가 초기화되고 의존성이 해결되는 중요한 단계이다. NestFactory.createApplicationContext()를 사용하여 애플리케이션 컨텍스트를 생성하고 ConfigService와 같은 구성 서비스를 통해 환경 변수에 접근하는 것도 가능하다. 이는 애플리케이션이 시작되기 전에 필요한 설정을 로드하는 데 활용될 수 있다.</p>

<h3 id="32-라이프사이클-후크lifecycle-hooks-생명의-주기">3.2 라이프사이클 후크(Lifecycle Hooks): 생명의 주기</h3>
<p>NestJS는 애플리케이션의 주요 생명 주기 이벤트에 대한 가시성을 제공하는 다양한 라이프사이클 후크를 제공한다. 이 후크들은 특정 시점에 로직을 실행할 수 있도록 하여 모듈 및 서비스의 적절한 초기화, 활성 연결 관리, 그리고 정상적인 종료 처리를 가능하게 한다.</p>

<table>
  <thead>
    <tr>
      <th>후크 메서드</th>
      <th>호출 시점</th>
      <th>주요 역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>onModuleInit()</td>
      <td>호스트 모듈의 종속성이 해결되면 호출</td>
      <td>동기 또는 비동기 초기화 작업 (예: 데이터베이스에서 데이터 가져오기)</td>
    </tr>
    <tr>
      <td>onApplicationBootstrap()</td>
      <td>모든 모듈이 초기화된 후 연결을 수신 대기하기 전에 호출</td>
      <td>애플리케이션이 요청을 받기 전 최종 초기화 작업</td>
    </tr>
    <tr>
      <td>onModuleDestroy()</td>
      <td>종료 신호(예: SIGTERM)가 수신된 후 호출</td>
      <td>모듈 내부의 자원 정리 (예: DB 연결 해제)</td>
    </tr>
    <tr>
      <td>beforeApplicationShutdown()</td>
      <td>모든 onModuleDestroy() 처리기가 완료된 후 호출</td>
      <td>모든 기존 연결이 닫히기 전 최종 정리 작업 (Promise 해결 또는 거부 완료 시)</td>
    </tr>
    <tr>
      <td>onApplicationShutdown()</td>
      <td>연결 종료 후 호출 (app.close() 해결)</td>
      <td>애플리케이션 종료 후 최종 작업 (예: 로그 기록)</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">onModuleInit()</code>과 같은 비동기 라이프사이클 후크의 경우, 모듈은 위상 순서(topological order)로 순차적으로 초기화되지만, 동일 모듈 내 프로바이더의 onModuleInit() 호출 순서는 보장되지 않을 수 있다. 이는 때때로 프로바이더 간의 비동기 의존성 문제로 이어질 수 있으며, 이를 완화하기 위해 각 비동기 후크를 가진 프로바이더를 별도의 모듈에 배치하는 방법이 제안되기도 한다.</p>

<p><code class="language-plaintext highlighter-rouge">onModuleDestroy()</code>, <code class="language-plaintext highlighter-rouge">beforeApplicationShutdown()</code>, <code class="language-plaintext highlighter-rouge">onApplicationShutdown()</code>와 같은 종료 후크들은 <code class="language-plaintext highlighter-rouge">enableShutdownHooks()</code> 메서드를 명시적으로 호출해야 활성화된다. 이는 Kubernetes와 같은 환경에서 애플리케이션이 종료 신호를 받았을 때 정상적인 종료(Graceful Shutdown)를 처리하는 데 중요한다. 이러한 후크를 사용하여 애플리케이션의 생명 주기를 섬세하게 제어하고, 자원 누수를 방지하며 안정적인 운영을 보장할 수 있다.</p>

<h3 id="33-요청-응답-라이프사이클-request-response-lifecycle-데이터의-여정">3.3 요청-응답 라이프사이클 (Request-Response Lifecycle): 데이터의 여정</h3>
<p>NestJS 애플리케이션에서 클라이언트의 요청이 들어와 응답이 반환되기까지는 일련의 정해진 흐름을 따른다. 이 흐름은 미들웨어, 가드, 인터셉터, 파이프, 컨트롤러, 서비스, 그리고 예외 필터와 같은 다양한 구성 요소들이 순차적으로 또는 조건부로 개입하며 요청을 처리하고 응답을 생성한다.</p>

<p><code class="language-plaintext highlighter-rouge">들어오는 요청</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 미들웨어</code> -&gt; <code class="language-plaintext highlighter-rouge">모듈 미들웨어</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 가드</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 가드</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 가드</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 인터셉터 (pre-controller)</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 인터셉터 (pre-controller)</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 인터셉터 (pre-controller)</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 파라미터 파이프</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 (메서드 핸들러)</code> -&gt; <code class="language-plaintext highlighter-rouge">서비스 (비즈니스 로직)</code> -&gt; <code class="language-plaintext highlighter-rouge">라우트 인터셉터 (post-request)</code> -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 인터셉터 (post-request)</code> -&gt; <code class="language-plaintext highlighter-rouge">전역 인터셉터 (post-request)</code> -&gt; <code class="language-plaintext highlighter-rouge">예외 필터 (라우트, 컨트롤러, 전역 순)</code> -&gt; <code class="language-plaintext highlighter-rouge">서버 응답</code></p>

<table>
  <thead>
    <tr>
      <th>단계</th>
      <th>순서</th>
      <th>역할</th>
      <th>주요 특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>미들웨어 (Middleware)</td>
      <td>1</td>
      <td>요청 및 응답 객체 변경, 로깅, 인증 등 공통 작업 처리</td>
      <td>요청-응답 주기의 첫 관문, next() 호출로 다음 미들웨어로 제어 전달</td>
    </tr>
    <tr>
      <td>가드 (Guards)</td>
      <td>2</td>
      <td>런타임에 요청이 라우트 핸들러에 의해 처리될지 여부 결정 (인증/인가)</td>
      <td>미들웨어와 달리 ExecutionContext에 접근 가능, 모든 미들웨어 실행 후 인터셉터/파이프 이전에 실행</td>
    </tr>
    <tr>
      <td>인터셉터 (Interceptors)</td>
      <td>3</td>
      <td>요청이 핸들러에 도달하기 전/응답이 클라이언트에 전송되기 전 가로채기</td>
      <td>로깅, 데이터 변환, 에러 처리 등에 사용. Pre-processing 및 Post-processing 단계 존재</td>
    </tr>
    <tr>
      <td>파이프 (Pipes)</td>
      <td>4</td>
      <td>클라이언트로부터 전송되거나 수신되는 데이터의 유효성 검사, 변환, 필터링</td>
      <td>@nestjs/common의 ValidationPipe와 class-validator 라이브러리 활용</td>
    </tr>
    <tr>
      <td>컨트롤러 (Controller)</td>
      <td>5</td>
      <td>클라이언트의 요청을 받아 처리하고 응답을 반환하는 역할</td>
      <td>라우팅 메커니즘을 통해 요청을 서비스로 위임</td>
    </tr>
    <tr>
      <td>서비스 (Service)</td>
      <td>6</td>
      <td>비즈니스 로직을 처리하는 역할</td>
      <td>컨트롤러에서 위임받은 작업을 수행 (데이터 처리, 외부 API 호출 등)</td>
    </tr>
    <tr>
      <td>예외 필터 (Exception Filters)</td>
      <td>7</td>
      <td>NestJS 요청 라이프사이클의 모든 단계에서 발생하는 예외/에러 처리</td>
      <td>에러 메시지 커스터마이징, 로깅 등. 포착되지 않은 예외 발생 시에만 작동</td>
    </tr>
  </tbody>
</table>

<p>각 단계의 역할은 다음과 같다.</p>

<ul>
  <li><strong>미들웨어 (Middleware)</strong>: 요청이 서버에 도달했을 때 가장 먼저 실행되는 부분이다. 요청 및 응답 객체에 접근하여 <code class="language-plaintext highlighter-rouge">로깅</code>, <code class="language-plaintext highlighter-rouge">인증</code>, <code class="language-plaintext highlighter-rouge">CORS</code> 설정 등 공통 작업을 처리하는 데 사용된다. 미들웨어는 next() 함수를 호출하여 다음 미들웨어 또는 라우트 핸들러로 제어를 전달한다. 글로벌 미들웨어와 모듈에 바인딩된 미들웨어가 순차적으로 실행된다.</li>
  <li><strong>가드 (Guards)</strong>: 모든 미들웨어 실행 후, 인터셉터나 파이프 이전에 실행된다. 가드의 주된 목적은 런타임에 요청이 라우트 핸들러에 의해 처리될지 여부를 결정하는 것으로, 주로 인증 및 인가 처리에 사용된다. 미들웨어와 달리 <code class="language-plaintext highlighter-rouge">ExecutionContext</code> 인스턴스에 접근하여 다음에 실행될 핸들러에 대한 정보를 알 수 있다는 차이점이 있다. 가드는 글로벌, 컨트롤러, 라우트 레벨로 바인딩될 수 있으며, 바인딩된 순서대로 실행된다.</li>
  <li><strong>인터셉터 (Interceptors)</strong>: 요청이 핸들러에 도달하기 전(pre-processing) 또는 응답이 클라이언트에 전송되기 전(post-processing)에 요청/응답을 가로챌 수 있다. 로깅, 데이터 변환(예: 응답 데이터를 data 키 안에 캡슐화), 에러 처리 등에 활용된다. 인터셉터는 RxJS Observable을 반환하며, 응답 경로에서는 ‘First In Last Out’ 방식으로 역순으로 해결된다.</li>
  <li><strong>파이프 (Pipes)</strong>: 클라이언트로부터 전송되거나 수신되는 데이터의 유효성 검사, 변환, 필터링을 담당한다. 예를 들어, 요청 본문의 데이터 형식을 원하는 형식으로 변환하거나, 데이터가 올바른지 검증하는 데 사용된다. <code class="language-plaintext highlighter-rouge">class-validator</code> 및 <code class="language-plaintext highlighter-rouge">class-transformer</code> 라이브러리와 함께 <code class="language-plaintext highlighter-rouge">ValidationPipe</code>를 사용하여 데코레이터 기반의 강력한 유효성 검사를 구현할 수 있다. 파이프는 예외 영역(exception zone) 내에서 실행되므로, 파이프에서 발생하는 예외는 <code class="language-plaintext highlighter-rouge">예외 필터</code>에서 처리된다.</li>
  <li><strong>컨트롤러 (Controller) 및 서비스 (Service)</strong>: 이 단계에서 컨트롤러는 요청을 받아 서비스로 비즈니스 로직 처리를 위임하고, 서비스는 실제 데이터 처리 및 로직을 수행한다. 서비스에서 처리된 결과는 다시 컨트롤러로 반환되어 최종 응답이 구성된다.</li>
  <li><strong>예외 필터 (Exception Filters)</strong>: NestJS 요청 라이프사이클의 모든 단계(미들웨어, 가드, 인터셉터, 파이프, 컨트롤러, 서비스 등)에서 포착되지 않은 예외/에러가 발생했을 때 호출된다. 예외 필터는 에러 메시지를 원하는 형태로 가공하여 응답하거나, 에러 로깅 등의 작업을 수행할 수 있다. NestJS는 내장된 전역 예외 필터를 제공하며, 개발자는 필요에 따라 커스텀 예외 필터를 작성하여 특정 예외를 섬세하게 처리할 수 있다. 예외가 발생하면 나머지 라이프사이클은 무시되고 즉시 예외 필터로 제어가 넘어간다.</li>
</ul>

<h2 id="4-백엔드-서버-관점에서의-nestjs-활용">4. 백엔드 서버 관점에서의 NestJS 활용</h2>
<p>NestJS는 백엔드 서버 개발에 필요한 다양한 기능을 효율적으로 구현하고 관리할 수 있도록 지원한다.</p>

<h3 id="41-인증-및-인가-authentication--authorization">4.1 인증 및 인가 (Authentication &amp; Authorization)</h3>
<p>백엔드 서버에서 사용자 인증(Authentication)과 인가(Authorization)는 필수적인 기능이다. 인증은 사용자의 신원을 증명하는 행위이며, 인가는 증명된 사용자에게 특정 자원에 대한 접근 권한을 부여하거나 거부하는 행위이다.</p>

<p>NestJS는 JWT(JSON Web Token)와 Session 기반 인증 방식을 모두 지원하며, 특히 Passport.js 라이브러리와의 통합을 통해 인증 및 인가 과정을 간소화한다. Passport.js는 다양한 인증 전략(예: JWT, 로컬, OAuth)을 플러그인 형태로 제공하여 유연한 구현을 가능하게 한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JWT 인증</code>: 사용자가 아이디와 비밀번호를 서버로 보내면, 서버는 JWT를 발급하여 클라이언트(브라우저)로 넘겨준다. 이후 클라이언트는 로그인 권한이 필요한 페이지를 요청할 때마다 HTTP Authorization 헤더에 <code class="language-plaintext highlighter-rouge">Bearer &lt;JWT&gt;</code> 형태로 토큰을 함께 보내 신분증처럼 사용하며, 서버는 이 토큰을 검증하여 접근을 허용한다. NestJS에서는 passport-jwt 패키지를 설치하고 PassportStrategy를 구현하여 JWT 토큰 검증 로직을 작성한다. secretOrKey를 통해 토큰 생성 시 사용한 비밀키를 설정하고, validate 메서드에서 토큰 검증 성공 시 사용자 객체를 Request.user에 저장하여 이후 로직에서 활용할 수 있도록 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Session 인증</code>: 클라이언트의 상태 정보를 서버에 저장하여 다루는 기술이다. 사용자가 로그인하면 서버는 SessionID를 발급하여 서버의 세션 목록에 추가하고, 이 SessionID를 사용자의 브라우저 쿠키에 저장하여 통행증처럼 사용한다. 이후 요청 시 클라이언트가 SessionID를 보내면 서버는 이를 세션 목록에서 확인하여 접근을 허용한다. JWT와 달리 민감한 정보가 서버에 저장되어 비교적 안전하지만, 요청마다 서버에서 확인하는 작업이 필요하여 부하가 걸릴 수 있다. 추가로 이러한 지속적인 상태 정보 저장은 stateful 한 특성으로 통상적인 서버에 비해 보다 많은 자원이 필요시 될 수 있다.</li>
</ul>

<p>가드(Guard)는 NestJS에서 인가 처리에 핵심적인 역할을 수행하며, @UseGuards() 데코레이터를 사용하여 특정 라우트나 컨트롤러에 적용할 수 있다.</p>

<h3 id="42-데이터베이스-연동">4.2 데이터베이스 연동</h3>
<p>NestJS는 TypeORM, Prisma와 같은 다양한 ORM(Object-Relational Mapping) 도구와의 통합을 강력하게 지원하여 데이터베이스와의 상호작용을 간소화한다. ORM은 JavaScript 객체를 사용하여 관계형 데이터베이스의 테이블에 접근할 수 있게 해주어, SQL 쿼리 없이도 데이터를 다룰 수 있게 한다.</p>

<ul>
  <li>TypeORM: 다양한 데이터베이스 시스템을 지원하며, 코드의 일관성을 유지하면서 유연하게 데이터베이스를 다룰 수 있도록 돕는다. TypeOrmModule.forRoot()를 사용하여 데이터베이스 연결 설정을 초기화하고 엔티티 클래스를 지정한다. Prisma 에 비하면 비교적 고전적인 형태지만, 그만큼 다양한 서버 연결구조나 데이터베이스 시스템의 다양한 활용성을 보장하는 편에서 비교적 사용이 용이할 수 있다.</li>
  <li>Prisma: 현대적인 ORM 도구로, 높은 수준의 타입 안정성을 보장하면서 효율적인 데이터베이스 작업을 가능하게 한다. Rust로 작성된 쿼리 엔진을 사용하며, schema.prisma 파일을 통해 데이터 모델과 관계를 쉽게 정의할 수 있다. PrismaService를 생성하여 NestJS 모듈 시스템에서 Prisma Client를 초기화하고 데이터베이스에 연결할 수 있다. NoSQL 을 포함하여 다양하고 현대적인 연결을 제공하지만, 한 편으로 TypeORM 에 비하면 데이터베이스의 다양한 시스템에 대응되는 수준 까진 아닌 경우가 있어, 데이터베이스의 복잡한 사용에 대응하기 어려울 수 있다는 점은 감안해야한다.</li>
</ul>

<h3 id="43-데이터베이스-쿼리-최적화">4.3 데이터베이스 쿼리 최적화:</h3>
<p>성능이 중요한 백엔드 애플리케이션에서 데이터베이스 쿼리 최적화는 필수적이다.</p>

<ul>
  <li>인덱스 사용: 자주 쿼리되거나 WHERE 절에 사용되는 컬럼에 <code class="language-plaintext highlighter-rouge">인덱스를 추가하여 데이터베이스가 필요한 데이터를 빠르게 찾을 수 있도록</code> 한다.</li>
  <li>SELECT * 지양: 모든 컬럼을 선택하는 대신, <code class="language-plaintext highlighter-rouge">필요한 특정 컬럼만</code> 선택하여 반환되는 데이터의 양을 줄이고 쿼리 속도를 높인다.</li>
  <li>Eager Loading 활용: 연관된 엔티티를 자주 로드하는 경우, <code class="language-plaintext highlighter-rouge">Eager Loading</code>을 사용하여 여러 쿼리를 실행하는 대신 한 번에 모든 관련 데이터를 가져와 쿼리 수를 줄인다.</li>
</ul>

<h3 id="44-테스트-전략">4.4 테스트 전략</h3>
<p>NestJS는 효과적인 테스트를 포함한 개발 모범 사례를 장려하며, Jest를 기본 테스트 프레임워크로 권장한다. NestJS 프로젝트를 생성할 때 Jest가 함께 주입되어 단위 테스트 및 E2E 테스트를 위한 기본 도구를 제공한다. 테스트 환경에서 Nest의 의존성 주입 시스템을 활용하여 컴포넌트를 쉽게 모킹(Mocking)할 수 있다.</p>

<p>테스트는 범위에 따라 크게 세 가지 유형으로 나뉜다:</p>

<ol>
  <li>
    <p><strong>단위 테스트 (Unit Test)</strong>: 애플리케이션을 구성하는 가장 작은 단위 기능(예: 단일 함수, 클래스 메서드)에 대한 테스트이다. NestJS에서는 서비스와 같은 단위 기능에 대한 테스트를 Jest를 사용하여 작성한다.</p>
  </li>
  <li>
    <p><strong>통합 테스트 (Integration Test)</strong>: 애플리케이션을 구성하는 여러 모듈 간의 상호작용에 대한 테스트이다. 개발자의 관점에서 모듈 간의 연동이 의도대로 동작하는지 확인하는 데 초점을 둔다. NestJS는 @nestjs/testing 패키지의 Test 클래스를 사용하여 테스트 모듈을 생성하고 특정 인스턴스를 검색하여 통합 테스트를 용이하게 한다.</p>
  </li>
  <li>
    <p><strong>E2E 테스트 (End-to-End Test)</strong>: 최종 사용자의 관점에서 애플리케이션이 시나리오대로 전체적으로 작동하는지 확인하는 테스트이다. 외부로부터의 요청부터 응답까지 기능이 잘 동작하는지에 대한 테스트이며, 실제 사용자 경험을 시뮬레이션한다. test 디렉토리에 위치하는 것이 일반적이다.</p>
  </li>
</ol>

<p>테스트 코드를 작성하는 것은 개발 안정성, 유지보수의 용이성, 그리고 디버깅 시간 단축에 크게 기여한다.</p>

<h3 id="45-성능-최적화">4.5 성능 최적화</h3>
<p>NestJS 애플리케이션의 성능을 최적화하기 위한 다양한 기법들이 있다.</p>

<ul>
  <li><strong>캐싱 (Caching)</strong>: 자주 접근하는 데이터를 메모리에 임시로 저장하여 애플리케이션의 속도를 높이는 기법이다. NestJS는 cache-manager 라이브러리를 통해 캐싱 구현을 지원한다. 캐싱 시에는 적절한 만료 시간을 설정하고, 데이터 업데이트 시 캐시를 무효화하며, 여러 서버에서 실행되는 경우 분산 캐시를 사용하는 것이 중요하다.</li>
  <li><strong>압축 (Compression)</strong>: 애플리케이션과 클라이언트 간에 전송되는 데이터 양을 줄여 성능을 향상시키는 기법이다. NestJS에서는 compression 미들웨어를 사용하여 응답 데이터를 압축할 수 있다. 압축 수준을 적절히 설정하고, 모든 응답을 압축하며, CPU 집약적인 압축 작업을 캐싱하는 것을 고려해야 한다.</li>
  <li><strong>Fastify 런타임 활용</strong>: NestJS는 기본적으로 Express를 런타임으로 사용하지만, Fastify 프레임워크를 래핑하여 동작할 수도 있다. Fastify는 Express보다 훨씬 높은 성능을 제공하며, 특히 API 중심의 애플리케이션과 마이크로서비스에 적합하다. 벤치마크 테스트에 따르면, Fastify는 Express보다 초당 요청 처리량에서 5배 이상 빠른 성능을 보였다. 이는 Fastify가 효율성과 낮은 오버헤드에 중점을 둔 설계와 이벤트 기반 아키텍처, 스키마 기반 유효성 검증을 사용하기 때문이다. 고성능이 요구되는 백엔드 애플리케이션에서는 Fastify를 런타임으로 선택하는 것이 유리할 수 있다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>Express</th>
      <th>Fastify</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>요청 처리 속도 (RPS)</td>
      <td>약 20,000</td>
      <td>약 114,000 (5.6배 이상 빠름)</td>
    </tr>
    <tr>
      <td>메모리 사용량 (1만 동시 연결 시)</td>
      <td>약 150MB</td>
      <td>약 100MB</td>
    </tr>
    <tr>
      <td>내장 유효성 검증</td>
      <td>없음 (외부 라이브러리 필요)</td>
      <td>스키마 기반 내장 (Ajv 사용)</td>
    </tr>
    <tr>
      <td>내장 로깅</td>
      <td>없음 (외부 라이브러리 필요)</td>
      <td>내장 (Pino 사용)</td>
    </tr>
    <tr>
      <td>TypeScript 지원</td>
      <td>커뮤니티 유지보수 <code class="language-plaintext highlighter-rouge">@types/express</code></td>
      <td>네이티브 지원</td>
    </tr>
    <tr>
      <td>HTTP/2 지원</td>
      <td>없음 (외부 라이브러리 필요)</td>
      <td>네이티브 지원</td>
    </tr>
    <tr>
      <td>주요 특징</td>
      <td>단순성, 유연성, 광범위한 생태계</td>
      <td>효율성, 낮은 오버헤드, 내장 유효성 검증, 구조화된 플러그인</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Docker 최적화</strong>: NestJS 애플리케이션을 Docker 컨테이너로 배포할 때, Dockerfile 및 .dockerignore 파일 최적화를 통해 빌드 시간과 이미지 크기를 크게 줄일 수 있다. <code class="language-plaintext highlighter-rouge">.dockerignore</code> 파일을 사용하여 node_modules/, dist/, .git 등 빌드에 불필요한 파일과 디렉토리를 제외한다. 또한, 멀티스테이지 빌드를 사용하여 빌드 단계와 프로덕션 단계를 분리함으로써, <code class="language-plaintext highlighter-rouge">최종 이미지에는 필요한 파일과 설정만 포함되도록 하여</code> 이미지 크기를 대폭 감소시킬 수 있다. 이는 <code class="language-plaintext highlighter-rouge">CI/CD 파이프라인에서 빌드 및 배포 효율성</code>을 높이는 데 기여한다.</li>
</ul>

<h3 id="46-고급-활용-패턴-간략-소개">4.6 고급 활용 패턴 (간략 소개)</h3>
<p>NestJS는 견고하고 확장 가능한 애플리케이션을 구축하기 위한 다양한 고급 아키텍처 패턴과 모범 사례를 적용할 수 있도록 지원한다.</p>

<ul>
  <li><strong>순환 의존성 해결 (forwardRef())</strong>: 두 개 이상의 모듈이 서로를 참조하는 순환 종속성(Circular Dependency)은 애플리케이션 초기화 실패, 무한 루프 등의 문제를 야기할 수 있다. NestJS에서는 @nestjs/common 패키지에서 제공하는 forwardRef() 기능을 사용하여 클래스에 중첩을 허용함으로써 이러한 순환 종속성 문제를 해결할 수 있다. 그 외에도 Shared Module 전략 등을 통해 의존성을 해결해줄 수 있다.</li>
  <li><strong>클린 아키텍처 (Clean Architecture) 및 DDD</strong>: NestJS는 모듈 기반 아키텍처와 의존성 주입을 통해 클린 아키텍처(Clean Architecture) 또는 헥사고날 아키텍처(Hexagonal Architecture)와 같은 계층형 아키텍처 패턴을 쉽게 적용할 수 있다. 클린 아키텍처는 애플리케이션을 동심원 계층으로 구성하여 내부 계층이 외부 계층에 의존하지 않도록 하며, 비즈니스 로직(도메인 레이어)을 외부 기술(인프라 레이어)로부터 분리하여 유연성과 유지보수성을 극대화한다. 도메인 주도 설계(DDD)는 비즈니스 도메인에 초점을 맞춰 소프트웨어 엔티티와 도메인 개념을 일치시키는 접근법으로, NestJS의 모듈 시스템이 이를 쉽게 구현하도록 돕는다.</li>
  <li><strong>CQRS (Command Query Responsibility Separation)</strong>: CQRS 패턴은 명령(Command, 쓰기 작업)과 조회(Query, 읽기 작업)를 분리하여 성능, 확장성, 보안성을 높이는 아키텍처 패턴이다. 복잡한 도메인 모델에서 읽기 모델과 쓰기 모델을 다르게 가져갈 수 있어, 읽기 작업이 많은 애플리케이션에서 특히 유용하다. NestJS는 @nestjs/cqrs 패키지를 통해 CommandBus, EventBus, QueryBus를 제공하여 CQRS 패턴을 쉽게 구현할 수 있도록 지원한다.</li>
  <li><strong>이벤트 소싱 (Event Sourcing)</strong>: 이벤트 소싱은 애플리케이션 상태의 모든 변경 사항을 불변의 이벤트 시퀀스로 저장하는 아키텍처 패턴이다. 현재 상태만 저장하는 대신, 상태를 변경하는 모든 동작을 이벤트로 기록한다. @event-nest/core와 같은 라이브러리는 NestJS 애플리케이션에서 이벤트, 애그리거트(Aggregate), 도메인 구독을 관리하는 도구를 제공하여 이벤트 소싱 구현을 간소화한다. 이는 CQRS 및 DDD와 함께 사용될 때 강력한 시너지를 발휘한다.</li>
</ul>

<h2 id="5-결론-및-향후-학습-방향">5. 결론 및 향후 학습 방향</h2>
<p>스프링부트의 그것과 유사한, 그러나 동시에 Node 라는 특성을 갖고 있는 언어적 기반 덕에 비동기 처리 서버로 아주 사용하기 편리한 NestJS에 대해 알아보았다.</p>

<p>정리해봄으로써 각 구성 요소들의 의미나 의도, 그리고 제일 중요한 라이프사이클에 대한 부분은 다시 봐도 개발에 반드시 필요한 요소라는 사실을, 그리고 조금 만 더 이해도를 높이면 단순히 서버를 만든다를 넘어서 어떤 파이프라인을 타고, 어떤 구조로 CICD 까지 이룰 수 있을지 이해의 길이 좀더 열릴 것 같다는 생각이다. 확실히 이제는 단위 단위의 정리도 좋지만, 전체를 아우르는 한번에 내용을 읽고 정리하는 작업도 상당히 도움이 된다는 것을 새삼 느끼게 된다.</p>

<p>제미니가 제시해주는 1년차 개발자의 추가 학습 방향도 참고할 것이지만, 좀더 고난이도 개발자가 되기위해 노력해야할 필요성은 보이는 것 같다. 제미니를 통해 향후 작성하고 세부적으로 알아볼 생각이지만, 한 12개 정도 나온다고 하니, 한 주에 하나는 꾸준히 써야 할 것이리라 생각된다(…)</p>

<p>주말도 바쁜게 끝이 없다 😅</p>

<h2 id="참조-문헌">참조 문헌</h2>
<ol>
  <li><a href="https://stack94.tistory.com/entry/NestJS-NestJS-%EC%84%A4%EC%B9%98%EB%B6%80%ED%84%B0-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">NestJS 설치부터 기본 개념 알아보자 - 느린 개발자</a></li>
  <li><a href="https://f-lab.kr/insight/efficient-backend-architecture-with-nestjs">NestJS를 활용한 효율적인 백엔드 구조 설계 - F-Lab</a></li>
  <li><a href="https://velog.io/@zvoniti/NestJS-Design-Pattern">NestJS-Design Pattern - velog</a></li>
  <li><a href="https://deemmun.tistory.com/35">NestJS가 각광받고 있는 이유? / 파일 트리 구조 / 실제코드</a></li>
  <li><a href="https://velog.io/@kimhalin/NestJS-Project-Structure">NestJS &amp; Project Structure - velog</a></li>
  <li><a href="https://ts01.tistory.com/15">[초보자의 눈으로 보는 NestJS] 3. 모듈, 컨트롤러, 그리고 프로바이더</a></li>
  <li><a href="https://velog.io/@dev_0livia/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0-01">NestJS 모듈이란? - velog</a></li>
  <li><a href="https://velog.io/@naljajm/NestJs-%EB%AA%A8%EB%93%88-%EC%84%A4%EA%B3%84">[NestJs] 모듈 설계 - velog</a></li>
  <li><a href="https://dev-junwoo.tistory.com/m/162">[NestJs] 데코레이터,컨트롤러,서비스,모듈</a></li>
  <li><a href="https://tristy.tistory.com/38">[Nest Js] Nest Js 공식 문서 파헤치기 - 시작하기</a></li>
  <li><a href="https://www.rldnd.net/nestjs-modules-controllers-providers">Nest.js의 Modules, Controllers, Providers 알아보기</a></li>
  <li><a href="https://puddingcamp.com/topics/nestjs-modular-architecture-principles">Nest.js와 모듈식 아키텍처: 원칙과 모범 사례 - 푸딩캠프</a></li>
  <li><a href="https://velog.io/@zunzero/Nest.js-%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C-%EC%A0%95%EB%A6%AC">[Nest.js] 공식문서 정리 (Overview) - velog</a></li>
  <li><a href="https://velog.io/@cocorig/NestJS-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%98%88%EC%8B%9C-Services-NotFoundException">[NestJS] 데코레이터 개념과 예시 - velog</a></li>
  <li><a href="https://velog.io/@jujube0/NestJS%EB%A1%9C-REST-API-%EB%A7%8C%EB%93%A4%EA%B8%B0">NestJS로 REST API 만들기 - velog</a></li>
  <li><a href="https://velog.io/@hyein0112/NestJS%EC%97%90%EC%84%9C%EC%9D%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85Dependency-Injection">NestJS에서의 의존성 주입(Dependency Injection) - velog</a></li>
  <li><a href="https://choidr.tistory.com/entry/NestJS-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85">NestJS - 의존성 주입 - 두루미의 개발기록</a></li>
  <li><a href="https://velog.io/@tlsdntjd95/NestJS-DI-%EB%94%B0%EB%9D%BC%ED%95%B4%EB%B3%B4%EA%B8%B0">NestJS DI 따라해보기 - velog</a></li>
  <li><a href="https://cdragon.tistory.com/entry/NestJS-Docs-Testing-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0">[NestJS- Docs] Testing 알아보기 - 티스토리</a></li>
  <li><a href="https://develop-const.tistory.com/11">NestJs Custom decorator에 대해 알아보자 - 티스토리</a></li>
  <li><a href="https://cdragon.tistory.com/entry/NestJS-Custom-Decorators-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0">[NestJS - Docs] Custom Decorators 알아보기 - 티스토리</a></li>
  <li><a href="https://docs.nestjs.com/recipes/hot-reload">Hot reload - NestJS 공식 문서</a></li>
  <li><a href="https://artosalminen.github.io/posts/how-to-use-config-service-in-nestjs-bootstrap/">ConfigService를 bootstrap에서 사용하는 방법</a></li>
  <li><a href="https://www.rldnd.net/nestjs-lifecycle-">Nest.js의 LifeCycle(생명 주기)는 어떻게 되지?</a></li>
  <li><a href="https://github.com/nestjs/nest/issues/14773">Provider Dependencies 관련 NestJS GitHub 이슈</a></li>
  <li><a href="https://docs.nestjs.com/fundamentals/overview">NestJS Fundamentals Overview 공식문서</a></li>
  <li><a href="https://ru-nestjs-docs.netlify.app/faq/request-lifecycle">Request lifecycle - Netlify</a></li>
  <li><a href="https://dev.to/ngtrthvu3007/nestjs-request-lifecycle-2jhe">NestJS: Request Lifecycle - DEV.to</a></li>
  <li><a href="https://velog.io/@ldhbenecia/NestJS-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC-class-Validator">NestJS - 유효성 검사 class-Validator - velog</a></li>
  <li><a href="https://velog.io/@wlduq0150/Nest.js-exception-filter-%ED%8C%8C%ED%97%A4%EC%B9%98">[Nest.js] exception filter 파헤치기 - velog</a></li>
  <li><a href="https://mag1c.tistory.com/476">[NestJS] 예외처리, Exception Filter - 티스토리</a></li>
  <li><a href="https://grepper.tistory.com/178">NestJS - 대충 서비스 만들어보기 (14)</a></li>
  <li><a href="https://choi-records.tistory.com/entry/NestJS-JWT1-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EA%B5%AC%ED%98%84">[NestJS] JWT(1) 기본 개념, 구현 - 티스토리</a></li>
  <li><a href="https://suloth.tistory.com/77">로그인의 원리와 Guard(1) - 개념편</a></li>
  <li><a href="https://sjh9708.tistory.com/48">[NestJS] JWT 토큰 인가 - PassportStrategy/Guard 사용과 토큰 재발급</a></li>
  <li><a href="https://develop-const.tistory.com/19">NestJs 데이터베이스 연동하기 (mysql, typeorm) - 티스토리</a></li>
  <li><a href="https://custom-li.tistory.com/209">제로부터 시작하는 Prisma와 Nest.js - 티스토리</a></li>
  <li><a href="https://www.oneclickitsolution.com/centerofexcellence/nodejs/nestjs-prisma-integration-guide">Boost Your Nest.js Project with Prisma - OneClick</a></li>
  <li><a href="https://delvingdeveloper.com/posts/nestjs-performance-optimization-tips">NestJS Performance Optimization: Expert Tips - Delving Developer</a></li>
  <li><a href="https://coldpresso.tistory.com/13">Jest를 이용한 Unit/E2E 테스트 - 티스토리</a></li>
  <li><a href="https://velog.io/@cxzaqq/NESTJS%EB%A5%BC-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%9020-Testing">NESTJS를 배워보자(20) - Testing - velog</a></li>
  <li><a href="https://velog.io/@hing/NestJS-%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C-Testing">NestJS 공식문서 Testing - velog</a></li>
  <li><a href="https://www.brilworks.com/blog/optimize-your-nest-js-app-performance/">Optimize Your Nest.js App Performance - Brilworks</a></li>
  <li><a href="https://betterstack.com/community/guides/scaling-nodejs/fastify-express/">Express.js vs Fastify - Better Stack</a></li>
  <li><a href="https://www.cbtnuggets.com/blog/technology/programming/express-vs-fastify">Express vs. Fastify - CBT Nuggets</a></li>
  <li><a href="https://velog.io/@carrykim/Nestjs-CI-CD-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-Docker-%EC%B5%9C%EC%A0%81%ED%99%94-%ED%9A%8C%EA%B3%A0">Nestjs CI CD 프로젝트에서 Docker 최적화 회고 - velog</a></li>
  <li><a href="https://developer-gyakya.tistory.com/22">[NestJs] 순환 종속성 문제 - 티스토리</a></li>
  <li><a href="https://junho2343.github.io/posts/clean-architecture-hexagonal-architecture-with-nestjs">클린 아키텍처(헥사고날 아키텍처) 알아보기 with NestJS</a></li>
  <li><a href="https://github.com/0xTheProDev/nestjs-clean-example">nestjs-clean-example - GitHub</a></li>
  <li><a href="https://assu10.github.io/dev/2023/04/29/nest-clean-architecture/">NestJS - 클린 아키텍처 · ASSU BLOG.</a></li>
  <li><a href="https://velog.io/@naljajm/NestJs-CQRS-%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC">[NestJs] CQRS 관심사 분리 - velog</a></li>
  <li><a href="https://assu10.github.io/dev/2023/04/16/nest-cqrs/">NestJS - CQRS · ASSU BLOG.</a></li>
  <li><a href="https://www.npmjs.com/package/@event-nest/core">@event-nest/core - npm</a></li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="NestJS" /><category term="TypeScript" /><category term="Node" /><summary type="html"><![CDATA[1. 서론: NestJS, 왜 선택해야 할까? NestJS는 Node.js 환경에서 효율적이고 확장 가능한 서버 사이드 애플리케이션을 구축하기 위한 진보적인 프레임워크다. 이 프레임워크는 Angular의 아키텍처에서 영감을 받아 개발되었으며, TypeScript를 기본 언어로 적극 지원한다는 특징을 가집니다. TypeScript의 강력한 타입 시스템은 개발 과정에서 발생할 수 있는 잠재적인 오류를 미연에 방지하고, 코드의 가독성과 안정성을 크게 향상시킨다.  ]]></summary></entry><entry><title type="html">docker는 흔들리고 있을까?</title><link href="http://localhost:4000/backend/2025/05/06/alternative-for-docker.html" rel="alternate" type="text/html" title="docker는 흔들리고 있을까?" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/06/alternative-for-docker</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/06/alternative-for-docker.html"><![CDATA[<h2 id="도커-왕좌를-지키지-못하는-이유-컨테이너-생태계의-지각변동">도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동</h2>

<p><img src="/assets/images/posts/2025-05/docker-wallpaper.jpeg" alt="" /></p>

<p>수년간 <strong>컨테이너 생태계의 중심에는 도커가 있었다</strong>. 사실 도커는 ‘대명사’가 되긴 했지만 원래 그 기술의 근간은 ‘컨테이너’라는 기술이다.</p>

<p>리눅스 기반 OS 에서 제공하는 기술로 <strong>컨테이너</strong>는 시스템의 나머지 부분으로부터 격리된 하나 이상의 프로세스 집합을 의미한다.</p>

<p>이러한 프로세스를 실행하는 데 필요한 모든 파일과 필수 라이브러리, 종속성이 개별 이미지 내에 함께 패키징된다. 한 마디로 정리하면, Host 에 해당하는 영역에서 공통적인 걸 가져오고, 실제 독립적인 시스템 구현을 위해 필요한 부분은 ‘레이어’ 라는 이름으로 별도로 이미지 내부에 장착시켜서 호스트와는 별개의 시스템이 마치 구동되는 듯 보이게 만들어준다.</p>

<p>컨테이너는 가상 머신과 달리 <strong>가상 머신보다 적은 리소스를 사용</strong>하면서도 애플리케이션 격리를 유지할 수 있다. 또한, 표준 인터페이스를 갖추고 있어 대규모 애플리케이션(여러 컨테이너)의 일부로 더 쉽게 관리될 수 있으며, 여러 클라우드에 걸쳐 오케스트레이션될 수 있다. 궁극적으로 컨테이너는 <strong>애플리케이션 개발, 배포, 관리 방식에서 이식성과 일관성을 유지시키며 발전</strong>시킨 기술이라고 볼 수 있다. 그리고 이러한 컨테이너를 활용하여 시스테메틱한 관리체계를 정립한 도커는 컨테이너의 대명사처럼 여겨졌다.</p>

<p>하지만 이제는 도커만의 독주 무대가 아니게 되어감을 종종 느끼게 된다. 도커는 여전히 인기가 있지만, 점점 더 많은 기업과 개발자들이 다른 대안으로 눈을 돌리고 있다는 점은 고려해볼만한 논지가 아닐까 한다. 이는 도커가 선택지에서 제외되었다는 것이 아닌 성능, 보안, 유연성, 비용 등 주요 측면에서 도커가 뒤처지거나, 대안이 있다 혹은 대안을 찾아야 한다는 인식이 확산되고 있는 것이다.</p>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0001.png" alt="" /></p>

<h3 id="도커가-가지는-현안들">도커가 가지는 현안들</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0002.png" alt="" /></p>

<ol>
  <li>
    <p><strong>라이선스 및 비용 구조 변경</strong></p>

    <p>가장 중요한 전환점 중 하나는 <strong>도커 데스크톱의 라이선스와 비용 구조 변경</strong>이다. 도커는 일정 규모 이상의 조직에 유료 멤버십을 요구하기로 결정했으며, 이전까지 무료로 사용하던 도구에 대해 기업들이 갑자기 비용을 지불해야 하는 상황이 발생했다.</p>

    <p>이러한 부분은 비용에 민감한 팀들이 <strong>도커에 대한 의존도를 진지하게 재평가</strong>하도록 만들게 된다. 오픈 소스 도구로 전환하고자 하는 이들이 대안을 모색하는 계기가 되었다.</p>
  </li>
  <li>
    <p><strong>성능 문제</strong></p>

    <p>도커는 리눅스에서는 뛰어난 성능을 가집니다. 물론, 이는 컨테이너라는 기술 자체의 본질적으로 리눅스 시스템 구조와 밀접한 연관성을 갖고 있다.</p>

    <p>하지만 문제는 이러한 편리함을 윈도우나 Mac 에서 사용하고자 하면서 여러 이슈가 발생하게 된다. 도커는 기본적으로 Host로 사용할 영역을 각각 WSL2, HyperKit 을 활용하는데, 이를 기반으로 하는 도커 데스크톱은 리눅스 컨테이너를 에뮬레이트하기 위해 가상 머신을 사용하기 때문에, 이로 인한 불가피한 <strong>성능 저하, 과도한 메모리와 CPU 사용 등의 문제가 발생</strong>할 수 있다.</p>

    <p>고질적인 윈도우 WSL Vmmem 이슈, 파일 시스템의 비정상적인 느림, IO 성능 저하, CPU 오버헤드 문제 등등… 알려진 문제들, 불편함은 이미 충분히 지적되고 있고, 이에 대한 개선은 수년째 언급 되고 있는 실정이다.</p>

    <p>특히나 무거운 빌드나 복잡한 멀티 컨테이너 구성에서는 문제가 더욱 심각해진다. 수겹의 레이어를 만들어야 하고, 그걸 위한 이미지들은 기존보다 훨씬 많은 양의 가상화를 위한 리소스를 필요로 한다.</p>

    <p>반면, 핀치(Finch)에서 사용하는 리마(Lima) 같은 신기술은 맥 개발자를 위해 최적화된 가상화 환경을 제공하여 도커 데스크톱의 복잡성 없이 성능을 개선합니다. 맥 성능을 극대화하는 것이 대체 런타임을 고려하는 또 하나의 이유다.</p>
  </li>
  <li>
    <p><strong>보안 문제</strong></p>

    <p>도커의 아키텍처는 켜보면 바로 알 수 있는 특징이 있다. 내부의 구동에서 <strong>루트 권한으로 실행되는 데몬에 의존</strong>하고 있다는 점이다. 그러나 이러한 점이 바로 보안의 문제냐? 라고 하면 그렇지는 않다고 생각한다. 오히려 개발 친화적이고, Host 로의 입구 관문이 존재하는 데, 각 내부에 더 많고, 두꺼운 보안은 불필요한 요소일 수 있다.</p>

    <p>하지만 이로 인해 운영 환경에서 <strong>보안 위협 노출이 넓어질 수 있다</strong>. 이러한 점에서 도커는 보안 기능을 추가했지만, 보안을 중시하는 조직들은 애초부터 보안을 고려해 설계된 대안들을 선호하는 경우가 생길 수 밖에 없다.</p>
  </li>
  <li>
    <p><strong>모노리틱 접근 방식</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0003.png" alt="" /></p>

    <p>클러스터링을 위한 스웜(Swarm)과 이미지 레지스트리를 위한 도커 허브(Docker Hub)가 밀접하게 결합된 도커의 모노리틱 구조는 적응하고 난 사용자에게는 매우 편리하게 느껴질 수 있다. 모든 것이 물 흐르듯, 일사천리로 움직이게 되고 이러한 구조는 설정과 이식에서 우수한 성능을 보여준다.</p>

    <p>하지만 <strong>현대 클라우드 네이티브 환경에서는 오히려 제약</strong>으로 다가오게 될 수 있다. 오늘날의 트렌드는 <strong>특화되고 모듈화된 도구들로의 전환</strong>이다. 오케스트레이션은 쿠버네티스(Kubernetes)가 완전히 지배하고 있으며, 패키징은 헬름(Helm)이 담당하고, 컨테이너드(containerd)와 같은 전용 컨테이너 런타임은 컨테이너 관리에만 집중해준다. 즉, 각 역할에 맞는 수준의 관리를 하고 통제가 가능하다는 것은, 전체의 조율과 모듈화에 오히려 도움이 되지, 도커의 통합적 관리는, 오히려 <strong>복잡성을 증가</strong>시킬 수 있다.</p>
  </li>
  <li>
    <p><strong>밴더 종속성 우려</strong></p>

    <p><img src="/assets/images/posts/2025-05/2025-05-06-0005.png" alt="" /></p>

    <p>개발자들은 도커의 특정 도구에 지나치게 의존하는 것에 신중해지고 있다. 도커 파일 문법은 널리 사용되지만, OCI 이미지 및 런타임 요구 사항처럼 공개 표준에 의해 관리되는 것이 아니다. 개발자들은 <strong>단일 툴체인에 묶이는 것을 피하고 싶어 하며</strong>, 특히 공개 표준이 더 큰 유연성과 장기적인 안정성을 보장해 줄 수 있다는 주장은 언제나 그렇지만 지속적으로 강조된다. <strong>다양한 도구와 플랫폼 간의 호환성 보장, 이식성, 밴더 중립성 확보가 더욱 중요</strong>해졌고 그렇지 못한 대상에 대해선 기피하는 것이 어느 기업이나, 개발자들의 공통된 영역이리라.</p>
  </li>
</ol>

<h3 id="도커의-대안들-새로운-플레이어들의-등장">도커의 대안들: 새로운 플레이어들의 등장</h3>

<p><img src="/assets/images/posts/2025-05/2025-05-06-0004.png" alt="" /></p>

<p>이러한 배경 속에서 여러 컨테이너 런타임들이 인기를 얻고 있으며, 이들은 현대적인 컨테이너 네이티브 환경의 핵심 가치인 모듈화, 성능, 개방성을 반영하고 있다. 주목할 만한 대안들은 다음과 같다.</p>

<ul>
  <li><strong>Podman</strong>: 레드햇(Red Hat)에서 개발한 포드만은 <strong>안전하고 데몬이 없는 대체재</strong>로 평가받는다. 도커와 달리 중앙 데몬에 의존하지 않으며, <strong>루트 권한 없이 컨테이너를 실행할 수 있는 루트리스 환경을 적극 지원</strong> 한다. 명령어 인터페이스도 도커와 매우 유사하여 보안을 중시하는 팀이 쉽게 전환할 수 있다.</li>
  <li><strong>containerd</strong>: 원래는 도커의 일부였지만 분리되어 현재는 CNCF가 관리하는 독립 프로젝트다. 특히 <strong>쿠버네티스 1.24에서 도커에 대한 직접 지원이 중단된 이후</strong>로, <strong>컨테이너드는 대부분의 쿠버네티스 배포판에서 기본 컨테이너 런타임으로 사용</strong>되고 있다. AWS, 구글 클라우드, 애저와 같은 주요 클라우드 제공 업체들도 자체 관리형 쿠버네티스 서비스에서 컨테이너드를 기반으로 사용한다. 컨테이너 관리에 단일 목적을 가지고 있어 <strong>경량화되고 확장 가능</strong>하다는 특징이 가장 크다.</li>
  <li><strong>CRI-O</strong>: CRI-O 역시 CNCF에서 관리하며, <strong>쿠버네티스를 위해 특별히 설계</strong>되었다. 컨테이너 런타임 인터페이스(CRI)를 엄격히 준수하며, 불필요한 요소를 제거한 간결하고 목적에 맞는 환경을 유지해준다. 오직 쿠버네티스 워크로드만을 지원하기 때문에 보안 측면에서도 이점을 제공한다. 레드햇 오픈 시프트의 기본 런타임이며, 최소주의와 규정 준수를 중시하는 팀들에게 선호된다.</li>
  <li><strong>Lima 및 Finch</strong>: 맥OS 성능 문제를 해결하기 위한 도구들이다. <strong>Lima는 맥OS에서 컨테이너 빌드를 위한 리눅스 가상 머신을 구성</strong>해 주는 도구로 성능에 최적화된 환경을 제공한다. <strong>Finch는 AWS가 후원하는 프로젝트</strong>로 리마와 컨테이너드/너드컨트롤(nerdctl)을 기반으로 하여 <strong>도커 데스크톱을 대체할 수 있는 고성능 도구를 제공</strong>한다. <strong>라이선스 제약 없이 사용할 수 있다는 점</strong>이 큰 장점이며, 맥OS 개발자들 사이에서 <strong>네이티브에 가까운 성능</strong>을 제공하는 대안으로 빠르게 선호되고 있다.</li>
</ul>

<h3 id="컨테이너-생태계의-미래">컨테이너 생태계의 미래</h3>

<p>컨테이너 생태계 전반의 분위기는 현재 지속적으로 <strong>모듈화와 전문화로의 전환</strong>을 반영하고 있다. 그러한 상황에서 도커의 아쉬운 부분을 이야기 해봤으나, 사실 지속적인 개선이 이루어지고 있다. 2025년 1월에 쓰여진 글로, <a href="https://www.paolomainardi.com/posts/docker-performance-macos-2025/">Docker on MacOS is still slow?</a>라는 이 글만 보더라도 2년 전 분석에 비하면 Docker 의 File Synchronization 기능으로 성능 저하는 최소화 가능하며, 아직 베타지만 Docker VMM 등 대안, 대첵 등도 거론된다는 점에서 MacOS 가상화 환경과 native linux 성능 간 격차 개선을 통해 컨테이너 생태계와 Docker가 여전히 개발자들의 선택을 받게 될 것이라는 점은 확실해 보인다.</p>

<p>도커는 사라지는 것이 아니라 변화하고 있는 것이다. 그러나 컨테이너라는 기술을 기반으로 하는 영역은 현재 <strong>개방형 표준, 경량화된 런타임, 클라우드 네이티브 원칙을 중심으로 빠르게 진화</strong>하고 있다. 도커가 이제는 컨테이너의 절대적인 중심은 아닐 수 있지만, 여전히 중요한 역할을 수행할 것이다. 우리가 목격하고 있는 것은 도커가 만들어낸 생태계의 성숙이며, 이를 통해 개발자들은 더 다양한 선택지를 갖게 되었다는 점이다.</p>

<p>미래는 <strong>모듈형 구조를 갖고 설계 단계부터 개방성을 지향하며, 기본적으로 안전하고 다양한 워크플로우에 유연하게 대응할 수 있는 도구들을 선호</strong>하는 것은 자연스러운 흐름일 것이고, 이 흐름을 읽고 대비하는 필요는 있어 보인다고 생각이 든다.</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="Backend" /><category term="DevOps" /><category term="Container" /><category term="Docker" /><summary type="html"><![CDATA[도커, 왕좌를 지키지 못하는 이유? 컨테이너 생태계의 지각변동]]></summary></entry><entry><title type="html">@types/~ 의존성을 설치하면 얻는 것</title><link href="http://localhost:4000/backend/2025/05/03/Type-library.html" rel="alternate" type="text/html" title="@types/~ 의존성을 설치하면 얻는 것" /><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>http://localhost:4000/backend/2025/05/03/Type-library</id><content type="html" xml:base="http://localhost:4000/backend/2025/05/03/Type-library.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>요 최근 MSA 서버 구현 공부를 다시 하고 있다. 영어 강의고, 상당히 난감한 번역의 자막이라 열은 받지만… 그럼에도 구조적 설계를 배울 수 있어서 좋다.</p>

<p>그러는 와중에 여전히 모르는게 많은 응애 개발자 답게, 모르는 라이브러리의 설치에 대한 내용이 남아 이렇게 적어본다.</p>

<h2 id="typebcrypt-가-뭐시여">@type/bcrypt 가 뭐시여..?</h2>
<p>MSA auth 구현을 하던 도중, 강사가 개발환경에서 좋다고 하여 설치를 했고, 그러나 개발환경..? 굳이 구분이 필요한가 라고 생각을 했었는데… 그게 아니었다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">@types/</code> 라이브러리들은 TypeScript 개발 환경에서 매우 중요한 역할을 합니다. 이 라이브러리들은 주로 <code class="language-plaintext highlighter-rouge">-D</code> 플래그(또는 <code class="language-plaintext highlighter-rouge">--save-dev</code>)를 사용하여 개발 의존성으로 설치됩니다. <em>- Claude 3.7</em></p>
</blockquote>

<p>해당 패키지들이 괜히 구분된게 아니라고, 실질적으로 나름의 역할하는 거였구나. 새삼 깨닫게 되었다. 😅</p>

<h3 id="types-라이브러리의-역할은">@types/ 라이브러리의 역할은</h3>

<ol>
  <li>
    <p><strong>타입 정의 제공</strong>: JavaScript로 작성된 라이브러리에 대한 TypeScript 타입 정의를 제공한다. JavaScript는 원래 타입이 없는 언어이기 때문에, TypeScript에서 이러한 라이브러리를 사용할 때 타입 정보가 필요하고 없을 경우 당연히 TypeConflict 로 고생할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 시 코드 자동완성과 IntelliSense</strong>: 개발 도구(VS Code 등)에서 코드 자동완성, 파라미터 힌트, 메서드 시그니처 등의 도움말을 제공한다. 따라서 편의성 향상에 매우 도움이 된다.</p>
  </li>
  <li>
    <p><strong>타입 체크</strong>: TypeScript 컴파일러가 코드의 타입 오류를 찾아내는 데 사용된다. 이는 런타임 전에 많은 버그를 발견하는 데 도움이 되어 안정성에 도움이 된다.</p>
  </li>
  <li>
    <p><strong>문서화</strong>: 라이브러리의 API가 어떻게 사용되어야 하는지에 대한 문서 역할도 한다. 타입 정의를 통해 함수의 매개변수, 반환 값 등의 정보를 확인할 수 있다.</p>
  </li>
</ol>

<h3 id="예시">예시</h3>

<p>예를 들어, Express.js를 TypeScript 프로젝트에서 사용하려면:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>express          <span class="c"># 실제 라이브러리 설치</span>
npm <span class="nb">install</span> <span class="nt">-D</span> @types/express <span class="c"># TypeScript 타입 정의 설치</span>
</code></pre></div></div>

<p>이렇게 하면 다음과 같은 TypeScript 코드를 작성할 수 있습니다:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">@types/express</code>는 <code class="language-plaintext highlighter-rouge">req</code>와 <code class="language-plaintext highlighter-rouge">res</code> 객체의 타입, 그리고 <code class="language-plaintext highlighter-rouge">express()</code> 함수의 반환 타입 등을 제공한다.</p>

<h2 id="알아둬야-하는-핵심-포인트">알아둬야 하는 핵심 포인트</h2>

<ol>
  <li>
    <p><strong>개발 의존성으로 설치할 것</strong>: <code class="language-plaintext highlighter-rouge">-D</code> 플래그를 사용하여 개발 의존성으로 설치하는 이유는 이 타입 정의가 런타임에 필요하지 않고 개발 및 컴파일 시에만 필요하기 때문.</p>
  </li>
  <li>
    <p><strong>라이브러리 버전 일치</strong>: <code class="language-plaintext highlighter-rouge">@types/</code> 패키지의 버전은 가능한 한 실제 라이브러리 버전과 일치해야 한다.</p>
  </li>
  <li>
    <p><strong>DefinitelyTyped</strong>: 대부분의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지는 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 프로젝트에서 관리됩니다. 이는 커뮤니티가 관리하는 타입 정의 저장소다.</p>
  </li>
  <li>
    <p><strong>내장 타입</strong>: 일부 라이브러리는 자체적으로 타입 정의를 포함하고 있어서 별도의 <code class="language-plaintext highlighter-rouge">@types/</code> 패키지가 필요하지 않기도 하다. 예를 들어, React 16.8 이후 버전은 자체 타입 정의를 포함하고 있다.</p>
  </li>
</ol>

<h2 id="yarn으로-types-패키지-설치하기">Yarn으로 @types/ 패키지 설치하기</h2>
<p>학습 시에는 pnpm 을 사용하였으나, 현재 회사의 의존성으로 yarn 을 사용 중이다. yarn 에선 다음과 같이 사용해서 type 을 다운받으면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 라이브러리 설치</span>
yarn add express

<span class="c"># 타입 정의를 개발 의존성으로 설치</span>
yarn add <span class="nt">--dev</span> @types/express
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 단축 </span>
yarn add <span class="nt">-D</span> @types/express
</code></pre></div></div>

<h2 id="yarn에서-packagejson-의존성-구분">Yarn에서 package.json 의존성 구분</h2>

<p>npm과 마찬가지로 Yarn도 <code class="language-plaintext highlighter-rouge">package.json</code> 파일에서 의존성을 다음과 같이 구분합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.1"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"devDependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"@types/express"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^4.17.13"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="타입-지원-여부-확인-방법">타입 지원 여부 확인 방법</h2>

<p>이렇듯 유용하기도 하고, 있는지 확인해 보면 좋은 <code class="language-plaintext highlighter-rouge">@type/~</code>는 각 라이브러리 마다 존재하는지 확인해서 필요시 설치하면 되고, 있는지 여부는 아래와 같은 방법을 활용하자.</p>

<ol>
  <li>패키지 설치 후 직접 확인</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 간단한 테스트 파일 작성</span>
<span class="k">import</span> <span class="o">*</span> <span class="kd">as </span><span class="kr">package</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">package-name</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>이 코드를 작성했을 때:</p>
<ul>
  <li>타입 오류가 없다면, 라이브러리가 이미 타입을 내장하고 있습니다.</li>
  <li>“Could not find a declaration file for module ‘package-name’” 오류가 발생한다면, 타입 정의가 없다고 보면 됨</li>
</ul>

<ol>
  <li>패키지 문서 확인</li>
</ol>

<p>대부분의 패키지는 README나 공식 문서에 TypeScript 지원 여부를 명시하니 확인 할 것</p>
<ul>
  <li>“Written in TypeScript” 또는 “TypeScript support included”와 같은 문구</li>
  <li>설치 안내에 <code class="language-plaintext highlighter-rouge">@types/package-name</code> 설치 지침이 포함되어 있는지 확인</li>
</ul>

<ol>
  <li>패키지 소스 확인</li>
</ol>

<p>패키지의 <code class="language-plaintext highlighter-rouge">package.json</code> 파일을 확인합니다:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"package-name"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"types"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">       </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typings"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="p">,</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="err">또는</span><span class="w">
  </span><span class="nl">"typescript"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"definition"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.d.ts"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ol>
  <li>NPM 페이지 확인</li>
</ol>

<p>NPM 웹사이트에서 패키지 페이지를 확인하세요. 패키지 파일 목록에 <code class="language-plaintext highlighter-rouge">.d.ts</code> 파일이 있으면 타입을 제공한다.</p>

<ol>
  <li>DefinitelyTyped 검색</li>
</ol>

<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped GitHub 저장소</a> 또는 <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a>에서 <code class="language-plaintext highlighter-rouge">@types/package-name</code>이 있는지 확인한다.</p>

<ol>
  <li>자동화된 도구 사용</li>
</ol>

<h4 id="typescript-auto-importer-확장-프로그램">TypeScript-Auto-Importer 확장 프로그램</h4>

<p>VS Code의 <code class="language-plaintext highlighter-rouge">TypeScript-Auto-Importer</code>와 같은 확장 프로그램은 사용 가능한 타입 정의를 자동으로 감지한다.</p>

<h4 id="npx-typescript-check-esm-사용"><code class="language-plaintext highlighter-rouge">npx typescript-check-esm</code> 사용</h4>

<p>이 도구는 프로젝트 의존성의 TypeScript 호환성을 검사한다.</p>

<h4 id="typed-npm-registry-사용"><code class="language-plaintext highlighter-rouge">typed-npm-registry</code> 사용</h4>

<p>이 웹사이트에서 패키지 이름을 검색하여 타입 지원 여부를 확인 가능: https://www.typedregistry.com/</p>

<h3 id="실용적인-워크플로우">실용적인 워크플로우</h3>

<ol>
  <li>먼저 기본 패키지만 설치 함: <code class="language-plaintext highlighter-rouge">yarn add package-name</code></li>
  <li>코드에서 임포트해보고 오류가 발생하는지 확인</li>
  <li>오류가 발생하면 <code class="language-plaintext highlighter-rouge">@types</code> 패키지 존재 여부를 확인:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn info @types/package-name
<span class="c"># 또는</span>
npm view @types/package-name
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@types</code> 패키지가 존재하면 설치: <code class="language-plaintext highlighter-rouge">yarn add -D @types/package-name</code></li>
</ol>

<h2 id="마치며">마치며</h2>
<p>확실히 사용해보니, 없을 때 보다 공식 설명이 더 풍부한 경우가 많고, 객체, 타입에 대한 설명이 상세 해지는 걸 보니, 개발 시 무언가 추가 시 신경 써서 넣어두거나, 기본적으로 갖춰 둔 템플릿을 활용하면 좋을 것 같다.</p>

<p>이런 거 보면 아직 짬이 덜 찬 느낌이 든다. 🫥</p>

<p>개발의 길은 멀고, 아주 멀고, 아주 멀다. 😖</p>]]></content><author><name>Paul2021-R</name></author><category term="Backend" /><category term="학습" /><category term="TypeScript" /><category term="Backend" /><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">클린 코드를 위한 룰</title><link href="http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming.html" rel="alternate" type="text/html" title="클린 코드를 위한 룰" /><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming</id><content type="html" xml:base="http://localhost:4000/%ED%95%99%EC%8A%B5/2025/04/27/golden-rule-for-programming.html"><![CDATA[<h2 id="-클린-코드-황금-6원칙-스터디-정리"><strong>🧠 클린 코드 황금 6원칙 스터디 정리</strong></h2>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0002.png" alt="" /></p>

<blockquote>
  <p>링크드인에서 개발과 관련한 이미지를 한 장봤다. 새롭게 개편한 블로그를 위한 글도 써야 하고, ‘오랜만에 정리 해 봐야겠구나’ 라는 생각이 들었다. 왜냐면 이제 개발을 시작한지 4년? 팀 개발을 해나가면 나갈 수록 더 중요한게 어디에 있는가에 대한 답변이 항상 거의 여기서 나오고 있다고 스스로도 느끼는데, 정작 정확하게 이해하고 있냐? 라고 하면 그렇지는 않다… 가 있기 때문이다. 🤔</p>
</blockquote>

<h3 id="1️⃣-soc-seperation-of-concerns--관심사는-분리해라">1️⃣ <strong>SOC (Seperation of Concerns) : 관심사는 분리해라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0003.png" alt="" />
어떤 비즈니스 로직을 구현 하는 과정에서, 다양한 것, 다양한 ‘관심’이 필요 시 된다. DTO로 들어오는 대상에 대해 무결성을 검증 해야 하고, 룰은 지켰으나 데이터는 온전한지도 확인 해야 하며,  그렇게 들어온 데이터는 비즈니스 로직이 정한 룰이나, 다양한 절차를 거쳐 결과적으로 요청을 한 클라이언트에게 전달되다.</p>

<p>따라서 다양한 요소들이나, 로직, 기능이 서로를 바라보게 될 수 밖에 없고, 보통 그런 구조가 설계되기 시작하면 거미줄처럼 얼키고 설켜 복잡한 형태를 이루게 된다.</p>

<p>문제는 그런 구조를 가지면 하나를 바꿔도 그 안에서 모든 것들이 영향을 미치게 되어 버린다는 점이다. 거기다 아무리 대단한 사람이 함께 참여하더라도 수천, 수만줄의 코드의 협업 속에서 그런 일이 일어난다면? 그걸 어떻게 발견하겠는가? 사소한 문제가 얼마나 커질 수 있는가를 여기서 알 수 있는 것이다. 물론, 이는 단적이고 극단적인 예시일 것이고 이 외에도 관심사의 혼재는 아주 큰 문제들을 많이 가진다.</p>

<p>따라서 많은 이들이 Seperation Of Concerns(관심사의 분리) 라는 가치를 이야기 하며, 이것이 필요한 이유를 크게 3가지 정도로 축약하여 이야기 한다.</p>

<ul>
  <li><strong>단일 책임 원칙을 지키기 위해</strong></li>
  <li><strong>유지 보수 과정에서 문제를 빠르게 좁혀야 한다.</strong></li>
  <li><strong>코드 재사용성을 극대화 하기 위해</strong></li>
</ul>

<p>예시를 그래도 간략하게 들어보자면… (feat. ChatGPT)</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Controller - 요청 처리만</span>
<span class="p">@</span><span class="nd">Post</span><span class="p">(</span><span class="dl">'</span><span class="s1">login</span><span class="dl">'</span><span class="p">)</span>
<span class="nf">login</span><span class="p">(@</span><span class="nd">Body</span><span class="p">()</span> <span class="nx">loginDto</span><span class="p">:</span> <span class="nx">LoginDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 여기서 무슨 일이 일어나든 </span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">login</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Service - 비즈니스 로직</span>
<span class="k">async</span> <span class="nf">login</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">:</span> <span class="nx">LoginDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">validateUser</span><span class="p">(</span><span class="nx">loginDto</span><span class="p">);</span>
  <span class="c1">// 여기서 무슨 일이 일어나든 로직은 구분되어 있다 </span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">authService</span><span class="p">.</span><span class="nf">issueToken</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2️⃣-dyc-document-your-code--코드를-문서화하라">2️⃣ <strong>DYC (Document Your Code) : 코드를 문서화하라</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0004.png" alt="" /></p>

<p>팀 플레이를 진행하던, 혼자서 코드를 짜던 한 가지 중요한 지점은 사람은 ‘컴퓨터’ 가 아니라는 점이다. 컴퓨터도 데이터를 소실되니 마니 하는 마당에, 사람의 머리가 알 수 있고 기억할 수 있는 용량은 반드시 한계가 있다. 작업을 하던 과정이 급하고, 촉박하거나 하지 않더라도 개발을 하다보면 시간이 지나면서  ‘뇌 내 풍화(?)’를 겪게 된다.</p>

<p>그럴 때면 드디어 객관적으로 내 코드를 볼 수 있게 되고, 그 코드를 보며 자괴감도 분노도, 실망도 느끼게 되는게 마치 인생같다는(?) 이상한 소리를 할 수 있다. 왜 이렇게 했더라, 이 부분이 왜 필요했지 등등.. 그러다 보면 몇 달만에 다시 보고, 그 부분을 수정해야 할 때 그저 쉽게 코드 몇줄 추가 했음에도 에러가 생기는 일 등… 다양한 방해물이 생기고 나면, 그제야 우리는 깨닫게 된다.</p>

<p>‘아 메모 해 둘걸’</p>

<p>하고 말이다.</p>

<p>문서화가 중요한 것은 다음과 같은 이유라고 보면 된다.</p>

<ul>
  <li><strong>협업자가 코드를 빠르게 이해할 수 있으려면 필요하다.</strong></li>
  <li><strong>시간이 지난 뒤 ‘나’의 이해를 돕기 위해 필요하다.</strong></li>
</ul>

<p>뭐 예시는 필요하진 않을 것이다. 심지어 요즘은 LLM 을 활용하여 자동 문서화도 기가 막히게 잘 되고 있으니, 이 부분은 확실하게 도입하고 습관을 들이는 것이 좋아 보인다.</p>

<p>Cursor를 활용해도 좋을 것이고 Vsc 에 Continue 를 활용해도 좋다고 느껴진다.</p>

<h3 id="3️⃣-dry-dont-repeat-yourself--중복을-피하라">3️⃣ <strong>DRY (Don’t Repeat Yourself) : 중복을 피하라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0005.png" alt="" />
이번에는 좀 극단적인 예시를 들어 보면 좋을 것 같다.</p>

<blockquote>
  <p>결제 로직을 만들게 되었다고 치자. 전처리 과정에서 데이터들에 대한 정리, 특히나 암호화된 데이터를 decode 해서 실제 결제 이벤트를 받아내야 한다. 그 뒤 자세한 로직들이 나온다. 그런데 작업을 하다보니 이 decode 의 과정이 코드가 너무 길어, 블록으로 떼어 내서 다시 메서드화 시키기 너무 귀찮다..!</p>

  <p>결제 이벤트는 총 4개. 마음은 아팠지만, 기간이 얼마 남지 않았다는 생각에 어쩔 수 없이 결단을 내려 ctrl + c를 4회 진행하게 되는데…</p>

  <p>몇 달이 흘러, 결제 개선이 가능한 시점이 되었다. 결제 이벤트 하나만 추가로 개선하면 되는 것이었음에도, 무언가 이상하다. 무엇이 문제 였을까?</p>
</blockquote>

<p>같은 코드가 같은 내용임에도 불구하고 다양한 로직에 사용되는 경우는 은근히 흔하게 있다. 암호화와 복호화 과정이라는 대표적인 예시도 있지만, 그 밖에도 처리해야 하는 데이터의 가공 영역은 특히나 그런 경우가 많다.</p>

<p>하지만 문제는 예를 들어 이럴 수 있다. A 라는 로직이 있고 이것이 4번 쓰였는데, A를 고친다는 생각에 A’를 만들었지만, 막상 내가 그때 A를 4번 복붙 해야 한다는 걸 까먹을 수도 있고 실제로 그런 경우로 사고가 나는 경우가 정말 많다.</p>

<p>따라서 꼭 기억할 것은 같은 코드, 같은 규칙이라면 하나를 작성하고 그것을 통해 항상 정확하게 처리하는 것이 필요하다. 이를 통해 버그 발생 확률을 낮추고, 수정과 리펙토링 과정을 쉽고 정확하게 만들어주며, 오히려 이런 설계가 되었을 때 향후 코드 확장성이 높아지는 것은 당연히 덤이니까.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이런 단순한 코드라도 만들어두면, 재사용할 때 검색 한번으로 찾아서 쓸 수 있고, </span>
<span class="c1">// 향후 조건이 여러개로 늘어나도 1번의 수정이면 끝난다</span>
<span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="4️⃣-kiss-keep-it-simple-stupid--단순하게-유지하라">4️⃣ <strong>KISS (Keep It Simple, Stupid) : 단순하게 유지하라</strong></h3>
<p><img src="/assets/images/posts/2025-04/2025-04-27-0007.png" alt="" /></p>

<p>백엔드 개발자로 입문하게 되어, 첫 해 작업을 할 때 항상 생각했던 것은, 단단한 구조, 안정적인 성능, 이를 위한 수학적이거나 계산적인 로직으로 단단한 기능으로 구현하는게 좋지 않을까! 라는 호기로움이었다.</p>

<p>하지만 6개월 정도 했었을까? 그런 코드가 ‘잘 동작’은 하지만 ‘쓸모 없다’ 는 것은 너무나 빨리 알게 된 사실이었다.</p>

<p>개발의 과정은 완벽이 없다. 기능은 그대로지만 방향성은 달라지게되고, 사업의 형태, 비즈니스의 방향성의 고려로 기능은 수시로 바뀔 수 있다.</p>

<p>뿐만 아니라 새로운 사람이 들어오거나, 코드를 만드는 입장과 리뷰, 관리 하는 입장이 다른 경우도 있다. 무엇이 되었든 그런 상황이 되면 우리는 코드를 봐야하고, 그 코드를 이해하고 문제가 없는지를 확인하는 작업들이 필요 시 된다.</p>

<p>그런데 여기서 나만 아는, 혹은 나 혼자 이해할만한 로직을 활용한다는 것은 심각한 비효율성을 낳는다.</p>

<p>리펙토링을 이후에 할 때도 어려워지고, 누군가 읽고 해석해서 향후 관리를 해 나가는 것도 어렵다. 특히나 디버깅이나 테스트 과정 역시 어려울 수 밖에 없는 경우가 많다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getUserStatus</span><span class="p">(</span><span class="nx">score</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">levels</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">bad</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">excellent</span><span class="dl">'</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">90</span><span class="p">];</span>

  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">thresholds</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">score</span> <span class="o">&gt;=</span> <span class="nx">thresholds</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">idx</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">levels</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>둘은 동일한 결과를 만든다. 사실, 의도만 이해할 수 있다면 아래의 코드는 비교가 많아질 때 O(log n)의 복잡도로 이진탐색을 진행하기에, chatGPT 도 ‘압도적으로’ 성능이 좋다고 말할 정도로 성능면에선 좋다.</p>

<p>하지만 만약 구조가 바뀌거나 조건이 바뀐다고 할 때, 그리고 이 코드를 처음 보고 이해해야 하는 사람 입장이라면? 이런 부분들이 지속적으로 나온다면? 내 고집으로 만들어서 넣어 두고 충격적인 결말을 마주하게 될 지도 모를 것이다.</p>
<h3 id="5️⃣-tdd-test-driven-development--테스트-주도-개발">5️⃣ <strong>TDD (Test Driven Development) : 테스트 주도 개발</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0006.png" alt="" /></p>

<p>TDD는 일종의 로망(?) 처럼 느껴지고, 마치 판타지 처럼 여겨지는 경우가 좀 있다. 현실에 적용하기엔 어렵고, 번거롭고, 복잡하다는 것.</p>

<p>이러한 점이, 거를 타선이 없다는 것은 격하게 공감한다(?)</p>

<p>하지만 생각을 조금만 바꿔봐도 요즘은 훨씬 TDD 를 구현하고 준비하는 것이 어렵지 않은 시대가 되었다. 예를 들어 refernece 로 쓰이는 DTO 를 설정하고, AI 를 활용하여 예시가 되는 에러 케이스를 만들고, 그 경우의 수에 맞춰 만들어 달라고 해줄 수 있다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0001.png" alt="" /></p>

<p>실패를 먼저 고려하고, 그에 대한 대응을 정리해둔다면 로직에서 핸들링할 에러를 빼먹지 않을 수 있으며, 훨씬 명확한 협업, 클라이언트를 배려한 협업이 가능하다는 점에서 반드시 100% 완벽한 TDD 가 아니더라도 충분히 LLM 을 활용한 효율적인 방법이 적용 가능한 것이다.</p>

<p>특히나, 이렇게 준비되고, 이에 대한 Jest 테스트 같은 것들이 준비 된다면? 아마 말 하지 않아도 알 것이다. <code class="language-plaintext highlighter-rouge">버그는 잡히며</code>, <code class="language-plaintext highlighter-rouge">리펙토링을 해도 문제 없는지를 거의 즉각적으로 알 수 있고</code>, 결정적으로 성능 향상과 같이 <code class="language-plaintext highlighter-rouge">지표가 필요한 영역의 기능</code>이라면 손쉽게 테스트를 통해 리펙토링 포인트를 파악할 수 있다.</p>

<h3 id="6️⃣-yagni-you-arent-gonna-need-it--필요할-때만-만들기">6️⃣ <strong>YAGNI (You Aren’t Gonna Need It) : 필요할 때만 만들기</strong></h3>

<p><img src="/assets/images/posts/2025-04/2025-04-27-0008.png" alt="" /></p>

<p>개발을 하는 것은 약간 장인정신(?)을 가지게 만든다. 내가 만드는 그것이 좀 더 멋지거나, 좀 더 성능이 좋거나, 뭐가 되었든 그 개발 분야가 뭐가 되었든 나름의 ‘미학’을 쫓는 것을 종종 보게 된다.</p>

<p>이것이 취미 일 땐 아름다울지 모른다.</p>

<p>취미 일 땐 입이 벌어지는 센스를 느낄 수 있는 것이 오히려 멋지고, 훌륭하며, 재미있다.</p>

<p>하지만 이것이 일이고, 비즈니스라면 말이 달라진다. 당장 필요한 기능, 시장이 원하는 기능, 괜찮은 아이디어를 빨리 구현하는 것이 이젠 너무 중요하고, 비즈니스에서 그 가치는 이미 십수년도 전, 아니 수백년 전부터 먼저 가져가는 사람이 임자였다.</p>

<p>개발 속도를 늦추는 오버 엔지니어링이 되어 버리게 된다면, 오히려 이후 유지 보수에도, 그리고 리소스의 낭비로 타이밍을 놓칠 수도 있다. 그리고 그것을 개발자도 경영자도, 상품을 소비할 소비자에게도 결코 좋을 리는 없다. 개발자는 회사 내지는 조직에서 함께 일하고 있고, 내가 맥을 쓰고, 커피를 마시면서, 일에 집중할 수 있게 해주는 건 내가 만든 그것을 쓰는 사람들의 돈으로 이루어진다는 사실을 잊고 살면, ‘잘 만들어도 욕을 먹는’ 케이스가 아주 드물지 않다는 것을 몸소 느낄 수 있을 것이다.</p>

<h2 id="-결론">📖 결론</h2>
<p>이 원치들에 대해 다양하게 적는건 시간 관계상 피하려고 한다. 이미 뭐 자료는 많으니… 😅</p>

<p>하지만 이 전체를 고민하고, 경험하고, 인정하게 되면 어느새 드는 하나의 생각은 다음처럼 정리 된다.</p>

<ul>
  <li>복잡한 시스템이 만들어지는 것을 막고</li>
  <li>코드를 읽기 쉽게 만들며</li>
  <li>유지 보수 가능하면서도</li>
  <li>팀 전체가 빠르게 개선할 수 있도록 하는 것.</li>
</ul>

<p>결국 이게 되면 그 어떤 소프트웨어도 유기적으로 살아 숨쉬듯 자기 복제와 자기 진화를 이루고, 목표 시 되는 프로덕트의 퀄리티를 맞추며, 인정받는 개인이자 팀이 될 수 있다.</p>

<p>오랜만에 링크드인에서 그저 짤로 본 것이지만, 정리를 하는 과정에서 CTO를 통해 얻어온 많은 경험들 그리고 백엔드 개발자로 1년 간 유지 보수, 코드를 짜오면서 얻은 많은 것들을 새삼 정리하는 감각을 느꼈다. 왜 실수가 많았고, 어디서 아쉬웠는지 새삼스럽게 느껴진 시간이었다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="etc" /><category term="cleanCode" /><category term="Programming" /><summary type="html"><![CDATA[🧠 클린 코드 황금 6원칙 스터디 정리]]></summary></entry><entry><title type="html">AI 로 어디까지 가능할까?</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game.html" rel="alternate" type="text/html" title="AI 로 어디까지 가능할까?" /><published>2025-04-12T00:00:00+00:00</published><updated>2025-04-12T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/12/ai-making-game.html"><![CDATA[<h2 id="ai-어디까지-가능할까-게임-만들-수-있을까">AI 어디까지 가능할까? 게임 만들 수 있을까?</h2>
<p>이런 영상을 보았다</p>

<p><a href="https://www.youtube.com/watch?v=NSXsTq6zg_s"><img src="https://img.youtube.com/vi/NSXsTq6zg_s/0.jpg" alt="5090사서..." /></a></p>

<p>엄밀히 말하면 5090을 가진 어마무시한 분의 이야기… 지금 살 수 있는 사람이 몇이나 될까하는 글카로 벤치에 AI까지 돌리는 내용인데.. 나에게는 다소 다르게 보였다.</p>

<h2 id="ai-로-어디까지-가능할까">AI 로 어디까지 가능할까?</h2>

<p>현재 stable diffusion 이나 Audacity + TortoiseTTS 등.. 오픈소스 AI 툴은 이미 성숙한 수준까지 올라온 상태이다.</p>

<p>뿐만 아니라 그러한 원초의 로우 툴에서 비롯되어, 웹 기반으로 서비스를 시작한 NovelAI, ComfyUI(이건 약간 중간 성격이긴 한데..), soundraw Ai 등… 이미 편리한 서비스들로 구체화 되었고, 좀더 알아보니 네이버나, 기타 굉장한 AI 스타트업들의 개발. 이제는 진짜 아무리 생각해도 AI가 핵심이고, 극강의 효율성이 필요하다는 점을 느낄 수 있었다. 이러한 점을 생각하니 이런 생각에 귀결 되었다.</p>

<blockquote>
  <p>이 정도면 혼자 게임도 만들 수 있지 않을까?</p>
</blockquote>

<p>게임, 게임성을 갖추는 것은 대단히 어렵고, 인간의 창조 영역에서도 특히나 혼자선 어려운 분야이다. 특히나 종합적인 컨텐츠로 연출, 그래픽스, 모션, 세부 분야로 파고 들면 생각보다 고려할 것들이 너무 많은 영역일 것이다.</p>

<p>하지만 생각해보면 꼭 종합적이어서 재밌거나 한건 아니다.</p>

<p>사람은 스토리를 먹고 사는 동물이다.</p>

<p>또한 사람은 본질적으로 <code class="language-plaintext highlighter-rouge">부족</code>할 때 비로소 <code class="language-plaintext highlighter-rouge">동기</code>를 얻는다.</p>

<p>그런 점이 가장 극대화 되는 장르들이 보통 퍼즐이나 비주얼 노벨류. 그리고 놀랍게도 현재 모바일 시장에서 여전히 흥행 강세이고, 수명이 유지되는 게임들도 결국 그런 부분에서 받춰져서 팬덤이 형성된 류가 꽤나 있다는 것을 알 수 있다.</p>

<p><img src="https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/2396980/capsule_616x353.jpg?t=1726036301" alt="" />
페이트 스테이 나이트는 내 시절 최고의 판타지 물이었고</p>

<p><img src="https://i.namu.wiki/i/ES0zVAPjU7o89_R-0Hywfus4caJ9LYFpF2zqLHQ0YTUuakUNw5LRY-MFHKKZmxoMiMdzor32OJc3moeQkySnCA.webp" alt="" />
그에 이어 나온 페이트 그랜드 오더는 소니를 먹여살리는 일등 공신 중 하나로 현재 수년째 그 인기를 이어가고 있는 프랜차이즈가 되었으며,</p>

<p><img src="https://i.namu.wiki/i/pvrIEFOSpzhHxbnEqMMSViO9_BnBoaHZs9hMbO32P27hV7hOv14nEQbJpPr3wpYelqgFxqk78z7C2dyPa2NeBg.webp" alt="" />
국내 성공작으로 게임성에선 뭐라고 욕을 먹어도 스토리에서 성공적인 블루 아카이브,</p>

<p><img src="https://cdn.getnews.co.kr/news/photo/202405/676535_395705_4552.png" alt="" />
빵댕이 게임이라고 하지만, 팬들에겐 그 이상이라는 평을 받는 니케</p>

<p>이런 류들이 런칭 이후 지속적인 사랑을 받고, 그 지속적인 사랑으로 얻은 캐시카우가 새로운 능력이나 도전을 이뤄내는 것을 생각해본다면… 과연 AI 를 활용하고, 핵심이 되는 부분 비주얼과 스토리에 대해서만 얼마나 좋은 스토리, 좋은 내용을 양질로 끌고 오냐만 결정 난다면 이건 굉장한 One Man Army 로 뭔가를 할 수 있는 게 아닐까?</p>

<h2 id="필요한-도구들은-뭐가-있을까">필요한 도구들은 뭐가 있을까?</h2>
<p>지금까지 확인 해보았을 때, 필요한 영역은 다음과 같다.</p>

<h3 id="게임의-툴-">게임의 툴 :</h3>
<p>게임의 툴로는 렌파이, Game Maker, Unity 를 생각해볼 수 있다. 툴의 난이도는 Unity 쪽이 가장 어렵지만, 활용성이나 장기적으론 Unity 가 가장 우수하다. 하지만 렌파이나 Game Maker는 쉽고, 오픈소스라는 가장 큰 장점을 갖고 있다.</p>

<p>비용의 처리나, 복잡성, 간단함을 승부로 할 것이라면 개인적으론 GameMaker 가 가장 현실적인 중간 답안이 아닐까? 다른 엔진도 여럿 추천 받았지만, 결국 2D 게임을 만든다고 할 때, 가장 적절한 수준은 어디인가에서 다플랫폼을 지원하고, 커뮤니티 수준등을 보면 결국 GameMaker로 갈 수 밖에 없을 것 같다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0003.png" alt="" /></p>

<p>거기다 이젠 영어만 있는 것들이 못 쓸 정도가 아니라는 점을 너무나 잘 알고 있다.</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0004.png" alt="" /></p>

<p>노트북LM 을 활용하여, 영어로 된 튜토리얼을 넣고, 학습 시켜 배워야할 영역만 체크하고, 영상도 볼 필요 없이 튜토리얼 대로 만든다… 진짜 지금 내가 사는 시대는 아무리 생각해도 말이 안된다(…)</p>

<h3 id="그림-">그림 :</h3>
<p>위에서도 언급한 Raw 한 툴을 활용하는 것도 가능하고, 거기서 좀더 개선된 것들이나 플러그인 등도 있다. 만약 쓰게 된다면 Stable Diffusion 을 사용할 것 같은데, 이는 오픈소스로 개방된 모델들을 활용할 수 있고, 무엇보다 오픈소스라는 점이 가장 중요하기 때문이다. 현재 끌리는 건 미드저니, NovelAI 와 같이 이미 좀더 편리하게 쓰도록 구성된 것들이 있는 것은 사실이지만, 혼자서 할 수 있는가? 로컬에서 이용 가능한가? 라는 점에서 테스트먼트를 한다면 stable diffusion을 우선 써보는게 낫다는 생각이 든다.</p>

<p>다만, 이걸 위해서 필요한 것은 역시 무드, 그리고 캐릭터를 별도로 가져갈 수 있냐는 점. 이 부분은 stable diffusion을 제대로 설치하여 사용해봐야 알 수 있을 것으로 보인다. 아직 아무것도 안하고 써보는 것이다보니(도커에 설치만 해봄 ㅋㅋ..) 뭐라고 이렇다 말하긴 애매하다.</p>

<p>한가지 현재 상황에서 대단히 중요한 부분은 과연 상용으로 쓸 수 있는가? 에 대한 부분이리라 생각된다. 상용 라이센스를 가지는 것들로만 구성을 해야 하므로, 이에 대한 고민 연구가 필요하며 법적인 부분에 대한 조언은 받아봄직 하긴 하다.</p>

<p>어쨌든, 이러라고 산 4080super 가 제 역할을 다해주길 기대한다…(<del>3년 내에 2천은 벌어야 한다…</del>)</p>

<h3 id="bgm--효과음-">BGM / 효과음 :</h3>
<p>사실 AI 가 거의 필요없다고 생각한다. 이런건 무료 에셋으로 가보자.</p>

<h3 id="음성-">음성 :</h3>
<p>이게 가장 큰 문제일 수 있을 것 같다. 비주얼 노벨에서 성우는 생각보다 중요하고, 현재 리메이크된 유명 게임들도 인게임 보이스를 넣어서 리메이크 하는 걸 보면, 확실하 예전 감성으로만 접근할 수 없긴 하다. 그래서 찾아보니…</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0001.png" alt="" /></p>

<p>세상에… AI 는 이미 여기도 이미 해결이 되어 있었다.</p>

<p>그 와중에 개인적으로 사용해본 결과 굉장히 독보적인 곳을 발견했는데, 그곳이 바로 이곳</p>

<p><img src="/assets/images/posts/2025-04/2025-04-13-0002.png" alt="" /></p>

<p>SUPERTONE 이라는 곳으로, 목소리 수준이나, 비용, 어떤 면에서도 로컬보단 월등히 낫다는 생각이 들었다. 특히 한국어 성우 학습이 정말 괜찮다.</p>

<h2 id="일단-해보자">일단 해보자</h2>
<p><img src="https://i.namu.wiki/i/H0zMZ4htL9ypyfJ0LXQrcTcC6f7dZBBh1KedrpMXNnEiXaAIzyBTAOgFReXNwgw6JWjtlr4Agc6_kEMckjFUeLQpFzEJiCxurXkxzaA3azZbR_6oMHND5511MI4fQyhP9BcG1zVgKX7GrKgka6uT1A.webp" alt="" /></p>

<p>AI 를 공부하고, 개발자로 뭔가 해보려고 하였다. 개발을 배우는 것도 중요하고 그래서 현재 회사에서 나름데로 정말 노력에 노력을 더하고 있지만, 취미로 무언가 만들기 위해선 역시 재미가 필요하다. 그리고 필요한 건 ‘가볍지만 제대로’ 할 수 있는 도구 들.</p>

<p>어차피 배워 나가고 살아 나가다보니 친구도 없고, 시간은 많다.</p>

<p>내가 좋아하는 건 판타지와 SF, 그리고 씹덕.</p>

<p>개발자로 이것저것 배운 것들이 접목될 수 있는데, 심지어 팀이 아니어도 할 수 있다? 지금 나에게 필요한건 어쩌면 이런 도전을 해보는게 아닐까 싶다.</p>

<p>가즈아.</p>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><category term="게임" /><summary type="html"><![CDATA[AI 어디까지 가능할까? 게임 만들 수 있을까? 이런 영상을 보았다]]></summary></entry><entry><title type="html">기술 블로그를 다시 시작하면서</title><link href="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start.html" rel="alternate" type="text/html" title="기술 블로그를 다시 시작하면서" /><published>2025-04-07T00:00:00+00:00</published><updated>2025-04-07T00:00:00+00:00</updated><id>http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start</id><content type="html" xml:base="http://localhost:4000/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/2025/04/07/new-start.html"><![CDATA[<h2 id="기술-블로그를-개편하면서">기술 블로그를 개편하면서</h2>
<p>기존의 개발자가 되기 전의 블로그를 써보겠다고 나름 노력했습니다. 
아카이브란 이름을 걸고, 기술 블로그를 만드는데 이것 저것 노력해봤던 그 흔적들.</p>

<p>하지만 취업을 하고나서 보니 부족한 것도 많고, 아쉬운 점도 많았습니다.
원래는 원대한 계획을 세우고, 직접 만들어보겠다! 이런 마인드도 있었지만…</p>

<p>일은 정신 없고, 내가 배우고 즐거워하는 것들을 씹어 삼키는 것만으로도 바쁘다 보니,
개인적인 일까지 겹치며서 시간을 확보하기는 커녕 하루 살아 하루 회복하는 일상…. 😫</p>

<p>하지만 조금 천천히 갈 순 있어도 멈추기는 싫었기에, 쇠뿔도 당긴 김에 빼라는 말 처럼 전체를 정리하고 다시 시작할 공간으로 정리를 단행했습니다.
(<del>정리라는 이름의 강제 초기화</del>)</p>

<p>기존의 글들도 다시 정리하여 마이그레이션을 할 것이고, 새롭게 배우던 것들도 좀더 깔끔하게, 좀더 쉽게 정리하는게 핵심입니다. 
그리고 이렇게 글로 내 생각을, 내 삶을 남겨, 나라는 존재의 능력치도, 동시에 내 가치도 함께 성장시키는 것이 이 공간에서 시작하려 합니다.</p>

<h2 id="앞으로">앞으로</h2>
<p>AI의 발전은 하루 걸러 하루 달라지고, 새로워지고, 진보합니다. 
백엔드적 경험은 무언가 하나 만들 때마다 성장을 하는 듯 하지만, 부족함을 놓치는 것들이 끊임없이 나오고 그것들을 못 챙겼다는 것은 상당한 아쉬움으로 남습니다.</p>

<p>그렇기에 목표는 명확합니다.</p>

<p>AI 는 아직 ‘따라잡을’ 수는 없어도, 따라가려고 노력은 할 것이며,</p>

<p>배운 것들 중 괜찮은 것들을 정리하여 이곳에 적고, 특히나 그것이 남들이 읽기 좋은 글의 형태로 남기려고 합니다.</p>

<p>이유는 간단합니다. 
쉬운 글로 남기려고 노력할 때, 비로소 어려운 것을 나 스스로도 이해하고, 동시에 누군가에게도 도움이 될 수도 있기 때문입니다. 
생각해보면 그 주제가 결국 개발이라는 점에서 차이가 있는 것은 아닌가- 라는 것도 한 편으로 생각해볼 지점이겠지만… 😂</p>]]></content><author><name>Paul2021-R</name></author><category term="생각정리" /><category term="etc" /><category term="생각정리" /><summary type="html"><![CDATA[기술 블로그를 개편하면서 기존의 개발자가 되기 전의 블로그를 써보겠다고 나름 노력했습니다. 아카이브란 이름을 걸고, 기술 블로그를 만드는데 이것 저것 노력해봤던 그 흔적들.]]></summary></entry></feed>