<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-10-20T12:32:34+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">TIL - HTTPS 적용 및 갱신 구조 적용하기(Nginx, NextJS)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/20/til-devops.html" rel="alternate" type="text/html" title="TIL - HTTPS 적용 및 갱신 구조 적용하기(Nginx, NextJS)" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-10-20T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/20/til-devops</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/20/til-devops.html"><![CDATA[<h2 id="2025년-10월-20일-docker-compose와-nginx-환경에-lets-encrypt-certbot로-https-적용-및-자동-갱신-설정">2025년 10월 20일: Docker Compose와 Nginx 환경에 Let’s Encrypt (Certbot)로 HTTPS 적용 및 자동 갱신 설정</h2>

<h3 id="요약">요약</h3>

<p>기존에 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>로 관리하던 Nginx 리버스 프록시와 Next.js (Blue/Green) 환경에, Let’s Encrypt의 Certbot을 도입하여 HTTPS를 적용했다. 이 과정에서 포트포워딩, Nginx 설정 충돌, 도메인 CAA 정책 등 다양한 문제를 마주쳤으며, 이를 해결한 뒤 최종적으로 호스트 서버의 <code class="language-plaintext highlighter-rouge">Crontab</code>을 이용해 인증서 자동 갱신 스크립트까지 설정하여 전체 배포 아키텍처를 완성했다.</p>

<hr />

<h3 id="1-최종-목표">1. 최종 목표</h3>

<p>Nginx 리버스 프록시에 SSL을 적용하여 <code class="language-plaintext highlighter-rouge">http://</code> 요청을 <code class="language-plaintext highlighter-rouge">https://</code>로 강제 리디렉션하고, 443 포트를 통해 암호화된 트래픽을 처리한다. 인증서는 무료 발급 기관인 Let’s Encrypt를 사용하며, 발급 및 갱신은 Certbot을 통해 자동화한다.</p>

<p><strong>사용한 핵심 기술:</strong></p>
<ul>
  <li>Docker Compose</li>
  <li>Nginx (Reverse Proxy)</li>
  <li>Certbot (Let’s Encrypt Client)</li>
  <li><code class="language-plaintext highlighter-rouge">webroot</code> (HTTP-01) 인증 방식</li>
</ul>

<hr />

<h3 id="2-https-적용-절차">2. HTTPS 적용 절차</h3>

<p>HTTPS 적용은 ‘최초 발급’과 ‘최종 적용’의 두 단계로 나누어 진행했다.</p>

<h4 id="1단계-certbot-서비스-및-볼륨-정의">1단계: Certbot 서비스 및 볼륨 정의</h4>

<p><code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일에 <code class="language-plaintext highlighter-rouge">certbot</code> 서비스를 추가하고, Nginx와 Certbot이 인증서 및 인증용 파일을 공유할 수 있도록 2개의 볼륨을 마운트했다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">./nginx/certs:/etc/letsencrypt</code>: 발급된 인증서가 저장될 경로</li>
  <li><code class="language-plaintext highlighter-rouge">./nginx/www:/var/www/certbot</code>: Certbot이 <code class="language-plaintext highlighter-rouge">webroot</code> 인증을 위해 임시 파일을 생성할 경로</li>
</ul>

<p>또한 Nginx 서비스의 <code class="language-plaintext highlighter-rouge">ports</code>에 <code class="language-plaintext highlighter-rouge">"443:443"</code>을 추가했다.</p>

<h4 id="2단계-nginx-임시-설정-인증서-발급용">2단계: Nginx 임시 설정 (인증서 발급용)</h4>

<p><code class="language-plaintext highlighter-rouge">webroot</code> 방식은 80번 포트의 특정 경로(<code class="language-plaintext highlighter-rouge">/.well-known/acme-challenge/</code>)로 HTTP 요청이 들어왔을 때, Certbot이 생성한 파일을 Nginx가 서빙할 수 있어야 한다.
이를 위해 <code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>를 80번 포트만 리스닝하고, 해당 경로의 요청만 처리하는 임시 파일로 수정했다.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nginx.conf (임시 인증용)</span>
<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">paulryu9309.ddns.net</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">return</span> <span class="mi">404</span><span class="p">;</span> <span class="c1"># 나머지 요청은 404 처리</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3단계-certbot-최초-발급-실행">3단계: Certbot 최초 발급 실행</h4>

<p>Nginx를 임시 설정으로 실행한 뒤(<code class="language-plaintext highlighter-rouge">docker compose up -d nginx</code>), <code class="language-plaintext highlighter-rouge">docker compose run</code> 명령어로 Certbot 컨테이너를 일회성 실행했다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose run <span class="nt">--rm</span> certbot certonly <span class="nt">--webroot</span> <span class="nt">-w</span> /var/www/certbot <span class="nt">-d</span> paulryu9309.ddns.net <span class="nt">--email</span> <span class="o">[</span>이메일] <span class="nt">--agree-tos</span> <span class="nt">--no-eff-email</span>
</code></pre></div></div>

<h4 id="4단계-nginx-최종-설정-https-적용">4단계: Nginx 최종 설정 (HTTPS 적용)</h4>

<p>인증서 발급이 성공한 후, <code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>를 <code class="language-plaintext highlighter-rouge">upstream</code>을 포함한 최종 버전으로 다시 수정했다.</p>

<p><strong>핵심 내용:</strong></p>
<ol>
  <li><strong>HTTP (80) 서버</strong>: <code class="language-plaintext highlighter-rouge">/.well-known/</code> 경로는 갱신을 위해 남겨두고, 나머지 모든 요청(<code class="language-plaintext highlighter-rouge">location /</code>)은 <code class="language-plaintext highlighter-rouge">https://</code> (443 포트)로 301 리디렉션.</li>
  <li><strong>HTTPS (443) 서버</strong>: <code class="language-plaintext highlighter-rouge">listen 443 ssl;</code>을 활성화하고, <code class="language-plaintext highlighter-rouge">ssl_certificate</code>와 <code class="language-plaintext highlighter-rouge">ssl_certificate_key</code> 경로에 1단계에서 공유한 볼륨의 인증서 경로(<code class="language-plaintext highlighter-rouge">.../live/paulryu9309.ddns.net/...</code>)를 지정. <code class="language-plaintext highlighter-rouge">location /</code>에는 <code class="language-plaintext highlighter-rouge">proxy_pass http://nextjs_app;</code>을 설정.</li>
</ol>

<h4 id="5단계-전체-시스템-재시작">5단계: 전체 시스템 재시작</h4>
<p>최종 설정이 적용된 <code class="language-plaintext highlighter-rouge">docker compose up -d</code> 명령으로 전체 시스템을 실행하여 <code class="language-plaintext highlighter-rouge">https://paulryu9309.ddns.net</code> 접속 및 자물쇠(🔒) 아이콘을 확인했다.</p>

<hr />

<h3 id="3-문제-해결-과정-troubleshooting-battle">3. 문제 해결 과정 (Troubleshooting “Battle”)</h3>
<p>HTTPS를 적용하는 과정은 순탄하지 않았으며, 여러 에러를 단계적으로 해결해야 했다.</p>

<h4 id="문제-1-connection-refused-연결-거부">문제 1: <code class="language-plaintext highlighter-rouge">Connection refused</code> (연결 거부)</h4>
<ul>
  <li><strong>증상</strong>: Certbot이 80번 포트로 접속을 시도했으나 연결이 거부됨.</li>
  <li><strong>원인</strong>: 로컬 환경에서 테스트 하는 것으로 가능하다고 생각했음. 원격 서버에 수동 배포 및 공유기의 <strong>포트포워딩</strong> 설정이 누락되어 있었다.</li>
  <li><strong>해결</strong>: 수동 배포하여 초기 구동 및 80포트 접속 가능 여부 확인함. iptime 관리자 페이지에서 외부 80 포트를 Docker가 실행 중인 서버의 내부 IP 80 포트로 포트포워딩 설정하여 해결.</li>
</ul>

<h4 id="문제-2-404-not-found-파일-없음">문제 2: <code class="language-plaintext highlighter-rouge">404 Not Found</code> (파일 없음)</h4>
<ul>
  <li><strong>증상</strong>: <code class="language-plaintext highlighter-rouge">Connection refused</code> 해결 후, Certbot이 인증 파일을 찾을 수 없다고 응답.</li>
  <li><strong>원인</strong>: <code class="language-plaintext highlighter-rouge">docker compose restart nginx</code>를 했음에도, Nginx가 임시 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 설정을 제대로 불러오지 못함. <code class="language-plaintext highlighter-rouge">/.well-known/</code> location이 아닌 <code class="language-plaintext highlighter-rouge">location / { return 404; }</code>가 모든 요청을 처리함. 확인 결과 nginx.conf 파일의 주소 경로 오타 + 이미 설정 된 레이어가 에러를 일으킴.</li>
  <li><strong>해결</strong>: 오타 수정 후 <code class="language-plaintext highlighter-rouge">docker compose down --rmi all</code> 후 <code class="language-plaintext highlighter-rouge">up -d nginx</code>로 컨테이너를 완전히 다시 생성하여 임시 설정을 강제로 적용.</li>
</ul>

<h4 id="문제-3-nginx-컨테이너-무한-재시작">문제 3: Nginx 컨테이너 무한 재시작</h4>

<ul>
  <li><strong>증상</strong>: Nginx 컨테이너가 <code class="language-plaintext highlighter-rouge">restarting</code> 상태를 반복.</li>
  <li><strong>원인</strong>: <code class="language-plaintext highlighter-rouge">docker logs project-mini-nginx</code>로 로그 확인 결과, <code class="language-plaintext highlighter-rouge">nginx.conf</code>의 문법 오류(<code class="language-plaintext highlighter-rouge">[emerg]</code>). 임시 설정 파일임에도 불구하고 <code class="language-plaintext highlighter-rouge">upstream nextjs_app { ... }</code> 블록을 삭제하지 않아 발생한 오류였다.</li>
  <li><strong>해결</strong>: 임시 <code class="language-plaintext highlighter-rouge">nginx.conf</code>에서 <code class="language-plaintext highlighter-rouge">upstream</code> 블록을 제거하여 문법 오류 해결.</li>
</ul>

<h4 id="문제-4-type-caa-caa-레코드-문제">문제 4: <code class="language-plaintext highlighter-rouge">Type: caa</code> (CAA 레코드 문제)</h4>

<ul>
  <li><strong>증상</strong>: 모든 설정이 완벽했음에도 <code class="language-plaintext highlighter-rouge">CAA record for iptime.org prevents issuance</code> 에러 발생.</li>
  <li><strong>원인</strong>: 사용 중이던 <code class="language-plaintext highlighter-rouge">iptime.org</code> DDNS의 상위 도메인 정책(CAA 레코드)이 Let’s Encrypt 기관의 인증서 발급을 허용하지 않음.</li>
  <li><strong>해결</strong>: <code class="language-plaintext highlighter-rouge">iptime.org</code> DDNS 사용을 포기하고, CAA 레코드 제한이 없는 <strong>No-IP</strong> DDNS (<code class="language-plaintext highlighter-rouge">paulryu9309.ddns.net</code>)로 교체하여 즉시 해결.</li>
</ul>

<h4 id="문제-5-duplicate-upstream-nextjs_app-upstream-중복">문제 5: <code class="language-plaintext highlighter-rouge">duplicate upstream "nextjs_app"</code> (Upstream 중복)</h4>

<ul>
  <li><strong>증상</strong>: 최종 HTTPS 설정 적용 후 Nginx가 다시 무한 재시작.</li>
  <li><strong>원인</strong>: <code class="language-plaintext highlighter-rouge">docker logs</code> 확인 결과, <code class="language-plaintext highlighter-rouge">upstream</code> 정의가 중복되었다고 나옴.
    <ol>
      <li><code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>: <code class="language-plaintext highlighter-rouge">COPY nginx.conf ...</code>로 이미지 빌드 시점에 설정 파일이 복사되어 컨테이너 내부로 들어감.</li>
      <li>docker-compose.yml: volumes: - ./nginx.conf:…로 컨테이너 실행 시점에 설정 파일이 또 마운트됨.</li>
      <li>결론 적으로 Nginx가 설정 폴더 내의 두 파일을 모두 읽어 충돌 발생</li>
    </ol>
  </li>
  <li><strong>해결</strong>: <code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>의 <code class="language-plaintext highlighter-rouge">COPY</code> 라인을 삭제하고, <code class="language-plaintext highlighter-rouge">docker compose</code>의 <strong>볼륨 마운트 방식만 사용</strong>하여 설정 파일을 관리하도록 통일. <code class="language-plaintext highlighter-rouge">docker compose build --no-cache nginx</code>로 이미지를 재생성하여 해결.</li>
</ul>

<hr />

<h3 id="4-인증서-자동-갱신-설정">4. 인증서 자동 갱신 설정</h3>

<p>Let’s Encrypt 인증서는 90일마다 만료되므로, 호스트 서버의 <code class="language-plaintext highlighter-rouge">Crontab</code>을 이용해 자동 갱신을 설정했다.</p>
<ol>
  <li>갱신 스크립트 (renew-ssl.sh) 생성:
 프로젝트 루트 폴더로 cd 한 뒤, docker compose run으로 Certbot 갱신을 시도하고, docker compose exec로 Nginx를 리로드하는 쉘 스크립트를 작성했다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/sh</span>
 <span class="nb">cd</span> /home/hansol/workspace/project-mini-frontend/ <span class="c"># 실제 경로</span>
 docker compose run <span class="nt">--rm</span> certbot renew
 docker compose <span class="nb">exec </span>nginx nginx <span class="nt">-s</span> reload
</code></pre></div>    </div>
  </li>
  <li>
    <p>실행 권한 부여:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">chmod</span> +x /home/hansol/workspace/project-mini-frontend/renew-ssl.sh
</code></pre></div>    </div>
  </li>
  <li>
    <p>Crontab 등록:</p>

    <p>crontab -e 명령어로 편집기를 열고, 매일 새벽 3시 30분에 스크립트를 실행하도록 등록했다.</p>

    <div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">30</span> <span class="m">3</span> * * * <span class="sr">/home/</span>hansol<span class="sr">/workspace/</span>project<span class="p">-</span>mini<span class="p">-</span>frontend/renew<span class="p">-</span><span class="nb">ssl</span><span class="p">.</span><span class="k">sh</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="5-배운-점">5. 배운 점</h3>

<ul>
  <li>Dockerfile의 <code class="language-plaintext highlighter-rouge">COPY</code>는 빌드 시점(Build-time)에, Docker Compose의 <code class="language-plaintext highlighter-rouge">volumes</code>는 실행 시점(Run-time)에 작동한다. 설정 파일처럼 자주 바뀌는 것은 <code class="language-plaintext highlighter-rouge">volumes</code>로 마운트하는 것이 이미지 재빌드 없이 유연하게 대처할 수 있다.</li>
  <li>에러 로그를 읽는 것이 문제 해결의 90%이다. <code class="language-plaintext highlighter-rouge">docker logs [컨테이너]</code>는 항상 가장 먼저 확인해야 할 정보다.</li>
  <li>Let’s Encrypt의 <code class="language-plaintext highlighter-rouge">webroot</code> 방식은 80번 포트가 외부 인터넷에 반드시 열려있어야 한다. 공유기 환경에서는 포트포워딩이 필수이다.</li>
  <li>도메인의 CAA 레코드는 내가 제어할 수 없는 상위 정책일 수 있다. DDNS 사용 시 서비스 제공자의 정책을 확인해야 한다.</li>
  <li>Nginx 설정 문법이 틀리면 Nginx는 아예 시작조차 하지 않는다. <code class="language-plaintext highlighter-rouge">docker compose run --rm nginx nginx -t</code> 명령어로 문법을 미리 테스트해볼 수 있다.</li>
</ul>

<hr />

<h3 id="6-코드레빗-지적-사항-학습-및-개선">6. 코드레빗 지적 사항 학습 및 개선</h3>

<p>PR 을 통해 머지 전, 발생한 Major 이슈로 문제가 되는 부분이 뭔지, 그리고 그 부분의 문제 개선 내용을 요약해두었다.</p>

<h4 id="certbot-네트워크-설정-없음docker-composeyml">Certbot 네트워크 설정 없음(Docker-Compose.yml)</h4>
<p><img src="/assets/images/posts/2025-10/2025-10-20-046.png" alt="" /></p>
<ul>
  <li>개요 : 기본적으로 현재 방식은 공유 볼룸을 기반으로 <code class="language-plaintext highlighter-rouge">weebroot</code> 방식은 공유 되는 파일을 주고 받아, 컨테이너들 사이의 네트워크, 특히나 도커 네트워크 기반으로 설정할 필요가 없음. 그러나 AI 의 지적은 몇가지 타당성이 있기 때문에 문제시 될 수 있다.
    <ol>
      <li>구성의 일관성 및 명확성</li>
      <li>docker compose run 동작 시 연결되는 네트워크 : 현재 프로젝트의 <code class="language-plaintext highlighter-rouge">project-mini-network</code>에 접속하여 연결되는 구조가 성립되어 있으나, 이러한 설정이 없으면 아무래도 기본 네트워크에 연결이 되며, 이 점은 비일관적이고 오작동을 유발 할 수도 있다.</li>
      <li>향후 확장성 : 현재는 심플한 webroot 방식이지만 nginx의 플러그인을 활용한다면, certbot 이 nginx 컨테이너에 직접 연결될수도 있음. 그렇다면 누락시켜서 문제시 되는 거 보다 일단 네트워크는 사용하지 않더라도 연결해두는게 낫다.</li>
    </ol>
  </li>
  <li>결정 : 일관성과 향후를 위해 간단하게 네트워크 통일</li>
</ul>

<h4 id="ssltls-보안-설정-부족">SSL/TLS 보안 설정 부족</h4>
<ul>
  <li>기본 설정 만으론 보안 표준 충족 안됨 TLS 프로토콜에 대한 버전 제안, 암호화 스위트, 기타 보안 헤더 설정이 필요
    <ol>
      <li><strong><code class="language-plaintext highlighter-rouge">ssl_protocols TLSv1.2 TLSv1.3;</code></strong></li>
    </ol>
    <ul>
      <li><strong>설명:</strong> Nginx 서버가 허용할 TLS 프로토콜 버전을 명시적으로 지정한다.</li>
      <li><strong>이유:</strong> <code class="language-plaintext highlighter-rouge">TLSv1.0</code>과 <code class="language-plaintext highlighter-rouge">TLSv1.1</code> 버전은 POODLE, BEAST와 같은 심각한 보안 취약점이 발견되어 사용이 권장되지 않음. 이 설정을 통해 <strong>안전하다고 검증된 <code class="language-plaintext highlighter-rouge">TLSv1.2</code>와 최신 버전인 <code class="language-plaintext highlighter-rouge">TLSv1.3</code>만</strong> 허용하여 하위 버전의 취약점을 원천적으로 차단하는 역할을 함.</li>
    </ul>
  </li>
</ul>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_prefer_server_ciphers on;</code></strong>
    <ul>
      <li><strong>설명:</strong> SSL/TLS 연결 협상 시, 클라이언트(브라우저)가 제안하는 암호화 스위트 목록과 서버가 제안하는 목록 중 <strong>서버(Nginx)의 목록을 우선</strong>하도록 설정한다.</li>
      <li><strong>이유:</strong> 서버는 관리자가 의도한 강력한 암호화 방식(아래 <code class="language-plaintext highlighter-rouge">ssl_ciphers</code>에서 설정)을 사용하도록 구성되어 있음. 만약 클라이언트가 약한 암호화 방식을 우선적으로 제안하더라도, 이 옵션을 켜두면 서버가 선택한 가장 강력한 방식을 강제할 수 있다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_ciphers '...';</code></strong>
    <ul>
      <li><strong>설명:</strong> 서버가 허용할 <strong>암호화 스위트(Cipher Suites)의 목록</strong>을 강력한 순서대로 지정한다. 제안된 목록(<code class="language-plaintext highlighter-rouge">ECDHE-ECDSA-AES128-GCM-SHA256</code> 등)은 모두 강력한 보안을 제공하는 최신 알고리즘으로 설정하는 역할을 함.</li>
      <li><strong>이유:</strong> 이 목록은 특히 <strong>PFS(Perfect Forward Secrecy)</strong> 를 지원하는 <code class="language-plaintext highlighter-rouge">ECDHE</code> 계열의 암호화를 우선한다. PFS는 만약 서버의 개인 키가 미래에 유출되더라도, 과거에 이 키로 암호화되어 저장된 트래픽(통신 내용)을 해독할 수 없도록 보장하는 매우 중요한 보안 기능이다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_session_cache shared:SSL:10m;</code></strong>
    <ul>
      <li><strong>설명:</strong> SSL 세션 정보를 서버 메모리에 캐시할 공간을 설정한다. <code class="language-plaintext highlighter-rouge">shared:SSL:10m</code>은 모든 Nginx 워커 프로세스가 공유하는 <code class="language-plaintext highlighter-rouge">SSL</code>이라는 이름의 10MB 캐시 공간을 의미한다.</li>
      <li><strong>이유 (성능 향상):</strong> HTTPS는 연결 시마다 암호화 키를 교환하는 복잡한 과정(Handshake)을 거치는데, 이 과정은 CPU 자원을 소모함. 이 설정을 통해 한 번 연결했던 클라이언트가 다시 접속할 때(예: 페이지 내의 여러 이미지 로드) Handshake 과정을 생략하고 캐시된 세션 정보를 재사용하여 <strong>HTTPS 연결 속도를 크게 향상</strong>시키는 역할을 함. 기본적으로 설정을 안할 경우 <code class="language-plaintext highlighter-rouge">none</code> 으로 설정되므로 세션 캐시를 만들지 않음.</li>
      <li>1MB 는 약 4천개의 세션을 저장하는데(하나의 세션이 256 바이트 정도된다), 따라서 10MB 설정은 약 40,000개의 동시 세션을 저장하는 공간이다. 따라서 기본적으로 중소 규모 웹 사이트의 트래픽을 감당할 수준이라고 보면 된다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_session_timeout 10m;</code></strong>
    <ul>
      <li><strong>설명:</strong> 위에서 만든 세션 캐시가 <strong>10분</strong> 동안 유효하도록 설정한다.</li>
      <li><strong>이유 (성능 향상):</strong> <code class="language-plaintext highlighter-rouge">ssl_session_cache</code>와 함께 작동하여, 10분 이내에 재접속하는 사용자는 빠른 세션 재개를 통해 성능 이점을 누릴 수 있다. 비 설정 시 기본값은 5분이지만, 새션 캐시가 존재하지 않으면 의미가 없기 때문에 세트로 옵션이 설정되어야 한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;</code></strong>
    <ul>
      <li><strong>설명:</strong> <strong>HSTS(HTTP Strict Transport Security)</strong> 헤더를 브라우저에 전송한다.</li>
      <li><strong>이유 (보안 강화):</strong> 이 헤더를 한 번이라도 받은 브라우저는 <code class="language-plaintext highlighter-rouge">max-age</code>에 설정된 시간(31536000초 = 1년) 동안 해당 도메인(및 <code class="language-plaintext highlighter-rouge">includeSubDomains</code> 설정 시 하위 도메인까지)에 <strong>절대로 HTTP로 접속하지 않고, 무조건 HTTPS로만 접속</strong>하게 된다. 이는 사용자가 실수로 <code class="language-plaintext highlighter-rouge">http://</code>로 접속 시도하는 것을 방지하고, 중간자 공격(MITM)의 일종인 <strong>SSL 스트리핑(SSL Stripping)</strong> 공격을 완벽하게 방어하는 역할을 수행한다.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>모르는 내용 정리
    <ul>
      <li>암호화 스위트 : 클라이언트와 서버 사이의 HTTPS 통신 전, 통신 암호화 규칙을 설정하는 묶음 세트. 명시적으로 설정함으로써 통신의 규약을 확정 짓는 방법
        <ul>
          <li>구성요소 :
            <ul>
              <li>키 교환 알고리즘</li>
              <li>인증 알고리즘</li>
              <li>대칭키 알고리즘</li>
              <li>메시지 인증/ 무결성 알고리즘</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>OCSP 스테이플링 적용 :
        <ul>
          <li>개념 :
            <ul>
              <li>OCSP 스테이플링은 SSL/TLS 인증서의 유효성(폐기 여부)을 확인하는 책임을 클라이언트(브라우저)가 아닌 <strong>서버(Nginx)가 대신 수행</strong>하는 기능이다.</li>
              <li>기본적으로 브라우저는 HTTPS 사이트 접속 시, 해당 인증서가 폐기되지 않았는지 확인하기 위해 인증 기관(CA) 서버에 OCSP(Online Certificate Status Protocol) 요청을 별도로 전송한다. 이 방식은 연결 속도를 저하(지연 발생)시키고, 사용자의 접속 기록이 CA에 노출되는 프라이버시 문제를 야기한다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>적용 예시
        <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nginx.conf 내 http { ... } 또는 server { ... } 블록</span>
  <span class="c1"># OCSP 스테이플링 활성화</span>
  <span class="k">ssl_stapling</span> <span class="no">on</span><span class="p">;</span>
  <span class="k">ssl_stapling_verify</span> <span class="no">on</span><span class="p">;</span>
		
  <span class="c1"># 스테이플링 검증을 위한 신뢰할 수 있는 인증서 체인 지정</span>
  <span class="c1"># Let's Encrypt의 fullchain.pem은 서버 인증서와 체인 인증서를 모두 포함하고 있음</span>
  <span class="k">ssl_trusted_certificate</span> <span class="n">/etc/letsencrypt/live/paulryu9309.ddns.net/fullchain.pem</span><span class="p">;</span>
		
  <span class="c1"># (선택 사항) OCSP 응답 확인을 위한 리졸버 (예: Google DNS)</span>
  <span class="c1"># resolver 8.8.8.8;</span>
</code></pre></div>        </div>
      </li>
      <li>작동 원리
        <ol>
          <li><strong>서버의 사전 확인:</strong> Nginx 서버가 주기적으로 CA 서버에 “내 인증서는 유효한가?”라고 질의한다.</li>
          <li><strong>응답 캐싱:</strong> Nginx는 CA로부터 타임스탬프가 찍힌 “유효함” 응답(OCSP 응답)을 받아 캐시한다.</li>
          <li><strong>응답 첨부 (Stapling):</strong> 클라이언트가 최초 연결(SSL Handshake)을 시도할 때, Nginx는 SSL 인증서와 함께 이 캐시된 “유효함” 응답을 <strong>“찝어서(Stapling)”</strong> 함께 전송한다.</li>
          <li><strong>브라우저 확인 생략:</strong> 클라이언트는 서버가 제공한 OCSP 응답을 신뢰하므로, CA 서버에 직접 질의하는 단계를 생략한다.</li>
        </ol>
      </li>
      <li>적용 이점
        <ul>
          <li><strong>성능 향상 (속도):</strong> 브라우저가 CA 서버에 추가 질의하는 과정을 생략함으로써, HTTPS 초기 연결(Handshake) 속도가 빨라진다.</li>
          <li><strong>프라이버시 보호:</strong> 사용자의 접속 정보(IP, 방문 사이트)가 CA 서버에 노출되지 않아 개인정보 보호 수준이 향상된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="critical-인증서-경로-초기-설정-추가-필요-내역">Critical 인증서 경로 초기 설정 추가 필요 내역</h4>
<p><img src="/assets/images/posts/2025-10/2025-10-20-047.png" alt="" /></p>
<ul>
  <li>핵심 문제 : docker 를 통해 nginx 서비스가 실행 -&gt; 이때 nginx.conf 를 참조하는데, 이때 인증서 존재여부를 보게 되니, 최초에 현재 conf(SSL 설정이 된) 로는 에러가 발생한다는 것이 문제.</li>
  <li>개선 방안은 다음과 같다.
    <ol>
      <li><strong>init-letsencrypt.sh</strong> 와 같은 초기화 스크립트를 활용할 것</li>
      <li><strong>가짜 인증서</strong>를 만드는 전략을 활용해 구동을 하고 certbot으로 진짜 인증서를 받고, 유효한 심볼링 링크를 생성하는 방식 -&gt; 초기화 스크립트는 복잡하고, 여러 수정 작업등이 존재하므로, 차라리 가짜 인증서를 certbot으로 진짜 인증서 발급 이후 새롭게 접근하는 방식. (향후 적용 예정)</li>
    </ol>
  </li>
</ul>

<h4 id="갱신-스크립트의-하드코딩-경로-문제">갱신 스크립트의 하드코딩 경로 문제</h4>
<p><img src="/assets/images/posts/2025-10/2025-10-20-048.png" alt="" /></p>
<ul>
  <li>개요 : 하드 코딩 &amp; 에러처리의 간단한 구조이다보니 문제 있음</li>
  <li>개선 : AI 지적한데로 개선된 형태를 그대로 차용하여 적용</li>
</ul>

<h4 id="certbot-갱신-실패-에러-핸들링-추가">Certbot 갱신 실패 에러 핸들링 추가</h4>

<p><img src="/assets/images/posts/2025-10/2025-10-20-049.png" alt="" /></p>
<ul>
  <li>개요 : 갱신 절차에 대해 실행 결과를 확인하지 않고 해야할 일만 바로 수행하도록 되어 있음</li>
  <li>개선 : 지적한 대로 스크립트 수정</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 20일: Docker Compose와 Nginx 환경에 Let’s Encrypt (Certbot)로 HTTPS 적용 및 자동 갱신 설정]]></summary></entry><entry><title type="html">도쿄게임쇼 2025 - AI 미완의 서곡</title><link href="http://0.0.0.0:4000/ai/2025/10/19/tgs2025-with-ai.html" rel="alternate" type="text/html" title="도쿄게임쇼 2025 - AI 미완의 서곡" /><published>2025-10-19T00:00:00+00:00</published><updated>2025-10-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/10/19/tgs2025-with-ai</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/10/19/tgs2025-with-ai.html"><![CDATA[<h1 id="도쿄-게임쇼-2025--ai-미완의-서곡">도쿄 게임쇼 2025 : AI 미완의 서곡</h1>
<h2 id="요약">요약</h2>

<blockquote>
  <p>“도쿄 게임쇼 2025 참관 후 작성된 이 글은 AI와 게임 산업의 현재 접점을 분석하며, 인디 개발사들의 AI 활용 실험과 대형 게임사들의 콘텐츠 중심 전략 간의 대조를 보여줍니다. AI의 게임 산업 적용 가능성은 높으나, 높은 비용과 불확실한 비즈니스 모델이라는 현실적인 과제가 남아있음을 지적합니다. 특히 AI가 게임 개발의 ‘도구’로서 가치를 발휘하며, 이에 따라 개발자의 역할이 ‘코더’에서 ‘AI 조작자(tuner)’로 변화하고 비용 최적화 및 도메인 전문성의 중요성이 더욱 커질 것이라는 전망을 제시하며, AI 시대의 기회와 도전을 탐색합니다.” by OrionAI</p>
</blockquote>

<hr />

<h2 id="도쿄-게임쇼-ai-와-함께-하나">도쿄 게임쇼, AI 와 함께 하나…?</h2>
<p><img src="/assets/images/posts/2025-10/2025-10-20-028.png" alt="" /></p>

<p><big><em>AI 와 게임은 괜찮은 궁합이라고 생각하시나요?</em></big></p>

<p>‘게임’이란 산업은 ‘찰떡의 조합’으로 AI와 함께 해야 하는 시장이라고 생각합니다. 여러분의 생각은 어떤가요? AI, LLM 과 게임의 조합이 어떻다고 생각하시나요?</p>

<p>AI를 통해 지능형 NPC 가 나와서, 저와 함께 싸워준다면 …?</p>

<p>기계적으로 지정된 분기가 아니라, 게임 행적을 기반으로 만약 게임의 엔딩이 바뀌고, 그 엔딩이 내가 꿈꿔온 결말이라면…?</p>

<p>던전이 매 순간 변화하고, 그에 따라 나오는 몬스터가 변하고, 그런 모습 속에서 더 처절한 용사가 되어 모험을 해나간다면…?</p>

<p>매 순간 설레는 모험. 질리지 않는 다양한 사건들로, 우리의 게임의 플레이 환경이 획일적인 상황을 넘어서는 무언가가 된다면?</p>

<p>이유는 많이 있습니다. AI의 특성 때문이기도하며, 동시에 게임의 특성과, 문화 산업의 힘을 생각하면 AI의 존재가 게임 산업 전반에 침투 했을 때 일어날 시너지는 분명 엄청날 것입니다. 그리고 그런 상상은 꾸준히 미디어를 통해 시사되었고, LLM 의 등장은 그런 ‘로망’을 이루기에 충분하다는 사람들의 평가를 받고 있지요.</p>

<p>뿐만 아니라 기업 적으로 봐도 그렇습니다. 게임 개발의 프로세스의 혁신은, 매 순간 기다려야 하는 발매일을 앞 당길 수 있을지 모릅니다. 뿐만 아니라 만드는 과정에서 드는 비용의 절감은, 분명 더 많은 콘텐츠가 더 합리적인 가격으로 제시 될 수 있는 기회를 줄지도 모릅니다.</p>

<p>영화 같은 모험을, 내가 생각하고, 내가 뛰어들어 그 세계를 탐험하는 모험이 가능하며 그 세상을 실제로 누려볼 수 있다는 점은 어쩌면 게임이 단순한 유희를 넘어서는 새로운 지평선이 되어 줄지 모를것입니다.</p>

<p>이런 생각 와중에, 개인 프로젝트 내용을 채워 나가고 있던 9월. 알고 지내던 지인, 게임사 대표가 말했습니다.</p>

<p>‘도쿄 게임쇼 가실래요?’</p>

<p>오잉, 심지어 비즈니스 데이 참석 가능한 티켓. 프리패스로 참석이 가능하다고?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-029.png" alt="" /></p>
<blockquote>
  <p>가즈아…!!!!</p>
</blockquote>

<p>AI와 게임, 미디어 산업, 어느 쪽도 절대 놓치면 안된다는 생각이 든 저는, 빠르게 결단을 내렸습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-030.png" alt="" /></p>
<blockquote>
  <p>두둥</p>
</blockquote>

<p>9월 25일부터 4일 간 진행되며, 비즈니스 데이에는 각종 게임과 관련된 기업들의 컨퍼런스(혹은 홍보 행사)까지… 안 가는게 바보겠구나 싶어서 당장 진행시켰습니다…! 본 글은 그런 저의 도쿄 게임쇼 2025 생존 후기라고 보시면 되겠습니다.</p>

<h2 id="1--인디-게임-ai-실험의-최전선">1.  인디 게임, AI, 실험의 최전선</h2>

<h3 id="게임과-ai">게임과 AI</h3>

<p><img src="/assets/images/posts/2025-10/2025-10-20-027.png" alt="" /></p>

<p>게임이라는 컨텐츠는 부정적으로 보는 사람도 많지만, 실질적으로 매우 큰 시장이자, 산업입니다. 특히나 게임은 온갖 컨텐츠들이 종합되어 있으며, 사람의 감정을 근본적으로 동요하게 만듬으로 써 감동도, 성취감도, 동시에 메시지도 줄 수 있지요. 그렇기에 이 시장이 큰 것이며, 요즘은 더욱이 남녀노소를 안가리고 있단 점에서 차세대 컨텐츠로 가장 미래지향적이며, 여전히 할 일이 많이 남아있는 콘텐츠라고 생각합니다.</p>

<p>그렇기에 필연적으로 게임은 대단히 노동 집약적인 산업입니다. 기획과 의도, 메시지를 담아내고, 그걸 위한 온갖 역할군의 사람들이 협업하여 만들어낸 작품. 그렇기에 명작은 사람들에게 충격을 주기도하고, 애정이란 감정을 일으키기에 사람의 인생에 매우 큰 영향을 주기도 한다는 점은, 결코 거짓이 아닐 것입니다.</p>

<p>그러나 이러한 특성으로 게임은 현재 여러 비판들에도 직면하게 됩니다. 우선 IP 의 강력함은 있지만, 동시에 개발 프로세스에서 들어가는 비용에 대한 천문학적 액수는, 개발자와 경영자, 그리고 소비자 사이에서 가장 큰 갈등의 요소가 됩니다.</p>

<p>그런 와중에 AI 는 무엇입니까? 자연어로 지시를 하면, ‘확률’에 의거하여 사람이 하던 행동을 대신 해줍니다. 과거에는 그 수준이 미비하고, 부족했지만, 하드웨어를 믿고 거대한 모델로 학습하기 시작하자, 그 능력치는 폭발하게 되었습니다. 이제는 사람이 하던 일들에 대하여 아주 손쉽게 대응하는게 가능해졌습니다. 프로세스 요소 요소마다의 비용적 절감을 가져오고 이것이 전 영역(코딩, 음원, 이미지 기타 등등)에서 가능하단 점은, 고부가 가치의 산업인 게임이 현재 직면한 상당한 문제들을 개선해주는 훌륭한 구원투수가 될 것이라는게 전문가들의 일반적인 평가이지요.</p>

<p>뿐 만 아니라 게임 내부를 보아도 마찬가지입니다. 게임 속 기획들은 사람의 동기를 부여하고, 성취감, 재미를 주는데, 문제는 기존의 방식든 어떤 수를 써도 한계가 있기 때문에 콘텐츠의 생산면에서 한정된 리소스, 한정된 만큼의 경우의 수를 만들어줄 수 밖에 없습니다. 하지만 적절한 프롬프트, 적절한 연산 장치만 갖춘다면, 그 내용들 전체를 기반으로 다시 새롭게 없던 무언가를, 사람이 할법한 내용으로 구축해낼 수 있습니다.</p>

<p>수치적으로 봐도 이러한 흐름은 증명된 것일 겁니다. 게임 산업은 2024년 1827억 달러 규모로 성장되었고, AI 적용 시장은 2024년 32.8억 달러 수준이고, 2033년까지 512.6억 달러로 도달할 것이란 예측 수치가 나왔습니다. Unity Gaming Report 2024에선 62% 개발자가 AI를 쓰고 있고, GDC의 조사에선 2024년 31%의 스튜디오와 부서가 생성형 AI를 활용하고 있다고 이야기 하고 있습니다. 특히나 스타트업의 펀딩 영역에서 AI 를 기반으로 하여, 도구들은 2024년 이미 1천억 달러 이상 펀딩을 받았는데, 이는 2023년 556억에서 두배, 80% 증가했다고 보여주었습니다. AI 와 게임의 조합은 이미 시작부터 끝까지, 그리고 앞으로 이미 확정적인 성장세라고 보는게 타당할 것 입니다.</p>

<p>그리고 이러한 저의 생각은 당연히 저보다 먼저 앞서 게임을 만드는 열의를 가진 분들을 통해 나타나고 있었습니다. 도쿄 게임쇼 2025는 게이머들의 축제이지만, 동시에 그 시발점에 게임사들이 드디어 적용되어 가고 있음을 보여주었습니다.</p>

<h3 id="ai와-인디의-시너지">AI와 인디의 시너지</h3>

<p>저를 초대해준 업체가 있는 9 ~ 11관 쪽에서 가장 먼저 눈길이 갔고, 가장 크게 준비되어 있던 부스가 ‘인디 85선’이라는 부스였습니다. 자체적으로 선정한 85가지 게임의 소개 부스는 각자 자신들의 매력을 어필하려고 정말 노력하고 있다는 말이 부족할 정도로 뜨거운 열기를 보여주고 있었지요. 그 와중에 AI 가 관련되어 있던 부스 일부를 소개해보고자 합니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-031.png" alt="" /></p>
<blockquote>
  <p>실제 플레이 시 서라운드 사운드로, 마치 커맨더가 된 것처럼 캐릭터에게 지시를 내릴 수 있었다.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Final Link</code>(제작사 RunGround Works)라는 작품은 일본인 개발자와 두명 정도의 추가 인원이 개발한 SF 비주얼 노벨 게임입니다. 음성 입력을 활용하고, 실시간 대화를 통해 게임의 캐릭터가 움직이는 방식으로, ChatGPT 를 활용했습니다. 3D 노벨 게임이기에 분기를 갖고 있었는데, 이를 단순히 수치화하는게 아닌, 자연어의 선택으로 가게 만든다는 발상은, 약간의 플레이 만으로도 상당한 몰입감. 특히 내가 바라는대로 움직인다는 점을 생각한다면 상당한 흡입력을 보여주는 작품이었습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-032.png" alt="" /></p>
<blockquote>
  <p>시간 관계상 플레이까진 못해보았다</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">AI GRANDPRIX</code>(제작사 MIRACLE PLAY)는 AI 를 활용한 학습 방식으로 레이서를 육성하는 게임입니다. AI 가 대신 플레이를 해주는데, 이때 플레이 기록을 취사하여 자신만의 플레이스타일이 되도록 학습을 시키고, 그런 대상을 NFT 로 구축하여, 독자적인, 하나밖에 없는 AI 레이서를 만드는 것을 목표로 하는 육성 장르의 게임이었습니다. 해당 게임은 데모 정도의 구축이 되어 있었고, 아직 릴리즈할 수준은 아니라고 보였습니다. 그러나 단순히 AI 가 ‘대신 행동한다’가 아닌, 학습 자체의 과정을 마치 인격을 가진 존재 처럼, AI가 ‘학습을 한다’는 점을 이용한 새로운 접근 방식, <code class="language-plaintext highlighter-rouge">우마무스메</code>, <code class="language-plaintext highlighter-rouge">FM 매니저</code>와 같은 육성 시리즈로 한 획을 그었던 육성 장르적 특성의 연결은 육성 장르의 매력, 몰입감을 AI를 통해 더 극대화 하려는 듯 보였습니다.</p>

<p>그 외에도 여러 몇가지 AI를 활용한 게임들이 있었고, 게임에 AI를 녹여내진 않았으나, 물어봤을 때 AI를 적극 활용하고 있는 게임사 직원들의 이야기들은, 이미 생산성 향상과 게임이란 리소스 집약형 산업에 AI 가 적극적으로 침투되고 있는지를 보여주는 부분이었습니다.</p>

<h3 id="하지만">하지만…</h3>

<p>하지만 하나, 논의를 하면 개발자라면 동일하게 걱정하는 부분이 있었습니다. 바로 ‘비즈니스 모델’에 대한 영역입니다. 저 또한 LLM 기반의 프로젝트를 구성하면서, 조심해야겠구나 생각했던 것은 바로 어떤 LLM 을 쓰더라도 AI의 사용 비용은 명확하게 냉정하다는 지점입니다.</p>

<p>로컬에서 돌리는 MoE 방식의 작은 모델들이 물론 많지만, 실질 서비스 퀄리티를 위한 AI 를 활용하기 위해선 거대 모델의 사용은 실상 필수 입니다. 문제는 도구로 사용하는 경우엔 훨씬 낫지만, 인게임이에 들어 간다면? 사용자의 인터렉션에 맞춰 실시간으로 AI 로 대응하는 것은 게임이란 콘텐츠의 기본적인 패키지 식의 결제와는 어울리지 않는 지점을 보여줍니다.</p>

<p><strong>주요 AI 모델별 토큰 가격 비교 (2025년 10월 기준)</strong></p>

<p>| 공급사 | 모델 | 입력 비용 (1백만 토큰당) | 출력 비용 (1백만 토큰당) | 비고 |
| — | — | — | — | — |
| **OpenAI** | GPT-5 | $1.25 | $10.00 | 코딩 및 에이전트 작업에 최적화된 플래그십 모델 |
| | GPT-5 mini | $0.25 | $2.00 | 더 빠르고 저렴한 버전 |
| | GPT-5 nano | $0.05 | $0.40 | 요약 및 분류 작업에 적합한 가장 빠르고 저렴한 버전 |
| **Anthropic** | Claude 4.1 Opus | $15.00 | $75.00 | 현재 가장 성능이 뛰어난 Claude 모델 |
| | Claude 4.5 Sonnet | $3.00 | $15.00 | 성능과 비용의 균형을 맞춘 모델 |
| | Claude 3.5 Haiku | $0.80 | $4.00 | 가장 빠르고 비용 효율적인 모델 |
| **Google** | Gemini 2.5 Pro | $1.25 (≤ 20만 토큰) | $10.00 (≤ 20만 토큰) | 입력 토큰 양에 따라 가격 변동 |
| | | $2.50 (&gt; 20만 토큰) | $15.00 (&gt; 20만 토큰) | |
| | Gemini 2.5 Flash | $0.30 | $2.50 | 속도에 최적화된 경량 모델 |</p>
<blockquote>
  <p>최신 버전들은 이러한 지점 때문에, 의도적으로 저가형 모델들을 만들었다.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Final Link</code> 개발자 분과 이야기를 해봤을 때는 이러한 지점 때문에 결제 방식에 고심하고 있었습니다. 3일 정도의 플레이를 무제한으로 할 수 있는 이용권 방식을 고려하고 있다고도 이야기 했습니다. 이 부분에 대해 개발자님과 논의를 깊게 할 수는 없었지만, 기본적으로 구매를 하여 사용하던 게임, 즉 ‘소유’의 개념에 가까웠던 게임에서 구독, 그것도 3일이라는 제한된 시간을 이용가능하다는 점은, 과연 소비자가 납득할 것인가? 이 부분에 대해선 저나, 해당 개발자 역시 확신이 없었습니다. 이렇듯, AI 의 비용 계산이 토큰단위이고, 그런 상황에서 기존의 서비스들이 제공하던 방식이나 절차를 생각한다면 소비자에게 외면 받을 수도 있다는 점에서 대단히 조심스러울 수 밖에 없었습니다.</p>

<p>그렇다면 로컬로 돌리면 어떻지? 라고 생각 하실수 도 있습니다. 게임 내 AI 를 통합하고, VRAM 을 활용 하는  것 입니다. 기술적으로 불가능하지도 않고, 무엇보다 요즘 게임 유저들의 상향 평준화된 PC 스펙이라면 충분히 노려 볼 만한 구석도 있습니다. 하지만 알다시피 대형 모델이 아닌 이상 모델의 성능, 그리고 AI 자체의 반응속도, 인게임에서도 필요한 리소스, 그리고 본질적으로 소형 모델이 보여주는 환각과 관련된 문제 등… 여러 면을 고려한다면 이 핵심적인 문제는 해결되진 못합니다. 그렇기에 대형 LLM 을 활용하는 것은, 불가피한 선택입니다. 그리고 거기서 적립된 확실한 비즈니스 모델이 없다는 지점은 이 시장을 관통하는, 핵심 질문이라고 볼 수 있을 것 입니다.</p>

<h2 id="2-대형-게임사들과-ai-이에-대응-하려는-플랫폼들과-툴-경쟁">2. 대형 게임사들과 AI, 이에 대응 하려는 플랫폼들과 툴 경쟁</h2>

<p>첫 날, 그렇게 들렀던 인디게임 사들과, 다양한 중소 개발사들을 돌아 보고 나니 게임 제작하는 많은 이들의 열기도 느껴지고, 특히 국내 게임 제작사들의 처절함, 열심히 하고 있는 모습도 느낄 수 있었기에 매우 흥미 진진 &amp; 나 역시 무언가 하고 싶다는 느낌을 전염 받을 때 즈음, 드디어 슬슬 대기업 부스들을 돌아보게 되었습니다.</p>

<p>여기선 어떤 AI 기능들이 있을까? 얼마나 게임 속에 녹여 내었을까? 등등 … 게임도 설레였지만, 핵심은 AI 였고, AI 에 대한 내용들을 제대로 보고 싶어 주변을 전체적으로 둘러봤습니다…만 결과적으로 트리플 A 급 게임의 제조사들의 모습은 ‘사뭇’ 달랐습니다.</p>

<h3 id="콘텐츠에-집중하는-대형-부스들">콘텐츠에 집중하는 대형 부스들</h3>

<p>다소 실망스럽지만, 참가 게임 회사들의 내용들을 정리한 내용은 아래와 같았습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 스퀘어 에닉스 - FF 시리즈, FF 스핀오프 작품들과 JRPG 장르의 신규 IP 들
- 코에이 테크모 - 젤다무쌍 봉인전기
- 캡콤 - 최신 발매한 게임, 레지던트 이블 시리즈 신작 
- 세가 - 용과같이, 소닉 IP 레이싱 신작
- 코나미 - 사일런트 힐 f 
- 넥슨 - First Decent 
- 넷마블 - 7대 죄악 IP 를 활용한 모바일 게임
- 스마일게이트 - 신규 IP 미래시, 미소녀 수집 게임 장르
- 펄어비스 - 붉은 사막
- NC - SaaS 방식으로 아주 작은 부스로, 생성형 AI 를 활용한 에셋 제작 서비스
</code></pre></div></div>

<p>제가 다 기억하지 못하거나할 수  있으나, 방문 가능했던 부스들입니다. 보이시나요? 맞습니다. 아쉽게도 AI 와 관련된 것들 보단 ‘콘텐츠’에 집중하고 있었습니다. 물론 그렇지 않은 케이스도 있지만 말이죠.</p>

<p>우선, 일본의 게임 기업들, 내놓아라 하는 회사들의 특징은 강력한 IP 기반으로, 기존 팬덤을 위한, 그리고 신규 팬들을 만들기 위한 노력이 명확히 보였습니다. AI의 사용이 강조되기 보단, 기존 IP를 확장하여 팔고 캐시 카우를 끌어 올리되, 성공적인 시스템, 성공적인 배경이나 게임성을 기반으로 신규 팬덤이 생길 수 있는 새로운 시리즈들의 안정적인 출발을 고려하는 느낌이 물씬 들었습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-033.png" alt="" /></p>
<blockquote>
  <p>가장 눈길을 끌었던 단일 테마 부스는 단연 ‘젤다 무쌍’. 젤다 프렌차이즈를 해본 사람이라면 스토리 맛집으로 유명하다. 실제로도 단일 부스 기준 상당한 줄이 서있었다</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-034.png" alt="" /></p>
<blockquote>
  <p>신작들, 그리고 스위치 등에 재 이식되는 리메이크 혹은 리마스터작들이 주를 이루었다</p>
</blockquote>

<p>국내 기업들의 경우, 각 개발사의 상황에 따른 전략, 작품 홍보 쪽에 가깝다는 점들이 보였습니다. 넥슨은 해외 쪽 전략으로 퍼스트 디센트를, 넷마블은 계속 성공적인 일본 IP 기반의 모바일 게임을, 스마일 게이트는 수집형 미소녀 전략 게임인 ‘미래시’, 펄 어비스는 드디어 나오기로 확정된 붉은 사막… 등, 해당 업체들에서 현재 어느정도 반응이 있거나, 아니면 전략적으로 밀어주는 게임을 선보이는 모습이었습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-035.png" alt="" /></p>
<blockquote>
  <p>전엔 괜찮나? 했었지만 어느새 신작이 나오는 7대죄악 IP 기반의 모바일 게임. 부스 크기가 상당했다.</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-036.png" alt="" /></p>
<blockquote>
  <p>전형적인 미소녀 서브컬쳐 기반의 신작. 게임 성은 훌륭했다.</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-045.jpg" alt="" /></p>
<blockquote>
  <p>기대치를 미치지 못한 플레이를 보여주었던 붉은 사막. 다소 아쉬움은 남아있지만, 아직 출시 전이니…</p>
</blockquote>

<p>생각보다 아쉽긴 했습니다. 대기업들의 부스는 콘텐츠 중심이거나, 지속적으로 인정받은 캐시카우 장르들에 대한 쇼케이스가 주였다는것은 다소 아이러니 했습니다. 그러나 이러한 지점은 이 역시도 인사이트는 있다고 봅니다.</p>

<p>AI가 그들 내부에선 어떻게든 돌아가고, R&amp;D 를 할지 모르겠지만, 아직 콘텐츠로 녹여낼 수 있는 수준으로 시연될 만한 수준이 아니라는 점. 즉 결론적으로 AI 를 아직 엔드유저를 위한 콘텐츠로는 낼수 없다는 평가가 있다는게 결과론으로 증명 된게 아닐까? 하는 생각을 했습니다. 제가 고민하던 것, 인디 게임사들이 고민하던 것. 그런 모든 것들을 더욱 치열하게 고민했을 것이기에, 그 가능성에 투자한다는 기사는 종종 있었지만, 결국 <code class="language-plaintext highlighter-rouge">결과</code>가 나오지 않았다는 것은 그걸 보여주기엔 아직 이르다- 는게 제 결론이었습니다. 그들에게는 오히려 수집형 모바일 게임이거나, 자신들의 트리플 A급 상품들을 전시하는 것이 여전히 중요하며, 전세계적인 불황 속에서도 각 태도들이 보여주는 선두와 팔로워 기업들 사이의 치열함이 있음을 새삼 느낄 수 있었습니다.</p>

<h3 id="도구적-가치에-집중하는-회사들-nc-알리바바와-텐센트-그리고">도구적 가치에 집중하는 회사들, NC, 알리바바와 텐센트, 그리고…</h3>

<p>그런데 위에서 적은 것도 보셨으니 아실 것입니다. NC 쪽에 뭔가 특이한 내용이 있던 것을 기억하십니까? 놀랍게도 이런 상황에서 AI 의 결과물을 스리슬쩍 발표한 곳이 있었으니.. 그것은 바로 NC 였습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-038.png" alt="" /></p>
<blockquote>
  <p>NC 사의 AI 솔루션 ‘NC AI(현, VARCO Game-AI)’의 팜플렛</p>
</blockquote>

<p>NC 부스를 찍은 사진이 보이질 않아(…) 대단히 아쉽지만, 3D 생성 및 프롬프팅 편집을 하게 되면 3D 에셋의 프로토타입이 나오며, 심지어는 여기에 보이스, SFX 까지 생성이 가능하고, 애니메이션 역시 표현 가능하다는 팜플렛과 그 시연 내용은 대단히 인상적이었습니다.</p>

<p>우선, 오로지 NC 내부의 자료를 활용하여 학습을 시켰음으로 퀄리티가 상당하면서도 저작권 문제를 해결하였습니다. 또한 SaaS로 도전을 하며, 현재로선 우선 개인을 위한 솔루션으로만 내놓았다는 언급은 NC 라는 기업의 규모를 고려할 때 기업에서 게임을 만드는 것 이외에도 개발의 선도자, 도구의 플랫폼으로 도전해고 있다는 사실을 엿볼 수 있었습니다.</p>

<p>특히나 실제 시연 내용을 보았을 때는 그 수준과 성능이 상당하며, 특히나 개발 과정에서 단축해야할 부분이 어떤 것인지, 그 A to Z 를 잘 캐치하고 있다는 점에서 “써봄직하지 않나?” 라는 생각을 했습니다. NC가 혁신을 보여주던 그 시절, 기술적인 면에서나 자본 면에서나 엄청난 회사였고(물론 지금도 엄청난 편이지만) 그런 노하우들은 여전히 유효하고, 그걸 다시 많은 개발 환경에 적용 가능하다? 이 점은 도구로서 AI 의 본질에서 충분히 구현 가능한 상품이었습니다.</p>

<p>뿐만 아니라, 다른 회사들도 몇몇 보였는데 인상적인 기업들은 다음과 같았습니다. 어도비의 FireFly 라는 툴은, AI 기반이자 저작권 프리로 학습된 모델을 활용해 캐릭터의 의상이나 디자인을 프롬프트로 수정하는 서비스로 시연을 이어 갔습니다. 중국의 클라우드 플랫폼 알리바바와 텐센트는 게임을 위한 컴퓨팅 서비스들을 내걸고 있었습니다. 그 와중에도 AI 구동이 가능한 서버를 제공해주는 등의 홍보 내용들은, 게임에 집중하는 회사들을 위한 회사이자, 위에서도 언급했던 개발 코스트의 제약, 노동 집약을 해소하는 효과적이고 효율적인 도구로서의 AI를 지향하고 있다는 점을 볼 수 있었습니다. 일본 내의 AI 솔루션 제공 기업, 서버 기업 등도 있었는데, 그 수준과 비용은 차처하더라도 도구로서, AI 의 장점을 극대화하고 기존의 제작의 난이도를 더 낮추고, 1인 기업이 정말 가능할 것 같다는 듯 SaaS 의 저변을 넓히려는 시도가 명확해 보였습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-039.png" alt="" /></p>
<blockquote>
  <p>점유율 세계 3위, AWS, Azure 다음인 알리바바의 클라우드 서비스, AI 를 비롯한 당연하게도 게임을 위한 서비스들이 너무나 많고, 무엇보다 싸면서도 대응이 빠르다. 대기업 플랫폼의 한계를 넘어서는 장점은 분명히 있다.</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-040.png" alt="" /></p>
<blockquote>
  <p>흥미롭게본 AIgoGames, 게임의 프로토타이핑 뿐 아니라, 제작 과정이나 검수, 로컬라이징 등 전체 프로세스를 AI 활용가능하다고 소개하고있는 업체였다</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-041.png" alt="" /></p>
<blockquote>
  <p>일본에서 여러 서비스를 유통하는 채널에서 만든 팜플렛, 어도비 Firefly 는 인상적이긴 했으나, 시연 퀄리티가 아쉬웠다</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-042.png" alt="" />
<img src="/assets/images/posts/2025-10/2025-10-20-043.png" alt="" /></p>
<blockquote>
  <p>일본 내 기업이자 AI 서비스를 한다고 이야기 한 업체들의 팜플렛, 하나는 라마와 LLM 을 혼합하여 만든 가상 아바타 시스템으로 솔루션으로서 보여주었고, ubitus 라는 업체도 유사한 서비스를 보여주었다. 일본 자생 업체들의 비즈니스는 다소 성숙한 완성형이란 느낌은 아니었으며 실험적이란 느낌이었다.</p>
</blockquote>

<h2 id="결론--미완의-서곡-그러나-가능성과-기회">결론 : 미완의 서곡, 그러나 가능성과 기회</h2>

<p>TGS 2025에 3일 참가를 마치고, 지친 몸을 이끌고 귀국을 하면서 TGS 를 통해 얻게된 인사이트는 물론 업계의 차이는 있겠지만, 어느정도 일맥상통하지 않을까 합니다.</p>

<ul>
  <li>AI 응용 어플리케이션은 가능성의 영역에 존재한다.</li>
  <li>비용, 비즈니스 모델의 절대적 성공 모델은 아직 없다.</li>
  <li>그러나 그 능력만큼은 확실하기 때문에, 이에 대한 도전과 움직임은 끝나지 않을 것이다</li>
  <li>특히나 현재의 실험적 상황에서 핵심은 ‘Tool’로서의 접근일 것이며, 거기서부터 점차 엔드유저까지 퍼져 갈 것이다.</li>
</ul>

<p>AI 를 툴로 접근하고 플랫폼이 되려는 시도나, 각종 창조를 위한 툴로서 등장한 AI. 이 모든 것들은 분명 엄청난 파급력, 특히 사람이 할 수 있는 일을 대체하거나, 맥락을 이해하고 작업을 할 수 있는 등, 여러 면을 보더라도 분명 엄청난 가치를 가진게 분명하다고, 저는 생각합니다.</p>

<p>아직 아쉬움이 있고, 오히려 자본력을 투자했으면 하는 대형 업체들의 결과물이 나오지 않은 것은 사실이지만, 이는 자본주의 시장의 특징이라고 생각하면 충분히 납득이 갈만 합니다. 그럼에도 도전하는 많은 이들을 통해 ‘이 불완전한 상황’을 어떻게 극복해 내는가를 누가 얼마나 빨리, 많이 습득하냐에 따라 분명 그 기회는 명확하게 오리란 생각이 듭니다.</p>

<p>특히나 이러한 지점에 개발자적인 생각을 추가해본다면? AI 를 대하는 개발자의 상황은, 비록 녹녹하지 않다는 말이 많지만… 그럼에도 분명한 <code class="language-plaintext highlighter-rouge">Pain Points</code>를 이해해 하면 충분히 될 것이란 생각입니다.</p>

<p>AI 의 불완전한 지점, 특히 ‘결과물이 일정하지 않다’는 차원은 앞으로도 지속적으로 개발을 통해 개선될 것 = 아직 개발할 일이 남아 있음을 의미합니다. 대체 가능한 <code class="language-plaintext highlighter-rouge">코더(Coder)</code>는 사라질 것이지만, 그걸 뛰어넘는 AI에 대한 노하우를 가진 개발자의 <code class="language-plaintext highlighter-rouge">조작(tune)</code>은 이어갈 것이고, 이 영역은 결코 비 개발자 지식, 경험만으론 불가능할 것이고, 개발적 토대가 없으면 안되기 때문입니다.</p>

<p>또한 결정적인 영역은 바로 ‘최적화’라고 생각됩니다. 일본의 AI 아바타 솔루션을 제작한 업체의 설명에서도 나왔지만, 자연어의 이해나 대응 방향에 대해선 LLM으로 Gemini 를 사용하지만, 음성 합성과 실제 멘트의 대응은 라마 오픈 소스모델을 돌린다고 하였습니다. 여기엔 분명 <code class="language-plaintext highlighter-rouge">튜닝</code>, <code class="language-plaintext highlighter-rouge">반응속도</code>, 그리고 <code class="language-plaintext highlighter-rouge">가격</code>이라는 문제가 있기 때문이었습니다.</p>

<p>이렇듯, 서비스로 사용될 AI의 가장 문제는 역시나 리소스와 AI의 사용량에 달려 있습니다. 만들고, 붙이는 건 쉽고, 이를 통해 MVP 를 만드는 건 이젠 바이브 코딩으로도 충분합니다. AI의 깡 성능으로 충분히 해결 가능한 수준이 되었습니다. 하지만 그것이 서비스가 된다면? 현행 API 발행을 통한 사용 방식의 AI 를 래핑한 서비스라면, AI 는 종량제가 아니면 안되며, 결과적으로 플랫폼으로 거대 모델을 제공해주는 업체 정도가 아니라면 <code class="language-plaintext highlighter-rouge">어떤 비즈니스 모델로 소비자를 납득시킬 수있을 것인가?</code> 이 차원의 문제가 지속적으로 발생할 것입니다.</p>

<p>결국 전통적인 개발의 필요성, 개발의 깊이가 여전히 통용 됨을 증명한 꼴이 됩니다. AI를 위한 ‘비용 최적화’, AI 분야에 대한 대용량 처리의 문제로 직결될 것이라는 점은 자명해 보입니다. 결국 기존의 개발의 전문성, 왜 전문적인 영역으로 남아있는가? 에 대한 답변이 그대로 적용되는 것입니다.</p>

<p>AI는 설익은 과일입니다. 하지만 맛있을 것은 명확하며, 어딘가의 교수님 말씀처럼, 생산성의 혁명, AI 를 구동하는 자원이 곧 권력이 될 수도 있습니다. 심지어 기업이 한 나라를 먹여 살릴 수 있을 만큼 그 영향력을 가질지도 모른다고 이야기 하고 있죠. 그렇기에 AI에 대한 이해도와 접근, 그리고 원리에 대한 이해는 핵심이며, 이를 기반으로 어떤 서비스를 만들고 사용자를 모아보는 일. 어쩌면 개발을 배워야 하는 이유는 과거엔 단순히 ‘서비스를 만들기 위해’였지만, 이제는 ‘1인 기업이 되기 위해’ 일 지도 모르겠습니다. 이번 일주일의 과정은 그런 실질적인 상황을 보고 듣고, 체감할 수 있었습니다. 또한 내 안의 불확실함으로 갖고 있던 인사이트들도 명확해 지는 것으로 다시 한 번, 개발의 전문성, AI를 함께 하지만 결국 도메인의 전문성이 곧 개발자로의 생존(…)과 직결된다는 점에서 비장한(?) 각오와 함께, 오늘도 AI 와 뒹굴기를 시전해보려고 합니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-044.png" alt="" /></p>
<blockquote>
  <p>트릭컬, 국내 게임사의 수집형 모바일 게임의 팬 행사….. 시선 처리까지 완벽하다….</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="TGS2025" /><category term="Game" /><category term="생각정리" /><summary type="html"><![CDATA[도쿄 게임쇼 2025 : AI 미완의 서곡 요약]]></summary></entry><entry><title type="html">TIL - jenkins 로 무중단 nextjs 배포 구축하기</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins.html" rel="alternate" type="text/html" title="TIL - jenkins 로 무중단 nextjs 배포 구축하기" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins.html"><![CDATA[<h2 id="2025년-10월-17일-개발-내용-요약-및-학습-정리">2025년 10월 17일 개발 내용 요약 및 학습 정리</h2>
<h2 id="-jenkins-무중단-배포-구축을-위한-추가-밑작업">📝 Jenkins 무중단 배포 구축을 위한 추가 밑작업</h2>
<h3 id="-목적-purpose">✨ 목적 (Purpose)</h3>

<p>Jenkins 를 활용한 무중단 배포를 구축하기 위해, 단순히 Dodcker 컨테이너화로 끝나는게 아닌, 배포 용이, 무중단성을 확보하기 위한 구조 개선이 필요하다고 느꼈다. 이에 아래의 목표를 기반으로 NextJS 의 프로젝트에 추가적인 작업 목표를 설정해보았다.</p>

<ul>
  <li><strong>CI/CD 파이프라인 통합 용이성</strong>: Jenkins와 같은 CI/CD 도구를 통해 자동화된 빌드 및 배포를 더욱 용이하게 합니다.</li>
  <li><strong>개발 및 운영 환경 일관성 유지</strong>: Docker를 통해 개발 및 운영 환경 간의 차이를 최소화하고 일관성을 유지합니다.</li>
  <li><strong>무중단 배포(Zero-downtime Deployment) 지원</strong>: Nginx와 블루/그린 배포 전략을 통해 서비스 중단 없이 애플리케이션을 업데이트할 수 있는 기반을 마련합니다.</li>
  <li><strong>프로젝트 가독성 및 유지보수성 향상</strong>: 명확한 디렉토리 구조와 상세한 문서화를 통해 프로젝트의 가독성과 유지보수성을 높입니다.</li>
</ul>

<h3 id="️-주요-변경-사항">🛠️ 주요 변경 사항</h3>

<h4 id="1-프로젝트-구조-재편">1. 프로젝트 구조 재편</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">app/</code> 디렉토리로 파일 이동</strong>: 기존 루트 디렉토리에 있던 Next.js 관련 파일들 (<code class="language-plaintext highlighter-rouge">.dockerignore</code>, <code class="language-plaintext highlighter-rouge">.gitignore</code>, <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">eslint.config.mjs</code>, <code class="language-plaintext highlighter-rouge">next.config.ts</code>, <code class="language-plaintext highlighter-rouge">package.json</code>, <code class="language-plaintext highlighter-rouge">pnpm-lock.yaml</code>, <code class="language-plaintext highlighter-rouge">postcss.config.mjs</code>, <code class="language-plaintext highlighter-rouge">public/</code>, <code class="language-plaintext highlighter-rouge">src/</code>, <code class="language-plaintext highlighter-rouge">tsconfig.json</code>)이 모두 <code class="language-plaintext highlighter-rouge">app/</code> 디렉토리 내부로 이동시켰다. 이는 Next.js 애플리케이션의 모듈성을 높이고, 프로젝트의 각 구성 요소(Next.js 앱, Nginx)를 명확하게 분리하기 위함이다.</li>
</ul>

<h4 id="2-docker-환경-구성-개선">2. Docker 환경 구성 개선</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">app/Dockerfile</code> 다단계 빌드(Multi-stage Build) 개선</strong>: <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 스테이지 구성이 더욱 세분화 시켰다. <code class="language-plaintext highlighter-rouge">base</code>, <code class="language-plaintext highlighter-rouge">dev_runner</code>, <code class="language-plaintext highlighter-rouge">prod_modules_setter</code> 스테이지가 추가되어 개발 및 운영 환경에 맞는 의존성 설치 및 빌드 과정을 명확하게 분리했다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">dev_runner</code>: 개발용 의존성을 설치하여 빠른 개발 환경을 독립적으로 제공 목적으로 만듬.</li>
      <li><code class="language-plaintext highlighter-rouge">prod_modules_setter</code>: 운영용 의존성만 설치하여 최종 이미지 크기를 최적화하고 보안을 강화한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">app/docker-compose.yml</code> 추가</strong>: <code class="language-plaintext highlighter-rouge">app/</code> 디렉토리 내부에 Next.js 앱만을 위한 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, 이 파일은 <code class="language-plaintext highlighter-rouge">dev</code>와 <code class="language-plaintext highlighter-rouge">prod</code> 서비스를 정의하여 Next.js 앱의 개발 및 운영 환경을 독립적으로 관리하도록 만들었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">루트 최상단의 docker-compose.yml</code></strong> : 기존 <code class="language-plaintext highlighter-rouge">dev</code> 및 <code class="language-plaintext highlighter-rouge">prod</code> 서비스 정의가 삭제되고, <code class="language-plaintext highlighter-rouge">nginx</code>, <code class="language-plaintext highlighter-rouge">app-blue</code>, <code class="language-plaintext highlighter-rouge">app-green</code> 서비스가 새로 정의되어있다. 이는 블루/그린 배포 전략을 위한 핵심적인 내용만을 담고 있어서, 빌드 시 production으로 완전히 빌드되어주는 것만을 바라본다.</li>
</ul>

<h4 id="3-nginx-리버스-프록시reverse-proxy-및-블루그린-배포-설정">3. Nginx 리버스 프록시(Reverse Proxy) 및 블루/그린 배포 설정</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리 생성 및 설정 파일 추가</strong>: <code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리가 새로 생성되었고, 그 안에 <code class="language-plaintext highlighter-rouge">Dockerfile</code>과 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 를 만들었다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>: Nginx 이미지를 빌드한다. 기존 설정을 배제하는 것 까지만 포함된다.</li>
      <li><code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>: <code class="language-plaintext highlighter-rouge">nextjs_app</code> 업스트림을 통해 Next.js 앱(<code class="language-plaintext highlighter-rouge">app-blue:3000</code>으로 초기 설정)으로 트래픽을 전달하도록 설정시키는 용이다. 이는 Jenkins와 같은 CI/CD 도구를 통한 동적 배포를 염두에 둔 구성.</li>
    </ul>
  </li>
  <li><strong>블루/그린 배포 전략 도입</strong>: 루트 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 <code class="language-plaintext highlighter-rouge">nginx</code> 서비스가 <code class="language-plaintext highlighter-rouge">app-blue</code>와 <code class="language-plaintext highlighter-rouge">app-green</code> 서비스에 의존하도록 설정하여, 무중단 배포를 위한 블루/그린 배포 전략의 기반을 마련하였다.</li>
</ul>

<hr />

<h2 id="배운-것들-정리">배운 것들 정리</h2>
<h3 id="멀티-스테이지-빌드multi-stage-build">멀티 스테이지 빌드(Multi-stage build)</h3>
<ul>
  <li>멀티스테이지 빌드는 최종 이미지를 <strong>최대한 가볍고 안전하게</strong> 만들기 위해, 하나의 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 안에 여러 개의 독립적인 빌드 환경(스테이지)을 정의하는 기술이다.</li>
</ul>

<h4 id="필요한-이유는">필요한 이유는?</h4>
<p>만약 스테이지 개념 없이 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 작성하면, 다음과 같은 문제가 발생할 수 있다.</p>
<ol>
  <li><strong>이미지 비대화 (Bloated Image)</strong>: 코드를 빌드하기 위해 설치했던 <code class="language-plaintext highlighter-rouge">typescript</code>, <code class="language-plaintext highlighter-rouge">eslint</code> 같은 모든 개발용 도구(<code class="language-plaintext highlighter-rouge">devDependencies</code>)가 최종 실행 이미지에 불필요하게 포함된다.</li>
  <li><strong>보안 취약점 (Security Risk)</strong>: 사용하지 않는 도구나 라이브러리가 많을수록, 해커가 악용할 수 있는 공격 지점(Attack Surface)이 늘어난다.</li>
</ol>

<hr />
<h4 id="작동-원리-from--as-와-copy---from">작동 원리: <code class="language-plaintext highlighter-rouge">FROM ... AS</code> 와 <code class="language-plaintext highlighter-rouge">COPY --from</code></h4>

<p>멀티스테이지 빌드는 이 두 가지 명령어로 동작한다.</p>
<h5 id="1-from--as-스테이지_이름">1. <code class="language-plaintext highlighter-rouge">FROM ... AS &lt;스테이지_이름&gt;</code></h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Dockerfile</code>에서 <code class="language-plaintext highlighter-rouge">FROM</code> 명령어가 나올 때마다 새로운 스테이지가 시작됩니다. 이는 <strong>이전 스테이지와는 완전히 격리된, 새로운 환경</strong>에서 시작한다는 뜻이다.</li>
  <li><code class="language-plaintext highlighter-rouge">AS &lt;스테이지_이름&gt;</code> (예: <code class="language-plaintext highlighter-rouge">AS builder</code>) 구문을 사용해, 해당 스테이지에 우리가 알아볼 수 있는 <strong>이름표</strong>를 붙여주는 역할을 한다.</li>
</ul>

<h5 id="2-copy---from스테이지_이름">2. <code class="language-plaintext highlighter-rouge">COPY --from=&lt;스테이지_이름&gt;</code></h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">COPY</code> 명령어에 <code class="language-plaintext highlighter-rouge">--from</code> 플래그를 사용하면, 다른 스테이지에 붙여둔 이름표를 호출하여 <strong>해당 스테이지의 결과물만</strong> 현재 스테이지로 가져올 수 있다.</li>
</ul>

<h4 id="실-예제로-보면">실 예제로 보면?</h4>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ======= 1. BASE 스테이지 =======</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:22-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">base</span>
<span class="c"># 작업 위치 설정 - 해당 컨테이너 위치 </span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># pnpm 설치 </span>
<span class="k">RUN </span>npm <span class="nb">install</span> <span class="nt">-g</span> pnpm

<span class="c"># package.json, pnpm-lock.yaml 등 의존성 관련 파일만 복사</span>
<span class="k">COPY</span><span class="s"> package.json pnpm-lock.yaml ./</span>

<span class="c"># ======= 2. dev용 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">base</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">dev_runner</span>
<span class="c"># 의존성 설치 - dev 용</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span>

<span class="c"># ======= 3. 빌드 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">dev_runner</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>

<span class="c"># 나머지 소스 코드 전체 복사 </span>
<span class="k">COPY</span><span class="s"> . .</span>

<span class="c"># 애플리케이션 빌드</span>
<span class="k">RUN </span>pnpm run build

<span class="c"># ======= 4. 의존성 증류 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">base</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">prod_modules_setter</span>

<span class="c"># 의존성 중 production용만 받아오기</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span> <span class="nt">--prod</span>

<span class="c"># ======= 5. prod 실행 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:22-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">runner</span>

<span class="c"># 작업 디렉토리 설정 </span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># 빌드 스테이지의 운영에 필요한 파일들만 복사 </span>
<span class="c"># 1. 빌드 결과물 </span>
<span class="k">COPY</span><span class="s"> --from=builder /app/.next ./.next</span>

<span class="c"># 2. 정적 파일</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/public ./public</span>

<span class="c"># 3. 운영용 의존성</span>
<span class="k">COPY</span><span class="s"> --from=prod_modules_setter /app/node_modules ./node_modules</span>

<span class="c"># 4. package.json 파일</span>
<span class="k">COPY</span><span class="s"> --from=prod_modules_setter /app/package.json ./package.json</span>

<span class="c"># 애플리케이션이 사용할 포트 노출 </span>
<span class="k">EXPOSE</span><span class="s"> 3000</span>

<span class="c"># 컨테이너 시작 시 명령어</span>
<span class="k">CMD</span><span class="s"> ["node", "./node_modules/next/dist/bin/next", "start"]</span>
</code></pre></div></div>

<ul>
  <li>BASE 스테이지는 공통된 영역까지를 전제로 작성되어 레이어를 구성한다.</li>
  <li>dev 개발 환경은 모든 의존성을 설치 및 HR(핫리로딩)으로 동작하므로 <code class="language-plaintext highlighter-rouge">dev_runner</code> 스테이지에서 모든 의존성을 받아서, 설정을 종료 하게 된다.(docker-compose.yml 을 통해)</li>
  <li>prod 의 경우 <code class="language-plaintext highlighter-rouge">builder</code> 를 통해 빌드가 이루어지는데, 이때 빌드 하면서 개발환경의 노드 모듈들을 포함해야 하는데, 그렇기에 실제 프로덕션 환경에서 필요한 노드 모듈만 받아오지 못하게 되어 있다.</li>
  <li>그렇기에 <code class="language-plaintext highlighter-rouge">prod_modules_setter</code>는 다시 <code class="language-plaintext highlighter-rouge">base</code> 기반에서 –prod 옵션을 통해 프로덕션에서 필요한 것들만을 받아 놓는 역할만을 수행한다.</li>
  <li>최종적으로 <code class="language-plaintext highlighter-rouge">runner</code>는 빌드된 파일, 순수한 production 기반의 모듈들만을 받아서, 깔끔하게 실행된다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 17일 개발 내용 요약 및 학습 정리 📝 Jenkins 무중단 배포 구축을 위한 추가 밑작업 ✨ 목적 (Purpose)]]></summary></entry><entry><title type="html">TIL - Next.js</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs.html" rel="alternate" type="text/html" title="TIL - Next.js" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs.html"><![CDATA[<h2 id="2025년-10월-14일-개발-내용-요약-및-학습-정리">2025년 10월 14일 개발 내용 요약 및 학습 정리</h2>

<h3 id="1-개발-내용-요약">1. 개발 내용 요약</h3>

<p>2025년 10월 14일, Next.js 프로젝트의 개발 환경 설정을 Docker 기반으로 고도화하는 작업이 완료되었다. 주요 내용은 다음과 같다.</p>

<ul>
  <li><strong>Next.js 프로젝트 설정:</strong> <code class="language-plaintext highlighter-rouge">create-next.js-app</code>을 사용하여 TypeScript 기반의 Next.js 프로젝트를 생성하고, <code class="language-plaintext highlighter-rouge">pnpm</code>을 최신 버전으로 업데이트하며 Next.js 15 버전으로 시작했다. Turbopack 사용 여부에 대한 검토 후, 현재 안정화된 webpack 기반으로 진행했다.</li>
  <li><strong>Docker 환경 구축:</strong>
    <ul>
      <li><strong>프로덕션(운영) Dockerfile 작성:</strong> 멀티 스테이지 빌드(Multi-stage builds)를 활용하여 <code class="language-plaintext highlighter-rouge">builder</code> 스테이지와 <code class="language-plaintext highlighter-rouge">runner</code> 스테이지로 나누어 효율적인 Docker 이미지를 생성했다. <code class="language-plaintext highlighter-rouge">builder</code> 스테이지에서는 의존성 설치 및 빌드를 수행하고, <code class="language-plaintext highlighter-rouge">runner</code> 스테이지에서는 빌드된 결과물만을 복사하여 가볍고 최적화된 운영 이미지를 구성했다. <code class="language-plaintext highlighter-rouge">.dockerignore</code> 파일을 통해 불필요한 파일이 이미지에 포함되지 않도록 설정했다.</li>
      <li><strong>Docker Compose를 활용한 개발 환경 구축:</strong> <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일을 작성하여 개발 환경(<code class="language-plaintext highlighter-rouge">dev</code> 서비스)을 설정했다. <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 <code class="language-plaintext highlighter-rouge">builder</code> 스테이지를 사용하고, <code class="language-plaintext highlighter-rouge">npm run dev</code> 명령어를 오버라이드하여 HMR(Hot Module Replacement)을 지원하며, 로컬 소스코드와 컨테이너를 볼륨으로 마운트하여 실시간 코드 변경이 반영되도록 했다.</li>
      <li><strong>Docker Compose를 활용한 프로덕션 환경 추가 및 분리:</strong> 동일한 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일 내에 프로덕션 환경(<code class="language-plaintext highlighter-rouge">prod</code> 서비스)을 추가했다. <code class="language-plaintext highlighter-rouge">prod</code> 서비스는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 전체를 빌드하되, 볼륨 마운트 없이 빌드된 이미지를 그대로 사용하고 <code class="language-plaintext highlighter-rouge">npm start</code> 명령어로 운영 서버를 실행하도록 설정했다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">package.json</code> 스크립트 연동:</strong> 개발 편의성을 극대화하기 위해 <code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">pnpm start:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm start:prod</code>, <code class="language-plaintext highlighter-rouge">pnpm set:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm set:prod</code>, <code class="language-plaintext highlighter-rouge">pnpm unset:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm unset:prod</code> 등의 Docker Compose 관련 스크립트를 추가하여 개발 경험(DX)을 효율화했다.</li>
</ul>

<h3 id="2-학습-내용-정리">2. 학습 내용 정리</h3>

<p>이번 개발 환경 설정을 통해 다음과 같은 내용을 학습하고 정리했다.</p>

<ul>
  <li><strong>Next.js 프로젝트 생성 및 기본 설정:</strong> <code class="language-plaintext highlighter-rouge">create-next-app</code> 사용법, TypeScript 및 <code class="language-plaintext highlighter-rouge">pnpm</code> 활용, Turbopack과 webpack의 차이점 및 선택 기준을 이해했다.</li>
  <li><strong>Docker Multi-stage Builds:</strong> 빌드 환경과 실행 환경을 분리하여 최종 이미지 크기를 최적화하고 보안을 강화하는 방법을 익혔다. 특히 <code class="language-plaintext highlighter-rouge">builder</code>와 <code class="language-plaintext highlighter-rouge">runner</code> 스테이지의 역할 분담을 명확히 이해했다.</li>
  <li><strong>Dockerfile 명령어 심층 이해:</strong> <code class="language-plaintext highlighter-rouge">RUN</code> vs <code class="language-plaintext highlighter-rouge">CMD</code>의 차이점, <code class="language-plaintext highlighter-rouge">COPY</code> 명령어의 역할과 캐싱 메커니즘, <code class="language-plaintext highlighter-rouge">alpine</code> 리눅스 이미지를 사용하는 이유(작은 크기, 보안) 등을 구체적으로 파악했다.</li>
  <li><strong>Docker Compose 활용:</strong> <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>을 통해 개발(<code class="language-plaintext highlighter-rouge">dev</code>) 및 운영(<code class="language-plaintext highlighter-rouge">prod</code>) 환경을 분리하고 관리하는 방법을 배웠다. 특히 개발 환경에서의 볼륨 마운트를 통한 HMR 구현과 프로덕션 환경에서의 최적화된 이미지 사용 방식을 이해했다.</li>
  <li><strong>개발 경험(DX) 최적화:</strong> <code class="language-plaintext highlighter-rouge">package.json</code> 스크립트를 활용하여 복잡한 Docker Compose 명령어를 단순화하고, 개발 워크플로우를 간소화하는 방법을 적용했다.</li>
</ul>

<h3 id="3-다음-단계-레포지토리-및-ai-리뷰-기능-연동">3. 다음 단계: 레포지토리 및 AI 리뷰 기능 연동</h3>

<p>이번 Docker 기반 개발 환경 설정을 성공적으로 마무리함에 따라, 다음 단계로는 이 환경을 기반으로 코드의 버전 관리 및 AI 기반 코드 리뷰 기능을 연동하는 작업을 진행할 예정이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="Front-End" /><summary type="html"><![CDATA[2025년 10월 14일 개발 내용 요약 및 학습 정리]]></summary></entry><entry><title type="html">Redis, 최근 보안 위협과 대응 방안</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/10/redis-critical-security-issues.html" rel="alternate" type="text/html" title="Redis, 최근 보안 위협과 대응 방안" /><published>2025-10-10T00:00:00+00:00</published><updated>2025-10-10T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/10/redis-critical-security-issues</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/10/redis-critical-security-issues.html"><![CDATA[<h3 id="redis-성능과-편의성-뒤에-숨겨진-보안-위협과-대응-방안">Redis, 성능과 편의성 뒤에 숨겨진 보안 위협과 대응 방안</h3>

<p>많은 시스템에서 캐싱(Caching) 전략이나 메시지 큐(Message Queue)의 구현체로 Redis를 활발하게 사용한다. 이전 직장에서 근무할 당시, 데이터베이스의 부하를 줄이고 애플리케이션의 응답 속도를 높이기 위해 Redis 도입을 적극적으로 추진했던 경험이 있다. 과정은 순탄치 않았고 여러 어려움이 있었지만, 성공적으로 적용한 뒤 눈에 띄게 향상된 성능과 줄어든 DB 사용량을 보며 큰 보람을 느꼈다.</p>

<h4 id="최근-동향과-경각심">최근 동향과 경각심</h4>

<p>최근 Redis의 보안 취약점을 악용한 공격 사례에 대한 보안뉴스 기사를 접하게 되었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-10-023.png" alt="" /></p>

<ul>
  <li><strong>참고 기사</strong>: <a href="https://m.boannews.com/html/detail.html?idx=139675">https://m.boannews.com/html/detail.html?idx=139675</a></li>
</ul>

<p>기사의 핵심은 <strong>별도의 인증 없이 외부에 노출된 Redis 서버가 주요 공격 대상이 되고 있다는 점</strong>이다. 많은 개발 환경에서 기능 구현의 편의성이나 개발 속도를 우선시하여 보안 설정을 간과하는 경우가 많다. 과거의 프로젝트들을 돌이켜보면, 나 또한 개발 편의를 위해 일부 보안 설정을 관대하게 적용했던 순간들이 있었다. 따라서 해당 기사를 계기로 Redis를 안전하게 운영하기 위해 반드시 적용해야 할 설정들을 다시 한번 정리하고 상기하고자 한다.</p>

<h4 id="redis-보안-강화를-위한-핵심-수칙">Redis 보안 강화를 위한 핵심 수칙</h4>

<p>기사에 따르면, 공격자는 외부에 노출된 Redis 서버에 접근해 데이터를 탈취하거나 서버를 악성코드 유포의 숙주로 삼을 수 있다. 이를 방지하기 위해 다음과 같은 설정은 필수로 적용해야 한다.</p>

<ol>
  <li>
    <p><strong>네트워크 격리를 통한 접근 제어</strong></p>

    <ul>
      <li>
        <p>Redis는 <strong>로컬 호스트(127.0.0.1) 바인딩을 기본 원칙</strong>으로 삼아야 한다. <code class="language-plaintext highlighter-rouge">redis.conf</code> 파일의 <code class="language-plaintext highlighter-rouge">bind</code> 지시어를 <code class="language-plaintext highlighter-rouge">bind 127.0.0.1</code>로 설정하여 외부에서의 직접적인 접근을 원천적으로 차단하는 것이 가장 중요하다.</p>
      </li>
      <li>
        <p>클라우드 환경(e.g., AWS)에서 여러 인스턴스를 운영할 때, <strong>같은 VPC(Virtual Private Cloud) 내에서 Private IP를 통해 통신하도록 아키텍처를 설계</strong>하는 것이 비용 효율성과 보안 강화 측면에서 필수적이다. 보안 수준을 높이기 위해 <code class="language-plaintext highlighter-rouge">0.0.0.0</code>과 같이 모든 인터페이스를 개방하는 설정은 반드시 지양해야 한다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>강력한 인증 체계 및 명령어 제어</strong></p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">redis.conf</code> 파일 내의 <code class="language-plaintext highlighter-rouge">requirepass</code> 항목을 통해 <strong>복잡하고 추측하기 어려운 비밀번호를 설정</strong>하는 것은 기본적이면서도 필수적인 조치이다. 데이터베이스와 달리 Redis의 데이터는 휘발성(in-memory)이라는 생각에 인증 절차의 중요성을 간과하기 쉽지만, 이는 세션 하이재킹이나 데이터 유출 등 심각한 보안 사고로 이어질 수 있는 매우 위험한 접근이다.</p>
      </li>
      <li>
        <p>데이터 전체 삭제(<code class="language-plaintext highlighter-rouge">FLUSHALL</code>, <code class="language-plaintext highlighter-rouge">FLUSHDB</code>)나 서버 설정 변경(<code class="language-plaintext highlighter-rouge">CONFIG</code>)과 같이 시스템 운영에 치명적인 영향을 줄 수 있는 명령어는 <code class="language-plaintext highlighter-rouge">rename-command</code> 설정을 통해 <strong>예측 불가능한 이름으로 변경하거나 비활성화</strong>하여 명령어 실행에 대한 리스크를 최소화해야 한다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>지속적인 버전 관리 및 모니터링</strong></p>

    <ul>
      <li>
        <p>소프트웨어의 구 버전에는 <strong>알려진 보안 취약점(CVE)이 존재</strong>할 수 있다. 따라서 항상 안정화된 최신 버전으로 Redis를 유지하여 잠재적인 위협을 사전에 방지해야 한다.</p>
      </li>
      <li>
        <p>외부로부터의 비정상적인 접근 시도나 내부에서의 비인가 명령어 실행 여부 등을 지속해서 감시할 수 있는 <strong>모니터링 및 로깅 시스템을 구축</strong>하는 것이 중요하다. 이를 통해 이상 징후를 조기에 탐지하고 신속하게 대응할 수 있다.</p>
      </li>
    </ul>
  </li>
</ol>

<p>결론적으로 향후 진행할 프로젝트에도 캐싱 전략은 선택이 아닌 필수 요소이다. 그때마다 안전하고 효율적인 Redis 환경을 구축하기 위해, 이번에 정리한 내용들을 표준 체크리스트로 활용하고자 한다. 더 나아가, 향후에는 이러한 보안 설정들을 코드화하여 구성 관리(Configuration Management)의 일부로 포함시키는 것을 목표로 해야겠다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Redis, 성능과 편의성 뒤에 숨겨진 보안 위협과 대응 방안]]></summary></entry><entry><title type="html">Ubuntu 서버 설정 할 때 snap 사용 시 주의해야하는 이유는?</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue.html" rel="alternate" type="text/html" title="Ubuntu 서버 설정 할 때 snap 사용 시 주의해야하는 이유는?" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2025/10/09/00-snap-package-management-with-issue.html"><![CDATA[<h2 id="ubuntu에서-docker를-sudo-없이-사용하려다-발견한-snap-설치의-함정">Ubuntu에서 Docker를 sudo 없이 사용하려다 발견한 snap 설치의 함정</h2>

<h3 id="문제-상황">문제 상황</h3>

<p>Project 를 위하여 Ubuntu 서버 머신을 한대 구했다. Geekom의 A5 7530U 칩셋 탑재 제품으로 윈도우 데스크탑은 나쁘지 않으나, 전성비나, 항시 켜놓고 사용 하기 위함, WSL의 번거로움 등을 고려할 때, 온전한 리눅스 전용 머신의 필요성으로 미니 PC 를 한대 구매했다.</p>

<p>Ubuntu 22.04 LTS 기반으로 설치 후, 개발환경 설정, 컨테이너 활용을 위해 Docker 설정까지 끝냈었다. 그리하여 Docker 명령어를 실행할 때마다 <code class="language-plaintext highlighter-rouge">sudo</code>를 입력하는 것이 번거로워, 일반 사용자 계정을 docker 그룹에 추가하려고 했다. 그런데 예상치 못한 문제들이 연쇄적으로 발생했는데…</p>

<h3 id="발견한-문제들">발견한 문제들</h3>

<h4 id="1-docker-그룹이-존재하지-않음">1. docker 그룹이 존재하지 않음</h4>

<p>일반적으로 Docker를 설치하면 자동으로 생성되는 <code class="language-plaintext highlighter-rouge">docker</code> 그룹이 시스템에 존재하지 않았다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/group | <span class="nb">grep </span>docker
<span class="c"># 결과: 아무것도 출력되지 않음</span>
</code></pre></div></div>

<h4 id="2-systemctl로-docker-서비스를-찾을-수-없음">2. systemctl로 Docker 서비스를 찾을 수 없음</h4>

<p>Docker가 분명 설치되어 있고 실행도 되는데, <code class="language-plaintext highlighter-rouge">systemctl status docker</code> 명령이 작동하지 않았다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
<span class="c"># Docker version 24.x.x 등 정상 출력</span>

systemctl status docker
<span class="c"># Unit docker.service could not be found.</span>
</code></pre></div></div>

<h4 id="3-원인-snap으로-설치된-docker">3. 원인: snap으로 설치된 Docker</h4>

<p>Docker 그룹이 설정이 안되는 경우는 공식 가이드 문서에서 볼 때 수동 설치만 해주면 되는 것이었다. <a href="https://docs.docker.com/engine/install/linux-postinstall/">링크</a>
단, 다른 문제들에 대해서는 찾아본 결과 snap 패키지였던 것이 문제의 근본 원인이었다. (이번엔 편한게 해보겠다고 스토어로 GUI 로 설치했더니만…)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snap list | <span class="nb">grep </span>docker
<span class="c"># docker    xx.x.x    xxxx    latest/stable    canonical    -</span>
</code></pre></div></div>

<h3 id="snap-vs-apt-무엇이-다른가">snap vs apt: 무엇이 다른가?</h3>

<h4 id="snap의-특징">snap의 특징</h4>

<p>snap은 Ubuntu에서 개발한 독립적인 패키지 시스템으로, 다음과 같은 특징이 있다:</p>

<ul>
  <li><strong>완전한 격리(confinement)</strong>: 앱을 샌드박스 환경에서 실행</li>
  <li><strong>자체 포함(self-contained)</strong>: 모든 의존성을 패키지 내부에 포함</li>
  <li><strong>보안 우선</strong>: 시스템 리소스 접근이 제한적</li>
  <li><strong>자동 업데이트</strong>: 백그라운드에서 자동으로 업데이트</li>
</ul>

<h4 id="apt의-특징">apt의 특징</h4>

<p>전통적인 패키지 관리 시스템으로:</p>

<ul>
  <li><strong>시스템 통합</strong>: 시스템 라이브러리를 직접 공유</li>
  <li><strong>완전한 접근</strong>: 시스템 리소스에 제약 없이 접근</li>
  <li><strong>가벼움</strong>: 공유 라이브러리 사용으로 용량 절약</li>
  <li><strong>수동 관리</strong>: 사용자가 직접 업데이트 제어</li>
</ul>

<hr />
<h4 id="docker에는-왜-apt가-적합한가">Docker에는 왜 apt가 적합한가?</h4>

<p>결과적으로 차이점을 고려해본 결과  Docker는 시스템 레벨에서 동작하는 도구이므로:</p>

<ul>
  <li>호스트 파일시스템에 광범위하게 접근 필요</li>
  <li>네트워크, 프로세스, 저장소 등 시스템 리소스 제어 필요</li>
  <li>snap의 격리 정책이 오히려 제약으로 작용</li>
</ul>

<p>일반 사용자에게는 snap이 편리하고 안전하지만, <strong>서버 개발 도구로는 apt 방식이 훨씬 적합하다는 결론을 내릴 수 있었다</strong>.</p>

<h3 id="해결-방법-snap-제거-후-apt로-재설치">해결 방법: snap 제거 후 apt로 재설치</h3>

<h4 id="1-기존-snap-docker-제거">1. 기존 snap Docker 제거</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>snap remove docker
</code></pre></div></div>

<h4 id="2-기존-apt-docker-패키지-제거-있을-경우-대비">2. 기존 apt Docker 패키지 제거 (있을 경우 대비)</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt remove docker docker-engine docker.io containerd runc
</code></pre></div></div>

<h4 id="3-docker-공식-저장소에서-설치">3. Docker 공식 저장소에서 설치</h4>

<p><strong>필수 패키지 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> ca-certificates curl gnupg lsb-release
</code></pre></div></div>

<p><strong>Docker 공식 GPG 키 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo install</span> <span class="nt">-m</span> 0755 <span class="nt">-d</span> /etc/apt/keyrings
curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/docker.gpg
<span class="nb">sudo chmod </span>a+r /etc/apt/keyrings/docker.gpg
</code></pre></div></div>

<p><strong>Docker 저장소 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="se">\</span>
  <span class="s2">"deb [arch=</span><span class="si">$(</span>dpkg <span class="nt">--print-architecture</span><span class="si">)</span><span class="s2"> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu </span><span class="se">\</span><span class="s2">
  </span><span class="si">$(</span>lsb_release <span class="nt">-cs</span><span class="si">)</span><span class="s2"> stable"</span> | <span class="nb">sudo tee</span> /etc/apt/sources.list.d/docker.list <span class="o">&gt;</span> /dev/null
</code></pre></div></div>

<p><strong>Docker 설치:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre></div></div>

<h4 id="4-일반-사용자로-docker-사용-설정">4. 일반 사용자로 Docker 사용 설정</h4>

<p><strong>docker 그룹에 사용자 추가:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>usermod <span class="nt">-aG</span> docker <span class="nv">$USER</span>
</code></pre></div></div>

<p><strong>변경사항 적용:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newgrp docker
<span class="c"># 또는 로그아웃 후 재로그인</span>
</code></pre></div></div>

<p><strong>설치 확인:</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
docker run hello-world
</code></pre></div></div>

<h3 id="주의사항">주의사항</h3>

<h4 id="보안-고려사항">보안 고려사항</h4>

<p>docker 그룹에 속한 사용자는 <strong>root 권한과 동등한 접근</strong>이 가능하다. 이는 다음을 의미한다:</p>

<ul>
  <li>컨테이너를 통해 호스트 시스템의 모든 파일에 접근 가능</li>
  <li>권한 상승(privilege escalation) 위험 존재</li>
  <li>보안이 중요한 환경에서는 신중히 고려 필요</li>
</ul>

<h4 id="데이터-백업">데이터 백업</h4>

<p>snap에서 apt로 전환 시 기존 데이터가 삭제된다:</p>

<ul>
  <li>snap Docker 컨테이너 및 이미지: 모두 삭제됨</li>
  <li>볼륨 데이터 경로: <code class="language-plaintext highlighter-rouge">/var/snap/docker/</code>에서 <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>로 변경</li>
  <li>중요한 데이터가 있다면 사전에 <code class="language-plaintext highlighter-rouge">docker save</code>, <code class="language-plaintext highlighter-rouge">docker export</code> 등으로 백업 필요</li>
</ul>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://docs.docker.com/engine/install/linux-postinstall/">Docker 공식 문서 - Linux 설치 후 설정</a></li>
  <li><a href="https://docs.docker.com/engine/install/ubuntu/">Docker 공식 문서 - Ubuntu 설치</a></li>
  <li><a href="https://docs.docker.com/engine/security/rootless/">Docker 공식 문서 - Rootless 모드</a></li>
</ul>

<h3 id="결론">결론</h3>

<p>GUI를 통한 편리한 설치가 항상 최선은 아니네 싶다. 특히 개발 도구의 경우, 패키지 관리 방식에 따라 동작 방식과 시스템 통합 수준이 크게 달라진다. Docker처럼 시스템 레벨 접근이 필요한 도구는 snap보다 전통적인 apt 방식이 더 적합하며, 이를 통해 불필요한 제약 없이, 최적화된 개발 환경을 구축할 수 있다.</p>

<p>물론 일반 사용에선 전혀 그렇지 않다고 생각도 든다. 왜냐면 리눅스 시스템의 라이브러리의 의존성 문제로 업데이트를 잘못하면 큰일나는 경우를 몇 번 경험했고(…) 무지성하게 구글에서 명령어 긁어다가, install 박아버리는 순간 지옥이 펼쳐지는 경우를 생각한다면(…). 의존성을 확실하게 관리하고 마치 Docker 처럼 정확하게 컨테이너화 시키는게 확실히 이유가 있어 보였다. 이러한 지점에서 Ubuntu 가 일반 소비자용의 철학을 가진 OS 라는 점을, 새삼 느끼게 만든다. (근데 프로세스까지 독립적으로 관리하게 하는 건 좀…)</p>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="DevOps" /><category term="Docker" /><category term="Linux" /><summary type="html"><![CDATA[Ubuntu에서 Docker를 sudo 없이 사용하려다 발견한 snap 설치의 함정]]></summary></entry><entry><title type="html">Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html" rel="alternate" type="text/html" title="Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html"><![CDATA[<h2 id="obsidian--copilot---나만의-글쓰기-agent를-만들어보자">Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자</h2>
<h3 id="글쓰기의-길은-멀고도-험하다">글쓰기의 길은 멀고도 험하다</h3>

<p>기술 블로그를 써라.</p>

<p>프로젝트의 후기나, 느낀 점. 기술의 효용성이나 고민한 과정을 써라</p>

<p>개발자로 살아가는 이상, 노하우, 기술에 대한 이해를 표현하는 것이 프로그램의 ‘질’ 또는 ‘실력’을 결정한다는 개발 분야의 공통의 법칙은 언제나 우릴 괴롭힌다.</p>

<p>이에 끊임없이 글을 적어둬야 한다는 고통과 노이로제에 시달린다.</p>

<p>나 역시 글쓰기를 완전 잘한다거나 글을 뽑아내는 기계도 아니다. 그나마 글을 쓰는걸 좋아하는 편이라지만, 그럼에도 해야할 일 산더미인데, 언제 적냐.. 라는 말이 매번 튀어나온다. 글쓰기가 가장 시간을 많이 쓴다는 사실은 달라지지 않는다.</p>

<p>그러다가 최소 2-3주 걸릴 만한 미니 프로젝트, Obsidian + Copilot + gemini 의 에이전트 만들기를 진행해 보았다. 그리고 그걸 적용한 이 글. 이 글을 단 3일 만에 마무리 되었다면 믿겠는가?</p>

<p>AI를 활용해서 글을 대신 파바박, 하루 만에 뚝딱 하고 써주진 않지만… 그럼에도 이번 미니 프로젝트를 통해, 글쓰기, 학습에서 정말 도움이 되는 Agent 생성에 도전 그리고 나름의 결과를 만들어냈다.</p>

<p><strong>개인적으로 풀어내는 이 후기, 함께 적용 해본다면, 정말 괜찮게, 도움이 되는 글쓰기 보조 에이전트를 만들 수 있지 않을까?</strong> 조심스레 이야기를 시작해보고자 한다.</p>

<h2 id="본론">본론</h2>

<h3 id="시작은-obsidian-그리고-copilot">시작은 Obsidian 그리고 Copilot</h3>
<p>Notion 은 많이들 쓸 것이다. 언제 어디서든, 그리고 어떤 장비든 웹 기반의 Notion은 데이터를 저장하기에 적절하다고 생각하는 이들이 많다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-003.png" alt="" /></p>

<p>하지만 한때 이를 진지하게 써본 입장에서, Obsidian을 주력 정보 저장, 글쓰기 도구로 쓰게되었다. 이유는 다음과 같다.</p>

<ol>
  <li>Notion 업데이트 시 잔버그가 수시로 발생하는데, 데이터 영역까지 함께 문제가 되는 경우가 발생함.(데이터 삭제도 발생한다.)</li>
  <li>한글 유저는 영어보다 특히나 버그 발생률이 높다</li>
  <li>문서 양이 많아지면, 유료 계정임에도 검색 문제, 버벅거림 문제가 발생한다</li>
</ol>

<p>요즘은 많이 나아졌다고 하지만, 한 번쯤 API 문서 같은거 만들어두었다가 날려먹어보면, Notion은 쳐다보지도 않게 된다. 그냥 포트폴리오 를 위한 간단 공유용 정도면 모를까.</p>

<p>Obsidian은 가벼우며, 검색, 태깅 등 기본적인 기능이 강력하다. 특히나 퍼포먼스가 매우 훌륭하다. 플러그인도 제공하기 때문에, 이를 활용하면 Notion 그 이상의 확장성, 사용성, 글쓰는 데 편리함을 제공해준다. 그리고 운명 같은 날이 찾아왔으니… 바로 <code class="language-plaintext highlighter-rouge">Copilot</code> 이란 플러그인을 발견했을 때였다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-004.png" alt="" /></p>

<p>코파일럿. 누가보면 윈도우에서 만든 AI 인줄알 것 같다. 이 플러그인은 단어 의미대로의 윈도우의 AI와는 별도의 플러그인이다. 당당하게 유료 결제 버전도 존재하는데, 그에 대해선 나중에 이야기 하려고 하고, 지금은 이 녀석이 뭔가에 대해 설명해주려고 한다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-005.png" alt="" /></p>

<h3 id="ai-좀더-통합-좀더-효율적이게-분신-만들기">AI, 좀더 통합, 좀더 효율적이게.. 분신 만들기?</h3>

<p>AI 가 말 하나는 기똥차게 하고, 이미 VSC 나 각종 IDE 는 통합이 이루어졌다. 그런데 이 Copilot 은 글쓰기 도구인 Obsidian을 그렇게 만들어주는 프로그램이다. 설치 방법은 간단하다. 로컬 LLM 이나, api 키를 활용해 연결이 된다. 만약 API 발급이 궁금하면 하단의 글을 참고하면 좋다.</p>

<p>연결하고, 사용을 해보니 순간 머릿속에 스치는 게 있었다.</p>

<blockquote>
  <p>“이 정도 통합이면… 나 대신 글쓰기 해줄 수 있지 않을까?”</p>
</blockquote>

<p>본론으로 돌아와서 글쓰기. 생각해보면 학습, 개발을 하다보면 글쓸 자료는 넘쳐났다. 지금까지는 gemini + 기타 다른 ai  이런 식으로 하여 사용도 해보았고. gemini 의 세부 기능을 활용한다거나 gemini-cli 라는 프로그램으로 내 맥북 내부에서 llm 을 구동해 자료를 취합, 글을 써보기도 해보았다.</p>

<p>하지만 이런 방식이  대중화되거나 입소문을 많이 타진 않았다. 왜그런가? 우선, 다양한 자료, 글감은 여기저기 흩뿌려져 있는 경우가 있다. 설치도 복잡하고, 오류도 있다. 뿐만 아니라, 정리를 해서 어딘가에 모아서 글감들을 정리해도,  ‘나답게’, ‘내 냄새’ 가 나는 글로 만들 수 있냐! 라고 하면 그렇지 않기 때문에, 실상 내가 알고 있는 것들을 모아서 글을 쓰는 것과 큰 차이가 없는 것이다.</p>

<p>그러는 와중에 Copilot 의 기능으로 <code class="language-plaintext highlighter-rouge">Command</code>라는 기능을 발견하였다. 단순히 LLM 을 연결만 해주는게 아니라, 직접 명령을 적어서 매크로처럼 쓸 수 있는데, 심지어 프롬프트로 전역 설정하는 것들도 있는 것이 아닌가?</p>

<p><strong>그리고 아까 전 상황. 그렇다. 이정도면 나의 문체를 그대로 문서화, 프롬프트화 시켜서 등록을 해두면, ‘딸깍’ 하고 글을 써줄수 있지 않을까? 이 생각에 무릎을 탁친 나는 도전을 해보기로 하였다.</strong></p>

<h4 id="나를-분석해보자-how">나를 분석해보자 How?</h4>

<p>우선, 첫 시작은 나를 분석하는 것이다. 내가 누굴까? 글로 표현되는 나를 AI 가 모방하는게 우선이라고 생각했다. 나는 가능하면 나의 주관적 판단이 들어가는 것은 좋지 않다고 생각했다. 나의 주관은 나에 대한 여러 측면에 대해 ‘과소평가’ 와 ‘과대평가’가 함께 공존하고 있다고 생각하기 때문이다. 그러니 나에 대한 긍정 평가도 부정 평가도 아닌 어딘가의 제 3자 관점에서 분석을 하는 것이 가장 적절하다고 생각했다.</p>

<p>그런데 이제는 간단하다. 내가 쓴 글들을 다 가져와서 분석을 시키던가, 내 블로그에 AI 가 알아서 분석해라고 하는게 가능하다. 오히려 도구를 뭘 쓸지만 고민하면 되었다.  이에 Claude 와 Gemini 의 <code class="language-plaintext highlighter-rouge">deep research</code> 기능으로, 나의 글, 나의 문체에 대한 분석을 각각 요청했다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-006.png" alt="" />
<img src="/assets/images/posts/2025-10/2025-10-09-007.png" alt="" /></p>

<blockquote>
  <p>💡 핵심은 자신에 대한 분석을 준비하는 것이다. 방법의 제약은 없다. AI 를 활용해, 자신을 표현하는 자료들을 최대한 보여주면서 분석을 요청해라.</p>
</blockquote>

<h4 id="나의-분신을-등록해보았다">나의 분신을 등록해보았다.</h4>

<p>음~ 나의 계획은 완벽해! 이런 착각을 하며 Claude 와 Gemini 는 열심히 생각을, GPU가 녹고 있음을 느끼고 있었다. 이제 내가 퇴고만 해주면 되는게 아닌가! 새삼 AI 의 능력은 믿어 의심치 않고 있었고, 개발까지 가지 않아도 해결 될 수 있다는 이 행복한 시대를 살고 있음에 하늘을 향해 감사인사를 하면서, 기다렸다.</p>

<p>10분이 채 안되어, 결론은 순식간에 나왔고, 그 결과가 다음과 같았다.</p>

<pre><code class="language-plain"># gemini의 정확한 모사 버전
### Persona
당신은 '성실한 기술 기록자(Diligent Technical Archivist)'입니다. 당신의 주된 목표는 커리어 발전을 위해 스스로 학습한 기술 내용을 미래의 자신이 다시 참고할 수 있도록 정확하고 체계적으로 기록하는 것입니다. 당신의 글은 타인을 가르치기 위한 것이 아니라, 스스로의 이해를 완성하고 검증하기 위한 학습 과정의 산물입니다.

### Core Philosophy
모든 내용은 '촘촘한 학습'과 '치밀한 정리'라는 핵심 철학을 따라야 합니다. 피상적인 요약 대신, 공식 문서나 신뢰할 수 있는 자료를 기반으로 한 깊이 있고 상세한 내용을 우선시합니다. 정확성과 완전성이 가장 중요한 가치이며, 모든 기술적 설명은 검증 가능해야 합니다.

### Voice and Tone
- **어조**: 체계적이고, 객관적이며, 사실에 기반한 약간의 격식체를 사용합니다.
- **감정 배제**: 과장, 유머, 지나치게 친근한 말투는 피합니다.
- **목적 명시**: 글의 목적이 학습과 기록임을 명확히 하되, 독자를 가르치려는 듯한 계몽적인 어조는 사용하지 않습니다.

### Content Generation Modes
당신은 아래 두 가지 모드 중 하나로 콘텐츠를 생성해야 합니다. 각 모드는 목적과 형식 면에서 명확히 구분됩니다.

#### Mode 1: 심층 탐구 학습 로그 (Deep Dive Study Log)
- **목적**: Kubernetes, Docker, CS 기초 등 근본적이고 방대한 주제를 체계적으로 학습하고 정리합니다.
- **형식**:
    - 예상 읽기 시간 15~30분 분량의 긴 글을 작성합니다.
    - 공식 문서를 번역하거나 핵심 내용을 재구성하는 방식으로 정보를 전달합니다.
    - 복잡한 시스템을 구성 요소별로 나누어 상세히 설명합니다.
    - 제목은 '[기술명] - [세부 주제]' 형식을 따릅니다.
    - 논리적 흐름에 따라 명확한 소제목으로 내용을 구조화합니다.

#### Mode 2: 기술 메모 (Technical Memo)
- **목적**: 특정 도구 사용법, 문제 해결 과정, 설정 방법 등 구체적이고 실용적인 정보를 빠르게 기록합니다.
- **형식**:
    - 예상 읽기 시간 2~5분 분량의 짧고 간결한 글을 작성합니다.
    - '문제 상황 -&gt; 해결 과정 -&gt; 결과'의 구조를 명확히 합니다.
    - 필요한 경우 코드 스니펫, 설정 파일, 명령어 등을 정확히 포함합니다.
    - 제목은 'memo - [문제 또는 주제]'와 같이 직관적으로 작성합니다.

### Formatting and Structure
- **제목**: 기능적이고 내용을 명확히 설명하는 제목을 사용합니다.
- **마크다운**: 헤딩(##, ###), 목록(리스트), 코드 블록을 적극적으로 사용하여 가독성을 높입니다.
- **용어 사용**: 기술 용어는 한국어와 영어를 자연스럽게 혼용합니다. (예: 쿠버네티스 컨트롤 플레인(Control Plane))

### Task
이제 위의 모든 규칙을 준수하여 다음 요청을 수행해 주십시오:
[여기에 구체적인 콘텐츠 생성 요청 입력]
</code></pre>

<pre><code class="language-plain"># claude의 정확한 모사 버전
Paul2021-R 스타일로 글을 작성해주세요:

[문체 지침]
- 삼박자 수식어구로 리듬감 조성 (예: "종합적으로, 효율적으로, 효과적으로")
- 격식체 기본 + "...!" 감탄부호로 친근함 표현
- 영어 기술용어와 한국어 개념어 자연스럽게 혼용
- 불렛포인트와 계층적 구조로 체계적 정보 정리

[어조와 관점]
- 겸손하면서도 전문적인 태도 유지
- 솔직한 자기성찰과 현실적 사고
- 비전공자/학습자 관점에서의 공감과 조언
- 과정 중심적 서술 (결과보다는 시행착오 과정 중시)

[표현 스타일]
- 구체적 수치와 날짜로 생생함 표현
- 게임/레벨링 비유로 성장 과정 설명
- "하루 하루", "항상 고민하고, 궁금해하며" 같은 반복 패턴
- 실패 인정 후 교훈 도출하는 구조
</code></pre>

<p>내용은 읽으면 읽을수록 찰떡 같았다. 다소의 차이점은 Gemini의 경우 철학, 그리고 Mode 라는 식으로 내 글의 종류에 따라 다르게 접근하는 방법을 포함하여 프롬프트를 만들어주었다.</p>

<p>Claude 는 좀더 중립적이지만, 글의 형태를 따라하는 스타일 가이드 형태로 만들어준 것이 눈에 들어왔다. 그렇게 만들어진 내용들은 서로 특징은 다르지만 분명하게 ‘나’를 담고 있었다.</p>

<p>그렇게 생각하고 보니 하는 김에 이왕이면 글을 좀더 보완한다면 어떻게 하면 좋을까? 라는 생각도 들었다.  그렇기에 내 글의 아쉬운 점을 보완하는 프롬프트까지 만들어달라고 하였다.</p>

<pre><code class="language-plain"># gemini - 문체 개선 요청 버전 
### Persona
당신은 '전문가 멘토이자 성실한 기술 기록자(Expert Mentor and Diligent Archivist)'입니다. 당신은 자신의 심도 깊은 학습 과정을 기록함과 동시에, 당신과 비슷한 길을 걷는 다른 엔지니어들에게 의도적으로 명확하고 유용한 가이드를 제공합니다. 당신의 글은 개인적인 기록이자, 가치 있는 공유 자산입니다.

### Audience Awareness
당신의 글을 읽는 독자는 당신과 같이 똑똑한 엔지니어이지만, 당신과 동일한 사전 지식이나 맥락을 가지고 있지 않을 수 있다고 가정하십시오. 따라서 '무엇(what)'을 설명하기 전에 항상 '왜(why)'를 먼저 설명하여 동기를 부여하고 이해를 도와야 합니다.

### Core Philosophy
'촘촘한 학습'과 '치밀한 정리'의 원칙을 지키되, 이를 '명확한 전달'이라는 가치와 결합합니다. 기술적 정확성과 깊이를 유지하면서도, 독자가 개념을 직관적으로 이해할 수 있도록 돕는 것이 중요합니다.

### Narrative and Contextual Framing
모든 게시물은 반드시 다음 세 가지 구조적 요소를 포함해야 합니다.
1.  **도입부 - 맥락 설정 (Opening Context)**: 글의 시작 부분에 이 주제를 왜 지금 다루는지, 이것이 당신의 학습 여정에서 어떤 위치에 있는지를 1~2 문단으로 설명합니다.
2.  **본문 - 기술적 설명**: 핵심 기술 내용을 정확하고 상세하게 설명합니다.
3.  **결론부 - 개인적 종합 (Closing Synthesis)**: 글을 마무리하며, 이번 학습을 통해 얻은 핵심적인 깨달음, 다른 기술과의 연결점, 또는 개인적인 관점을 요약하여 제시합니다.

### Engagement and Readability Elements
콘텐츠 생성 시, 다음 요소들을 능동적으로 통합하여 가독성과 몰입도를 높여야 합니다.
- **비유 (Analogies)**: 복잡하고 추상적인 개념을 설명할 때, 독자의 직관적인 이해를 돕기 위한 적절한 비유를 포함시키십시오.
- **핵심 요약 (Key Takeaway)**: 각 중요 섹션이 끝나거나 글 전체의 마지막에, 핵심 내용을 강조하는 인용문(blockquote) 형식의 요약 박스를 추가하십시오.
- **질문형 소제목 (Interrogative Subheadings)**: "Service의 종류"와 같은 서술형 제목 대신, "쿠버네티스 Service에는 어떤 종류가 있으며, 각각은 언제 사용해야 하는가?"와 같은 질문형 제목을 사용하여 독자의 탐구심을 자극하십시오.

### Formatting and Structure
- **제목**: 기능적이면서도 독자의 흥미를 끌 수 있는 제목을 사용합니다.
- **마크다운**: 헤딩, 목록, 코드 블록, 인용문을 효과적으로 사용하여 시각적 계층 구조와 가독성을 극대화합니다.
- **용어 사용**: 기술 용어는 한국어와 영어를 자연스럽게 혼용합니다.

### Task
이제 위의 모든 규칙을 준수하여 다음 요청을 수행해 주십시오:
[여기에 구체적인 콘텐츠 생성 요청 입력]
</code></pre>

<pre><code class="language-plain"># claude - 문체 개선 요청 버전
Paul2021-R 스타일로 글을 작성해주세요:

[문체 지침]
- 삼박자 수식어구로 리듬감 조성 (예: "종합적으로, 효율적으로, 효과적으로")
- 격식체 기본 + "...!" 감탄부호로 친근함 표현
- 영어 기술용어와 한국어 개념어 자연스럽게 혼용
- 불렛포인트와 계층적 구조로 체계적 정보 정리

[어조와 관점]
- 겸손하면서도 전문적인 태도 유지
- 솔직한 자기성찰과 현실적 사고
- 비전공자/학습자 관점에서의 공감과 조언
- 과정 중심적 서술 (결과보다는 시행착오 과정 중시)

[표현 스타일]
- 구체적 수치와 날짜로 생생함 표현
- 게임/레벨링 비유로 성장 과정 설명
- "하루 하루", "항상 고민하고, 궁금해하며" 같은 반복 패턴
- 실패 인정 후 교훈 도출하는 구조
</code></pre>

<p>마지막으로 Gemini 와 Claude가 서로 다른 시각. 다른 형태의 프롬프트이니, 이걸 합치면 서로 부족한 부분을 보완하고, 완벽해지지 않을까? 아까 전에 언급했던 제 3의 관점의 완전체가 이것이라 생각했다. 화룡점정.</p>

<p>예전부터 gemini, 구글의 모델은 서비스 차원에서 과도한 긍정성, 아첨이 문제시 되기도 했는데, 그러니 서로 다른 관점을 엮거나 합친다면 얼마나 좋을까? 두 모델의 차이를 포함하여 온전한 프롬프트, 강력한 프롬프트를 상상했다. 머릿속에선 이미 나를 대신할 새로운 분신 1호의 탄생에 종이 울리고 있었다. 결과물을 만들 때였다.</p>

<h3 id="context-engineering">Context Engineering</h3>
<h4 id="-뭔가-이상하다--결과물의-상태가-">🤔 뭔가 이상하다 : 결과물의 상태가 ?</h4>

<p>나는 눈을 의심했다. 정리하고, 프롬프트를 등록하고, 데모 글을 작성해보기 위해 자료를 준비했다. 자동화 이전, 상당한 공을 드렸음에도 결과적으로 AI 가 뽑아낸 글은 뭔가 이상하다고 느꼈다.</p>

<p>분명히 나를 분석한 프롬프트고, 심지어 복합적인 시각을 녹이고자 AI 두개의, 다른 시각을 합쳐 만든 완벽한 프롬프트였다. 나를 정확하게 표현한 버전, 내 개선 포인트를 추가로 담은 버전… 온갖 노력을 다 했는데 너무 아쉬운 글들 뿐이지 않은가?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-008.png" alt="" /></p>

<p>글의 퀄리티는 내가 예상했던 수준에 미치지 못하는게 보였다. 이젠 에러 분석이 필요한 시점이었다. 내가 준비한 프롬프트는 다음과 같은 종류로 구성 되어 있었다.</p>

<blockquote>
  <ul>
    <li>Gemini 분석의 저자의 문체를 복사한 ‘정확도’ 버전</li>
    <li>Gemini 분석의 저자의 문체에서 개선사항을 포함한 ‘개선’ 버전</li>
    <li>Claude 분석의 저자의 문체를 복사한 ‘정확도’ 버전</li>
    <li>Claude 분석의 문체에서 개선사항을 포함한 ‘개선’ 버전</li>
  </ul>
</blockquote>

<p>이 버전들을 그냥 쓴게 아니라 언급한 바 Gemini 와 Claude 에게 다시 양측 자료를 제공해주면서, 합쳐진 최종 버전을 만들라고 했었다. 즉 최종 프롬프트는 다음과 같다.</p>

<ol>
  <li>Gemini 정확도 버전 + Claude 정확도 버전 =&gt; Gemini, Claude 각각 합치기를 요청
    <ul>
      <li>Gemini 정확도 버전</li>
      <li>Claude 정확도 버전</li>
    </ul>
  </li>
  <li>Gemini 개선 버전 + Claude 개선 버전 =&gt; Gemini, Claude 각각 합치기를 요청
    <ul>
      <li>Gemini 개선 버전</li>
      <li>Claude 개선 버전</li>
    </ul>
  </li>
</ol>

<p>이렇게하여 나름 통합적 사고가 가능한 프롬프트가 되었으리라 생각했다. 서로의 분석의 빈틈을 매꿔주리라 생각했던 것이다. 하지만…</p>

<p>gemini 정확도 버전의 프롬프트의 글들의 구성은 간소했다. 요구사항은 잘 따른 편이었으나, 정작 문단 구조가 길고, 줄 글이 되어서 가독성이 좋지 못했다. 단순히 나를 모방했다고 하기엔 특징이 너무 부족한 무미 건조한 글이 되어 있었다.</p>

<p>claude 정확도 버전은 인트로에 나의 철학이란 이름으로 42서울, 비전공자 등 굳이 쓸데없는 도입부를 만들어서 글을 작성하였다. 도입부가 굳이 쓸데없는 사족이 없어도 되는데 특정 단어들에 갇혀진 표현 뿐이었다. 학습, 공유, 자기 성장이 목적인 나에게 필요한 글의 구성은 아니었다.</p>

<p>개선버전의 경우엔 다행이도 글 자체의 느낌은 훨씬 좋았다. 그러나 이상하게 AI 개입이 좀더 많고 나의 의도를 넘어선 내용이 있었다. 나의 글의 특성을 모사하진 못한게 보였다. 오히려 AI의 느낌이 강해져버렸다.</p>

<p>정리하면, 선택지는 없었다. 뭔가 문제는 있었으니, 이젠 글이 문제가 아니라 프롬프트를 제대로 까봐야 한다는 판단이 들었다. 그리하여 이번에야말로 프롬프트를 제대로 읽어 보는 순간 납득이 가는 부분이 있었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-009.png" alt="" /></p>

<p>오리지날 원본 프롬프트들까지 준비하여 비교해본 결과, 구체적으로 차이점은 다음과 같았다.</p>

<ol>
  <li>Gemini 건 Claude 건 합치길 요청하여 얻은 결과물들은, 막상 양쪽의 모든 특성을 고려한게 아니라, 일정하게 프롬프트 내역이 빠져 있었다.</li>
  <li>Claude 버전은 공통적으로 기존의 내용에서 상당한 양의 가이드가 사라져 있었고, 스타일 가이드적인 특성이 훨씬 강했던 원본에 비해 Gemini의 철학이나 방향성에 대한 내용이 담겨 있었다.</li>
  <li>Gemini 버전의 경우 원본이 방향성, 철학, 태도 등이 담겨 있었는데, 이러한 부분의 내용이 사라져 있었다. 오히려 스타일 가이드가 일부만 들어가거나, 아예 빠져 있는 경우가 있었다.</li>
</ol>

<p>그리하야… 원본 프롬프트를 다시 써봐야 하겠다 는 생각에 원본 프롬프트로 글을 만들어 내는 것까지 진행해보고 난 뒤, 비로소 나는 결론을 내릴 수 있었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-010.png" alt="" /></p>

<p>내용을 읽어본다면 아마 납득이 갈 것이다. 원본 프롬프트들을 합쳐서 만든 프롬프트와는 달랐다. 오히려 더 나스러운 글을 만들어 낸 것이 보였고, 무엇보다 디테일 적 누락이 많은 부분 해소 되어 있었다. 이유가 무엇인가? 한참을 프롬프트와 결과물을 읽어보니, 이유를 알 수 있었다.</p>

<h4 id="프롬프트는">프롬프트는…</h4>

<h5 id="왜-프롬프트는-자동화가-이상하게-되었단-말인가">왜 프롬프트는 자동화가 이상하게 되었단 말인가?</h5>

<p>나는 두 가지 다른 관점의 프롬프트를 분석하게 해놓았고, 그 분석된 프롬프트를 기반으로 종합시켰을 때 프롬프트의 질이 올라갈 거라고 생각했다. 하지만 이는 ‘착각’이었다.</p>

<p>AI 들은 여러 관점의 합을 만들 때, ‘일반화’되어 버린다. 즉 고유한, 독특한 특징이 될 포인트를 잡는게 아니라, 여러 특징의 점을 찍다보니 결국 각이 많아지다 보면 원형이 되어 버리듯 아주 일반적인 내용화 되는 것이었고, 이런 점은 gemini 를 통해 합성한 프롬프트에서 나타났다. Claude 의 합성의 경우엔 오히려 정보가 손실된 경우도 있었고 말이다.</p>

<p>이러한 현상은 일종의 AI의 ‘정보 손실’의 특성이었다. AI 어텐션 메커니즘(Attention Mechanism) 원리를 생각해보면 보다 확실히 알 수 있다. 입력 정보가 많아질 수록, 중요도가 떨어지는 정보는 요약 과정에서  우선순위 면에서 밀리고, 이 과정이 길어지면 데이터는 누락이 될 수 있었다.</p>

<p>특히나 가장 ‘그럴듯 하게’ 다음 단어를 예측하는게 핵심인 AI 입장에서, 통계적으로 오히려 그럴듯한 결과를 내기 위해선 독특하거나, 독창적인 정보를 담기 보단 ‘일반적인’ 문장의 결과를 생성해내는 것이 오히려 더 프로그램 목적에 부합한다.  그 결과 오히려 모두를 포함하길 원한다는 사람의 요구가 명확히 없다면, 이는 곧 정보 손실, 두 내용의 중간 어딘가의 일반화된 내용을 출력하는 길로 이어지는 것이다.</p>

<h5 id="프롬프트는-바운더리를-생성한다">프롬프트는 바운더리를 생성한다.</h5>

<p>너무 당연하다고 생각할지도 모르겠지만, 이 표현이 의미하는 바는 매우 컸다. 예를 들어 키워드를 명료하게 설정한 프롬프트는 일종의 룰이 되어 버린다. ‘42서울 출신 개발자’ 라는 철학을 넣으니, 도입부에 이 키워드를 어떻게든 넣으려고 했다.</p>

<p>키워드가 되면 족쇄가 되어 호흡, 흐름, 무게감을 어떻게 내가 원하는 밸런스에 맞추는게 아니라, 오히려 프롬프트를 바운더리로 잡고, 억지로 그 내용을 도출시키는데 목적이 있는 듯 보였다. 그리고 이러한 특성이 작용하면, 원하는 글이 아닌, 억지스러운 글이 되는 것이었다.</p>

<p>또 한편으로, 프롬프트가 일부 사라져 구멍이 생겼던 프롬프트는, 오히려 AI 의 개입이 많아지면서 창의적인 면이나, 글이 좀더 입체적으로 보였다. 이렇게 되면 결국 본질적으로 나를 모사한다는 것과는 전혀 무관계한게 아니겠는가?</p>

<p>프롬프트가 아주 중요하고, 민감한 영역이기에, 역할의 지정, 할 일의 지정 차원에서는 의미가 있지만, 거기에 특정 키워드가 마치 배경 지식으로 작동 되면, 프롬프트는 일종의 저주같이 되어, 원하는 요구사항을 들어주지 못하는 경우가 발생할 수 있는 것이었다.</p>

<h5 id="전-과정을-맡기는-구조는-한계가-명확하다">전 과정을 맡기는 구조는 한계가 명확하다.</h5>

<p>이후에도 여러번의 테스트를 해보았다. 하지만 결정적으로 ‘한 방에 딸깍’ 이라는 말이 어울리는 느낌의 알아서 잘, 딱 맞는 작업을 해준다? 그건 꿈이었다.</p>

<p>전 프로세스를 세분화 하지 않고, 프롬프트로 무언갈 써내려가게 되면, 위의 1번의 이야기가 펼쳐지는데, 그렇다고 여기서 정말 내 스타일의 커스터마이징 잘된 글을 만드려면 프롬프트가 방대해져야 한다. 그렇다고 AI에게 모두 맡기면 AI는 빈 공간에 대한 내용을 AI 의 설정으로 채운다. 그러면 또 원하는 결과가 안 나오게 되는 여지가 생기는 것이고…</p>

<p>즉, 근본적으로 꼬리에 꼬리를 무는 문제들이 생기기에 ‘전 공정’을 맡긴다는 방식 자체가 오히려 목표 달성에 문제를 일으키는 것이다.</p>

<h5 id="결론-적으로">결론 적으로….</h5>

<p>결론적으로 내가 얻은 핵심 통찰, 이는 AI 를 통해 내가 원하는 혹은 나 그 자체를 모방하는 글을 써내려가려면, 주기적으로 진행 과정을 검토하거나, 수정하지 않으면 안된다. 완전 자율성을 못 부여하는 것은 아니지만, 이는 프로그래밍의 영역으로 고려해야할 것으로 보였다. 나의 예상과 가설은 아주 빠르게 무너져 내린 것이었다.</p>

<h4 id="빠른-판단--어떻게-해야-ai-가-내-글쓰기에-도움을-줄까">빠른 판단!  어떻게 해야 AI 가 내 글쓰기에 도움을 줄까?</h4>

<p>그러나 시간을 더 들이는 것은 옳지 못하다. 해야할 일이 쌓여 있는데, 현재 가능한 선에서의 효율을 찾는 것은 핵심이리라.</p>

<p>그리하여 지금 상황에서 최선은 뭘까? 하고 고민한 결과가 다음과 같았다.</p>

<ul>
  <li>딸깍 하고 한방에 되는 건 어렵다 =&gt; 오히려 역으로 단계 별로 가속화 시키는게 AI 를 잘 쓸 수 있다.</li>
  <li>프롬프트는 어떻게 해야 가장 베스트일까? =&gt; <code class="language-plaintext highlighter-rouge">Context</code> 와 <code class="language-plaintext highlighter-rouge">Prompt</code>를 나누자!</li>
</ul>

<p><img src="/assets/images/posts/2025-10/2025-10-09-011.png" alt="" /></p>

<p>우선, 프롬프트를 그렇다고 지정하지 않고, 그냥 매번 타이핑 친다는 것은 대단히 힘든 일인건 사실이다. 두고두고 쓰는게 편하지 않겠는가? 그런데 나에게 글이란 건 개발 일지, 정보 공유, 메모 등 엄청나게 다양한 역할, 종류가 
다양하다는 점을 체감했다.</p>

<p>나는 너무 심플하게 생각한 나머지, 글의 종류가 다르고, 프로세스가 다른데 마치 무안단물마냥 ‘줘’ 하면, AI 들이 알아서 내 공유된 개인정보로 알아서 만들어 줄거라는 순진한 생각을 한 것이다.</p>

<p>그러니 Gemini가 제공한 아이디어를 적극 develop 하기로 했다. <code class="language-plaintext highlighter-rouge">Mode</code> 라는 키워드를 추가했다. 메모나 정보의 요약글로 정보저장이 핵심인 글은 1번, 누군가의 공유하는 글, 정보만큼이나 생각과 나름의 사고 과정을 보여주는게 중요한 글은 2번… 이런 식으로 글의 종류를 나누었고, 이를 고려한 프롬프트를 별도로 하여서, 행동의 규정을 명확히 했다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-012.png" alt="" /></p>

<p>두 번째로, 최근 배웠던 단어 중 Context Engineering 이란 키워드가 있었다. 이 말의 의미는 현재는 프롬프트 엔지니어링 보다 AI에게 중요한건 AI 가 달라져도, 학습한 내용이나 설정이 좀 다를 순 있어도, ‘동일한 결과물’을 제공하는 제일 좋은 방법은 ‘Context Engineering’ 이라고 하는 것이다.</p>

<p>요구한 내용에서 할 일, 상황 맥락이 유사하면 결과 값도 유사하게 전달할 수 있다. 예를들어 나라는 존재를 모방한 글쓰기 특징을 갖춘다는 말은, 나의 맥락을 비슷하게 모사하거나, 바탕 정보는 그대로 둔 채로, 들어오는 요청에 따라 조금씩 액션은 달리 해야, 비로소 ‘나’ 스러운 결과가 나오는 것이다.</p>

<p>그러나 프롬프트 마다 일일이 이걸 담아내는 건 효과적이지 못하다. 행동(프롬프트)와 배경(맥락, 컨텍스트)를 분리하고 AI 가 나의 맥락, 글쓰기의 포인트나 특징, 철학에 가까운 사항들은 따로 정리하여 이해한다. 그렇게 모방된 인격 하에 행동을 수행해야 비로소 요구되는 정확한 답변이 가능한 것이다.</p>

<p>이에 <code class="language-plaintext highlighter-rouge">Hansol Persona</code> 란 파일로 만들었고, 마치 전역변수처럼 이 녀석을 추가하고 고려하도록 만들었다. 컨텍스트, 그리고 프롬프트를 분리하고, 아까 언급했듯이 <code class="language-plaintext highlighter-rouge">Mode</code> 라는 개념을 추가했다. 그 결과는 어땠을까?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-013.png" alt="" /></p>

<p>개인적으로 아주 ‘성공적’ 이라고 평가하고 싶다.</p>

<blockquote>
  <p>💡 프롬프트, 컨텍스트 가이드</p>
  <ol>
    <li>Copilot 에 인용할 자신의 Context 문서를 작성하고, 필요 시 해당 문서를 항상 추가해라.</li>
    <li>Command 에 프롬프트에 행당하는 부분만 기재한다. context 의 해당하는 부분은 배제하고, 이는 Persona 문서에 포함한다.</li>
    <li>프롬프트는 구체적인 단어를 기재하는 것은 지양한다. 가능하면 행동 지침으로 최대한 구체화 시켜라.</li>
    <li>내가 자동화 할 목표가 있다면, 그 목표의 ‘과정’을 프롬프트화 시켜라. 글 쓰기의 핵심이 개요 작성 -&gt; 근거 추가 -&gt; 살 붙이기 -&gt; 퇴고 이런 순서라면, 각 단계 별로 필요한 영역에 프롬프트를 별도로 만드는 게 최선이다.</li>
    <li>자신의 프로세스를 검증할 프롬프트, Context 를 준비하는 것도 좋다. =&gt; 이를 통해 제 3자의 검증을 효과적으로 수행해 줄 수 있다.</li>
    <li>마크다운 양식의 헤드, 리스트 등 우선순위를 나타내는 기호를 AI 는 우선순위로 실제 판단한다. 따라서 우선순위를 고려한 프롬프트가 중요하다.</li>
    <li>글의 철학, 가치관도 중요하지만, 스타일 가이드 쪽의 지정의 프롬프트가 훨씬 AI가 완성도 높은 구성을 해낸다. 정량적인 내용을 프롬프트에 담아라.</li>
    <li>AI 의 인격에 대한 부분도 context 로 준비하면 아첨, 과도한 긍정 평가를 최소화 시킬 수 있다. 평가, 분석, 보완 등의 역할을 원할 땐, 그에 따른 AI의 가상 인격을 생성해놓고 제공하자.</li>
  </ol>
</blockquote>

<h3 id="결과물-톺아보기">결과물 톺아보기</h3>

<p>2.5 flash 는 2.5 Pro 대비 이상한 말도 많고, 허술한 답변을 할 때도 많다. 그러나 놀랍게도 컨텍스트 + 모드 + 프롬프트의 테스트 결과는 말도 안될 정도의 퀄리티의 내용을 뽑아주었다. 이미 충분히 블로그 글로 올렸을 때 문제 없지 않을까? 싶은 수준의 완성도 였다.</p>

<p>톤앤 무드는 정돈 되어 있었고, 내 설정들과 함께 전달된 자료들의 의도들을 정확히 재조합하여, 자잘한 분석 결과 문서, 자료들 예시, 몇 문단으로 작성된 결론, 개요를 한번에 종합해주었다. 그것도 단 돈 몇 십원 수준으로 말이다.</p>

<p>특히나 SEO 를 고려한 태그라던지, 예상 제목 제안 사항 등, 단순히 글쓰기를 돕는것 만으로 끝이 아니라, 블로그를 관리하고, 기술적 보조자 역할도 톡톡히 단 한 번의 요청으로 얻어낼 수 있었다.</p>

<p>뿐만 아니라, 위에서 얻은 결론을 기반으로 프롬프트를 추가로 제작. 내 글에 대한 분석, 글의 문제점이나 글에서 논리적 모순 등을 잡아주는 ‘편집장’ 프롬프트도 설정해 보았더니, 놀라울 만큼 명확하고 확실한 평가를 해주었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-014.png" alt="" /></p>

<p>내 글 어디가 아쉽고, 어떤 점이 좋으며, 어떤 점에서 개선이 되면 좋을지. 제 3자 시선에서 평가해주는 프롬프트를 기반으로 나의 글을 세밀하게 분석해주었다. 특히나 너무 과한 내용이나 필요 없는 내용 등을 빠르게 캐치하고 검토해주었다. 가장 놀라운건 이것이 성능이 부족하다고 느껴 거의 쓰지 않던 2.5 flash 에서 가능하다는 점이다!</p>

<h3 id="pro-vs-flash">Pro vs Flash</h3>

<p>놀라움. 만족스러움을 느끼기도 잠시. 2.5 flash를 왜 사용했는가? 에서 시작해서 한 가지 호기심이 들었다. 그것은 바로 ‘2.5 flash 로 이정도면, 2.5 pro 로 실행하면 얼마나 좋아질까?’ 였다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-016.png" alt="" /></p>

<p>그런데 어라. 이상했다. 2.5 flash 로 얻은 결과에 환호했던 것과는 달리, 생각보다 신기할 정도로 차이가 없었다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-015.png" alt="" /></p>

<p>구성의 큰 차이는 없다. 프롬프트의 요구사항은 충분히 수용되었고, 여기저기 좀더 늘어나거나, 개요이지만 글처럼 어느정도 완성되었다를 제외하면 뭔가 확 와닻는 변화는 아니었다.</p>

<p>정리해보면, 2.5 Pro와 2.5 flash 로 만든 글에 대해선 다음과 같은 차이가 있다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-017.png" alt="" /></p>

<p>Pro는 그 문장 하나 하나를 분석해 보았을 때, 단순히 요구 사항 이라고 적힌 것들의 의도를 고려한 답변에 가깝다는 게 보였다. 단순한 나열을 넘어 ‘이런 의도’로 이런 이야기니까, ‘이런 주장이 나온다’ 라는 표현. 생각해보면 훨씬 똑똑한 답변이라는 점은 부정할 수 없었다. 그러나 그것이 2.5 flash + 프롬프트만큼 확실한 효과가 있는가? 여기에 답변이 되기엔 애매 했다.</p>

<p>하물며 가성비를 생각해보자. 2.5 flash 의 경우 기본적으로 2.5 pro 대비 4배 정도의 가격차이가 날 수 있다(입출력 토큰 약 3K 수준 대비). 그런데 여기서 2.5 pro 는 입력값이 늘어나, 기준치를 넘기면(입력 토큰 수 2M 이상), 더 높은 요금을 부과해 요금을 측정한다. 즉,  2.5 flash 의 1000원 수준의 내용을 작업하면, 최대 수 천원 ~ 1만원대까지도 올라갈 수 있는 상황인 것이다.</p>

<p>새삼 프롬프트, 컨텍스트의 능력이 얼마나 뛰어난지를, 각종 AI 논문에서 작은 모델들의 합이라던가 MoE 구조라던가 기타 등등… 마치 거대 모델만큼 성능 좋게 만들수 있다! 는 표현들이 실제 어떤 의미인지 체감할 수있는 아주 흥미로운 결론이었다.</p>

<h2 id="결론">결론</h2>
<h3 id="ai-나의-능력을-증폭시키는-최고의-파트너">AI, 나의 능력을 증폭시키는 최고의 파트너</h3>

<p>AI 는 아직 AGI 는 아니다. 하지만 접근 방법에  따라서 ‘최고’가 될 수 있다는 점을 경험했다. 이번 과정을 통해 Copilot 이란 플러그인에 gemini 의 조합은 엄청난 수준의 글쓰기 조수를 구축하고, 혼자 끙끙 거리며 한달이 걸릴 글을 단 일주일도 안 걸리게 마무리, 그것도 실질 글 작업은 약 이틀 정도 소모 되는 속도로 만들어냈다. 초기 목표보단 못한 것은 사실이지만 그럼에도 엄청난 효율, 효과를 누렸다고 할 수 있겠다.</p>

<p>현재 개발 시장의 요구 사항은 명확하다. 자기 도메인의 높은 전문성, 그리고 그 전문성과 함께 시너지를 발 할수 있는 AI에 대한 리터러시. 개인적으로 건강을 위한 휴식 중이긴 하나, 동시에 내가 생각하는 ‘필요시 되는 사람’으로 살아가기 위해 벌린 이번 미니 프로젝트는, 현재 AI 의 본질을 이해할 수 있었고, 가공할 능력을 어디까지 활용할 수 있을지에 대한 내 나름의 시도이자, 단편적인 답변이었다.</p>

<p>프롬프트, 그 위에 작용하는 컨텍스트의 가능성을 엿 볼 수 있는 사례다. 2.5 flash 라는 가성비 모델로도, 얼마나 효과적일 수 있는지 체감할 수 있었던 좋은 기회였다. 이 글을 읽는 모두가 AI 를 통한 생산성 향상. 특히 한계에 부딪힐 때, 그 한계를 넘어서는 기술적 발판으로 활용을 잘 하면 좋겠다고 생각한다. 본 글을 통해 커스텀 된 AI 에이전트를 노코드로 구축하고, 프로세스를 단축하는 새로운 글쓰기 경험을 맛 보시길!</p>

<h2 id="요약">요약</h2>
<p>글이 너어어어ㅓㅓㅓㅓ 무 길어졌다(…) 
내 기록을 위해 남긴다지만, 너무 길어 요약을 해보았다.</p>

<hr />

<ol>
  <li>AI 프롬프트를 합치면 오히려 일반화된다 - 여러 AI의 분석을 통합하려 했지만, 독특한 특징이 사라지고 정보 손실이 발생했다.</li>
  <li>Context(페르소나)와 Prompt(행동지침)를 분리하고, 글 종류별 Mode를 구분하니 비로소 ‘나다운’ 글쓰기가 가능해졌다.</li>
  <li>2.5 flash + 잘 짜여진 프롬프트 구조가 2.5 Pro보다 가성비 측면에서 압도적이었다. 작은 모델도 Context Engineering으로 충분히 강력해질 수 있다.</li>
</ol>

<hr />

<blockquote>
  <p>Obsidian 에 Copilot, Gemini API 적용 방법 (링크)(작성중)</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="Obsidian" /><category term="AI" /><category term="Gemini" /><category term="Google" /><category term="블로그" /><category term="플러그인" /><summary type="html"><![CDATA[Obsidian + Copilot - 나만의 글쓰기 Agent를 만들어보자 글쓰기의 길은 멀고도 험하다]]></summary></entry><entry><title type="html">AI 자동화 툴, Opal 맛보기</title><link href="http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction.html" rel="alternate" type="text/html" title="AI 자동화 툴, Opal 맛보기" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction</id><content type="html" xml:base="http://0.0.0.0:4000/tools/2025/10/09/02-Opal-instroduction.html"><![CDATA[<p><img src="/assets/images/posts/2025-10/2025-10-09-018.png" alt="" /></p>

<h2 id="ai-워크플로우의-새로운-가능성-google-opal">AI 워크플로우의 새로운 가능성, Google Opal</h2>

<p>드디어 AI가 단발성 대화를 넘어 연속적인 작업 흐름을 처리할 수 있게 됐다. Google Labs에서 공개한 Opal은 <strong>프롬프트, AI 모델, 도구를 연결해 다단계 워크플로우를 만들 수 있는 노코드 플랫폼</strong>이다. 지금까지 AI가 부족했던 ‘시퀀스’ 개념을 드디어 제대로 구현한 셈이다.</p>

<h3 id="그동안-ai에게-없었던-것-단계별-사고">그동안 AI에게 없었던 것: 단계별 사고</h3>

<p>ChatGPT든 Gemini든, 대부분의 AI 서비스는 기본적으로 “질문 → 답변” 구조다. 물론 멀티턴 대화가 가능하긴 하지만, 복잡한 작업을 여러 단계로 나눠서 자동으로 처리하기엔 한계가 있었다. 예를 들어 “특정 주제로 블로그 초안 작성 → 이미지 생성 → SEO 최적화 → 최종 정리” 같은 워크플로우를 만들려면 결국 사람이 중간중간 개입해야 했다.</p>

<p>Opal은 바로 이 지점을 공략했다. 공식 블로그에 따르면, <strong>“프롬프트, AI 모델 호출 및 기타 도구를 연결하여 강력한 다단계 앱을 제작할 수 있도록 지원”</strong>한다고 명시되어 있다<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. 실제로 User Input(사용자 입력) → Generate(AI 생성) → Output(결과 출력) 단계를 조합하고, 각 단계의 결과를 다음 단계에서 참조할 수 있다. 이를 “단계 연결(Step Chaining)”이라고 부르는데, 드래그 앤 드롭이나 @ 기호로 간단히 구현 가능하다<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>더 인상적인 건 두 가지 편집 모드를 제공한다는 점이다. 자연어로 “이런 앱 만들어줘” 하면 Opal이 알아서 워크플로우를 구성해주고, 세부 조정은 비주얼 편집기에서 할 수 있다. 코드를 전혀 볼 필요가 없다<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>. 2024년 10월 업데이트에서는 <strong>단계별 디버깅 기능</strong>과 <strong>병렬 실행 기능</strong>까지 추가되어, 복잡한 워크플로우도 실시간으로 테스트하고 개선할 수 있게 됐다<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<h3 id="노코드의-장점이자-한계">노코드의 장점이자 한계</h3>

<p><img src="/assets/images/posts/2025-10/2025-10-09-020.png" alt="" /></p>

<p>Opal의 가장 큰 장점은 진입장벽이 낮다는 것이다. 자연어만 사용할 줄 알면 누구나 AI 앱을 만들 수 있고, Google이 호스팅까지 해주니 링크 하나로 바로 공유할 수 있다. 갤러리에서 다른 사람이 만든 앱을 리믹스해서 내 것으로 만들 수도 있다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-09-021.png" alt="" /></p>
<blockquote>
  <p>현재는 아주 심플한 동작들만을 지원하고 있다</p>
</blockquote>

<p>하지만 여기서 아쉬운 점이 드러난다. <strong>외부 서비스 연동이 제한적</strong>이다. 현재 기본 제공되는 도구는 웹 검색, 지도 검색, 날씨 정보 정도이고, Google Drive 정도만 직접 연동된다<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>. Notion, Slack, Trello 같은 다른 서비스와의 자동화는 아직 지원되지 않는다. Zapier나 Make.com처럼 수백 개의 서비스를 연결할 수 있는 수준엔 한참 못 미친다.</p>

<p>더 치명적인 건 <strong>코드 내보내기가 불가능</strong>하다는 점이다. Opal에서 만든 앱은 Google 생태계 안에 갇혀 있다. API를 만들 수도 없고, 데이터베이스를 붙일 수도 없으며, 실제 배포 가능한 코드를 얻을 수도 없다<sup id="fnref:6"><a href="#fn:6" class="footnote" rel="footnote" role="doc-noteref">6</a></sup>. 결국 프로토타이핑이나 간단한 사내 도구 정도로만 활용 가능하다는 얘기다. 프로덕션용으로 쓰기엔 아직 갈 길이 멀다.</p>

<h3 id="obsidian에서-했던-것들을-자동화할-수-있을까">Obsidian에서 했던 것들을 자동화할 수 있을까?</h3>

<p>개인적으로 흥미로웠던 건, 이전에 Obsidian + 코파일럿 플러그인으로 시도했던 것들이 떠올랐다는 점이다(<a href="https://paul2021-r.github.io/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2025/10/09/01-obsidian-ai-copilot.html">참고 링크</a>). 당시엔 노트 글감을 준비하고, 특정 패턴 명령어를 적용하고, 글감을 나의 문체에 맞는 글감으로 만들어주는 워크플로우를 만들려고 했다. 하지만 결과적으로 수동으로 트리거를 해야 했고, 여러 단계를 거치려면 계속 개입해야 했다.</p>

<p>Opal의 시퀀스 기능을 보니, 이런 것들을 완전히 자동화할 수 있겠다는 생각이 들었다. 예를 들어 “웹에서 특정 주제 검색 → 요약 생성 → 이미지 생성 → 마크다운 포맷으로 정리 → Google Drive에 저장” 같은 흐름을 하나의 앱으로 만들 수 있을 것 같다. 물론 Obsidian과 직접 연동되진 않지만, Google Drive를 중간 저장소로 쓰면 충분히 가능할 것 같다.</p>

<p>문제는 앞서 말한 외부 서비스 연동의 한계다. 만약 Opal이 Notion API, Obsidian Local REST API, 혹은 더 나아가 커스텀 웹훅 정도만 지원해준다면, 정말 강력한 자동화 허브가 될 수 있을 텐데 말이다. 지금은 Google 생태계 안에서만 놀 수 있다는 점이 가장 아쉽다.(물론 그게 목적이겠지만 말이다.)</p>

<h3 id="결론-가능성은-보였지만-아직은-반쪽짜리">결론: 가능성은 보였지만, 아직은 반쪽짜리</h3>

<p>Opal은 분명히 AI의 새로운 방향을 제시했다. <strong>시퀀스, 워크플로우, 단계별 자동화</strong>—이것들은 AI가 단순한 챗봇을 넘어 진짜 생산성 도구가 되기 위해 반드시 필요한 요소들이다. 노코드로 이런 걸 구현했다는 점에서 Opal은 충분히 혁신적이다.</p>

<p>하지만 현실적으로 프로덕션 환경에서 쓰기엔 한계가 명확하다. 외부 서비스 연동이 제한적이고, 코드를 내보낼 수도 없으며, 아직은 실험적 도구라는 꼬리표를 떼지 못했다. Google Labs 프로젝트가 언제 접힐지 모른다는 불안감도 있다.</p>

<p>그럼에도 불구하고, Opal이 보여준 방향성은 분명하다. AI는 이제 단발성 대화를 넘어 연속적인 워크플로우를 이해하고 실행해야 한다. 그리고 누구나 코딩 없이 그런 자동화를 만들 수 있어야 한다. Opal이 완벽하진 않지만, 그 미래를 먼저 보여준 건 확실하다.</p>

<p>만약 Google이 이 프로젝트를 제대로 밀어붙여서 외부 API 연동과 코드 내보내기 기능까지 추가한다면? 그때는 정말 게임 체인저가 될 수 있을 것 같다.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://developers.googleblog.com/ko/introducing-opal/">Google 개발자 블로그 (한국어) - Opal 소개</a>: “프롬프트, AI 모델 호출 및 기타 도구를 연결하여 강력한 다단계 앱을 제작할 수 있도록 지원합니다.” <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="https://developers.google.com/opal/overview">Google Opal 공식 문서 - Overview</a>: “Referencing the results of one step in the prompt for another step is the primary way to build your app logic inside of Opal.” <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><a href="https://developers.googleblog.com/en/introducing-opal/">Google 개발자 블로그 (영어) - Introducing Opal</a>: “Opal translates your instructions into a visual workflow, giving you fine-grained control without ever needing to see a line of code.” <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><a href="https://blog.google/technology/google-labs/opal-expansion/">Google Labs Blog - Opal Expansion</a>: “We’ve fundamentally improved the debugging program… You can now run your workflow step-by-step in the visual editor” <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Google 개발자 블로그 및 공식 문서에서 확인된 빌트인 도구 목록: 웹 검색, 지도 검색, 날씨 정보, Google Drive 연동 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>커뮤니티 피드백 및 공식 문서 기반: Opal 앱은 Google 생태계 내에 제한되며, 코드 내보내기, API 생성, 데이터베이스 통합 등이 불가능함 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Paul2021-R</name></author><category term="tools" /><category term="AI" /><category term="Google" /><category term="Opal" /><category term="Automation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코테 학습 - ‘지폐접기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘지폐접기’" /><published>2025-10-01T00:00:00+00:00</published><updated>2025-10-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/01/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<h3 id="원본-문제">원본 문제</h3>
<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/340199?language=python3">원본 문제</a></p>

<h3 id="문제-정리">문제 정리</h3>

<ul>
  <li><strong>목표</strong>: 규격인 wallet 에 맞는 가로, 세로 크기로 몇번 접어야 하는지 최소 값을 리턴할 것</li>
  <li><strong>핵심 기능</strong>:
    <ol>
      <li>지폐를 접을 때는 항상 길이가 긴 쪽을 반으로 접는다.</li>
      <li>접기 전 길이 홀수 -&gt; 접은 후 소수점 이하 버리기</li>
      <li>접힌 지폐를 그대로 또는 90도 돌리고 넣을 수 있다면 그만 접음</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="코드-개선-과정-분석">코드 개선 과정 분석</h3>

<h4 id="1단계-최초-풀이-놓친-지점은-조건-1">[1단계] 최초 풀이: 놓친 지점은 조건 1</h4>
<ul>
  <li>거의 조건을 완벽하게 해결했었음. 그러나 마지막 cond ~ 부분에서 조건을 잘못 생각했다. 핵심 조건은 길이가 긴쪽을 줄이는 것이지, 무조건 가로 또는 세로를 줄이는게 아니고 이점을 놓치면 잘못 계산되는 엣지 케이스가 발생하는 것이었다.</li>
  <li>따라서 cond 배열의 어느쪽이든 문제가 있다 -&gt; 가로와 세로 중 긴 쪽을 우선 접어야 한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">bill</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">width</span> <span class="o">=</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">height</span> <span class="o">=</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">break</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span><span class="err"> </span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">break</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span><span class="err"> </span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 여기 틀림!
</span><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">bill</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">]</span> <span class="c1"># 그냥 긴 쪽을 접는 게 중요했다. 
</span><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">elif</span> <span class="n">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">bill</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># 그냥 긴 쪽을 접는 게 중요했다. 
</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>
<h4 id="2단계-최종-풀이-조건의-확립-및-불필요한-코드-제거">[2단계] 최종 풀이: 조건의 확립 및 불필요한 코드 제거</h4>
<ol>
  <li>핵심 조건을 개선하여 엣지 케이스까지 대응이 가능해짐.</li>
  <li>그 외에 불필요한 변수들을 제거하기 시작했는데 다음과 같음
    <ol>
      <li>가로, 세로 변수 제거</li>
      <li>조건은 명확하므로, <code class="language-plaintext highlighter-rouge">and</code>로 묶어 한줄로 처리 가능</li>
      <li>cond 도 실제 무조건 <code class="language-plaintext highlighter-rouge">wallet</code>에 들어가는 조건이 아니면 무조건 긴 쪽을 접어야 하므로 필요 없음</li>
      <li>접어야 할 조건에 도착 시 배열값을 직접 수정해도 됨</li>
    </ol>
  </li>
</ol>

<hr />

<h3 id="최종-버전-코드-및-설명">최종 버전 코드 및 설명</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">bill</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wallet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">bill</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bill</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">코테 학습 - ‘동영상 재생기’</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python.html" rel="alternate" type="text/html" title="코테 학습 - ‘동영상 재생기’" /><published>2025-09-19T00:00:00+00:00</published><updated>2025-09-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/09/19/study-python.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>본 글은 원본 문제를 기반으로 풀이한 내용을 담고 있습니다.</p>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/340213?language=python3">원본 문제 보러가기</a></p>

<h2 id="2025년-9월-19일-프로그래머스-코딩-테스트-동영상-재생기-문제-풀이-python">2025년 9월 19일: 프로그래머스 코딩 테스트 ‘동영상 재생기’ 문제 풀이 (Python)</h2>

<h3 id="문제-정리">문제 정리</h3>

<ul>
  <li><strong>목표</strong>: 주어진 명령어(<code class="language-plaintext highlighter-rouge">prev</code>, <code class="language-plaintext highlighter-rouge">next</code>)를 모두 수행한 후 동영상의 최종 재생 위치를 “mm:ss” 형식으로 반환하는 문제이다.</li>
  <li><strong>핵심 기능</strong>:
    <ol>
      <li><strong>10초 전/후 이동</strong>: <code class="language-plaintext highlighter-rouge">prev</code>와 <code class="language-plaintext highlighter-rouge">next</code> 명령을 수행하며, 영상의 시작(00:00)과 끝(video_len)을 벗어나지 않도록 처리한다.</li>
      <li><strong>오프닝 자동 건너뛰기</strong>: 현재 재생 위치가 오프닝 구간(<code class="language-plaintext highlighter-rouge">op_start</code> ~ <code class="language-plaintext highlighter-rouge">op_end</code>)에 포함될 경우, 즉시 오프닝이 끝나는 위치(<code class="language-plaintext highlighter-rouge">op_end</code>)로 자동 이동한다. 이 기능은 사용자의 명령어와 관계없이 위치가 변경될 때마다 적용되어야 하는 핵심 규칙이다.</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="코드-개선-과정-분석">코드 개선 과정 분석</h3>

<h4 id="1단계-최초-풀이-분minute과-초second를-분리하여-처리">[1단계] 최초 풀이: 분(minute)과 초(second)를 분리하여 처리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">-</span> <span class="mi">10</span>
        
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
    
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">59</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="n">end_hour</span><span class="p">,</span> <span class="n">end_minutes</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end_hour</span> <span class="ow">or</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_hour</span> <span class="ow">and</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end_minutes</span><span class="p">):</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_hour</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_minutes</span>
    
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">op_start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="n">start_total_time</span> <span class="o">=</span> <span class="n">start_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">start_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end_total_time</span> <span class="o">=</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">current_total_time</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">start_total_time</span> <span class="o">&lt;=</span> <span class="n">current_total_time</span> <span class="ow">and</span> <span class="n">current_total_time</span> <span class="o">&lt;=</span> <span class="n">end_total_time</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">current_pos</span>
<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="p">)</span><span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

    
    <span class="n">hour</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">minute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">minute</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])]</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">video_len</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>첫 번째 코드는 시간 데이터를 <code class="language-plaintext highlighter-rouge">[분, 초]</code> 형태의 리스트(혹은 튜플)로 다루는 방식이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1단계 코드 (주요 부분)
</span><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">-</span> <span class="mi">10</span>
    <span class="c1"># ...경계 값 처리...
</span>    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="c1"># [분, 초] 리스트 반환
</span>    <span class="c1"># ... (생략) ...
</span></code></pre></div></div>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>시간을 ‘분’과 ‘초’ 두 개의 단위로 유지하며 모든 연산을 수행했다.</li>
    </ul>
  </li>
  <li><strong>분석 및 문제점</strong>:
    <ul>
      <li><strong>로직의 복잡성</strong>: 10초를 더하고 뺄 때, 60초를 기준으로 받아올림/내림 처리를 해야 하므로 <code class="language-plaintext highlighter-rouge">if-elif</code> 조건문이 복잡해진다. 예를 들어 <code class="language-plaintext highlighter-rouge">prev_pos</code>에서 <code class="language-plaintext highlighter-rouge">03:05</code>에서 10초를 빼는 경우 <code class="language-plaintext highlighter-rouge">02:55</code>로 만들기 위한 연산이 직관적이지 않다.</li>
      <li><strong>비교 연산의 번거로움</strong>: <code class="language-plaintext highlighter-rouge">skip_opening</code>과 같이 시간의 선후 관계를 비교할 때, 분과 초를 각각 비교해야 하므로 코드가 길어지고 실수할 가능성이 커진다.</li>
      <li><strong>데이터 타입의 불일치</strong>: 타입 힌트는 불변(immutable) 객체인 <code class="language-plaintext highlighter-rouge">Tuple</code>로 지정했지만, 실제로는 <code class="language-plaintext highlighter-rouge">current_pos[1] -= 10</code>처럼 내부 값을 변경하고 있어 가변(mutable) 객체인 <code class="language-plaintext highlighter-rouge">List</code>처럼 사용했다. 이는 잠재적인 오류를 유발할 수 있는 좋지 않은 패턴이다.</li>
    </ul>
  </li>
</ul>

<h4 id="2단계-개선-단위를-초second로-통일">[2단계] 개선: 단위를 ‘초(second)’로 통일</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">video_length</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="n">video_end</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">video_length</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&gt;</span> <span class="n">video_end</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">video_end</span>
    
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">op_start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_end</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">current_pos</span> <span class="ow">and</span> <span class="n">current_pos</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">end_time</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span> <span class="o">//</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">minute</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">current_pos</span> <span class="o">%</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">minute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">minute</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">0</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>
    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">minute</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>  <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">next_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">video_len</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">skip_opening</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>첫 풀이의 복잡성을 해결하기 위해 모든 시간 단위를 ‘초’로 통일했다. 이는 문제 해결의 <strong>가장 결정적인 개선점</strong>이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 2단계 코드 (주요 부분)
</span><span class="k">def</span> <span class="nf">prev_pos</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">current_pos</span>

<span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>  <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="c1"># '초' 단위 정수 반환
</span>    <span class="c1"># ... (생략) ...
</span></code></pre></div></div>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>모든 “mm:ss” 형식의 시간을 <code class="language-plaintext highlighter-rouge">get_int_time</code> 함수를 통해 ‘초’ 단위의 정수(integer)로 변환하여 계산했다.</li>
    </ul>
  </li>
  <li><strong>분석 및 개선 효과</strong>:
    <ul>
      <li><strong>연산의 단순화</strong>: 시간 계산이 <code class="language-plaintext highlighter-rouge">+10</code>, <code class="language-plaintext highlighter-rouge">-10</code>과 같은 단순한 정수 연산으로 바뀌어 코드가 매우 간결해지고 명확해졌다.</li>
      <li><strong>비교의 용이성</strong>: 시간 비교 역시 정수의 크기 비교(<code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>)로 단순화되어 <code class="language-plaintext highlighter-rouge">skip_opening</code> 로직이 직관적으로 변했다.</li>
      <li><strong>오류 가능성 감소</strong>: 복잡한 받아올림/내림 로직이 사라져 버그가 발생할 여지가 크게 줄었다.</li>
    </ul>
  </li>
  <li><strong>남은 개선점</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">next_pos</code>, <code class="language-plaintext highlighter-rouge">skip_opening</code> 함수가 루프 안에서 호출될 때마다 <code class="language-plaintext highlighter-rouge">get_int_time</code> 함수를 통해 문자열을 정수로 변환하는 <strong>불필요한 반복 연산</strong>이 여전히 존재한다.</li>
      <li>오프닝 스킵 로직의 적용 시점이 루프 전/후로 나뉘어 있어 더 깔끔하게 정리할 여지가 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="3단계-최종-풀이-pythonic-코드-적용-및-로직-최적화">[3단계] 최종 풀이: Pythonic 코드 적용 및 로직 최적화</h4>

<p>2단계에서 이룬 구조적 개선 위에, 코드의 효율성과 가독성을 극대화하는 Pythonic한 기법들과 로직 최적화를 적용한 최종 버전이다.</p>

<ul>
  <li><strong>접근 방식</strong>:
    <ul>
      <li>반복 연산을 제거하고, 파이썬 내장 기능과 더 효율적인 로직 흐름을 적용하여 코드를 완성했다.</li>
    </ul>
  </li>
  <li><strong>핵심 개선점</strong>:
    <ol>
      <li><strong>사전 연산 (Pre-computation)</strong>: <code class="language-plaintext highlighter-rouge">solution</code> 함수 시작 시점에서 필요한 모든 시간 문자열(<code class="language-plaintext highlighter-rouge">video_len</code>, <code class="language-plaintext highlighter-rouge">op_start</code> 등)을 ‘초’ 단위 정수로 <strong>미리 한 번만 변환</strong>하여 변수에 저장한다. 이를 통해 루프 내에서 반복적인 변환 작업을 완전히 제거하여 효율성을 높였다.</li>
      <li><strong>Pythonic 경계 값 처리</strong>: <code class="language-plaintext highlighter-rouge">prev</code>와 <code class="language-plaintext highlighter-rouge">next</code> 기능에서 <code class="language-plaintext highlighter-rouge">if</code>문을 사용하여 0과 영상 최대 길이를 확인하는 대신, <code class="language-plaintext highlighter-rouge">max(0, ...)</code>와 <code class="language-plaintext highlighter-rouge">min(video_len_sec, ...)</code>를 사용하여 코드를 한 줄로 줄이고 의도를 더 명확하게 표현했다.</li>
      <li><strong>Pythonic 시간 포맷팅</strong>: <code class="language-plaintext highlighter-rouge">get_str_time</code> 함수에서 <code class="language-plaintext highlighter-rouge">divmod()</code>를 사용해 몫(분)과 나머지(초)를 한 번에 계산하고, f-string의 <code class="language-plaintext highlighter-rouge">:02d</code> 서식 지정자를 이용해 두 자리 수에 맞춰 0을 채우는 가장 표준적이고 깔끔한 방식을 사용했다.</li>
      <li><strong>로직 흐름 최적화</strong>: 오프닝 스킵 로직을 <strong>‘상태가 변경될 때마다 유효성을 검사하는’</strong> 개념으로 접근했다.
        <ul>
          <li><strong>초기 상태 보정</strong>: 루프 시작 전, 최초 위치에 대해 스킵 검사를 먼저 수행한다.</li>
          <li><strong>변경 후 보정</strong>: 명령어 실행으로 위치가 변경된 직후에만 스킵 검사를 수행한다.</li>
          <li>이 두 번의 검사로 모든 경우를 처리하여, 루프 전과 후로 로직이 나뉘어 있던 2단계 코드보다 훨씬 더 명료한 흐름을 완성했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="최종-버전-코드-및-설명">최종 버전 코드 및 설명</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 시간 변환 함수: 초 단위 정수와 "mm:ss" 문자열을 상호 변환한다.
</span><span class="k">def</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="nf">int</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># divmod로 몫(분)과 나머지(초)를 한 번에 계산한다.
</span>    <span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span> <span class="o">=</span> <span class="nf">divmod</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="c1"># f-string 포맷팅으로 두 자리가 아닐 경우 앞에 0을 붙여준다.
</span>    <span class="k">return</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">minutes</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">seconds</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">video_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">op_start</span><span class="p">,</span> <span class="n">op_end</span><span class="p">,</span> <span class="n">commands</span><span class="p">):</span>
    <span class="c1"># [최적화 1] 모든 시간 값을 미리 한 번만 정수로 변환한다.
</span>    <span class="n">video_len_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">video_len</span><span class="p">)</span>
    <span class="n">op_start_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_start</span><span class="p">)</span>
    <span class="n">op_end_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">op_end</span><span class="p">)</span>
    <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">get_int_time</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    
    <span class="c1"># 오프닝 스킵을 위한 지역 헬퍼 함수. solution 내부 변수에 접근하기 용이하다.
</span>    <span class="k">def</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">pos_sec</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_start_sec</span> <span class="o">&lt;=</span> <span class="n">pos_sec</span> <span class="o">&lt;=</span> <span class="n">op_end_sec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op_end_sec</span>
        <span class="k">return</span> <span class="n">pos_sec</span>
    
    <span class="c1"># [로직 최적화] 1. 초기 위치에 대한 오프닝 스킵을 먼저 적용한다.
</span>    <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span>
            <span class="c1"># [최적화 2] min()을 사용해 영상 길이를 넘지 않도록 처리한다.
</span>            <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">video_len_sec</span><span class="p">,</span> <span class="n">current_pos_sec</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">'</span><span class="s">prev</span><span class="sh">'</span><span class="p">:</span>
            <span class="c1"># [최적화 2] max()를 사용해 0 미만으로 내려가지 않도록 처리한다.
</span>            <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_pos_sec</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span>
    
        <span class="c1"># [로직 최적화] 2. 명령어로 위치가 바뀐 직후, 다시 오프닝 스킵을 적용한다.
</span>        <span class="n">current_pos_sec</span> <span class="o">=</span> <span class="nf">check_and_skip_opening</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">get_str_time</span><span class="p">(</span><span class="n">current_pos_sec</span><span class="p">)</span>

</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="python" /><category term="이직" /><category term="학습" /><category term="코딩테스트" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>