<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2026-02-19T03:19:37+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">Protostar review note - 08 NestJS Middlewares &amp;amp; Guards &amp;amp; Interceptors &amp;amp; Pipes</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/19/00-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 08 NestJS Middlewares &amp;amp; Guards &amp;amp; Interceptors &amp;amp; Pipes" /><published>2026-02-19T00:00:00+00:00</published><updated>2026-02-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/19/00-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/19/00-protostar-review.html"><![CDATA[<h1 id="nestjs-파이프라인-구성요소-분석">NestJS 파이프라인 구성요소 분석</h1>
<h2 id="middleware--guards--interceptors--pipes">Middleware → Guards → Interceptors → Pipes</h2>

<blockquote>
  <p>이 파일은 요청이 컨트롤러에 도달하기 전까지의 처리 계층을 <strong>실행 순서</strong>대로 분석한다.
프로젝트에 존재하는 구성 파일 목록:</p>

  <table>
    <thead>
      <tr>
        <th>분류</th>
        <th>파일</th>
        <th>등록 방식</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Middleware</td>
        <td>_(별도 클래스 없음, Express 직접 사용)_</td>
        <td><code class="language-plaintext highlighter-rouge">app.use()</code> in main.ts</td>
      </tr>
      <tr>
        <td>Guard</td>
        <td><code class="language-plaintext highlighter-rouge">origin.guard.ts</code></td>
        <td><code class="language-plaintext highlighter-rouge">useGlobalGuards()</code> in main.ts</td>
      </tr>
      <tr>
        <td>Guard</td>
        <td><code class="language-plaintext highlighter-rouge">jwt-auth.guard.ts</code></td>
        <td><code class="language-plaintext highlighter-rouge">APP_GUARD</code> in AppModule</td>
      </tr>
      <tr>
        <td>Guard</td>
        <td><code class="language-plaintext highlighter-rouge">ai-circuit.guard.ts</code></td>
        <td><code class="language-plaintext highlighter-rouge">@UseGuards()</code> in Controller</td>
      </tr>
      <tr>
        <td>Interceptor</td>
        <td><code class="language-plaintext highlighter-rouge">logging.interceptor.ts</code></td>
        <td><code class="language-plaintext highlighter-rouge">useGlobalInterceptors()</code> in main.ts</td>
      </tr>
      <tr>
        <td>Interceptor</td>
        <td><code class="language-plaintext highlighter-rouge">knowledge-upload-busy-check.interceptor.ts</code></td>
        <td><code class="language-plaintext highlighter-rouge">@UseInterceptors()</code> in Controller</td>
      </tr>
      <tr>
        <td>Pipe</td>
        <td><code class="language-plaintext highlighter-rouge">ValidationPipe</code></td>
        <td><code class="language-plaintext highlighter-rouge">useGlobalPipes()</code> in main.ts</td>
      </tr>
      <tr>
        <td>Pipe</td>
        <td><code class="language-plaintext highlighter-rouge">ClassSerializerInterceptor</code></td>
        <td><code class="language-plaintext highlighter-rouge">useGlobalInterceptors()</code> in main.ts</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<hr />

<h1 id="1-주요-개념">1. 주요 개념</h1>

<h2 id="middleware">Middleware</h2>

<p>NestJS의 Middleware는 <strong>Express/Fastify 레벨</strong>에서 동작한다. 라우터보다 먼저 실행되며, 요청·응답 객체에 직접 접근할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Request] → Middleware → Guard → Interceptor → Pipe → Controller
</code></pre></div></div>

<p><strong>이 프로젝트에서의 선택</strong>: 별도의 NestJS Middleware 클래스 없이 <code class="language-plaintext highlighter-rouge">app.use()</code>로 Express 미들웨어를 직접 등록.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.ts</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="nf">json</span><span class="p">({</span> <span class="na">limit</span><span class="p">:</span> <span class="dl">'</span><span class="s1">50mb</span><span class="dl">'</span> <span class="p">}));</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="nf">urlencoded</span><span class="p">({</span> <span class="na">extended</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">limit</span><span class="p">:</span> <span class="dl">'</span><span class="s1">50mb</span><span class="dl">'</span> <span class="p">}));</span>
</code></pre></div></div>

<p>→ bodyParser만 미들웨어 레이어에서 처리하고, 인증·Origin 검사 등은 Guard 레이어로 위임한 설계로 구성되어있다.</p>

<h2 id="guards">Guards</h2>

<table>
  <thead>
    <tr>
      <th>가드</th>
      <th>등록 방식</th>
      <th>적용 범위</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OriginGuard</code></td>
      <td><code class="language-plaintext highlighter-rouge">useGlobalGuards()</code></td>
      <td>전체 요청</td>
      <td>HTTP Origin 화이트리스트 검사</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ThrottlerGuard</code></td>
      <td><code class="language-plaintext highlighter-rouge">APP_GUARD</code></td>
      <td>전체 요청</td>
      <td>Rate Limit (burst/sustained)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">JwtAuthGuard</code></td>
      <td><code class="language-plaintext highlighter-rouge">APP_GUARD</code></td>
      <td>전체 요청 (<code class="language-plaintext highlighter-rouge">@Public()</code> 제외)</td>
      <td>JWT 토큰 인증</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AiCircuitGuard</code></td>
      <td><code class="language-plaintext highlighter-rouge">@UseGuards()</code></td>
      <td>채팅·지식 엔드포인트</td>
      <td>AI 서비스 생존 여부 확인</td>
    </tr>
  </tbody>
</table>

<p>NestJS Guard의 핵심: <code class="language-plaintext highlighter-rouge">canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt;</code>
→ <code class="language-plaintext highlighter-rouge">false</code> 또는 예외를 던지면 요청을 차단, <code class="language-plaintext highlighter-rouge">true</code>를 반환해야 다음 단계 진행이 된다.</p>

<h2 id="interceptors">Interceptors</h2>

<table>
  <thead>
    <tr>
      <th>인터셉터</th>
      <th>등록 방식</th>
      <th>적용 범위</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoggingInterceptor</code></td>
      <td><code class="language-plaintext highlighter-rouge">useGlobalInterceptors()</code></td>
      <td>전체 요청</td>
      <td>HTTP 트래픽 구조화 로깅</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClassSerializerInterceptor</code></td>
      <td><code class="language-plaintext highlighter-rouge">useGlobalInterceptors()</code></td>
      <td>전체 응답</td>
      <td><code class="language-plaintext highlighter-rouge">@Exclude()/@Expose()</code> 직렬화 적용</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">KnowledgeUploadBusyCheckInterceptor</code></td>
      <td><code class="language-plaintext highlighter-rouge">@UseInterceptors()</code></td>
      <td>업로드 엔드포인트</td>
      <td>큐 포화 상태 사전 차단</td>
    </tr>
  </tbody>
</table>

<p>NestJS Interceptor의 핵심: <code class="language-plaintext highlighter-rouge">intercept(context, next: CallHandler): Observable&lt;any&gt;</code>
→ <code class="language-plaintext highlighter-rouge">next.handle()</code> 호출 전: 요청 전처리 / 호출 후 <code class="language-plaintext highlighter-rouge">pipe()</code>: 응답 후처리.</p>

<h2 id="pipes">Pipes</h2>

<table>
  <thead>
    <tr>
      <th>파이프</th>
      <th>등록 방식</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ValidationPipe</code></td>
      <td><code class="language-plaintext highlighter-rouge">useGlobalPipes()</code></td>
      <td>DTO 필드 검증 + 타입 변환</td>
    </tr>
    <tr>
      <td>_(ClassSerializerInterceptor)_</td>
      <td><code class="language-plaintext highlighter-rouge">useGlobalInterceptors()</code></td>
      <td>응답 직렬화 (Pipe는 아니지만 유사 역할)</td>
    </tr>
  </tbody>
</table>

<p>파이프는 Guards·Interceptors 이후, Controller 직전에 실행된다. 인증된 요청의 데이터만 검증하는 것이 목적으로 존재한다.</p>

<hr />

<h1 id="2-핵심-로직-흐름">2. 핵심 로직 흐름</h1>

<h2 id="전체-요청-처리-흐름-실행-순서">전체 요청 처리 흐름 (실행 순서)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[HTTP Request]
      │
      ▼
 app.use(json/urlencoded)          ← Express Middleware (bodyParser)
      │
      ▼
 OriginGuard                       ← 전역 가드 1 (main.ts useGlobalGuards)
  - origin 헤더 없음 → 통과
  - 화이트리스트 포함 → 통과
  - 그 외 → ForbiddenException
      │
      ▼
 ThrottlerGuard                    ← 전역 가드 2 (APP_GUARD, AppModule)
  - burst: 초당 2000 req
  - sustained: 분당 60000 req
  - Redis에 카운터 저장
      │
      ▼
 JwtAuthGuard                      ← 전역 가드 3 (APP_GUARD, AppModule)
  - @Public() → 바이패스
  - Reflector로 메타데이터 확인
  - JWT 유효 → request.user 세팅
  - JWT 무효 → UnauthorizedException
      │
      ▼
 [AiCircuitGuard]                  ← 라우트 가드 (@UseGuards, 해당 엔드포인트만)
  - Redis heartbeat 확인
  - AI ONLINE → 통과
  - AI OFFLINE → ServiceUnavailableException
      │
      ▼
 LoggingInterceptor                ← 전역 인터셉터 (요청 시각 기록)
      │
      ▼
 [KnowledgeUploadBusyCheckInterceptor] ← 라우트 인터셉터 (업로드 엔드포인트만)
  - QueueService.isBusy() 확인
  - 큐 여유 → 통과
  - 큐 포화 → ServiceUnavailableException
      │
      ▼
 ValidationPipe                    ← 전역 파이프
  - DTO 인스턴스로 변환 (transform: true)
  - 미선언 필드 제거 (whitelist: true)
  - 검증 실패 → BadRequestException
      │
      ▼
 Controller → Service              ← 비즈니스 로직
      │
      ▼
 LoggingInterceptor (tap)          ← 응답 후처리 (응답 시간 측정·로깅)
 ClassSerializerInterceptor        ← @Exclude/@Expose 직렬화
      │
      ▼
 GlobalExceptionFilter             ← 예외 발생 시 일괄 처리
      │
      ▼
 [HTTP Response]
</code></pre></div></div>

<h2 id="originguard-흐름">OriginGuard 흐름</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">:</span> <span class="nx">ExecutionContext</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">origin</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">origin</span><span class="p">;</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">origin</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>          <span class="c1">// Server-to-Server, Postman 등 → 통과</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">whitelist</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">origin</span><span class="p">))</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">ForbiddenException</span><span class="p">();</span>    <span class="c1">// 미등록 브라우저 origin → 403</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>[!note] <code class="language-plaintext highlighter-rouge">origin</code> 헤더가 없는 경우 무조건 통과하는 이유
<code class="language-plaintext highlighter-rouge">origin</code> 헤더는 <strong>브라우저가 보내는 CORS 헤더</strong>다.
서버 간 통신(FastAPI 워커 웹훅), Postman, curl 등에는 origin이 없다.
이 엔드포인트들을 차단하지 않으려면 <code class="language-plaintext highlighter-rouge">!origin</code> 일 때 통과가 맞다.
단, 이 경우 웹훅 엔드포인트는 별도의 시크릿 키 검증으로 보완하고 있다.</p>
</blockquote>

<h2 id="jwtauthguard-흐름">JwtAuthGuard 흐름</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">:</span> <span class="nx">ExecutionContext</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isPublic</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">reflector</span><span class="p">.</span><span class="nx">getAllAndOverride</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">IS_PUBLIC_KEY</span><span class="p">,</span> <span class="p">[</span>
    <span class="nx">context</span><span class="p">.</span><span class="nf">getHandler</span><span class="p">(),</span>   <span class="c1">// 메서드 레벨 메타데이터 우선</span>
    <span class="nx">context</span><span class="p">.</span><span class="nf">getClass</span><span class="p">(),</span>     <span class="c1">// 클래스 레벨 메타데이터 차선</span>
  <span class="p">]);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">isPublic</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>

  <span class="k">return</span> <span class="k">super</span><span class="p">.</span><span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>  <span class="c1">// Passport jwt 전략 실행</span>
  <span class="c1">// → JwtStrategy.validate() → request.user 세팅</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="logginginterceptor-흐름">LoggingInterceptor 흐름</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">intercept</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">CallHandler</span><span class="p">):</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">();</span>                <span class="c1">// 요청 진입 시각 기록</span>

  <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span>
    <span class="nf">tap</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>                          <span class="c1">// 응답 완료 후 실행</span>
      <span class="kd">const</span> <span class="nx">duration</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">now</span><span class="p">;</span>
      <span class="c1">// 4xx 이상은 로깅 안 함 (GlobalExceptionFilter에서 처리)</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">statusCode</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http_traffic_protostar</span><span class="dl">'</span><span class="p">,</span> <span class="nx">duration_ms</span><span class="p">,</span> <span class="p">...</span> <span class="p">});</span>
    <span class="p">})</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="knowledgeuploadbusycheckinterceptor-흐름">KnowledgeUploadBusyCheckInterceptor 흐름</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">intercept</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">CallHandler</span><span class="p">):</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">queueService</span><span class="p">.</span><span class="nf">isBusy</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 큐가 꽉 찼으면 next.handle() 자체를 호출하지 않음</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">ServiceUnavailableException</span><span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">queueService</span><span class="p">.</span><span class="nf">getStatus</span><span class="p">()</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">();</span>   <span class="c1">// 큐 여유 있으면 그냥 통과</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="validationpipe-흐름">ValidationPipe 흐름</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.ts</span>
<span class="k">new</span> <span class="nc">ValidationPipe</span><span class="p">({</span>
  <span class="na">transform</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>    <span class="c1">// JSON string → DTO 클래스 인스턴스</span>
  <span class="na">whitelist</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>    <span class="c1">// DTO에 없는 필드 자동 제거</span>
<span class="p">})</span>

<span class="c1">// 예시 DTO</span>
<span class="kd">class</span> <span class="nc">CreateChatDto</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">IsString</span><span class="p">()</span> <span class="p">@</span><span class="nd">IsNotEmpty</span><span class="p">()</span>
  <span class="nx">content</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="p">@</span><span class="nd">IsString</span><span class="p">()</span>
  <span class="nx">sessionId</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="p">@</span><span class="nd">IsOptional</span><span class="p">()</span>
  <span class="nx">context</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// content, sessionId, context 외 필드는 자동 제거</span>
<span class="c1">// content가 없으면 BadRequestException</span>
</code></pre></div></div>

<hr />

<h1 id="3-구조적-취약점--개선-방향">3. 구조적 취약점 / 개선 방향</h1>

<h2 id="originguard-origin-없는-요청을-무조건-통과">[OriginGuard] <code class="language-plaintext highlighter-rouge">origin</code> 없는 요청을 무조건 통과</h2>

<p>서버 내부 통신, curl, Postman을 허용하기 위한 의도적 설계이지만, <strong>서버가 인터넷에 직접 노출된 경우</strong> <code class="language-plaintext highlighter-rouge">origin</code> 헤더를 생략한 악의적 요청도 통과될 수 있게 되어 있다.</p>

<p><strong>현재 보완책</strong>: 웹훅 엔드포인트는 <code class="language-plaintext highlighter-rouge">x-webhook-secret</code> 헤더로 추가 검증을 통해 막아내고 있고, API 사용시 이를 추가하도록 해둠. 
<strong>추가 보완 방향</strong>: 보다 섬세한 방어를 위해선 IP 화이트리스트 또는 네트워크 레벨 격리 (Docker network 분리).</p>

<h2 id="jwtauthguard-useglobalguards-vs-app_guard-혼용">[JwtAuthGuard] <code class="language-plaintext highlighter-rouge">useGlobalGuards</code> vs <code class="language-plaintext highlighter-rouge">APP_GUARD</code> 혼용</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.ts: DI 컨테이너 밖</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalGuards</span><span class="p">(</span><span class="k">new</span> <span class="nc">OriginGuard</span><span class="p">());</span>

<span class="c1">// AppModule: DI 컨테이너 안</span>
<span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">JwtAuthGuard</span> <span class="p">}</span>
</code></pre></div></div>

<p><strong>문제</strong>: 두 방식이 혼용되어 전역 가드 목록을 한 곳에서 파악하기 어렵다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">main.ts</code>의 <code class="language-plaintext highlighter-rouge">OriginGuard</code>는 생성자 주입이 없어서 두 방식 다 가능하지만, <code class="language-plaintext highlighter-rouge">APP_GUARD</code>로 통일하면 가드 관리 포인트가 <code class="language-plaintext highlighter-rouge">AppModule</code> 하나로 집중된다. 추후 개선이 필요한 영역</li>
</ul>

<h2 id="knowledgeuploadbusycheckinterceptor-큐-상태를-에러-응답으로-노출">[KnowledgeUploadBusyCheckInterceptor] 큐 상태를 에러 응답으로 노출</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="k">new</span> <span class="nc">ServiceUnavailableException</span><span class="p">({</span>
  <span class="na">data</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">queueService</span><span class="p">.</span><span class="nf">getStatus</span><span class="p">(),</span>  <span class="c1">// active, pending, concurrency, maxPending 노출</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getStatus()</code>가 반환하는 내부 처리량 정보(동시 실행 수, 대기열 크기)가 외부에 그대로 노출되도록 해두었던것을 발견. 해당 지표는 내부 운영 지표로 모니터링 시스템에서 보고(logging, loki), 외부 응답에서는 단순 재시도 안내만 해주는 것으로 해두는 것이 좋아 보인다.</p>

<hr />

<h1 id="4-핵심-메서드-및-라이브러리-함수-설명">4. 핵심 메서드 및 라이브러리 함수 설명</h1>

<h2 id="executioncontext"><code class="language-plaintext highlighter-rouge">ExecutionContext</code></h2>

<p>가드·인터셉터·필터에서 현재 실행 컨텍스트에 접근하는 객체. HTTP 외에도 WebSocket, RPC를 지원하기 때문에 <strong>프로토콜에 맞는 캐스팅</strong>이 필요하다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">context</span><span class="p">.</span><span class="nf">switchToHttp</span><span class="p">().</span><span class="nf">getRequest</span><span class="p">()</span>   <span class="c1">// HTTP Request 객체</span>
<span class="nx">context</span><span class="p">.</span><span class="nf">switchToHttp</span><span class="p">().</span><span class="nf">getResponse</span><span class="p">()</span>  <span class="c1">// HTTP Response 객체</span>
<span class="nx">context</span><span class="p">.</span><span class="nf">getHandler</span><span class="p">()</span>   <span class="c1">// 현재 라우트 핸들러 메서드 참조</span>
<span class="nx">context</span><span class="p">.</span><span class="nf">getClass</span><span class="p">()</span>     <span class="c1">// 현재 컨트롤러 클래스 참조</span>
</code></pre></div></div>

<h2 id="reflectorgetallandoverridekey-handler-class"><code class="language-plaintext highlighter-rouge">Reflector.getAllAndOverride(key, [handler, class])</code></h2>

<p>메타데이터를 읽는 NestJS 유틸리티. <code class="language-plaintext highlighter-rouge">getAllAndOverride</code>는 <strong>먼저 나열된 대상에서 값을 찾으면 거기서 반환</strong>한다 (오버라이드 우선순위 적용).</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 메서드에 @Public()이 있으면 그 값 사용</span>
<span class="c1">// 없으면 클래스에 @Public()이 있는지 확인</span>
<span class="k">this</span><span class="p">.</span><span class="nx">reflector</span><span class="p">.</span><span class="nx">getAllAndOverride</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">IS_PUBLIC_KEY</span><span class="p">,</span> <span class="p">[</span>
  <span class="nx">context</span><span class="p">.</span><span class="nf">getHandler</span><span class="p">(),</span>  <span class="c1">// 1순위: 메서드 레벨</span>
  <span class="nx">context</span><span class="p">.</span><span class="nf">getClass</span><span class="p">(),</span>    <span class="c1">// 2순위: 클래스 레벨</span>
<span class="p">]);</span>
</code></pre></div></div>

<h2 id="authguardjwt-passport"><code class="language-plaintext highlighter-rouge">AuthGuard('jwt')</code> (Passport)</h2>

<p><code class="language-plaintext highlighter-rouge">@nestjs/passport</code>가 제공하는 추상 가드. 내부적으로 <code class="language-plaintext highlighter-rouge">PassportStrategy</code>를 실행하고, 성공 시 <code class="language-plaintext highlighter-rouge">request.user</code>에 <code class="language-plaintext highlighter-rouge">validate()</code> 반환값을 세팅한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 상속 구조</span>
<span class="nx">JwtAuthGuard</span> <span class="kd">extends</span> <span class="nc">AuthGuard</span><span class="p">(</span><span class="dl">'</span><span class="s1">jwt</span><span class="dl">'</span><span class="p">)</span>
  <span class="err">→</span> <span class="nx">Passport가</span> <span class="nx">jwt</span> <span class="nx">전략을</span> <span class="nx">찾아</span> <span class="nx">실행</span>
  <span class="err">→</span> <span class="nx">JwtStrategy</span><span class="p">.</span><span class="nf">validate</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="nx">호출</span>
  <span class="err">→</span> <span class="nx">반환값</span> <span class="err">→</span> <span class="nx">request</span><span class="p">.</span><span class="nx">user</span>
</code></pre></div></div>

<h2 id="createparamdecorator-validateuser"><code class="language-plaintext highlighter-rouge">createParamDecorator</code> (<code class="language-plaintext highlighter-rouge">@ValidateUser()</code>)</h2>

<p>컨트롤러 파라미터에서 값을 추출하는 커스텀 데코레이터 생성 함수. 인가된 유저에 대하여 토큰 속에 포함된 데이터를 기반으로 접근하여 빠른 이용자 확인, 유저 정보 이용이 가능하다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">ValidateUser</span> <span class="o">=</span> <span class="nf">createParamDecorator</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">:</span> <span class="nx">ExecutionContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">switchToHttp</span><span class="p">().</span><span class="nf">getRequest</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">request</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>   <span class="c1">// JwtStrategy.validate()가 세팅한 값</span>
  <span class="p">},</span>
<span class="p">);</span>

<span class="c1">// 사용</span>
<span class="k">async</span> <span class="nf">uploadDocs</span><span class="p">(@</span><span class="nd">ValidateUser</span><span class="p">()</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="nexthandle--callhandler"><code class="language-plaintext highlighter-rouge">next.handle()</code> / <code class="language-plaintext highlighter-rouge">CallHandler</code></h2>

<p>인터셉터에서 다음 단계(컨트롤러 또는 다음 인터셉터)를 실행하는 메서드. <strong>호출하지 않으면 컨트롤러 실행 자체가 막힌다</strong>. <code class="language-plaintext highlighter-rouge">KnowledgeUploadBusyCheckInterceptor</code>는 큐가 꽉 찼을 때 <code class="language-plaintext highlighter-rouge">next.handle()</code>을 호출하지 않고 예외를 던져 흐름을 차단한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 요청 전처리만 (응답 후처리 없음)</span>
<span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">();</span>

<span class="c1">// 요청 전처리 + 응답 후처리</span>
<span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span>
  <span class="nf">tap</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)),</span>      <span class="c1">// 사이드 이펙트</span>
  <span class="nf">map</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nf">transform</span><span class="p">(</span><span class="nx">data</span><span class="p">)),</span>        <span class="c1">// 응답 변환</span>
  <span class="nf">catchError</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">...)</span>               <span class="c1">// 에러 처리</span>
<span class="p">);</span>
</code></pre></div></div>

<h2 id="setmetadatakey-value"><code class="language-plaintext highlighter-rouge">SetMetadata(key, value)</code></h2>

<p>클래스 또는 메서드에 메타데이터를 첨부하는 NestJS 유틸리티.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @Public() 데코레이터 구현</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">IS_PUBLIC_KEY</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">isPublic</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Public</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">SetMetadata</span><span class="p">(</span><span class="nx">IS_PUBLIC_KEY</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</code></pre></div></div>

<p>Reflect API(<code class="language-plaintext highlighter-rouge">Reflect.defineMetadata</code>)를 래핑한 것으로, <code class="language-plaintext highlighter-rouge">Reflector</code>로 런타임에 조회할 수 있다.</p>

<h2 id="skipthrottle-chatcontroller-sse"><code class="language-plaintext highlighter-rouge">@SkipThrottle()</code> (ChatController SSE)</h2>

<p><code class="language-plaintext highlighter-rouge">@nestjs/throttler</code>가 제공하는 데코레이터. 특정 라우트에서 Rate Limit을 우회한다. 지정된 RateLimit 과 관계가 없는 장기 연결에서 자칫 RateLimit 이 발생하지 않기 위한 처리이다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Sse</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream/:sessionId</span><span class="dl">'</span><span class="p">)</span>
<span class="p">@</span><span class="nd">SkipThrottle</span><span class="p">()</span>   <span class="c1">// SSE는 장기 연결이므로 요청 카운트 제외</span>
<span class="nf">stream</span><span class="p">(...)</span> <span class="p">{}</span>
</code></pre></div></div>

<hr />

<h1 id="5-대체-가능한-라이브러리-및-트레이드오프">5. 대체 가능한 라이브러리 및 트레이드오프</h1>

<h2 id="guards-대안">Guards 대안</h2>

<h3 id="passport-jwt-vs-직접-구현-jwt-검증"><code class="language-plaintext highlighter-rouge">passport-jwt</code> vs 직접 구현 JWT 검증</h3>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**passport-jwt** (현재)</td>
      <td>NestJS 공식 통합, 전략 패턴으로 확장 용이</td>
      <td>추상화가 많아 흐름 파악이 어려움</td>
    </tr>
    <tr>
      <td>**jose / jsonwebtoken 직접**</td>
      <td>흐름이 투명, 의존성 최소</td>
      <td>검증 로직 직접 구현 필요</td>
    </tr>
    <tr>
      <td>**@fastify/jwt**</td>
      <td>Fastify 어댑터 사용 시 성능 우위</td>
      <td>Express 어댑터와 혼용 불가</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Passport는 전략(Strategy) 패턴을 사용해 OAuth, Local, JWT 등 인증 방식을 교체하기 쉽다는 장점이 있다. 단일 JWT만 쓴다면 <code class="language-plaintext highlighter-rouge">jsonwebtoken</code> 직접 사용이 더 투명하다.</p>
</blockquote>

<h3 id="originguard의-cors-처리-위치">OriginGuard의 CORS 처리 위치</h3>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**OriginGuard** (현재)</td>
      <td>NestJS 파이프라인 내 처리, DI 활용 가능</td>
      <td>Guard에서 CORS를 처리하면 역할이 애매해짐</td>
    </tr>
    <tr>
      <td>**enableCors() 단독**</td>
      <td>CORS 표준 방식, 브라우저 프리플라이트 처리</td>
      <td>비브라우저 요청에 대한 서버 측 검증 없음</td>
    </tr>
    <tr>
      <td>**Nginx 레벨**</td>
      <td>앱 레이어 도달 전 차단, 성능 우수</td>
      <td>동적 도메인 관리 어려움</td>
    </tr>
  </tbody>
</table>

<h2 id="interceptors-대안">Interceptors 대안</h2>

<h3 id="tap-vs-map-vs-switchmap"><code class="language-plaintext highlighter-rouge">tap()</code> vs <code class="language-plaintext highlighter-rouge">map()</code> vs <code class="language-plaintext highlighter-rouge">switchMap()</code></h3>

<table>
  <thead>
    <tr>
      <th>연산자</th>
      <th>용도</th>
      <th>특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**<code class="language-plaintext highlighter-rouge">tap()</code>** (현재 로깅)</td>
      <td>사이드 이펙트 (로깅, 캐싱 등)</td>
      <td>스트림 값을 변경하지 않음</td>
    </tr>
    <tr>
      <td>**<code class="language-plaintext highlighter-rouge">map()</code>**</td>
      <td>응답 데이터 변환</td>
      <td>값을 변환해서 반환</td>
    </tr>
    <tr>
      <td>**<code class="language-plaintext highlighter-rouge">switchMap()</code>**</td>
      <td>비동기 변환 (DB 조회 등)</td>
      <td>내부 Observable을 교체</td>
    </tr>
    <tr>
      <td>**<code class="language-plaintext highlighter-rouge">catchError()</code>**</td>
      <td>에러 처리</td>
      <td>에러를 잡아 대체 Observable 반환</td>
    </tr>
  </tbody>
</table>

<h3 id="로깅-인터셉터-대안">로깅 인터셉터 대안</h3>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**LoggingInterceptor** (현재)</td>
      <td>NestJS 파이프라인 내 통합</td>
      <td>Guard 이전 로그 불가</td>
    </tr>
    <tr>
      <td>**Express Middleware**</td>
      <td>Guard 이전 포함 전체 요청 로깅</td>
      <td>NestJS 추상화 우회</td>
    </tr>
    <tr>
      <td>**APM 도구 (Datadog, New Relic)**</td>
      <td>자동 계측, 분산 추적</td>
      <td>비용, 벤더 잠금</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">LoggingInterceptor</code>는 Guard에서 차단된 요청(401, 403)은 로깅하지 않는다는 한계가 있다. 차단된 요청도 추적하려면 <code class="language-plaintext highlighter-rouge">GlobalExceptionFilter</code>에서 보완하거나 Express 미들웨어 레이어에서 처리해야 한다.</p>
</blockquote>

<h2 id="validationpipe-대안">ValidationPipe 대안</h2>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**class-validator** (현재)</td>
      <td>NestJS 공식, 데코레이터 기반, 직관적</td>
      <td>런타임 반영(reflect-metadata) 필요</td>
    </tr>
    <tr>
      <td>**zod + ZodPipe**</td>
      <td>타입 추론 강력, TS 친화적</td>
      <td>NestJS 기본 통합 아님</td>
    </tr>
    <tr>
      <td>**Joi + JoiPipe**</td>
      <td>성숙한 생태계</td>
      <td>class-decorator 방식과 혼용 불편</td>
    </tr>
    <tr>
      <td>**수동 검증**</td>
      <td>의존성 없음</td>
      <td>반복 코드, 유지보수 어려움</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>zod</strong>는 최근 TypeScript 생태계에서 강세. 스키마 정의와 타입 추론이 동시에 되어 <code class="language-plaintext highlighter-rouge">z.infer&lt;typeof schema&gt;</code>로 별도 DTO 클래스 없이 타입을 뽑을 수 있다. 단, <code class="language-plaintext highlighter-rouge">class-validator</code>와 달리 데코레이터 방식이 아니라 파이프 코드를 직접 작성해야 한다.</p>
</blockquote>

<hr />

<h1 id="6-개발자로서-알아야-할-영역">6. 개발자로서 알아야 할 영역</h1>

<h2 id="a-각-레이어의-책임-경계-이해">A. 각 레이어의 책임 경계 이해</h2>

<p>파이프라인 각 단계가 <strong>왜 그 위치에 있는지</strong> 설명할 수 있어야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Middleware  → HTTP 레벨 처리. NestJS 추상화 없이 요청·응답 객체 직접 조작.
              인증이나 로직보다는 rawBody 파싱, 압축, 요청 변환에 적합.

Guard       → "이 요청이 들어올 자격이 있는가?" 를 판단.
              인증(Authentication), 인가(Authorization), 서비스 가용성 확인.
              boolean을 반환하므로 로직이 단순해야 한다.

Interceptor → "요청/응답 주변에 무엇을 할 것인가?" 를 처리.
              로깅, 캐싱, 응답 변환, 타임아웃, 큐 체크 등.
              Observable을 반환하므로 RxJS 연산자 활용 가능.

Pipe        → "데이터가 올바른 형태인가?" 를 검증·변환.
              타입 변환, 유효성 검사. 인증 이후에만 실행.
</code></pre></div></div>

<h2 id="b-canactivate가-false를-반환하는-것과-예외를-던지는-것의-차이">B. <code class="language-plaintext highlighter-rouge">canActivate</code>가 <code class="language-plaintext highlighter-rouge">false</code>를 반환하는 것과 예외를 던지는 것의 차이</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// false 반환 → NestJS가 기본 UnauthorizedException 생성</span>
<span class="nf">canActivate</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 예외 직접 throw → 원하는 상태코드·메시지 제어 가능</span>
<span class="nf">canActivate</span><span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">ForbiddenException</span><span class="p">(</span><span class="dl">'</span><span class="s1">Not allowed origin</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">false</code>를 반환하면 NestJS가 자동으로 <code class="language-plaintext highlighter-rouge">401 Unauthorized</code>를 응답한다. 하지만 이 프로젝트처럼 이유가 다를 때(Origin 차단은 <code class="language-plaintext highlighter-rouge">403 Forbidden</code>, AI 서비스 불가는 <code class="language-plaintext highlighter-rouge">503 Service Unavailable</code>)는 <strong>예외를 직접 던져야 원하는 상태코드</strong>를 줄 수 있다.</p>

<h2 id="c-전역-등록-vs-라우트-등록의-설계-원칙">C. 전역 등록 vs 라우트 등록의 설계 원칙</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>전역 등록</th>
      <th>라우트 등록</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**기준**</td>
      <td>모든 요청에 적용해야 하는가</td>
      <td>특정 도메인·엔드포인트에만 필요한가</td>
    </tr>
    <tr>
      <td>**가드 예시**</td>
      <td>JwtAuthGuard, ThrottlerGuard</td>
      <td>AiCircuitGuard</td>
    </tr>
    <tr>
      <td>**인터셉터 예시**</td>
      <td>LoggingInterceptor</td>
      <td>KnowledgeUploadBusyCheckInterceptor</td>
    </tr>
    <tr>
      <td>**장점**</td>
      <td>누락 위험 없음</td>
      <td>불필요한 실행 없음, 명시적 의도</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>이 프로젝트의 <code class="language-plaintext highlighter-rouge">JwtAuthGuard</code>는 전역으로 걸되 <code class="language-plaintext highlighter-rouge">@Public()</code>으로 예외를 허용하는 방식 → <strong>“기본 잠금, 필요 시 열기”</strong> 패턴. 
<code class="language-plaintext highlighter-rouge">AiCircuitGuard</code>는 AI 관련 라우트에만 명시적으로 적용 → <strong>“필요한 곳에만 잠금”</strong> 패턴. 
두 패턴을 기능적 특성, 상황에 맞게 선택할 수 있어야 한다.</p>
</blockquote>

<h2 id="d-interceptor에서-rxjs를-사용하는-이유">D. Interceptor에서 RxJS를 사용하는 이유</h2>

<p>NestJS Interceptor가 <code class="language-plaintext highlighter-rouge">Observable</code>을 반환하는 이유는 <strong>SSE·WebSocket·스트리밍 응답을 일관된 방식으로 처리</strong>하기 위해서다. 일반 HTTP 응답도 내부적으로 Observable로 래핑된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 응답 완료 후 로직 (tap)</span>
<span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">tap</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="cm">/* 로깅 */</span> <span class="p">}))</span>

<span class="c1">// 응답 변환 (map)</span>
<span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">success</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">data</span> <span class="p">})))</span>

<span class="c1">// 에러 → 정상 응답으로 변환 (catchError)</span>
<span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">catchError</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="k">of</span><span class="p">({</span> <span class="na">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">error</span><span class="p">:</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="p">})))</span>

<span class="c1">// 타임아웃 처리</span>
<span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">timeout</span><span class="p">(</span><span class="mi">5000</span><span class="p">),</span> <span class="nf">catchError</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">...))</span>
</code></pre></div></div>

<h2 id="e-public-패턴의-보안-함의">E. <code class="language-plaintext highlighter-rouge">@Public()</code> 패턴의 보안 함의</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Public</span><span class="p">()</span>
<span class="p">@</span><span class="nd">Post</span><span class="p">(</span><span class="dl">'</span><span class="s1">webhook</span><span class="dl">'</span><span class="p">)</span>
<span class="nf">handleWebhook</span><span class="p">(@</span><span class="nd">Headers</span><span class="p">(</span><span class="dl">'</span><span class="s1">x-webhook-secret</span><span class="dl">'</span><span class="p">)</span> <span class="nx">secret</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">secret</span> <span class="o">!==</span> <span class="nx">INTERNAL_SECRET</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@Public()</code>으로 JWT 인증을 우회한 엔드포인트는 <strong>반드시 다른 인증 수단</strong>으로 보완해야 한다. 
이 프로젝트의 웹훅은 <code class="language-plaintext highlighter-rouge">x-webhook-secret</code> 헤더 검증으로 보완하고 있다. 
<code class="language-plaintext highlighter-rouge">@Public()</code> 붙이고 아무 검증도 없는 엔드포인트는 의도치 않은 공개 API가 된다.</p>

<h2 id="f-파이프라인-디버깅-방법">F. 파이프라인 디버깅 방법</h2>

<p>요청이 어느 단계에서 막히는지 확인하는 실용적 방법:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Guard에서 로그 추가</span>
<span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Guard] 실행됨</span><span class="dl">'</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// Interceptor에서 로그 추가</span>
<span class="nf">intercept</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Interceptor] before</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span>
    <span class="nf">tap</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Interceptor] after</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>또는 NestJS의 <code class="language-plaintext highlighter-rouge">Logger</code>를 활용해 각 단계 진입 로그를 남겨두면 운영 중에도 Loki에서 요청 흐름 추적이 가능하다.</p>

<hr />

<h1 id="핵심-요약-카드">핵심 요약 카드</h1>

<blockquote>
  <p>[!abstract] Guard 3종 역할 구분</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">OriginGuard</code> → <strong>출처(Origin) 검사</strong> : 브라우저 기반 요청의 도메인 화이트리스트</li>
    <li><code class="language-plaintext highlighter-rouge">JwtAuthGuard</code> → <strong>신원(Authentication)</strong> : 토큰 유효성 확인 + request.user 세팅</li>
    <li><code class="language-plaintext highlighter-rouge">AiCircuitGuard</code> → <strong>서비스 가용성</strong> : AI 워커 생존 여부에 따른 서킷브레이커</li>
  </ul>
</blockquote>

<blockquote>
  <p>[!abstract] Interceptor 3종 역할 구분</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">LoggingInterceptor</code> → 요청 전/응답 후 구조화 로그 수집</li>
    <li><code class="language-plaintext highlighter-rouge">KnowledgeUploadBusyCheckInterceptor</code> → 컨트롤러 도달 전 큐 포화 차단</li>
    <li><code class="language-plaintext highlighter-rouge">ClassSerializerInterceptor</code> → 응답 객체의 민감 필드 직렬화 제어</li>
  </ul>
</blockquote>

<blockquote>
  <p>[!question] 설명할 수 있어야 하는 것</p>
  <ol>
    <li>Middleware가 Guard보다 먼저 실행되는 이유</li>
    <li><code class="language-plaintext highlighter-rouge">OriginGuard</code>에서 <code class="language-plaintext highlighter-rouge">origin</code>이 없을 때 통과시키는 이유와 보완책</li>
    <li><code class="language-plaintext highlighter-rouge">next.handle()</code>을 호출하지 않으면 어떻게 되는가</li>
    <li><code class="language-plaintext highlighter-rouge">getAllAndOverride</code> vs <code class="language-plaintext highlighter-rouge">getAllAndMerge</code>의 차이</li>
    <li>인터셉터가 <code class="language-plaintext highlighter-rouge">Observable</code>을 반환해야 하는 이유</li>
    <li><code class="language-plaintext highlighter-rouge">ValidationPipe</code>의 <code class="language-plaintext highlighter-rouge">whitelist</code>와 <code class="language-plaintext highlighter-rouge">forbidNonWhitelisted</code>의 차이</li>
  </ol>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="NestJS" /><category term="AI" /><summary type="html"><![CDATA[NestJS 파이프라인 구성요소 분석 Middleware → Guards → Interceptors → Pipes]]></summary></entry><entry><title type="html">Protostar review note - 06 NestJS Intro</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/18/00-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 06 NestJS Intro" /><published>2026-02-18T00:00:00+00:00</published><updated>2026-02-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/18/00-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/18/00-protostar-review.html"><![CDATA[<h1 id="nestjs-개념-정리">NestJS 개념 정리</h1>
<p>본 정리 내용은, 프레임워크에 대한 이해도를 복기 하면서도 짜게 되었던 구성요소들을 더 심화시켜 바라보고 풀스택을 하다보니 놓치거나 좀더 좋은 코드를 만들기 위해 필요한 개념 복습, 코드 구성에 대한 고민을 위한 추가 복습이다.</p>

<p>개괄적인 전체 내용을 복습한 이후, 특정 파일 구성요소 중심으로 복습을 기록할 예정이다.</p>

<ul>
  <li>Node.js 위에서 동작하는 <strong>구조화된 백엔드 프레임워크</strong></li>
  <li>TypeScript 네이티브 지원, Angular에서 영감을 받은 <strong>모듈/DI 기반 아키텍처</strong></li>
  <li>Express(기본) 또는 Fastify를 HTTP 어댑터로 사용</li>
  <li>데코레이터(<code class="language-plaintext highlighter-rouge">@Module</code>, <code class="language-plaintext highlighter-rouge">@Controller</code>, <code class="language-plaintext highlighter-rouge">@Injectable</code> 등)로 메타데이터를 선언하고, IoC 컨테이너가 의존성을 관리함</li>
</ul>

<h2 id="핵심-철학-및-특징">핵심 철학 및 특징</h2>
<ul>
  <li><strong>모듈성(Modularity)</strong>: 기능 단위로 모듈을 나누고, 각 모듈이 자신의 책임 범위를 캡슐화</li>
  <li><strong>의존성 주입(DI)</strong>: NestJS IoC 컨테이너가 Provider 인스턴스를 생성·관리하며, 생성자에서 자동 주입</li>
  <li><strong>데코레이터 기반</strong>: 클래스와 메서드에 데코레이터를 붙여 역할을 선언적으로 표현</li>
  <li><strong>레이어드 파이프라인</strong>: 요청이 들어오면 정해진 순서(Lifecycle)대로 처리 계층을 통과</li>
</ul>

<h2 id="fastapi와의-비교">FastAPI와의 비교</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>NestJS</th>
      <th>FastAPI</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**언어**</td>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>**DI 방식**</td>
      <td>IoC 컨테이너(자동 관리)</td>
      <td>함수 기반 Depends(명시적 추적)</td>
    </tr>
    <tr>
      <td>**구조화**</td>
      <td>강제적(Module/Controller/Service 분리)</td>
      <td>자유로움(도메인 설계는 개발자 몫)</td>
    </tr>
    <tr>
      <td>**비동기**</td>
      <td>Promise / RxJS Observable</td>
      <td>async/await (ASGI 기반)</td>
    </tr>
    <tr>
      <td>**주요 용도**</td>
      <td>복잡한 비즈니스 로직, 엔터프라이즈</td>
      <td>AI 서빙, 경량 마이크로서비스</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="요청-생명주기-request-lifecycle">요청 생명주기 (Request Lifecycle)</h1>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">main.ts</code> 주석에 직접 남겨둔 순서. NestJS의 파이프라인은 <strong>절대적으로 지켜지는 순서</strong>이므로 설계 시 이 흐름을 먼저 이해해야 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 요청 진입 (HTTP Request)
2. Middleware     ─ 요청 자체가 이상하면 미리 컷
3. Guards        ─ 인증/인가 (검증 실패 시 Pipe 불필요)
4. Interceptors  ─ 요청 전처리 (로깅, 변환 등)
5. Pipes         ─ 인증된 사용자만 데이터 검사·변환
6. Controller &amp; Service ─ 실제 비즈니스 로직
7. Interceptors  ─ 응답 후처리 (직렬화, 포맷 등)
8. Exception Filters ─ 에러 일괄 처리
9. Response
</code></pre></div></div>

<blockquote>
  <p>[!tip] 핵심 포인트
Guards 다음에 Pipe가 오는 이유: <strong>인증이 안 된 요청의 데이터를 굳이 검증할 필요가 없기 때문</strong>. 순서에 논리적 이유가 있다.</p>
</blockquote>

<hr />

<h1 id="프로젝트-구조-protostar-nestjs">프로젝트 구조 (Protostar NestJS)</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
├── app.module.ts          # 루트 모듈 (전체 조립)
├── app.controller.ts      # 루트 컨트롤러 (헬스체크 등)
├── app.service.ts
├── main.ts                # 진입점 (글로벌 파이프라인 설정)
│
├── common/                # 공통 인프라 레이어
│   ├── constants.ts       # 전역 상수
│   ├── decorators/        # 커스텀 데코레이터
│   │   ├── public.decorator.ts        # @Public() - JWT 인증 우회
│   │   └── validate-user.decorator.ts # @ValidateUser() - 유저 추출
│   ├── filters/
│   │   └── http-exception.filter.ts   # 전역 예외 필터
│   ├── guards/
│   │   ├── jwt-auth.guard.ts          # 전역 JWT 인증 가드
│   │   ├── ai-circuit.guard.ts        # AI 서비스 상태 서킷브레이커
│   │   └── origin.guard.ts            # Origin 화이트리스트 검사
│   ├── interceptors/
│   │   ├── logging.interceptor.ts            # HTTP 트래픽 로깅
│   │   └── knowledge-upload-busy-check.interceptor.ts
│   ├── monitoring/
│   │   ├── ai-status-monitoring.service.ts   # AI 상태 폴링 (1초 크론)
│   │   └── system-monitoring.service.ts
│   ├── objectStorage/     # MinIO 연동
│   ├── prisma/            # Prisma ORM 모듈
│   ├── queue/
│   │   └── queue.service.ts           # 인메모리 동시성 제어 큐
│   ├── redis/
│   │   └── redis.module.ts            # Redis 클라이언트 모듈
│   └── strategy/
│       └── jwt.strategy.ts            # Passport JWT 전략
│
└── features/              # 기능 도메인 레이어
    ├── auth/              # 인증 (로그인, 회원가입, JWT 발급)
    ├── chat/              # SSE 스트림 + Redis Pub/Sub
    └── knowledge/         # 파일 업로드 + RAG 웹훅
</code></pre></div></div>

<blockquote>
  <p>[!info] 구조 설계 원칙</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">common/</code> : 어떤 도메인에도 종속되지 않는 인프라성 코드 (가드, 인터셉터, 필터, 공유 서비스)</li>
    <li><code class="language-plaintext highlighter-rouge">features/</code> : 실제 비즈니스 도메인 단위 (각 도메인이 자신의 module/controller/service/dto를 포함)</li>
  </ul>
</blockquote>

<hr />

<h1 id="모듈-시스템">모듈 시스템</h1>

<p>NestJS의 모든 구성 요소는 <strong>모듈로 조립</strong>된다. <code class="language-plaintext highlighter-rouge">@Module</code> 데코레이터의 4가지 필드를 이해하면 전체 구조가 보인다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Module</span><span class="p">({</span>
  <span class="na">imports</span><span class="p">:</span> <span class="p">[],</span>      <span class="c1">// 다른 모듈에서 가져올 것들</span>
  <span class="na">controllers</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1">// 이 모듈의 HTTP 엔드포인트</span>
  <span class="na">providers</span><span class="p">:</span> <span class="p">[],</span>    <span class="c1">// 이 모듈에서 DI로 관리할 서비스/가드 등</span>
  <span class="na">exports</span><span class="p">:</span> <span class="p">[],</span>      <span class="c1">// 외부 모듈에서 사용할 수 있도록 공개</span>
<span class="p">})</span>
</code></pre></div></div>

<h3 id="appmodule-분석-appmodulets">AppModule 분석 (<code class="language-plaintext highlighter-rouge">app.module.ts</code>)</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Module</span><span class="p">({</span>
  <span class="na">imports</span><span class="p">:</span> <span class="p">[</span>
    <span class="nx">ConfigModule</span><span class="p">.</span><span class="nf">forRoot</span><span class="p">({</span> <span class="na">isGlobal</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}),</span>   <span class="c1">// 환경변수 전역 등록</span>
    <span class="nx">RedisModule</span><span class="p">,</span>
    <span class="nx">ChatModule</span><span class="p">,</span>
    <span class="nx">ThrottlerModule</span><span class="p">.</span><span class="nf">forRootAsync</span><span class="p">({</span> <span class="p">...</span> <span class="p">}),</span>       <span class="c1">// Redis 기반 Rate Limit</span>
    <span class="nx">ObjectStorageModule</span><span class="p">,</span>
    <span class="nx">AuthModule</span><span class="p">,</span>
    <span class="nx">PrismaModule</span><span class="p">,</span>
    <span class="nx">KnowledgeModule</span><span class="p">,</span>
  <span class="p">],</span>
  <span class="na">providers</span><span class="p">:</span> <span class="p">[</span>
    <span class="nx">AppService</span><span class="p">,</span>
    <span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">ThrottlerGuard</span> <span class="p">},</span>  <span class="c1">// 전역 Rate Limit 가드</span>
    <span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">JwtAuthGuard</span> <span class="p">},</span>    <span class="c1">// 전역 JWT 인증 가드</span>
  <span class="p">],</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">AppModule</span> <span class="p">{}</span>
</code></pre></div></div>

<blockquote>
  <p>[!note] APP_GUARD 토큰
<code class="language-plaintext highlighter-rouge">APP_GUARD</code> 는 NestJS가 전역 가드를 등록하는 특수 토큰. 모든 요청에 자동 적용된다.
<code class="language-plaintext highlighter-rouge">ThrottlerGuard</code>와 <code class="language-plaintext highlighter-rouge">JwtAuthGuard</code> 두 개를 등록하면 <strong>모든 요청이 두 가드를 순서대로 통과</strong>한다.</p>
</blockquote>

<hr />

<h1 id="guards-가드">Guards (가드)</h1>

<p>요청을 <strong>허용할지 차단할지 결정</strong>하는 계층. <code class="language-plaintext highlighter-rouge">canActivate()</code> 가 <code class="language-plaintext highlighter-rouge">true</code>를 반환해야 다음 단계로 진행된다.</p>

<h2 id="jwtauthguard---전역-jwt-인증">JwtAuthGuard - 전역 JWT 인증</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">JwtAuthGuard</span> <span class="kd">extends</span> <span class="nc">AuthGuard</span><span class="p">(</span><span class="dl">'</span><span class="s1">jwt</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">reflector</span><span class="p">:</span> <span class="nx">Reflector</span><span class="p">)</span> <span class="p">{</span> <span class="k">super</span><span class="p">();</span> <span class="p">}</span>

  <span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">:</span> <span class="nx">ExecutionContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Reflector로 메타데이터 확인</span>
    <span class="kd">const</span> <span class="nx">isPublic</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">reflector</span><span class="p">.</span><span class="nx">getAllAndOverride</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">IS_PUBLIC_KEY</span><span class="p">,</span> <span class="p">[</span>
      <span class="nx">context</span><span class="p">.</span><span class="nf">getHandler</span><span class="p">(),</span>  <span class="c1">// 메서드 레벨 메타데이터</span>
      <span class="nx">context</span><span class="p">.</span><span class="nf">getClass</span><span class="p">(),</span>    <span class="c1">// 클래스 레벨 메타데이터</span>
    <span class="p">]);</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">isPublic</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>  <span class="c1">// @Public() 이면 통과</span>
    <span class="k">return</span> <span class="k">super</span><span class="p">.</span><span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>  <span class="c1">// 아니면 JWT 검증</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>핵심 패턴</strong>: 전역으로 JWT 인증을 걸되, <code class="language-plaintext highlighter-rouge">@Public()</code> 데코레이터로 특정 엔드포인트만 우회.
→ 기본값이 “인증 필요”이므로 <strong>새 엔드포인트 추가 시 인증을 까먹을 위험이 없다</strong>.</p>

<h2 id="aicircuitguard---서킷-브레이커">AiCircuitGuard - 서킷 브레이커</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">AiCircuitGuard</span> <span class="k">implements</span> <span class="nx">CanActivate</span> <span class="p">{</span>
  <span class="nf">canActivate</span><span class="p">(</span><span class="nx">context</span><span class="p">:</span> <span class="nx">ExecutionContext</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">isAvailable</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">aiStatusMonitoringService</span><span class="p">.</span><span class="nf">isAvailable</span><span class="p">();</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">isAvailable</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">ServiceUnavailableException</span><span class="p">(</span><span class="dl">'</span><span class="s1">AI Service Unavailable.</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>AI 서비스(FastAPI 워커)가 살아있는지 확인 후 요청 차단</li>
  <li>서킷브레이커 패턴을 Guard 레이어에서 구현</li>
  <li><code class="language-plaintext highlighter-rouge">@UseGuards(AiCircuitGuard)</code> 로 채팅/지식 엔드포인트에만 적용</li>
</ul>

<hr />

<h1 id="interceptors-인터셉터">Interceptors (인터셉터)</h1>

<p>요청/응답 <strong>전후를 모두 가로채는</strong> 계층. RxJS <code class="language-plaintext highlighter-rouge">Observable</code>을 반환해야 한다.</p>

<h2 id="logginginterceptor---http-트래픽-로깅">LoggingInterceptor - HTTP 트래픽 로깅</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">LoggingInterceptor</span> <span class="k">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
  <span class="nf">intercept</span><span class="p">(</span><span class="nx">context</span><span class="p">:</span> <span class="nx">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">CallHandler</span><span class="p">):</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">handle</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span>
      <span class="nf">tap</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 응답이 나간 후 실행 (afterResponse)</span>
        <span class="kd">const</span> <span class="nx">responseTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">now</span><span class="p">;</span>
        <span class="c1">// Promtail/Loki 수집용 구조화 로그 출력</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http_traffic_protostar</span><span class="dl">'</span><span class="p">,</span> <span class="na">duration_ms</span><span class="p">:</span> <span class="nx">responseTime</span><span class="p">,</span> <span class="p">...</span> <span class="p">});</span>
      <span class="p">}),</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>[!tip] <code class="language-plaintext highlighter-rouge">next.handle().pipe(tap(...))</code></p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">next.handle()</code> : 다음 핸들러(컨트롤러)를 실행하는 Observable</li>
    <li><code class="language-plaintext highlighter-rouge">tap()</code> : 스트림을 변환하지 않고 <strong>사이드 이펙트만</strong> 실행 (로깅에 적합)</li>
    <li>요청 전 로직은 <code class="language-plaintext highlighter-rouge">next.handle()</code> 호출 <strong>전</strong>, 응답 후 로직은 <code class="language-plaintext highlighter-rouge">pipe()</code> 안에 작성</li>
  </ul>
</blockquote>

<hr />

<h1 id="exception-filters-예외-필터">Exception Filters (예외 필터)</h1>

<p>파이프라인의 <strong>마지막 방어선</strong>. 처리되지 않은 예외를 잡아 일관된 에러 응답으로 변환한다.</p>

<h2 id="globalexceptionfilter">GlobalExceptionFilter</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Catch</span><span class="p">()</span>  <span class="c1">// 인자 없으면 모든 예외 캐치</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">GlobalExceptionFilter</span> <span class="k">implements</span> <span class="nx">ExceptionFilter</span> <span class="p">{</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">exception</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">host</span><span class="p">:</span> <span class="nx">ArgumentsHost</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">exception</span> <span class="k">instanceof</span> <span class="nx">HttpException</span>
      <span class="p">?</span> <span class="nx">exception</span><span class="p">.</span><span class="nf">getStatus</span><span class="p">()</span>
      <span class="p">:</span> <span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">INTERNAL_SERVER_ERROR</span><span class="p">;</span>

    <span class="c1">// 5xx: logger.error / 4xx: logger.warn 으로 Loki 레벨 분리</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">500</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">logData</span><span class="p">));</span>
    <span class="k">else</span> <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">logData</span><span class="p">));</span>

    <span class="nx">response</span><span class="p">.</span><span class="nf">status</span><span class="p">(</span><span class="nx">status</span><span class="p">).</span><span class="nf">json</span><span class="p">({</span>
      <span class="na">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">statusCode</span><span class="p">:</span> <span class="nx">status</span><span class="p">,</span>
      <span class="na">timestamp</span><span class="p">:</span> <span class="p">...,</span>
      <span class="na">path</span><span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span>
      <span class="na">message</span><span class="p">:</span> <span class="p">...,</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>설계 포인트</strong>:</p>
<ul>
  <li>모든 에러의 응답 형태를 <code class="language-plaintext highlighter-rouge">{ success: false, statusCode, timestamp, path, message }</code> 로 통일</li>
  <li>5xx / 4xx를 로그 레벨로 분리해 Loki(로그 시스템)에서 알람 기준을 다르게 설정</li>
</ul>

<hr />

<h1 id="커스텀-데코레이터">커스텀 데코레이터</h1>

<p>NestJS에서 메타데이터를 활용한 커스텀 데코레이터를 만드는 두 가지 패턴.</p>

<h2 id="public---메타데이터-태깅">@Public() - 메타데이터 태깅</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정의</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">IS_PUBLIC_KEY</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">isPublic</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Public</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">SetMetadata</span><span class="p">(</span><span class="nx">IS_PUBLIC_KEY</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

<span class="c1">// 사용</span>
<span class="p">@</span><span class="nd">Public</span><span class="p">()</span>
<span class="p">@</span><span class="nd">Get</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream/:sessionId</span><span class="dl">'</span><span class="p">)</span>
<span class="nf">stream</span><span class="p">(...)</span> <span class="p">{}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SetMetadata(key, value)</code> : 클래스/메서드에 메타데이터를 심는다</li>
  <li><code class="language-plaintext highlighter-rouge">Reflector.getAllAndOverride(key, [handler, class])</code> : 메서드 → 클래스 순서로 메타데이터를 읽는다</li>
  <li>Guard에서 이 값을 읽어 분기처리</li>
</ul>

<h2 id="validateuser---파라미터-데코레이터">@ValidateUser() - 파라미터 데코레이터</h2>

<p>요청 컨텍스트에서 JWT 검증 후 주입된 유저 객체를 꺼내는 파라미터 데코레이터.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용</span>
<span class="p">@</span><span class="nd">Post</span><span class="p">()</span>
<span class="k">async</span> <span class="nf">uploadDocs</span><span class="p">(@</span><span class="nd">ValidateUser</span><span class="p">()</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<hr />

<h1 id="jwt-인증-흐름">JWT 인증 흐름</h1>

<h2 id="jwtstrategy---passport-전략">JwtStrategy - Passport 전략</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">JwtStrategy</span> <span class="kd">extends</span> <span class="nc">PassportStrategy</span><span class="p">(</span><span class="nx">Strategy</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">configService</span><span class="p">:</span> <span class="nx">ConfigService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">({</span>
      <span class="na">jwtFromRequest</span><span class="p">:</span> <span class="nx">ExtractJwt</span><span class="p">.</span><span class="nf">fromAuthHeaderAsBearerToken</span><span class="p">(),</span> <span class="c1">// Authorization: Bearer ...</span>
      <span class="na">ignoreExpiration</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">secretOrKey</span><span class="p">:</span> <span class="nx">configService</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">JWT_SECRET</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">async</span> <span class="nf">validate</span><span class="p">(</span><span class="nx">payload</span><span class="p">:</span> <span class="nx">JwtPayload</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nb">Partial</span><span class="o">&lt;</span><span class="nx">User</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="c1">// stateless: DB 조회 없이 토큰 payload만으로 유저 정보 반환</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">sub</span><span class="p">,</span> <span class="na">email</span><span class="p">:</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span> <span class="na">role</span><span class="p">:</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">role</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="authmodule---비동기-설정-패턴">AuthModule - 비동기 설정 패턴</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JwtModule</span><span class="p">.</span><span class="nf">registerAsync</span><span class="p">({</span>
  <span class="na">imports</span><span class="p">:</span> <span class="p">[</span><span class="nx">ConfigModule</span><span class="p">],</span>
  <span class="na">inject</span><span class="p">:</span> <span class="p">[</span><span class="nx">ConfigService</span><span class="p">],</span>
  <span class="na">useFactory</span><span class="p">:</span> <span class="k">async </span><span class="p">(</span><span class="na">configService</span><span class="p">:</span> <span class="nx">ConfigService</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">JwtModuleOptions</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">secret</span><span class="p">:</span> <span class="nx">configService</span><span class="p">.</span><span class="kd">get</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">'</span><span class="s1">JWT_SECRET</span><span class="dl">'</span><span class="p">),</span>
    <span class="na">signOptions</span><span class="p">:</span> <span class="p">{</span> <span class="na">expiresIn</span><span class="p">:</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">configService</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">JWT_EXPIRATION</span><span class="dl">'</span><span class="p">))</span> <span class="p">},</span>
  <span class="p">}),</span>
<span class="p">})</span>
</code></pre></div></div>

<blockquote>
  <p>[!warning] 타입 단언 주의
<code class="language-plaintext highlighter-rouge">configService.get&lt;string&gt;('KEY')</code> 의 제네릭은 <strong>형변환이 아닌 타입 단언</strong>이다.
실제로 <code class="language-plaintext highlighter-rouge">string</code>이 아닌 값이 들어와도 런타임 에러가 발생하지 않는다.
확실한 검증이 필요하면 <strong>Joi</strong> 로 환경변수 스키마를 검증해야 한다.</p>
</blockquote>

<hr />

<h1 id="sse-server-sent-events--rxjs">SSE (Server-Sent Events) + RxJS</h1>

<p>채팅 스트림은 <code class="language-plaintext highlighter-rouge">@Sse</code> 데코레이터와 RxJS <code class="language-plaintext highlighter-rouge">Observable</code>로 구현되어 있다.</p>

<h2 id="chatcontroller---sse-엔드포인트">ChatController - SSE 엔드포인트</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Sse</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream/:sessionId</span><span class="dl">'</span><span class="p">)</span>
<span class="p">@</span><span class="nd">SkipThrottle</span><span class="p">()</span>            <span class="c1">// Rate Limit 우회 (스트리밍은 장기 연결)</span>
<span class="p">@</span><span class="nd">Header</span><span class="p">(</span><span class="dl">'</span><span class="s1">X-Accel-Buffering</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">no</span><span class="dl">'</span><span class="p">)</span>  <span class="c1">// Nginx 버퍼링 비활성화</span>
<span class="nf">stream</span><span class="p">(@</span><span class="nd">Param</span><span class="p">(</span><span class="dl">'</span><span class="s1">sessionId</span><span class="dl">'</span><span class="p">)</span> <span class="nx">sessionId</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">MessageEvent</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">userStreamSubject</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">chatService</span><span class="p">.</span><span class="nf">addClient</span><span class="p">(</span><span class="nx">uuid</span><span class="p">,</span> <span class="nx">sessionId</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">initEvent</span> <span class="o">=</span> <span class="k">from</span><span class="p">([{</span> <span class="na">data</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">init</span><span class="dl">'</span><span class="p">,</span> <span class="nx">uuid</span><span class="p">,</span> <span class="p">...</span> <span class="p">}</span> <span class="p">}]);</span>      <span class="c1">// 연결 즉시 전송</span>
  <span class="kd">const</span> <span class="nx">heartbeatEvent</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="mi">5000</span><span class="p">).</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">heartbeat</span><span class="dl">'</span> <span class="p">}</span> <span class="p">})));</span>
  <span class="kd">const</span> <span class="nx">messageStream</span> <span class="o">=</span> <span class="nx">userStreamSubject</span><span class="p">.</span><span class="nf">asObservable</span><span class="p">().</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="nx">payload</span> <span class="p">})));</span>

  <span class="k">return</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">initEvent</span><span class="p">,</span> <span class="nx">heartbeatEvent</span><span class="p">,</span> <span class="nx">messageStream</span><span class="p">).</span><span class="nf">pipe</span><span class="p">(</span>
    <span class="nf">finalize</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">chatService</span><span class="p">.</span><span class="nf">removeClient</span><span class="p">(</span><span class="nx">uuid</span><span class="p">,</span> <span class="nx">sessionId</span><span class="p">))</span>  <span class="c1">// 연결 종료 시 정리</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="chatservice---redis-pubsub-연동">ChatService - Redis Pub/Sub 연동</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Redis 구독자와 발행자는 별도 커넥션을 사용해야 함</span>
<span class="nf">constructor</span><span class="p">(@</span><span class="nd">Inject</span><span class="p">(</span><span class="nx">REDIS_CLIENT</span><span class="p">)</span> <span class="k">private</span> <span class="k">readonly</span> <span class="nx">redisPublisher</span><span class="p">:</span> <span class="nx">Redis</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">redisSubscriber</span> <span class="o">=</span> <span class="nx">redisPublisher</span><span class="p">.</span><span class="nf">duplicate</span><span class="p">();</span>  <span class="c1">// 커넥션 복제</span>
<span class="p">}</span>

<span class="k">async</span> <span class="nf">onModuleInit</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">redisSubscriber</span><span class="p">.</span><span class="nf">psubscribe</span><span class="p">(</span><span class="dl">'</span><span class="s1">chat:stream:*</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// 패턴 구독</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">redisSubscriber</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">pmessage</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">routeMessageToUser</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span>  <span class="c1">// 해당 유저의 Subject에 push</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>전체 흐름</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client SSE연결 → Subject 생성 → Redis 구독
→ POST /message → Redis에 Job 적재
→ FastAPI 워커가 처리 후 Redis Publish
→ NestJS가 수신 → Subject.next() → SSE 전송
</code></pre></div></div>

<hr />

<h1 id="ai-서비스-상태-모니터링-서킷-브레이커">AI 서비스 상태 모니터링 (서킷 브레이커)</h1>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">AiStatusMonitoringService</span> <span class="k">implements</span> <span class="nx">OnModuleInit</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">isAiAvailable</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="p">@</span><span class="nd">Cron</span><span class="p">(</span><span class="dl">'</span><span class="s1">*/1 * * * * *</span><span class="dl">'</span><span class="p">)</span>   <span class="c1">// 1초마다 실행</span>
  <span class="k">async</span> <span class="nf">syncStatus</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">threshold</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">-</span> <span class="mi">5</span><span class="p">;</span>  <span class="c1">// 5초 이내 heartbeat만 유효</span>

    <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">redis</span><span class="p">.</span><span class="nf">zremrangebyscore</span><span class="p">(</span><span class="dl">'</span><span class="s1">cluster:heartbeats</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">-inf</span><span class="dl">'</span><span class="p">,</span> <span class="nx">threshold</span><span class="p">);</span>  <span class="c1">// 좀비 제거</span>
    <span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">redis</span><span class="p">.</span><span class="nf">zcard</span><span class="p">(</span><span class="dl">'</span><span class="s1">cluster:heartbeats</span><span class="dl">'</span><span class="p">);</span>   <span class="c1">// 생존 서버 수 확인</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isAiAvailable</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>[!warning] Redis Timeout 설정 필요
ioredis 기본 설정은 명령어 타임아웃이 <code class="language-plaintext highlighter-rouge">undefined</code>. Redis가 죽으면 <code class="language-plaintext highlighter-rouge">await</code> 이하에서 영구 대기.
크론 작업에서 이가 반복되면 <strong>Promise 스택 누적 → 힙 메모리 고갈 → 이벤트 루프 고갈</strong>로 이어진다.
<code class="language-plaintext highlighter-rouge">redis.module.ts</code>에서 <code class="language-plaintext highlighter-rouge">commandTimeout</code> 옵션으로 해결함.</p>
</blockquote>

<hr />

<h1 id="validationpipe--dto">ValidationPipe &amp; DTO</h1>

<p>요청 바디를 자동으로 검증하고 변환하는 파이프라인.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.ts</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalPipes</span><span class="p">(</span><span class="k">new</span> <span class="nc">ValidationPipe</span><span class="p">({</span>
  <span class="na">transform</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>    <span class="c1">// 요청 데이터를 DTO 클래스 인스턴스로 자동 변환</span>
  <span class="na">whitelist</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>    <span class="c1">// DTO에 없는 필드는 자동 제거 (보안)</span>
<span class="p">}));</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">class-validator</code> 데코레이터 (<code class="language-plaintext highlighter-rouge">@IsString()</code>, <code class="language-plaintext highlighter-rouge">@IsEmail()</code> 등)로 DTO에서 검증 선언</li>
  <li><code class="language-plaintext highlighter-rouge">class-transformer</code>가 JSON → 클래스 인스턴스 변환</li>
  <li><code class="language-plaintext highlighter-rouge">whitelist: true</code> 로 DTO에 정의되지 않은 필드를 자동으로 제거 → <strong>의도치 않은 필드 주입 방지</strong></li>
</ul>

<hr />

<h1 id="lifecycle-hooks">Lifecycle Hooks</h1>

<p>모듈/서비스의 초기화·종료 시점을 후킹하는 인터페이스.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">ChatService</span> <span class="k">implements</span> <span class="nx">OnModuleInit</span><span class="p">,</span> <span class="nx">OnModuleDestroy</span> <span class="p">{</span>
  <span class="k">async</span> <span class="nf">onModuleInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// NestJS 앱 완전 시작 직후 실행</span>
    <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">redisSubscriber</span><span class="p">.</span><span class="nf">psubscribe</span><span class="p">(</span><span class="dl">'</span><span class="s1">chat:stream:*</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">onModuleDestroy</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 앱 종료 직전 실행 (Graceful Shutdown)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">redisSubscriber</span><span class="p">.</span><span class="nf">quit</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">main.ts</code>의 <code class="language-plaintext highlighter-rouge">app.enableShutdownHooks()</code> 와 함께 사용하면 <strong>Docker 종료 시 연결된 소켓이 안전하게 닫힌다</strong>.</p>

<hr />

<h1 id="인메모리-동시성-제어-큐-queueservice">인메모리 동시성 제어 큐 (QueueService)</h1>

<p>지식 업로드 같은 무거운 작업의 동시 처리 수를 제한하는 <strong>직접 구현 큐</strong> 했다. 이러한 설계는 AI 를 위한 RAG 의 실시간 처리에서 과포화 상태를 만들거나 하여 서비스 안정성을 해치는 것을 막기 위해서다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">QueueService</span> <span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">concurrency</span> <span class="o">=</span> <span class="nx">CONSTANTS</span><span class="p">.</span><span class="nx">CONCURRENCY</span><span class="p">;</span>   <span class="c1">// 최대 동시 실행 수</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">maxPending</span> <span class="o">=</span> <span class="nx">CONSTANTS</span><span class="p">.</span><span class="nx">MAX_PENDING</span><span class="p">;</span>    <span class="c1">// 최대 대기 수</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">queue</span><span class="p">:</span> <span class="nx">Task</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">private</span> <span class="nx">activeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">public</span> <span class="nx">add</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">task</span><span class="p">:</span> <span class="nx">Task</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">maxPending</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">reject</span><span class="p">(</span><span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">System queue is full</span><span class="dl">'</span><span class="p">));</span>  <span class="c1">// 큐가 꽉 찼으면 즉시 거절</span>
      <span class="p">}</span>

      <span class="kd">const</span> <span class="nx">wrappedTask</span> <span class="o">=</span> <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">activeCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">try</span> <span class="p">{</span> <span class="nf">resolve</span><span class="p">(</span><span class="k">await</span> <span class="nf">task</span><span class="p">());</span> <span class="p">}</span>
        <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span> <span class="nf">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">finally</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">activeCount</span><span class="o">--</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span> <span class="p">}</span>  <span class="c1">// 작업 완료 후 다음 큐 실행</span>
      <span class="p">};</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">wrappedTask</span><span class="p">);</span>
      <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">activeCount</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">concurrency</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>동작 원리</strong>:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">concurrency</code>: 동시에 실행 중인 작업 수 상한</li>
  <li><code class="language-plaintext highlighter-rouge">maxPending</code>: 대기열 최대 크기, 초과 시 즉시 거절(Back Pressure)</li>
  <li>Redis Throttler와는 다른 계층 - 이건 <strong>서버 내부 처리 리소스 보호</strong>가 목적</li>
</ul>

<hr />

<h1 id="maints-글로벌-설정-요약">main.ts 글로벌 설정 요약</h1>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">bootstrap</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">NestFactory</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">logger</span><span class="p">:</span> <span class="nx">WinstonModule</span><span class="p">.</span><span class="nf">createLogger</span><span class="p">(...),</span>  <span class="c1">// Winston으로 로거 교체</span>
    <span class="na">bodyParser</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>                         <span class="c1">// express json/urlencoded 직접 설정 (50mb 제한)</span>
  <span class="p">});</span>

  <span class="nx">app</span><span class="p">.</span><span class="nf">enableCors</span><span class="p">({</span> <span class="na">origin</span><span class="p">:</span> <span class="nx">staticWhitelist</span><span class="p">,</span> <span class="na">credentials</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>

  <span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalFilters</span><span class="p">(</span><span class="k">new</span> <span class="nc">GlobalExceptionFilter</span><span class="p">());</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalInterceptors</span><span class="p">(</span><span class="k">new</span> <span class="nc">LoggingInterceptor</span><span class="p">());</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">enableShutdownHooks</span><span class="p">();</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalGuards</span><span class="p">(</span><span class="k">new</span> <span class="nc">OriginGuard</span><span class="p">());</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalPipes</span><span class="p">(</span><span class="k">new</span> <span class="nc">ValidationPipe</span><span class="p">({</span> <span class="na">transform</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">whitelist</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}));</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalInterceptors</span><span class="p">(</span><span class="k">new</span> <span class="nc">ClassSerializerInterceptor</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">Reflector</span><span class="p">)));</span>

  <span class="k">await</span> <span class="nx">app</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">??</span> <span class="mi">3000</span><span class="p">,</span> <span class="dl">'</span><span class="s1">0.0.0.0</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>[!note] <code class="language-plaintext highlighter-rouge">ClassSerializerInterceptor</code>
<code class="language-plaintext highlighter-rouge">class-transformer</code>의 <code class="language-plaintext highlighter-rouge">@Exclude()</code>, <code class="language-plaintext highlighter-rouge">@Expose()</code> 같은 데코레이터를 응답 직렬화 시 자동 적용.
예: 비밀번호 필드를 DTO에서 <code class="language-plaintext highlighter-rouge">@Exclude()</code> 하면 응답에서 자동으로 제거됨.</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="NestJS" /><category term="AI" /><summary type="html"><![CDATA[NestJS 개념 정리 본 정리 내용은, 프레임워크에 대한 이해도를 복기 하면서도 짜게 되었던 구성요소들을 더 심화시켜 바라보고 풀스택을 하다보니 놓치거나 좀더 좋은 코드를 만들기 위해 필요한 개념 복습, 코드 구성에 대한 고민을 위한 추가 복습이다.]]></summary></entry><entry><title type="html">Protostar review note - 07 NestJS main.ts &amp;amp; app.module.ts</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/18/01-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 07 NestJS main.ts &amp;amp; app.module.ts" /><published>2026-02-18T00:00:00+00:00</published><updated>2026-02-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/18/01-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/18/01-protostar-review.html"><![CDATA[<h1 id="nestjs-maints--appmodulets-분석">NestJS <code class="language-plaintext highlighter-rouge">main.ts</code> / <code class="language-plaintext highlighter-rouge">app.module.ts</code> 분석</h1>

<blockquote>
  <p>두 파일은 NestJS 앱의 <strong>조립 지점</strong>이다.</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">app.module.ts</code>: 무엇을 연결할지 선언 (정적 구조)</li>
    <li><code class="language-plaintext highlighter-rouge">main.ts</code>: 어떻게 실행할지 설정 (동적 부트스트랩)</li>
  </ul>
</blockquote>

<hr />

<h1 id="1-주요-개념">1. 주요 개념</h1>

<h2 id="maints에-등장하는-핵심-개념"><code class="language-plaintext highlighter-rouge">main.ts</code>에 등장하는 핵심 개념</h2>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>사용처</th>
      <th>한 줄 설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**Bootstrap 함수**</td>
      <td><code class="language-plaintext highlighter-rouge">NestFactory.create()</code></td>
      <td>NestJS 앱 인스턴스를 생성하는 진입점</td>
    </tr>
    <tr>
      <td>**글로벌 파이프라인**</td>
      <td><code class="language-plaintext highlighter-rouge">useGlobal*</code> 메서드들</td>
      <td>모든 요청에 공통 적용되는 필터/인터셉터/가드/파이프</td>
    </tr>
    <tr>
      <td>**CORS**</td>
      <td><code class="language-plaintext highlighter-rouge">enableCors()</code></td>
      <td>교차 출처 요청 허용 범위 설정. 특히 메인 프론트엔드 서비스 포인트와, AI 챗봇의 엔드포인트 등에서 차이가 있다보니 신중한 개념 이해 및 적용이 필요하다.</td>
    </tr>
    <tr>
      <td>**Graceful Shutdown**</td>
      <td><code class="language-plaintext highlighter-rouge">enableShutdownHooks()</code></td>
      <td>OS 종료 신호(SIGTERM) 수신 시 연결 정리 후 종료. 고가용성을 위한 기본 중에 기본 개념. 컨테이너화 하기 전, 반드시 필요한 처리였다.</td>
    </tr>
    <tr>
      <td>**Winston 로거**</td>
      <td><code class="language-plaintext highlighter-rouge">WinstonModule.createLogger()</code></td>
      <td>NestJS 기본 로거를 Winston으로 교체 및 Loki 대응으로 변경.</td>
    </tr>
    <tr>
      <td>**bodyParser 직접 설정**</td>
      <td><code class="language-plaintext highlighter-rouge">json({ limit: '50mb' })</code></td>
      <td>파일 업로드 대응을 위한 요청 바디 크기 제한 확장(기본값으로 부족함 대비)</td>
    </tr>
  </tbody>
</table>

<h2 id="appmodulets에-등장하는-핵심-개념"><code class="language-plaintext highlighter-rouge">app.module.ts</code>에 등장하는 핵심 개념</h2>

<table>
  <thead>
    <tr>
      <th>개념</th>
      <th>사용처</th>
      <th>한 줄 설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**루트 모듈**</td>
      <td><code class="language-plaintext highlighter-rouge">AppModule</code></td>
      <td>모든 기능 모듈을 조립하는 최상위 모듈</td>
    </tr>
    <tr>
      <td>**isGlobal**</td>
      <td><code class="language-plaintext highlighter-rouge">ConfigModule.forRoot({ isGlobal: true })</code></td>
      <td>다른 모듈에서 import 없이 ConfigService 사용 가능</td>
    </tr>
    <tr>
      <td>**forRootAsync**</td>
      <td><code class="language-plaintext highlighter-rouge">ThrottlerModule.forRootAsync()</code></td>
      <td>비동기로 다른 모듈(Redis)을 주입받아 설정</td>
    </tr>
    <tr>
      <td>**APP_GUARD 토큰**</td>
      <td><code class="language-plaintext highlighter-rouge">{ provide: APP_GUARD, useClass: ... }</code></td>
      <td>DI 컨테이너를 통해 전역 가드를 등록하는 NestJS 특수 토큰</td>
    </tr>
    <tr>
      <td>**Rate Limiting**</td>
      <td><code class="language-plaintext highlighter-rouge">ThrottlerModule</code></td>
      <td>burst/sustained 두 레벨의 요청 수 제한</td>
    </tr>
    <tr>
      <td>**Redis 기반 Throttler**</td>
      <td><code class="language-plaintext highlighter-rouge">ThrottlerStorageRedisService</code></td>
      <td>다중 인스턴스 환경에서 Rate Limit 상태를 Redis로 공유</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="2-핵심-로직-흐름">2. 핵심 로직 흐름</h1>

<h2 id="maints---부트스트랩-순서"><code class="language-plaintext highlighter-rouge">main.ts</code> - 부트스트랩 순서</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NestFactory.create(AppModule, { logger: Winston, bodyParser: false })
  │
  ├─ CORS 설정 (Origin 화이트리스트 검사 콜백)
  │
  ├─ app.use(json({ limit: '50mb' }))        ← bodyParser 수동 설정
  ├─ app.use(urlencoded({ extended: true, limit: '50mb' }))
  │
  ├─ useGlobalFilters(GlobalExceptionFilter)   ← 예외 후처리
  ├─ useGlobalInterceptors(LoggingInterceptor) ← 요청/응답 로깅
  │
  ├─ enableShutdownHooks()                     ← SIGTERM 처리
  │
  ├─ useGlobalGuards(OriginGuard)              ← Origin 재검사
  ├─ useGlobalPipes(ValidationPipe)            ← DTO 검증/변환
  ├─ useGlobalInterceptors(ClassSerializerInterceptor) ← 직렬화
  │
  └─ app.listen(PORT, '0.0.0.0')
</code></pre></div></div>

<blockquote>
  <p>[!warning] 등록 순서가 실행 순서를 결정하지 않는다
<code class="language-plaintext highlighter-rouge">useGlobal*</code> 호출 순서는 파이프라인 실행 순서와 무관하다.
NestJS는 Lifecycle에 따라 <strong>Guard → Interceptor → Pipe → Controller → Interceptor → Filter</strong> 순서를 고정으로 실행한다.
<code class="language-plaintext highlighter-rouge">main.ts</code>의 등록 순서는 가독성을 위한 선언일 뿐이다.
하지만 그렇기 때문에 명시적으로 순서를 이해하고, 선언해둠은 요청이 어떻게 응답으로 나가는지를 유기적으로 이해할 수 있다.</p>
</blockquote>

<h2 id="appmodulets---모듈-조립-구조"><code class="language-plaintext highlighter-rouge">app.module.ts</code> - 모듈 조립 구조</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AppModule
  │
  ├── imports
  │     ├── ConfigModule (isGlobal: true)      ─ 환경변수 전역 공급
  │     ├── RedisModule                        ─ Redis 클라이언트 공급
  │     ├── ChatModule                         ─ SSE 채팅 도메인
  │     ├── ThrottlerModule.forRootAsync()     ─ Redis로 상태 공유하는 Rate Limit
  │     │     └── inject: [REDIS_CLIENT]       ─ RedisModule에서 공급된 인스턴스 주입
  │     ├── ObjectStorageModule                ─ MinIO 연동
  │     ├── AuthModule                         ─ JWT 인증
  │     ├── PrismaModule                       ─ DB ORM
  │     └── KnowledgeModule                   ─ 문서 업로드/RAG 도메인
  │
  └── providers
        ├── AppService
        ├── APP_GUARD → ThrottlerGuard         ─ 전역 Rate Limit (1순위)
        └── APP_GUARD → JwtAuthGuard           ─ 전역 JWT 인증 (2순위)
</code></pre></div></div>

<h2 id="rate-limit-설정-상세">Rate Limit 설정 상세</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">throttlers</span><span class="p">:</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">burst</span><span class="dl">'</span><span class="p">,</span>     <span class="na">ttl</span><span class="p">:</span> <span class="nf">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>  <span class="na">limit</span><span class="p">:</span> <span class="mi">2000</span>  <span class="p">},</span>  <span class="c1">// 초당 2000 req</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">sustained</span><span class="dl">'</span><span class="p">,</span> <span class="na">ttl</span><span class="p">:</span> <span class="nf">seconds</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> <span class="na">limit</span><span class="p">:</span> <span class="mi">60000</span> <span class="p">},</span>  <span class="c1">// 분당 60000 req</span>
<span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><strong>burst</strong>: 순간적인 트래픽 스파이크 허용 (초당 2000)</li>
  <li><strong>sustained</strong>: 지속적 과부하 방지 (분당 60000 = 초당 평균 1000)</li>
  <li>두 조건 모두 통과해야 요청이 허용됨</li>
  <li>상태를 <code class="language-plaintext highlighter-rouge">ThrottlerStorageRedisService</code>로 Redis에 저장 방식을 적용 → <strong>수평 확장(Scale-out) 시에도 공유 가능</strong> Redis 이용 면에서 심도있게 다룰 예정</li>
</ul>

<hr />

<h1 id="3-구조적-취약점--개선-방향">3. 구조적 취약점 / 개선 방향</h1>

<h2 id="maints-cors-화이트리스트의-하드코딩">[main.ts] CORS 화이트리스트의 하드코딩</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">staticWhitelist</span> <span class="o">=</span> <span class="p">[</span>
  <span class="dl">'</span><span class="s1">https://paul2021-r.github.io</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">https://service-protostar.ddns.net</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">http://localhost:4000</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">];</span>
</code></pre></div></div>

<p><strong>문제</strong>: 허용 도메인이 코드에 박혀 있어 도메인 추가/변경 시 재배포 필요. 개발 시 가장 이상적인 형태는 ‘dynamic’한 관리가 맞다고 판단했었음. 하지만 일정 및 기획 축소로 하드코딩 방식으로 진행함.</p>

<p><strong>개선</strong>: 환경변수로 분리. 이후 DB 형태로 관리가 fine 한 관리가 필요.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">whitelist</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">CORS_ORIGINS</span><span class="p">?.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">)</span> <span class="o">??</span> <span class="p">[];</span>
</code></pre></div></div>

<h2 id="maints-전역-originguard와-cors의-중복-검사">[main.ts] 전역 OriginGuard와 CORS의 중복 검사</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">enableCors()</code> 에서 한 번, <code class="language-plaintext highlighter-rouge">OriginGuard</code> 에서 한 번 더 Origin을 검사하고 있다.</li>
  <li>Origin 검사 로직을 한 곳으로 통합하거나, 역할을 명확히 분리(CORS = 브라우저 사전 검사, Guard = 서버 최종 검사)하는 것이 의도를 더 명확하게 만든다.</li>
</ul>

<h2 id="appmodulets-app_guard-등록-순서-의존성">[app.module.ts] APP_GUARD 등록 순서 의존성</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">providers</span><span class="p">:</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">ThrottlerGuard</span> <span class="p">},</span>  <span class="c1">// 1번</span>
  <span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">JwtAuthGuard</span> <span class="p">},</span>    <span class="c1">// 2번</span>
<span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>NestJS는 <code class="language-plaintext highlighter-rouge">APP_GUARD</code>를 등록 순서대로 실행한다.</li>
  <li>현재 Rate Limit을 먼저 검사하는 것은 합리적이지만, <strong>문서화가 없으면 순서 변경 시 버그 발생</strong> 가능성이 있다고 함.</li>
  <li>이에 대해 AI와 답변, Best Practice 를 확인해본 결과 다음과 같은 방향성으로 해결 가능하다.
    <ol>
      <li>주석을 남겨 설명을 명료하게 만들어 둔다.</li>
      <li>하나의 단일한 가드 형태로 가드를 통합화 시켜서 적용시켜둠으로써, 맥락을 유지시킨다.</li>
    </ol>
  </li>
</ul>

<h2 id="appmodulets-redismodule-직접-의존">[app.module.ts] RedisModule 직접 의존</h2>

<ul>
  <li>지적 부분 : <code class="language-plaintext highlighter-rouge">ThrottlerModule</code>이 <code class="language-plaintext highlighter-rouge">RedisModule</code>을 직접 <code class="language-plaintext highlighter-rouge">inject</code>로 받는 구조는, <code class="language-plaintext highlighter-rouge">RedisModule</code>의 토큰(<code class="language-plaintext highlighter-rouge">REDIS_CLIENT</code>)이 바뀌거나 모듈이 분리되면 <code class="language-plaintext highlighter-rouge">AppModule</code>도 수정해야 한다.</li>
  <li>개선 제안 : Throttler 전용 Redis 설정을 <code class="language-plaintext highlighter-rouge">ThrottlerModule</code> 내부로 캡슐화하는 방법도 고려할 수 있다.</li>
</ul>

<h2 id="maints-bodyparser-비활성화-후-수동-설정의-맥락-누락">[main.ts] bodyParser 비활성화 후 수동 설정의 맥락 누락</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">NestFactory</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">,</span> <span class="p">{</span> <span class="na">bodyParser</span><span class="p">:</span> <span class="kc">false</span> <span class="p">})</span>
<span class="c1">// ...</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="nf">json</span><span class="p">({</span> <span class="na">limit</span><span class="p">:</span> <span class="dl">'</span><span class="s1">50mb</span><span class="dl">'</span> <span class="p">}));</span>
</code></pre></div></div>

<ul>
  <li>기본 bodyParser를 끄고 수동으로 다는 이유가 코드에 설명되어 있지 않다.</li>
  <li>실제 이유: <strong>파일 업로드 처리(Multer)와 충돌 방지 + 50MB 제한 확장</strong>. 주석이 없으면 다음 개발자가 이유를 모르고 제거할 위험이 있다.
    <ul>
      <li>이 부분은 개선이 필요하였으나, 개발 일정 고려 하드코딩으로 마무리 되었었음. 향후 개선이 필요하고, 특히나 이부분은 요청에 따라 다른 적용 내지는, 파일 확장자 별로도 고려할 사항들이 다소 존재한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="4-핵심-메서드-및-라이브러리-함수-설명">4. 핵심 메서드 및 라이브러리 함수 설명</h1>

<h2 id="nestfactorycreatemodule-options"><code class="language-plaintext highlighter-rouge">NestFactory.create(module, options)</code></h2>

<p>NestJS 앱 인스턴스를 생성하는 팩토리 메서드.</p>

<table>
  <thead>
    <tr>
      <th>옵션</th>
      <th>타입</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">logger</code></td>
      <td><code class="language-plaintext highlighter-rouge">LoggerService</code></td>
      <td>기본 로거를 교체</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bodyParser</code></td>
      <td><code class="language-plaintext highlighter-rouge">boolean</code></td>
      <td>Express bodyParser 자동 탑재 여부 (기본 <code class="language-plaintext highlighter-rouge">true</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cors</code></td>
      <td><code class="language-plaintext highlighter-rouge">boolean \| CorsOptions</code></td>
      <td>CORS 설정 (create 시점에 옵션으로도 가능)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">httpsOptions</code></td>
      <td><code class="language-plaintext highlighter-rouge">HttpsOptions</code></td>
      <td>HTTPS 인증서 설정</td>
    </tr>
  </tbody>
</table>

<h2 id="configmoduleforroot-isglobal-true-"><code class="language-plaintext highlighter-rouge">ConfigModule.forRoot({ isGlobal: true })</code></h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">isGlobal: true</code>: 이 모듈을 <strong>글로벌 모듈</strong>로 등록. 다른 모듈에서 <code class="language-plaintext highlighter-rouge">imports</code>에 추가 없이 <code class="language-plaintext highlighter-rouge">ConfigService</code>를 바로 주입받을 수 있다.</li>
  <li>내부적으로 <code class="language-plaintext highlighter-rouge">process.env</code>를 래핑해서 타입 안전하게 환경변수를 조회하는 <code class="language-plaintext highlighter-rouge">ConfigService</code>를 제공.</li>
</ul>

<h2 id="throttlermoduleforrootasync-usefactory-"><code class="language-plaintext highlighter-rouge">ThrottlerModule.forRootAsync({ useFactory })</code></h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">forRoot()</code>: 정적 설정 (값이 고정)</li>
  <li><code class="language-plaintext highlighter-rouge">forRootAsync()</code>: 비동기 설정 팩토리. 다른 Provider(여기서는 Redis 클라이언트)를 <strong>주입받아</strong> 설정값을 만들 때 사용.</li>
  <li><code class="language-plaintext highlighter-rouge">inject</code> 배열에 넣은 토큰들이 <code class="language-plaintext highlighter-rouge">useFactory</code> 함수의 인자로 순서대로 들어온다.</li>
</ul>

<h2 id="app_guard--app_filter--app_interceptor--app_pipe"><code class="language-plaintext highlighter-rouge">APP_GUARD</code> / <code class="language-plaintext highlighter-rouge">APP_FILTER</code> / <code class="language-plaintext highlighter-rouge">APP_INTERCEPTOR</code> / <code class="language-plaintext highlighter-rouge">APP_PIPE</code></h2>

<p>NestJS가 전역 파이프라인 요소를 DI 컨테이너를 통해 등록하기 위한 <strong>특수 토큰들</strong>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 두 방식의 차이</span>
<span class="c1">// 방식 A: DI 컨테이너 밖 (다른 서비스 주입 불가)</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalGuards</span><span class="p">(</span><span class="k">new</span> <span class="nc">OriginGuard</span><span class="p">());</span>

<span class="c1">// 방식 B: DI 컨테이너 안 (다른 서비스 주입 가능)</span>
<span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">JwtAuthGuard</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">OriginGuard</code>는 생성자에 주입받을 게 없어서 방식 A로도 괜찮다.</li>
  <li><code class="language-plaintext highlighter-rouge">JwtAuthGuard</code>는 <code class="language-plaintext highlighter-rouge">Reflector</code>를 주입받아야 하므로 <strong>반드시 방식 B</strong>여야 한다.</li>
</ul>

<h2 id="appenableshutdownhooks"><code class="language-plaintext highlighter-rouge">app.enableShutdownHooks()</code></h2>

<ul>
  <li>OS 프로세스 종료 신호(<code class="language-plaintext highlighter-rouge">SIGTERM</code>, <code class="language-plaintext highlighter-rouge">SIGINT</code>)를 NestJS가 감지하도록 활성화.</li>
  <li>신호 수신 시 <code class="language-plaintext highlighter-rouge">OnApplicationShutdown</code> 인터페이스를 구현한 서비스의 <code class="language-plaintext highlighter-rouge">onApplicationShutdown()</code> 메서드를 호출.</li>
  <li>Docker/Kubernetes 환경에서 컨테이너가 내려갈 때 <strong>진행 중인 요청을 마저 처리하고 종료</strong>하는 Graceful Shutdown에 필수.</li>
</ul>

<h2 id="classserializerinterceptor--reflector"><code class="language-plaintext highlighter-rouge">ClassSerializerInterceptor</code> + <code class="language-plaintext highlighter-rouge">Reflector</code></h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalInterceptors</span><span class="p">(</span><span class="k">new</span> <span class="nc">ClassSerializerInterceptor</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">Reflector</span><span class="p">)));</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">class-transformer</code>의 <code class="language-plaintext highlighter-rouge">@Exclude()</code>, <code class="language-plaintext highlighter-rouge">@Expose()</code>, <code class="language-plaintext highlighter-rouge">@Transform()</code> 데코레이터를 응답 직렬화에 자동 적용.</li>
  <li><code class="language-plaintext highlighter-rouge">app.get(Reflector)</code>: DI 컨테이너 밖에서 <code class="language-plaintext highlighter-rouge">Reflector</code> 인스턴스를 직접 꺼내는 방법.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용 예</span>
<span class="kd">class</span> <span class="nc">UserResponseDto</span> <span class="p">{</span>
  <span class="nl">email</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="p">@</span><span class="nd">Exclude</span><span class="p">()</span>
  <span class="nx">password</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>  <span class="c1">// 응답에서 자동 제거됨</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="validationpipe-transform-true-whitelist-true-"><code class="language-plaintext highlighter-rouge">ValidationPipe({ transform: true, whitelist: true })</code></h2>

<table>
  <thead>
    <tr>
      <th>옵션</th>
      <th>효과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">transform: true</code></td>
      <td>요청 데이터를 DTO 클래스 인스턴스로 변환 (타입 캐스팅 포함)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">whitelist: true</code></td>
      <td>DTO에 선언되지 않은 필드를 자동 제거</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">forbidNonWhitelisted: true</code></td>
      <td>(미사용) 선언 외 필드가 있으면 400 에러</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">disableErrorMessages: true</code></td>
      <td>(미사용) 에러 메시지 숨기기 (프로덕션 권장)</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="5-대체-가능한-라이브러리-및-트레이드오프">5. 대체 가능한 라이브러리 및 트레이드오프</h1>

<h2 id="winston-로거-vs-대안">Winston 로거 vs 대안</h2>

<table>
  <thead>
    <tr>
      <th>라이브러리</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**Winston** (현재)</td>
      <td>성숙한 생태계, 다양한 Transport(파일/HTTP/Loki)</td>
      <td>설정이 장황, 번들 크기 큼</td>
    </tr>
    <tr>
      <td>**Pino**</td>
      <td>성능이 가장 빠름(JSON 직렬화 최적화), <code class="language-plaintext highlighter-rouge">nest-pino</code> 공식 지원</td>
      <td>커스터마이징이 상대적으로 제한적</td>
    </tr>
    <tr>
      <td>**Bunyan**</td>
      <td>구조화 로깅 특화</td>
      <td>유지보수 저조, 생태계 축소</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Loki + Promtail 스택을 쓰는 경우 <strong>Pino</strong>가 JSON 출력이 더 깔끔하고 성능도 우수해 선호되는 추세.</p>
</blockquote>

<h2 id="throttlermodule-vs-대안">ThrottlerModule vs 대안</h2>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**@nestjs/throttler + Redis** (현재)</td>
      <td>NestJS 네이티브, 데코레이터로 라우트별 커스텀 가능</td>
      <td>Redis 의존성 추가</td>
    </tr>
    <tr>
      <td>**Nginx Rate Limit**</td>
      <td>앱 레이어 밖에서 처리, 성능 우수</td>
      <td>세밀한 비즈니스 로직 적용 어려움</td>
    </tr>
    <tr>
      <td>**express-rate-limit**</td>
      <td>설정 간단</td>
      <td>다중 인스턴스 환경에서 메모리 공유 어려움</td>
    </tr>
    <tr>
      <td>**API Gateway (Kong 등)**</td>
      <td>중앙 집중 관리</td>
      <td>인프라 복잡도 증가</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>이미 Nginx Traffic Dam이 앞단에 있으므로, NestJS 레이어의 Throttler는 <strong>내부 서비스 보호(2차 방어선)</strong> 역할임을 고려하고, 이 역할 수준을 벗어나지 않도록 맥락이 유지되어야함.</p>
</blockquote>

<h2 id="configmodule-vs-대안">ConfigModule vs 대안</h2>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**@nestjs/config** (현재)</td>
      <td>NestJS 통합, <code class="language-plaintext highlighter-rouge">ConfigService</code> DI 가능</td>
      <td>런타임 타입 검증 없음</td>
    </tr>
    <tr>
      <td>**@nestjs/config + Joi**</td>
      <td>앱 시작 시 환경변수 스키마 검증</td>
      <td>Joi 라이브러리 추가</td>
    </tr>
    <tr>
      <td>**zod + env 파싱**</td>
      <td>타입 추론이 강력, TS 친화적</td>
      <td>수동 연동 필요</td>
    </tr>
    <tr>
      <td>**dotenv 직접**</td>
      <td>의존성 최소화</td>
      <td>NestJS DI와 통합 어려움</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>[!tip] <code class="language-plaintext highlighter-rouge">configService.get&lt;string&gt;('KEY')</code>는 타입 단언이지 검증이 아니다
환경변수가 없거나 잘못된 값이 들어와도 런타임에 <code class="language-plaintext highlighter-rouge">undefined</code>가 반환될 수 있다.
<strong>Joi 또는 zod로 시작 시점에 검증</strong>하는 것이 프로덕션 수준의 접근이라고 한다. 다음 프로젝트에서는 반드시 적용하면서 진행하면 좋으리라 본다.</p>
</blockquote>

<h2 id="bodyparser-50mb-제한-vs-대안">bodyParser 50MB 제한 vs 대안</h2>

<table>
  <thead>
    <tr>
      <th>접근</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**express json/urlencoded** (현재)</td>
      <td>익숙한 방식, 세밀한 제어</td>
      <td>파일 업로드는 별도 Multer 필요</td>
    </tr>
    <tr>
      <td>**Multer 전용**</td>
      <td>파일 업로드에 최적화</td>
      <td>일반 JSON 바디와 혼용 복잡</td>
    </tr>
    <tr>
      <td>**파일을 Object Storage에서 직접 수신**</td>
      <td>NestJS에 파일 부하 없음</td>
      <td>아키텍처 복잡도 증가</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="6-개발자로서-알아야-할-영역">6. 개발자로서 알아야 할 영역</h1>

<h2 id="a-nestjs-ioc-컨테이너와-di-범위">A. NestJS IoC 컨테이너와 DI 범위</h2>

<p><code class="language-plaintext highlighter-rouge">APP_GUARD</code> 패턴을 이해하려면 NestJS의 DI가 어떻게 동작하는지 알아야 한다.</p>

<ul>
  <li><strong>Singleton scope</strong> (기본): 모듈 당 인스턴스 하나. 앱 전체에서 공유.</li>
  <li><strong>Request scope</strong>: 요청마다 새 인스턴스 생성. 성능 비용 있음.</li>
  <li><strong>Transient scope</strong>: 주입받을 때마다 새 인스턴스 생성.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">APP_GUARD</code>로 등록된 <code class="language-plaintext highlighter-rouge">JwtAuthGuard</code>는 Singleton이다. <code class="language-plaintext highlighter-rouge">Reflector</code>도 Singleton으로 공유되므로, <code class="language-plaintext highlighter-rouge">app.get(Reflector)</code> 또는 생성자 주입 중 어느 방식이든 같은 인스턴스를 받는다.</p>

<h2 id="b-글로벌-등록-두-가지-방식의-차이">B. 글로벌 등록 두 가지 방식의 차이</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방식 1: main.ts에서 useGlobal* (DI 컨테이너 외부)</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">useGlobalGuards</span><span class="p">(</span><span class="k">new</span> <span class="nc">OriginGuard</span><span class="p">());</span>

<span class="c1">// 방식 2: AppModule에서 APP_* 토큰 (DI 컨테이너 내부)</span>
<span class="p">{</span> <span class="na">provide</span><span class="p">:</span> <span class="nx">APP_GUARD</span><span class="p">,</span> <span class="na">useClass</span><span class="p">:</span> <span class="nx">JwtAuthGuard</span> <span class="p">}</span>
</code></pre></div></div>

<p><strong>결정 기준</strong>: 해당 클래스가 다른 Provider를 주입받을 필요가 있는가?</p>
<ul>
  <li>주입이 필요 없다 → 방식 1 (단순)</li>
  <li>주입이 필요하다 → 반드시 방식 2</li>
</ul>

<h2 id="c-forroot-vs-forrootasync-패턴">C. <code class="language-plaintext highlighter-rouge">forRoot</code> vs <code class="language-plaintext highlighter-rouge">forRootAsync</code> 패턴</h2>

<p>NestJS 동적 모듈의 표준 패턴. 라이브러리를 직접 만들거나 커스텀 모듈을 설계할 때 필수로 이해해야 한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동기: 정적 값</span>
<span class="nx">ThrottlerModule</span><span class="p">.</span><span class="nf">forRoot</span><span class="p">({</span> <span class="na">ttl</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="na">limit</span><span class="p">:</span> <span class="mi">100</span> <span class="p">})</span>

<span class="c1">// 비동기: 다른 Provider에서 값을 받아야 할 때</span>
<span class="nx">ThrottlerModule</span><span class="p">.</span><span class="nf">forRootAsync</span><span class="p">({</span>
  <span class="na">imports</span><span class="p">:</span> <span class="p">[</span><span class="nx">RedisModule</span><span class="p">],</span>    <span class="c1">// 필요한 모듈 등록</span>
  <span class="na">inject</span><span class="p">:</span> <span class="p">[</span><span class="nx">REDIS_CLIENT</span><span class="p">],</span>    <span class="c1">// 팩토리 인자로 주입할 토큰</span>
  <span class="na">useFactory</span><span class="p">:</span> <span class="p">(</span><span class="nx">redis</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="p">...</span> <span class="p">})</span>  <span class="c1">// 실제 설정 반환</span>
<span class="p">})</span>
</code></pre></div></div>

<h2 id="d-graceful-shutdown과-컨테이너-오케스트레이션">D. Graceful Shutdown과 컨테이너 오케스트레이션</h2>

<p>Docker/K8s 환경에서 배포 시 <code class="language-plaintext highlighter-rouge">SIGTERM</code> 신호가 날아온다. <code class="language-plaintext highlighter-rouge">enableShutdownHooks()</code>를 활성화하지 않으면:</p>
<ul>
  <li>진행 중인 HTTP 요청이 강제 종료됨</li>
  <li>Redis 구독 연결이 비정상 종료됨</li>
  <li>DB 커넥션 풀이 정리되지 않음</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">OnModuleDestroy</code>를 구현해 각 서비스가 자신의 리소스를 정리하는 패턴은 <strong>마이크로서비스 안정성의 기본</strong>이다.</p>

<h2 id="e-rate-limiting-계층-설계">E. Rate Limiting 계층 설계</h2>

<p>Rate Limit은 하나의 계층에서만 하는 것이 아니라 <strong>계층별로 역할이 다르다</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[클라이언트]
    │
[Nginx] ── Traffic Dam (토큰 버킷, Heavy/Light Zone 구분)
    │
[NestJS ThrottlerGuard] ── 서비스 레벨 보호 (burst/sustained 2단계)
    │
[내부 QueueService] ── 개별 작업 동시성 제어
    │
[FastAPI 워커] ── AI 연산 보호
</code></pre></div></div>

<p>각 계층이 왜 필요한지, 어느 계층에서 무엇을 막는지 설명할 수 있어야 한다.</p>

<h2 id="f-환경변수-관리의-프로덕션-수준">F. 환경변수 관리의 프로덕션 수준</h2>

<p>현재 코드의 <code class="language-plaintext highlighter-rouge">configService.get&lt;string&gt;('JWT_SECRET')</code>는 <strong>타입 단언</strong>이다. 이부분은 AI 의 지적이 뼈아픈데, 프로덕션에서는:</p>

<ol>
  <li><strong>시작 시 검증</strong>: Joi 스키마로 필수 환경변수가 빠지면 앱이 시작조차 안 되게</li>
  <li><strong>시크릿 관리</strong>: .env 파일 대신 AWS Secrets Manager, HashiCorp Vault, K8s Secret 사용</li>
  <li><strong>런타임 재로드</strong>: 일부 설정은 재배포 없이 변경 가능하도록 설계</li>
</ol>

<p>라는 조건이 필요함을 강조했다. 알긴 하는데 바쁘다고 안했지만 뼈아프긴 하다(…)</p>

<h2 id="g-구조화-로깅과-옵저버빌리티">G. 구조화 로깅과 옵저버빌리티</h2>

<p><code class="language-plaintext highlighter-rouge">main.ts</code>에서 Winston을 JSON 포맷으로 설정한 이유는 <strong>Promtail이 파싱하기 위해서</strong>다. 로그를 단순 텍스트로 출력하면 Loki에서 필터링이 어렵다.</p>

<p>개발자가 알아야 할 로깅 설계 원칙:</p>
<ul>
  <li>구조화된 JSON 로그 출력 (key-value로 파싱 가능하게)</li>
  <li>로그 레벨 분리 (<code class="language-plaintext highlighter-rouge">error</code> / <code class="language-plaintext highlighter-rouge">warn</code> / <code class="language-plaintext highlighter-rouge">info</code> / <code class="language-plaintext highlighter-rouge">debug</code>)</li>
  <li>요청 추적을 위한 Trace ID / Correlation ID 포함</li>
  <li>민감 정보(비밀번호, 토큰) 로그 미노출</li>
</ul>

<h2 id="h-cors와-보안-헤더">H. CORS와 보안 헤더</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="nf">enableCors</span><span class="p">({</span>
  <span class="na">origin</span><span class="p">:</span> <span class="p">(</span><span class="nx">requestOrigin</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
  <span class="na">methods</span><span class="p">:</span> <span class="dl">'</span><span class="s1">GET, HEAD, PUT, PATCH, POST, DELETE, OPTIONS</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">credentials</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>  <span class="c1">// 쿠키/인증 헤더 허용</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">credentials: true</code>를 쓸 때는 <code class="language-plaintext highlighter-rouge">origin: '*'</code> 가 불가능하다. 명시적 화이트리스트가 필요하다는 점, 그리고 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 프리플라이트 요청까지 포함해야 한다는 점을 이해해야 한다.</p>

<p>추가로 알아야 할 보안 헤더: <code class="language-plaintext highlighter-rouge">helmet</code> 라이브러리로 <code class="language-plaintext highlighter-rouge">X-Content-Type-Options</code>, <code class="language-plaintext highlighter-rouge">X-Frame-Options</code>, <code class="language-plaintext highlighter-rouge">Strict-Transport-Security</code> 등 설정 가능. 현재 코드에는 미적용되어 있다.</p>

<hr />

<h1 id="핵심-요약-카드">핵심 요약 카드</h1>

<blockquote>
  <p>[!abstract] main.ts의 역할</p>
  <ul>
    <li><strong>어떻게 실행할지</strong> 결정하는 부트스트랩 파일</li>
    <li>글로벌 파이프라인 구성 (필터, 인터셉터, 가드, 파이프)</li>
    <li>런타임 설정 (CORS, bodyParser, 로거, 포트)</li>
    <li><code class="language-plaintext highlighter-rouge">useGlobal*</code> 순서 ≠ 실행 순서 (Lifecycle이 고정)</li>
  </ul>
</blockquote>

<blockquote>
  <p>[!abstract] app.module.ts의 역할</p>
  <ul>
    <li><strong>무엇을 연결할지</strong> 선언하는 조립 파일</li>
    <li>모든 도메인 모듈의 집합점</li>
    <li>DI 컨테이너를 통한 전역 가드 등록 (<code class="language-plaintext highlighter-rouge">APP_GUARD</code>)</li>
    <li><code class="language-plaintext highlighter-rouge">forRootAsync</code> 패턴으로 동적 모듈 구성</li>
  </ul>
</blockquote>

<blockquote>
  <p>[!question] 면접/리뷰에서 설명할 수 있어야 하는 것</p>
  <ol>
    <li><code class="language-plaintext highlighter-rouge">useGlobalGuards</code> vs <code class="language-plaintext highlighter-rouge">APP_GUARD</code> 토큰 방식의 차이와 선택 기준</li>
    <li><code class="language-plaintext highlighter-rouge">ThrottlerModule</code>이 Redis를 쓰는 이유 (단일 인스턴스 vs 다중 인스턴스)</li>
    <li><code class="language-plaintext highlighter-rouge">enableShutdownHooks()</code>를 켜야 하는 이유와 연결되는 인터페이스</li>
    <li><code class="language-plaintext highlighter-rouge">ValidationPipe whitelist: true</code>가 보안에 미치는 영향</li>
    <li><code class="language-plaintext highlighter-rouge">ClassSerializerInterceptor</code>와 <code class="language-plaintext highlighter-rouge">@Exclude()</code>의 관계</li>
  </ol>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="NestJS" /><category term="AI" /><summary type="html"><![CDATA[NestJS main.ts / app.module.ts 분석]]></summary></entry><entry><title type="html">Protostar review note - 05 FastAPI RAG</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/17/00-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 05 FastAPI RAG" /><published>2026-02-17T00:00:00+00:00</published><updated>2026-02-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/17/00-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/17/00-protostar-review.html"><![CDATA[<h2 id="corerag_servicepy">core/rag_service.py</h2>

<h3 id="1-주요-개념">1. 주요 개념</h3>

<ul>
  <li><strong>RAG (Retrieval-Augmented Generation)</strong>: 외부 지식 베이스(데이터베이스)에서 질문과 관련된 정보를 검색(Retrieval)하고, 그 정보를 대규모 언어 모델(LLM)에 전달하여 답변을 생성(Generation)하게 함으로써 모델의 내부 지식 한계를 극복하는 기법이다.</li>
  <li><strong>Vector Embedding (벡터 임베딩)</strong>: 텍스트 데이터를 고차원의 수치 벡터로 변환하는 과정이며, 이를 통해 단어나 문장 간의 의미적 유사도를 계산할 수 있게 한다.</li>
  <li><strong>Cosine Similarity (코사인 유사도)</strong>: 두 벡터 사이의 각도를 측정하여 유사성을 판단하는 방식이며, 본 코드에서는 <code class="language-plaintext highlighter-rouge">cosine_distance</code> 연산자를 활용해 질문과 가장 가까운 문서를 추출한다.</li>
</ul>

<h3 id="2-핵심-로직-흐름">2. 핵심 로직 흐름</h3>

<ul>
  <li><strong>질문 벡터화</strong>: 사용자의 쿼리를 <code class="language-plaintext highlighter-rouge">get_embeddings</code> 함수를 통해 수치 벡터로 변환하며, 실패 시 경고 로그를 남기고 빈 리스트를 반환한다.</li>
  <li><strong>유사 문서 검색</strong>: SQLAlchemy를 사용하여 <code class="language-plaintext highlighter-rouge">VectorizedDoc</code> 테이블에서 질문 벡터와 코사인 거리가 가장 짧은 상위 <code class="language-plaintext highlighter-rouge">top_k</code>개의 데이터를 조회한다.
    <ul>
      <li>default top_k = 3: 검색 문서가 너무 과해지면 프롬프트가 길어지며, 모델 응답 속도가 느려짐. 이에 주요 정보들까지 검색을 위하여 top_k 의 값을 표준적인 사이즈로 설정함.
        <ul>
          <li>1 ~ 2 : 응답속도 빨라지며, 비용 저렴해지나 상대적으로 복합 질문 답변 어려움</li>
          <li>중간 값</li>
          <li>5 ~ 10 : 폭 넓은 맥락 제공 가능, 단, 관련 없는 정보가 다소 포함되여 엉뚱한 답으로 변화될 가능성 있슴</li>
          <li>현재는 고정값으로 설정되어 구현하였으나, 필요시 다양한 방식으로 동적 혹은 상대적 정밀도로 구성 변경도 가능함.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>컨텍스트 구조화</strong>: 검색된 문서 객체들에서 키워드, 요약문, 본문을 추출하여 LLM이 이해하기 쉬운 <code class="language-plaintext highlighter-rouge">[Document #n]</code> 형태의 텍스트 블록으로 포맷팅한다.</li>
</ul>

<h3 id="3-구조적-취약점-및-개선-방향">3. 구조적 취약점 및 개선 방향</h3>

<ul>
  <li><strong>취약점</strong>: 대규모 데이터 처리 시 검색 성능 저하 우려가 있다. 현재의 DB 기반 정렬 방식은 인덱스가 적절히 구성되지 않을 경우 검색 속도가 선형적으로 느려질 수 있다.</li>
  <li><strong>개선 방향</strong>: 전문 벡터 데이터베이스(ChromaDB, Pinecone 등)를 도입하거나, PostgreSQL의 <code class="language-plaintext highlighter-rouge">pgvector</code>를 쓰고 있으니 HNSW 인덱스를 적용하여 검색 속도를 최적화를 도입해봐도 된다.</li>
</ul>

<h3 id="4-핵심-메서드-및-라이브러리-함수">4. 핵심 메서드 및 라이브러리 함수</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">search_similar_docs(query, top_k)</code></strong>: 입력된 문자열 질문을 벡터로 변환하고 DB에서 가장 유사한 문서를 찾는 핵심 비동기 함수이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">format_rag_context(docs)</code></strong>: 검색 결과 리스트를 LLM 프롬프트에 주입하기 적합한 단일 문자열로 변환하는 유틸리티 함수이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">VectorizedDoc.embedding.cosine_distance()</code></strong>: 데이터베이스 수준에서 벡터 간 유사도를 계산하는 SQLAlchemy 익스텐션 메서드이다.</li>
</ul>

<h3 id="5-대체-가능한-라이브러리-및-메서드트레이드-오프">5. 대체 가능한 라이브러리 및 메서드(트레이드 오프)</h3>

<ul>
  <li><strong>SQLAlchemy vs LangChain (VectorStore)</strong></li>
  <li><strong>차이</strong>: 현재는 SQLAlchemy로 직접 쿼리를 작성하지만, LangChain은 다양한 벡터 DB를 동일한 인터페이스로 다루는 추상화 레이어를 제공한다.</li>
  <li>
    <p><strong>트레이드 오프</strong>: 직접 구현 시 의존성이 적고 최적화가 자유롭지만, 기능 확장 시(필터링, 하이브리드 검색 등) 모든 로직을 수동으로 개발해야 하는 공수가 발생한다. 보다 다양한 포멧의 다양한 벡터화된 문서들이 도입시 이에 따라서 보다 복잡하고 세밀한 접근이 필요해진다.</p>
  </li>
  <li><strong>Cosine Distance vs L2 Distance (유클리드 거리)</strong></li>
  <li><strong>차이</strong>: 코사인 거리는 벡터의 방향(의미)에 집중하고, L2 거리는 벡터의 절대적인 위치(크기 포함)에 집중한다.</li>
  <li>
    <p><strong>트레이드 오프</strong>: 텍스트 분석에서는 문장 길이에 덜 민감한 코사인 유사도가 일반적으로 유리하지만, 특정 임베딩 모델에 따라 L2 거리가 더 높은 정확도를 보이기도 한다.</p>
  </li>
  <li><strong>pgvector vs Specialized Vector DB (Milvus, Qdrant)</strong></li>
  <li><strong>차이</strong>: pgvector는 기존 RDBMS 내부에서 관리하지만, 전용 DB는 벡터 연산에 최적화된 엔진을 별도로 가진다.</li>
  <li><strong>트레이드 오프</strong>: pgvector는 관리가 편하고 데이터 정관계를 유지하기 좋으나, 초고대규모 데이터셋에서는 전용 DB의 인덱싱 성능과 분산 처리 능력이 앞선다. 결과적으로 고가용성 서버를 위한 별도 데이터DB의 구축은 AI 서비스 트래픽을 위해 고려 대상이 될 수 있다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="FastAPI" /><category term="AI" /><summary type="html"><![CDATA[core/rag_service.py]]></summary></entry><entry><title type="html">Protostar review note - 04 FastAPI AI</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/16/00-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 04 FastAPI AI" /><published>2026-02-16T00:00:00+00:00</published><updated>2026-02-16T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/16/00-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/16/00-protostar-review.html"><![CDATA[<h2 id="coreaipy">core/ai.py</h2>
<p>이 파일은 OpenAI 호환 API(OpenRouter)를 사용하여 AI 비서(Protostar)의 응답을 생성하고, RAG(Retrieval-Augmented Generation) 구성을 위한 파일 청킹(Chunking) 및 프롬프트 구성을 담당하는 핵심 모듈이다.</p>

<h3 id="1-주요-개념">1. 주요 개념</h3>

<ul>
  <li><strong>RAG (Retrieval-Augmented Generation)</strong>: 언어 모델(LLM)이 답변을 생성하기 전에, 외부의 신뢰할 수 있는 데이터베이스(이력서, 블로그 글 등)에서 관련 문서를 검색하여 컨텍스트로 제공하는 기술이다. 이를 통해 할루시네이션(환각)을 줄이고 최신/개인화된 정보를 바탕으로 답변할 수 있다.</li>
  <li><strong>Chunking (청킹)</strong>: 긴 문서를 LLM의 컨텍스트 윈도우(Context Window)에 맞게, 그리고 검색 효율성을 높이기 위해 의미 있는 작은 조각으로 나누는 과정이다.</li>
  <li><strong>Streaming (스트리밍)</strong>: 전체 답변이 생성될 때까지 기다리지 않고, 토큰 단위로 생성되는 즉시 클라이언트에게 전송하여 체감 대기 시간을 줄이는 기술이다.</li>
</ul>

<h3 id="2-핵심-로직-흐름">2. 핵심 로직 흐름</h3>

<ul>
  <li><strong>문서 적재 및 청킹 (<code class="language-plaintext highlighter-rouge">load_and_chunk_files</code>)</strong>:
    <ol>
      <li>로컬 디렉토리의 Markdown(<code class="language-plaintext highlighter-rouge">.md</code>) 파일들을 읽어 들인다.</li>
      <li>빈 줄(<code class="language-plaintext highlighter-rouge">\n\n</code>)을 기준으로 분리한다.</li>
      <li>문단 단위의 청크(Chunk)로 나눈다.</li>
      <li>길이가 너무 짧은 문자열은 버리고, 파일명과 문단 번호를 메타데이터처럼 문자열에 포함시켜 리스트에 저장한다.</li>
    </ol>
  </li>
  <li><strong>응답 스트리밍 생성 (<code class="language-plaintext highlighter-rouge">generate_response_stream</code>)</strong>:
    <ol>
      <li>외부(Worker)에서 전달받은 RAG 검색 결과(<code class="language-plaintext highlighter-rouge">context</code>)와 대화 이력(<code class="language-plaintext highlighter-rouge">history</code>), 사용자 질문(<code class="language-plaintext highlighter-rouge">prompt</code>)을 조립한다.</li>
      <li>LLM에 전달할 메시지 배열을 구성한다. 시스템 프롬프트에는 페르소나 및 엄격한 규칙(한국어 사용, 3문단 이내 등)이 정의된다.</li>
      <li>생성된 응답은 <code class="language-plaintext highlighter-rouge">async for</code> 문을 통해 토큰(Token)이 생성될 때마다 비동기 제너레이터(<code class="language-plaintext highlighter-rouge">yield</code>)로 즉시 반환한다.</li>
    </ol>
  </li>
  <li><strong>응답 요약 (<code class="language-plaintext highlighter-rouge">generate_summary</code>)</strong>:
    <ol>
      <li>대화를 저장한다.</li>
      <li>별도의 작업으로 Redis 를 통해 다시 ‘수주’를 맡긴다.</li>
      <li>수주를 받으면 새로운 Worker 가 해당 수주를 챙겨서, DB 상의 대화 원문을 읽는다.</li>
      <li>다음 컨텍스트 활용을 위해, 생성된 긴 응답 텍스트를 다시 LLM에 통과시켜 3문장 이내의 간결한 한 문단으로 요약을 요청한다.</li>
      <li>저장한다.</li>
      <li>(이후) 동일 세션에서의 대화 시 이 내용이DB 상에 발견되면, 요약본과 함께 전달된다. (요약 없을 시 원본 대화 그대로 들어감)</li>
    </ol>
  </li>
</ul>

<h3 id="3-대체-가능한-라이브러리-및-메서드-트레이드오프">3. 대체 가능한 라이브러리 및 메서드 (트레이드오프)</h3>

<ul>
  <li><strong>텍스트 청킹(Text Chunking) 로직</strong>
    <ul>
      <li><strong>현재 방식</strong>: <code class="language-plaintext highlighter-rouge">content.split("\n\n")</code>을 사용하여 빈 줄(문단) 기준으로 문자열을 단순 분리한다.</li>
      <li><strong>대체 라이브러리</strong>: <code class="language-plaintext highlighter-rouge">LangChain</code>의 <code class="language-plaintext highlighter-rouge">RecursiveCharacterTextSplitter</code> 또는 <code class="language-plaintext highlighter-rouge">LlamaIndex</code>의 문장 분리 도구.</li>
      <li><strong>트레이드오프</strong>: 현재의 단순 분리 방식은 외부 의존성이 없고 실행 속도가 매우 빠르다는 장점(Lightweight)이 있다. 단락 내의 길이가 너무 길어질 경우 LLM의 토큰 제한을 초과할 수 있고, 문맥이 끊기는 가장자리 데이터의 손실이 발생할 수 있다. 반면 LangChain 등을 사용하면 오버랩(Overlap) 기능을 통해 문맥 단절을 방지하고 정확한 토큰 수 기반으로 분리할 수 있지만, 라이브러리 의존성이 추가되고 메모리 및 연산 오버헤드가 증가한다.</li>
    </ul>
  </li>
</ul>

<h3 id="4-구조적-취약점-및-개선-방향">4. 구조적 취약점 및 개선 방향</h3>

<ul>
  <li><strong>취약점</strong>: 전반적으로 파일 및 토큰의 섬세한 관리적 차원에서의 한계가 존재한다.
    <ol>
      <li>파일 로딩 시 <code class="language-plaintext highlighter-rouge">read()</code>로 전체 텍스트를 메모리에 한 번에 올리고 단순 문자열로 자르기 때문에, 파일 크기가 커지거나 구조가 복잡해지면 OOM(Out of Memory) 위험이 있다.</li>
      <li>LLM으로 전달되는 토큰 한도에 대한 예외 처리가 부재하다.</li>
    </ol>
  </li>
  <li><strong>개선 방향</strong>: 텍스트 분할 시 토큰 카운터 기반의 청크 분할 기법(예: Tiktoken 결합)을 도입하고 Chunk 간 Overlap을 두어 문맥 손실을 방지해야 한다.</li>
</ul>

<h3 id="5-핵심-메서드-및-라이브러리-함수">5. 핵심 메서드 및 라이브러리 함수</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">AsyncOpenAI</code> (openai 라이브러리)</strong>: 비동기(Asynchronous) 환경에서 OpenAI API(또는 호환되는 OpenRouter API)와 통신하기 위한 클라이언트 객체이다. FastAPI와 같은 비동기 프레임워크에서 I/O 블로킹 없이 LLM 요청을 처리하기 위해 필수적이다.
    <ul>
      <li>현재 사용 중인 OpenRouter 에서는 API 호환이 되서 SDK 를 OpenAI 를 사용하였다. 하지만 OpenRouter 에서 현재 OpenRouter SDK Beta가 나온 상태이고 이거에 대응할 필요가 있다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">client.chat.completions.create(..., stream=True)</code></strong>: LLM의 응답을 한 번에 기다리지 않고, 텍스트가 생성되는 즉시 스트리밍 형태로 받아오기 위한 핵심 메서드이다. 실시간 챗봇 체감 속도를 높이는 데 기여한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">textwrap.dedent</code> (내장 모듈)</strong>: Python 코드 내에서 멀티라인 문자열(Multi-line string)로 시스템 프롬프트를 작성할 때, 코드 가독성을 위해 추가된 들여쓰기 공백을 텍스트에서 깔끔하게 제거해주는 함수이다. 불필요한 공백 토큰을 줄여 LLM의 인식을 돕는다.</li>
</ul>

<h2 id="coreworkerpy">core/worker.py</h2>

<p>이 파일은 Redis를 백엔드로 사용하는 비동기 작업 워커(Worker) 시스템이다. 클라이언트의 채팅 요청을 큐에서 꺼내어 처리하고, RAG 문서를 검색하여 AI 모듈에 전달한 뒤, 생성된 응답 조각을 Redis Pub/Sub을 통해 다시 전송하는 역할을 수행한다. 기본적으로 AI 를 기반으로 하는 모든 작업은 해당의 로직을 따라 진행된다.</p>

<h3 id="1-주요-개념-1">1. 주요 개념</h3>

<ul>
  <li><strong>Message Queue (메시지 큐)</strong>: 요청을 즉시 처리하지 않고 큐(<code class="language-plaintext highlighter-rouge">chat:job:queue</code>)에 담아두었다가, 워커가 자신의 처리 능력(Capacity)에 맞게 순차적으로 꺼내어 처리하는 비동기 처리 패턴을 취하여, 요청하는 대상(Nestjs)과 처리자(FastAPI)를 구분하여 시스템 안정성을 향상 시키고, 수평적 스케일 아웃 호환성을 유지시킨다.</li>
  <li><strong>Pub/Sub (발행/구독 모델)</strong>: 워커가 AI 모델로부터 스트리밍으로 전달받은 토큰(조각)을 특정 채널(<code class="language-plaintext highlighter-rouge">chat:stream:{uuid}-{session_id}</code>)에 발행(Publish)하면, 이를 구독(Subscribe)하고 있는 웹서버(NestJS 등)가 클라이언트에게 즉시 전달하는 실시간 메시징 패턴이다.</li>
  <li><strong>Semaphore (세마포어)</strong>: <code class="language-plaintext highlighter-rouge">asyncio.Semaphore(MAX_CONCURRENT_JOBS)</code>를 활용하여 동시에 처리할 수 있는 최대 코루틴(작업)의 수를 제한하는 동시성 제어 기법이다. 이를 통해 시스템의 과도한 작업이 올라감으로써 생길 문제들을 제어한다.</li>
</ul>

<h3 id="2-핵심-로직-흐름-1">2. 핵심 로직 흐름</h3>

<ul>
  <li><strong>작업 리스닝 루프 (<code class="language-plaintext highlighter-rouge">run_worker</code>)</strong>:
    <ol>
      <li>무한 루프(<code class="language-plaintext highlighter-rouge">while True</code>)를 돌며 Redis의 특정 큐(<code class="language-plaintext highlighter-rouge">chat:job:queue</code>)에서 대기 중인 작업을 감시한다.</li>
      <li>세마포어(Semaphore)를 획득하여 동시 처리량을 조절한다.</li>
      <li>큐에 작업이 들어오면 백그라운드 태스크로 분리하여 실행을 요청한다.</li>
    </ol>
  </li>
  <li><strong>단일 작업 처리 (<code class="language-plaintext highlighter-rouge">process_chat_job</code>)</strong>:
    <ol>
      <li>JSON 형태의 작업 데이터를 파싱한 후</li>
      <li><code class="language-plaintext highlighter-rouge">general</code> 모드일 경우 RAG 문서 검색을 수행하여 컨텍스트를 구성한다. (그렇지 않은 경우는 블로그의 글을 요약하는 등의 특수 목적이므로, 이에 따른 로직에 들어간다.)</li>
      <li>DB에 사용자 질문을 기록하고 과거 대화 이력을 조회한다.
        <ul>
          <li>별도의 워커가 대화를 요약해서 저장해둔다. 요약한 내용이 있을 시 이를 가져가고, 요약이 없다면 원본 대화 내용 일부를 전달한다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">generate_response_stream</code>을 호출한다.</li>
    </ol>
  </li>
  <li><strong>실시간 스트리밍 및 후처리</strong>:
    <ol>
      <li>AI가 생성한 응답 조각(Token)을 하나씩 받을 때마다, 즉시 Redis의 Pub/Sub 채널(<code class="language-plaintext highlighter-rouge">chat:stream:{uuid}-{sessionId}</code>)로 발행(<code class="language-plaintext highlighter-rouge">publish</code>)하여 클라이언트(NestJS 등)로 데이터를 전송한다.</li>
      <li>완료 시 <code class="language-plaintext highlighter-rouge">done</code> 신호를 전송하고, 최종 조립된 전체 텍스트를 DB에 저장한 후 요약 작업을 위한 큐로 메시지 ID를 밀어 넣는다(<code class="language-plaintext highlighter-rouge">rpush</code>). (새롭게 만든 답변에 대한 요약)</li>
    </ol>
  </li>
</ul>

<h3 id="3-대체-가능한-라이브러리-및-메서드-트레이드오프-1">3. 대체 가능한 라이브러리 및 메서드 (트레이드오프)</h3>

<ul>
  <li><strong>작업 큐 및 워커 루프</strong>
    <ul>
      <li><strong>현재 방식</strong>: Redis의 <code class="language-plaintext highlighter-rouge">brpop</code> 명령어를 무한 루프(<code class="language-plaintext highlighter-rouge">while True</code>)로 직접 폴링(Polling)하며 <code class="language-plaintext highlighter-rouge">asyncio.create_task</code>로 작업을 실행한다.</li>
      <li><strong>대체 라이브러리</strong>: <code class="language-plaintext highlighter-rouge">Celery</code>, <code class="language-plaintext highlighter-rouge">ARQ</code> (Asyncio Redis Queue), <code class="language-plaintext highlighter-rouge">RQ</code> 등 전문 Task Queue 프레임워크.</li>
      <li><strong>트레이드오프</strong>: 현재의 커스텀 루프 방식은 설정이 직관적이고 코드가 가벼워 추가적인 데몬이나 프레임워크 학습이 필요 없다는 장점이 있다. 그러나, 워커 프로세스가 갑자기 종료될 경우 현재 처리 중이던 데이터를 복구할 수 있는 기능(Message ACK)이 기본적으로 없으며, 재시도(Retry) 로직이나 스케줄링을 직접 구현해야 하는 단점이 있다. Celery나 ARQ를 사용하면 이러한 안정성(Reliability) 기능이 보장되지만, 아키텍처가 무거워지고 설정이 복잡해진다.</li>
    </ul>
  </li>
</ul>

<h3 id="4-구조적-취약점-및-개선-방향-1">4. 구조적 취약점 및 개선 방향</h3>

<ul>
  <li><strong>취약점</strong>: <code class="language-plaintext highlighter-rouge">brpop</code>으로 큐에서 데이터를 꺼낸 직후(Pop) 워커가 크래시(다운)되면, 해당 작업은 완료되지 않은 상태로 영구적으로 유실(Data Loss)되며, Redis Pub/Sub 특성상 발행 시점에 구독자가 없으면 스트리밍 데이터 역시 유실된다.</li>
  <li><strong>개선 방향</strong>: 작업 유실 방지를 위해 단순 List 기반의 큐 대신 Redis Streams 기반의 큐 연산(XREADGROUP)을 도입하거나 비동기 큐 전문 라이브러리(ARQ 등)로 마이그레이션 해야 한다. (자세한 내용이 필요하면 요청 바람)</li>
</ul>

<h3 id="5-핵심-메서드-및-라이브러리-함수-1">5. 핵심 메서드 및 라이브러리 함수</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">redis_client.brpop("chat:job:queue", timeout=5)</code></strong>: 지정된 큐(List 자료구조)에 데이터가 들어올 때까지 대기(Block)하다가, 데이터가 들어오면 꺼내오는(Pop) Redis 명령어이다. CPU를 점유하는 무한 폴링(Polling) 방식보다 시스템 자원을 효율적으로 사용한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">redis_client.publish(channel, message)</code></strong>: Redis의 Pub/Sub 메커니즘을 사용하여 지정된 채널을 구독 중인 모든 클라이언트에게 비동기적으로 메시지를 전송한다. 이를 통해 스트리밍 데이터 조각을 타 서비스로 즉각 브로드캐스트할 수 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">asyncio.Semaphore</code></strong>: 동시에 실행될 수 있는 코루틴(작업)의 최대 개수(예: <code class="language-plaintext highlighter-rouge">MAX_CONCURRENT_JOBS = 100</code>)를 제한하는 동기화 객체이다. 외부 API Rate Limit이나 DB 커넥션 풀의 한도를 초과하지 않도록 보호하는 역할을 한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">asyncio.create_task</code></strong>: 이벤트 루프에 코루틴 실행을 예약하여 블로킹 없이 백그라운드에서 비동기 작업을 병행(Concurrent) 처리하게 하는 내장 함수이다. <code class="language-plaintext highlighter-rouge">run_worker</code> 루프가 각 Job을 넘기고 즉시 다음 Job을 대기할 수 있게 만든다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="FastAPI" /><category term="AI" /><summary type="html"><![CDATA[core/ai.py 이 파일은 OpenAI 호환 API(OpenRouter)를 사용하여 AI 비서(Protostar)의 응답을 생성하고, RAG(Retrieval-Augmented Generation) 구성을 위한 파일 청킹(Chunking) 및 프롬프트 구성을 담당하는 핵심 모듈이다.]]></summary></entry><entry><title type="html">Protostar review note - 03 - FastAPI DBs</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/14/00-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 03 - FastAPI DBs" /><published>2026-02-14T00:00:00+00:00</published><updated>2026-02-14T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/14/00-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/14/00-protostar-review.html"><![CDATA[<h2 id="coreminio_clientpy">core/minio_client.py</h2>

<p>이 모듈은 MinIO 오브젝트 스토리지와의 연결을 관리하고 파일을 다운로드하는 래퍼(Wrapper) 클래스를 정의하고 있다.</p>

<h3 id="1-코드-분석-및-개념">1. 코드 분석 및 개념</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">__init__</code>: 설정값(endpoint, access_key 등)을 가져와 동기식 <code class="language-plaintext highlighter-rouge">Minio</code> 클라이언트 객체를 초기화한다.</li>
  <li><code class="language-plaintext highlighter-rouge">check_connection</code>: 서버 시작 시 버킷이 존재하는지 확인하여 연결 상태를 로깅한다. 동기 함수인 <code class="language-plaintext highlighter-rouge">bucket_exists</code>를 <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>로 감싸서 실행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_file_content</code>: 지정된 버킷에서 객체를 읽어 바이트 배열로 반환한다. 이 역시 I/O 블로킹을 막기 위해 <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>를 사용하여 별도의 스레드에서 <code class="language-plaintext highlighter-rouge">get_object</code>와 <code class="language-plaintext highlighter-rouge">read()</code>를 수행한다.</li>
  <li><strong>개념 (비동기 오프로딩):</strong> 파이썬의 <code class="language-plaintext highlighter-rouge">asyncio</code> 환경에서 동기 라이브러리(MinIO SDK)가 메인 이벤트 루프를 블로킹하는 것을 방지하기 위해 <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>를 사용한다. 이는 무거운 I/O 작업을 백그라운드 스레드 풀로 넘겨 비동기적으로 결과를 기다리는 기법이다.</li>
</ul>

<h3 id="2-대체-가능한-라이브러리-및-메서드">2. 대체 가능한 라이브러리 및 메서드</h3>

<p>동기식 <code class="language-plaintext highlighter-rouge">minio</code> 라이브러리를 스레드로 래핑하는 대신, 처음부터 비동기를 지원하는 <strong><code class="language-plaintext highlighter-rouge">aioboto3</code></strong> 라이브러리를 사용할 수 있다. AWS S3 호환 스토리지를 비동기로 다루는 표준적인 방법이다.</p>

<h3 id="3-트레이드오프-trade-off">3. 트레이드오프 (Trade-off)</h3>

<ul>
  <li><strong>현재 방식 (<code class="language-plaintext highlighter-rouge">minio</code> + <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>):</strong> 공식 MinIO 라이브러리를 사용하므로 API 문서 참고와 구현이 매우 직관적이고 쉽다. 하지만 요청이 많아질 경우 스레드 컨텍스트 스위칭 오버헤드가 발생하며, 진정한 의미의 Non-blocking I/O 성능을 100% 발휘하지 못한다.
    <ul>
      <li>Why:
        <ul>
          <li>공식 MinIO 라이브러리를 사용한 이유가 여기에 있다. 기본적으로 원본 데이터는 최초 다운로드 받는 정도이며, 모든 비즈니스 로직은 NestJS 가 이를 대응함.</li>
          <li>결과적으로 이후엔 RAG 기반으로 변환한 데이터를 pgVector 기반으로 대응하므로, 현재의 방식으로 하더라도 스레드 컨텍스트 스위칭 오버헤드가 발생하더라도 큰 문제가 없음.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>대체 방식 (<code class="language-plaintext highlighter-rouge">aioboto3</code>):</strong> 완전한 비동기 I/O를 지원하므로 대규모 동시성 처리에 매우 효율적이다. 하지만 Boto3 기반이므로 MinIO에 특화된 기능 접근이 까다로울 수 있고, 러닝 커브가 존재한다. 따라서 구체적으로 더 다양한 작업들이 이어진다면 해당 기능을 활용해야 하며 특히 S3 등을 쓴다면 더욱 그러하다.</li>
</ul>

<h3 id="4-구조적-취약점-및-개선-방향">4. 구조적 취약점 및 개선 방향</h3>

<ul>
  <li><strong>취약점:</strong> <code class="language-plaintext highlighter-rouge">get_file_content</code> 내에서 <code class="language-plaintext highlighter-rouge">response.read()</code>를 호출하여 파일 전체를 한 번에 메모리에 올린다. 대용량 파일을 요청할 경우 서버 I/O 병목 및 메모리 고갈(OOM, Out Of Memory)이 발생할 위험이 크다.
    <ul>
      <li>현 상황에서 사용하는 파일 자료가 md 텍스트 파일로 제한되어 있기 때문에 넘어갔음.</li>
    </ul>
  </li>
  <li><strong>개선 방향:</strong> 대용량 파일 처리, 파일 종류에 따라 OOM 방지를 위해 전체 데이터를 메모리에 올리지 않고 <strong>청크(Chunk) 단위의 스트리밍 반환 구조</strong>로 개선해야 한다. (자세한 내용 요청 시 응답 가능)</li>
</ul>

<hr />

<h2 id="coredatabasepy">core/database.py</h2>

<p>PostgreSQL 데이터베이스와의 비동기 연결 및 ORM 세션을 설정하는 모듈이다.</p>

<h3 id="1-코드-분석">1. 코드 분석</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">engine</code> 및 <code class="language-plaintext highlighter-rouge">AsyncSessionLocal</code>: 비동기 처리용 <code class="language-plaintext highlighter-rouge">create_async_engine</code>을 활용하여 커넥션 풀(pool_size=10, max_overflow=20)을 구성하고 세션 팩토리를 만든다.</li>
  <li><code class="language-plaintext highlighter-rouge">init_db()</code>: 애플리케이션 시작 시 호출되어 모델을 임포트하고, <code class="language-plaintext highlighter-rouge">create_all</code>을 통해 데이블을 강제 생성한다. 에러 발생 시 <code class="language-plaintext highlighter-rouge">sys.exit(1)</code>로 서버를 종료한다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_db()</code>: FastAPI의 의존성 주입(Dependency Injection)에 사용될 제너레이터(Generator)로, 세션을 열고 안전하게 닫거나 롤백하는 라이프사이클을 관리한다.</li>
</ul>

<h3 id="2-대체-가능한-라이브러리-및-메서드-1">2. 대체 가능한 라이브러리 및 메서드</h3>

<p>현재 <strong><code class="language-plaintext highlighter-rouge">SQLAlchemy</code></strong> ORM을 사용 중인데, 대체제로 <strong><code class="language-plaintext highlighter-rouge">Prisma Client Python</code></strong> 또는 ORM을 배제한 순수 비동기 드라이버인 <strong><code class="language-plaintext highlighter-rouge">asyncpg</code></strong>를 직접 사용할 수 있다.</p>

<h3 id="3-트레이드오프-trade-off-1">3. 트레이드오프 (Trade-off)</h3>

<ul>
  <li><strong>SQLAlchemy ORM:</strong> 매우 강력하고 파이썬 생태계의 표준 격이라 호환성이 좋으나, 매핑 오버헤드로 인해 순수 드라이버보다 속도가 다소 느리다. DB의 중요성, 트랜잭션 퍼포먼스의 우선도가 떨어지는 일반적인 서비스의 경우 사용이 편리함.</li>
  <li><strong>asyncpg:</strong> 파이썬 DB 드라이버 중 압도적으로 빠르지만, 모든 쿼리를 날(Raw) SQL 스트링으로 관리해야 하므로 생산성과 유지보수성이 급격히 떨어진다. DB가 특성적으로 매우 중요한 서비스라면 이렇게 가고 Raw SQL 을 이용하는게 좋을 수 있다.</li>
</ul>

<h3 id="4-구조적-취약점-및-개선-방향-1">4. 구조적 취약점 및 개선 방향</h3>

<ul>
  <li><strong>취약점:</strong> <code class="language-plaintext highlighter-rouge">init_db</code>에서 <code class="language-plaintext highlighter-rouge">Base.metadata.create_all</code>을 사용하고 있으며 연결 실패 시 <code class="language-plaintext highlighter-rouge">sys.exit(1)</code>로 서버를 다운시킨다. 프로덕션 환경에서는 테이블 변경 이력 관리가 안 되며, 일시적인 네트워크 장애에도 컨테이너가 죽어버리는 결함이 발생할 수 있다.</li>
  <li><strong>개선 방향:</strong>
    <ul>
      <li>프로덕션 스키마 관리를 위해 <code class="language-plaintext highlighter-rouge">create_all</code> 대신 <strong>Alembic 마이그레이션 툴</strong>을 도입하는게 유효할 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">init_db</code>에 데이터베이스 연결 <strong>재시도(Backoff Retry) 로직</strong>을 추가해야 한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="coreredispy">core/redis.py</h2>

<p>인메모리 데이터 저장소인 Redis와의 비동기 연결 풀을 구성하고 클라이언트 객체를 제공하는 모듈이다.</p>

<h3 id="1-코드-분석-및-개념-1">1. 코드 분석 및 개념</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pool</code>: <code class="language-plaintext highlighter-rouge">redis.ConnectionPool.from_url</code>을 사용해 최대 1000개의 연결을 유지할 수 있는 비동기 커넥션 풀을 생성한다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_redis_client()</code>: 생성된 풀을 기반으로 <code class="language-plaintext highlighter-rouge">Redis</code> 인스턴스를 반환한다.</li>
  <li><code class="language-plaintext highlighter-rouge">init_test_redis()</code>: 서버 시작 단계에서 <code class="language-plaintext highlighter-rouge">ping()</code>을 날려 상태를 체크하고, 실패하면 자원 해제 후 <code class="language-plaintext highlighter-rouge">sys.exit(1)</code>로 프로세스를 종료한다.</li>
  <li><strong>개념 (In-memory DB):</strong> 모든 데이터를 디스크가 아닌 메모리에 저장하여 압도적인 읽기/쓰기 속도를 자랑한다. 세션 관리, 캐싱, 큐(Queue) 등 일시적이고 빠른 접근이 필요한 데이터 처리에 주로 쓰인다.</li>
</ul>

<h3 id="2-대체-가능한-라이브러리-및-메서드-2">2. 대체 가능한 라이브러리 및 메서드</h3>

<p>현재 사용 중인 <code class="language-plaintext highlighter-rouge">redis.asyncio</code>는 과거 <code class="language-plaintext highlighter-rouge">aioredis</code>가 병합된 공식 표준 라이브러리이므로 파이썬 생태계에서는 가장 최적의 선택이다. 저장소 수준에서 대체를 고려한다면 <strong><code class="language-plaintext highlighter-rouge">Memcached</code></strong>를 사용할 수 있지만, Redis 의 본래의 제공 기능을 위하여 최대한 공식 표준 라이브러리를 사용했다.</p>

<h3 id="3-트레이드오프-trade-off-2">3. 트레이드오프 (Trade-off)</h3>

<ul>
  <li><strong>Redis:</strong> 문자열, 리스트, 해시, 셋 등 다양한 자료구조를 지원하고 디스크 영속성(Persistence)을 부분 지원하나, 구조가 복잡해지면 메모리 파편화나 관리 비용이 증가한다.</li>
  <li><strong>Memcached:</strong> 단순한 키-값(Key-Value) 캐싱에는 오버헤드가 적어 아주 미세하게 더 빠르고 메모리 관리가 단순하지만, 다양한 자료구조를 활용할 수 없고 시스템 재시작 시 데이터가 100% 날아간다.</li>
</ul>

<h3 id="4-구조적-취약점-및-개선-방향-2">4. 구조적 취약점 및 개선 방향</h3>

<ul>
  <li><strong>취약점:</strong> <code class="language-plaintext highlighter-rouge">database.py</code>와 마찬가지로 <code class="language-plaintext highlighter-rouge">init_test_redis</code>에서 연결 예외 발생 시 <code class="language-plaintext highlighter-rouge">sys.exit(1)</code>로 강제 종료를 발생시킨다. Redis는 주로 캐싱 용도이므로 서버 전체가 죽어야 할 만큼의 치명적 장애가 아닐 수 있다 (Graceful degradation 부재).</li>
  <li><strong>개선 방향:</strong> Redis 연결 장애 시 애플리케이션을 강제 종료하는 대신, 기능을 우회(Fallback)하거나 <strong>지수 백오프(Exponential Backoff)를 활용한 재시도 구조</strong>로 안정성을 높여야 한다.</li>
</ul>

<p>앞서 작성된 <code class="language-plaintext highlighter-rouge">## core/redis.py</code> 문서의 후속 내용으로, 프로젝트 전체 아키텍처 관점에서 Redis가 어떻게 활용되고 있는지 분석한 5번 항목을 추가해 드립니다.</p>

<h3 id="5-protostar-프로젝트-전체에서의-redis-활용-부분-정리">5. Protostar 프로젝트 전체에서의 Redis 활용 부분 정리</h3>

<p>현재 프로젝트의 <code class="language-plaintext highlighter-rouge">core/redis.py</code>에서 생성된 비동기 Redis 클라이언트는 FastAPI 애플리케이션 전반에서 다음과 같은 핵심적인 역할을 수행한다.</p>

<ul>
  <li><strong>백그라운드 비동기 작업 큐 (Task Queue 및 Message Broker):</strong> FastAPI 웹 서버는 클라이언트의 요청에 대해 최대한 빠르게 응답해야 하므로, 실행 시간이 오래 걸리는 무거운 I/O 작업(예: LLM 기반의 AI 요약, RAG 문서 벡터화 연산 등)을 메인 이벤트 루프에서 직접 처리해서는 안 된다. 메인 API 서버(생산자)는 클라이언트 요청을 받으면 <strong>Redis 큐에 작업 명세(Task)를 밀어 넣고(Push) 즉시 응답을 반환(Fire and Forget)</strong>한다. 이후 <code class="language-plaintext highlighter-rouge">worker_knowledge.py</code>, <code class="language-plaintext highlighter-rouge">worker_summary.py</code> 등의 독립된 백그라운드 워커(소비자)들이 Redis에서 작업을 꺼내어(Pop) 비동기적으로 안전하게 처리하는 <strong>메시지 브로커(Message Broker)</strong> 역할을 수행한다.</li>
  <li><strong>분산 컴포넌트 간의 상태 공유 (State Management):</strong> API 서버(FastAPI)와 여러 워커 프로세스(AI/요약/지식 처리 등)가 서로 독립적인 컨테이너로 분리되어 동작하는 분산 환경에서, 각 작업의 진행 상태(예: 대기 중, 처리 중, 완료, 실패)나 임시 결과물 데이터를 실시간으로 빠르고 안전하게 주고받기 위한 <strong>중앙 인메모리 상태 저장소</strong>로 기능한다. 데이터베이스(PostgreSQL)에 매번 접근하는 것에 비해 압도적으로 빠른 속도를 보장한다.</li>
  <li><strong>데이터 캐싱 (Caching) 및 부하 분산:</strong> AI 모델이 생성한 요약 결과나 동일한 문서에 대한 반복적인 질의응답 처리 결과를 메모리에 일시적으로 저장(TTL 설정)해 두는 캐싱 용도로도 활용된다. 이를 통해 불필요한 연산과 데이터베이스 I/O를 줄여 전반적인 응답 속도를 극대화하고, 트래픽이 몰리는 상황(Spike)에서 시스템 후단 시스템의 부하를 효과적으로 경감시킨다.</li>
</ul>

<hr />

<h2 id="asyncio-및-코루틴coroutine-추가-정리">asyncio 및 코루틴(Coroutine) 추가 정리</h2>

<h3 id="1-비동기-논블로킹과-코루틴의-개념">1. 비동기 논블로킹과 코루틴의 개념</h3>

<p>비동기 프로그래밍을 명확히 이해하기 위해서는 패러다임과 이를 구현하는 도구를 구분해야 한다.</p>

<ul>
  <li><strong>비동기 논블로킹 (Async Non-blocking):</strong> I/O 작업(네트워크 요청, 파일 읽기 등) 시 결과를 마냥 기다리지 않고(Non-blocking), 제어권을 넘겨 다른 작업을 수행하다가 완료되면 다시 돌아와 처리하는(Async) <strong>프로그래밍 패러다임</strong>이다.</li>
  <li><strong>코루틴 (Coroutine):</strong> 파이썬에서 비동기 논블로킹 패러다임을 실제로 구현하기 위해 사용하는 <strong>특수한 함수 구조(도구)</strong> 이다. 일반 함수(Subroutine)와 달리 실행 도중 일시 정지(Pause/Yield)하고, 나중에 멈춘 지점부터 다시 재개(Resume)할 수 있는 특징을 가진다.</li>
</ul>

<h3 id="2-코루틴-객체와-await의-동작-원리">2. 코루틴 객체와 <code class="language-plaintext highlighter-rouge">await</code>의 동작 원리</h3>

<p><code class="language-plaintext highlighter-rouge">async def</code>로 정의된 함수를 호출하거나 비동기 래퍼 함수를 실행하면 즉시 작업이 실행되지 않는다.</p>

<ul>
  <li><strong>코루틴 객체 반환:</strong> 함수 호출 시 실제 결과값이 아닌, “나중에 실행될 작업 명세서(대기표)” 역할을 하는 <strong>코루틴(Coroutine) 객체</strong>가 반환된다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">await</code> 키워드:</strong> 코루틴 객체 앞에 <code class="language-plaintext highlighter-rouge">await</code>를 붙여야만 이벤트 루프에 의해 실제 작업이 스케줄링 및 실행되며, 작업이 완료된 후 최종 결과값을 반환받을 수 있다.</li>
</ul>

<h3 id="3-asyncioto_thread를-활용한-동기-io-오프로딩">3. <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>를 활용한 동기 I/O 오프로딩</h3>

<p>FastAPI와 같은 비동기 프레임워크 환경에서 외부 라이브러리(예: MinIO SDK)의 동기식 블로킹 함수를 그대로 호출하면 메인 이벤트 루프가 멈추는 병목 현상이 발생함. 이를 해결하기 위해 <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>를 사용한다.</p>

<ul>
  <li><strong>역할:</strong> 무거운 동기 함수 호출을 백그라운드 스레드 풀(Thread Pool)로 넘겨서 실행하고, 메인 스레드는 블로킹 없이 다른 코루틴을 처리할 수 있게 한다.</li>
  <li><strong>반환 타입의 변화:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">asyncio.to_thread(...)</code> 호출 직후: <code class="language-plaintext highlighter-rouge">&lt;class 'coroutine'&gt;</code> 타입을 반환한다.</li>
      <li><code class="language-plaintext highlighter-rouge">await asyncio.to_thread(...)</code> 실행 완료 후: 원본 동기 함수가 뱉어내는 <strong>본래의 데이터 타입</strong>(예: <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">bytes</code>)을 그대로 반환한다.</li>
    </ol>
  </li>
</ul>

<h3 id="4-ide-타입-추론-한계-극복-type-annotation">4. IDE 타입 추론 한계 극복 (Type Annotation)</h3>

<p>외부 라이브러리(Boto3, MinIO 등)의 동기 함수를 <code class="language-plaintext highlighter-rouge">asyncio.to_thread</code>로 감쌀 때, 원본 라이브러리에 최신 파이썬 타입 힌트가 누락되어 있다면 IDE(VS Code 등)는 최종 반환 타입을 <code class="language-plaintext highlighter-rouge">unknown</code>이나 <code class="language-plaintext highlighter-rouge">Any</code>로 인식하여 자동완성을 지원하지 못한다.</p>

<ul>
  <li><strong>해결 방안:</strong> 개발자가 직접 반환 타입을 명시(Type Annotation)하여 가독성과 유지보수성을 높여야 한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 명시적 타입 힌팅 적용 예시
</span><span class="n">found</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">to_thread</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">bucket_exists</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bucket_name</span><span class="p">)</span>
<span class="n">content</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">to_thread</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">read</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="5-nestjs-nodejs와-python-asyncio의-비동기-동작-방식-차이">5. NestJS (Node.js)와 Python <code class="language-plaintext highlighter-rouge">asyncio</code>의 비동기 동작 방식 차이</h3>

<p>비동기 함수를 다룰 때 파이썬과 Node.js(NestJS) 생태계는 근본적인 동작 방식에 큰 차이가 있다. 가장 핵심적인 차이는 비동기 함수를 호출했을 때 반환되는 객체의 실행 상태(Hot vs Cold)이다.</p>

<ul>
  <li><strong>NestJS (Node.js) 방식: “Hot Promise” 🔥</strong>
    <ul>
      <li><strong>동작 원리:</strong> Node.js 환경에서는 비동기 함수(<code class="language-plaintext highlighter-rouge">async function</code>)를 호출하는 그 즉시 내부 로직이 동기적으로 실행되기 시작한다 (함수 내부에서 첫 번째 <code class="language-plaintext highlighter-rouge">await</code>를 만날 때까지).</li>
      <li><strong>특징:</strong> 반환되는 <code class="language-plaintext highlighter-rouge">Promise</code> 객체는 이미 실행 중인(Hot) 상태이다. 따라서 <code class="language-plaintext highlighter-rouge">await</code> 키워드를 생략하고 함수를 호출만 해두어도(던져 놓기만 해도), 이벤트 루프가 이를 이미 인지하고 백그라운드에서 남은 작업을 알아서 처리한다.</li>
    </ul>
  </li>
  <li><strong>Python (<code class="language-plaintext highlighter-rouge">asyncio</code>) 방식: “Cold Coroutine” ❄️</strong>
    <ul>
      <li><strong>동작 원리:</strong> 파이썬에서는 비동기 함수(<code class="language-plaintext highlighter-rouge">async def</code>)를 호출하면, 실제 코드는 단 1%도 실행되지 않고 오직 “나중에 이 작업을 실행하겠다”는 작업 명세서인 <strong>코루틴(Coroutine) 객체</strong>만 반환한다.</li>
      <li><strong>특징:</strong> 반환된 코루틴은 아직 전혀 실행되지 않은(Cold) 상태이다. 파이썬의 이벤트 루프는 개발자가 명시적으로 큐에 등록해주기 전까지 이 코루틴 객체를 쳐다보지도 않는다.</li>
      <li><strong>주의점:</strong> <code class="language-plaintext highlighter-rouge">await</code> 없이 비동기 함수만 호출하고 방치하면 작업 자체가 아예 실행되지 않으며, 파이썬은 프로그램 종료 시 <code class="language-plaintext highlighter-rouge">RuntimeWarning: coroutine was never awaited</code>라는 경고 에러를 발생시킨다.</li>
    </ul>
  </li>
  <li><strong>핵심 요약 (Fire and Forget 패턴의 구현):</strong>
    <ul>
      <li>NestJS에서는 단순히 비동기 함수를 <code class="language-plaintext highlighter-rouge">await</code> 없이 호출하는 것만으로 백그라운드 실행(Fire and Forget)이 성립된다.</li>
      <li>하지만 파이썬에서 결과를 기다리지 않고 백그라운드에서 알아서 실행되게 하려면, 함수를 덩그러니 던져놓는 것이 아니라 반드시 <strong><code class="language-plaintext highlighter-rouge">asyncio.create_task(my_async_function())</code></strong>를 사용하여 이벤트 루프의 스케줄러에 명시적으로 밀어 넣어주어야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="sqlalchemy-라이브러리의-개념-및-주요-특징">SQLAlchemy 라이브러리의 개념 및 주요 특징</h2>

<p>본 문서는 파이썬 생태계에서 가장 널리 사용되는 데이터베이스 툴킷이자 ORM(Object-Relational Mapping) 라이브러리인 <strong>SQLAlchemy</strong>의 핵심 개념과 특징을 정리한 것이다. Protostar 프로젝트의 데이터베이스 연동(<code class="language-plaintext highlighter-rouge">core/database.py</code>)에도 핵심적으로 사용되었다.</p>

<h3 id="1-sqlalchemy란">1. SQLAlchemy란?</h3>

<p>SQLAlchemy는 파이썬 프로그램과 관계형 데이터베이스(RDBMS) 간의 소통을 돕는 강력한 SQL 툴킷이자 ORM 라이브러리이다.</p>

<h3 id="2-핵심-개념">2. 핵심 개념</h3>

<ul>
  <li><strong>ORM (Object-Relational Mapping):</strong> 데이터베이스의 ‘테이블’을 파이썬의 ‘클래스(Class)’로, 테이블의 ‘로우(Row/Record)’를 파이썬의 ‘인스턴스(Instance)’로 매핑하는 기술이다. 이를 통해 데이터베이스를 철저히 객체 지향적인 관점에서 다룰 수 있음. 편리함.</li>
  <li><strong>Engine (엔진):</strong> SQLAlchemy 애플리케이션의 심장부로, 데이터베이스와의 통신을 담당하는 기본 인터페이스. 내부적으로 커넥션 풀(Connection Pool)과 Dialect(데이터베이스 방언 해석기)를 관리하여, DB 연결을 효율적으로 재사용하고 각기 다른 DB(PostgreSQL, MySQL 등)의 문법 차이를 추상화한다.</li>
  <li><strong>Session (세션):</strong> ORM 객체들의 ‘작업 공간(Workspace)’이다. 데이터베이스 트랜잭션(Transaction)을 캡슐화하며, 세션 내에서 변경된 객체 상태를 추적하다가 <code class="language-plaintext highlighter-rouge">commit()</code>이 호출될 때 비로소 실제 DB에 반영(Flush)한다.</li>
  <li><strong>Declarative Base:</strong> 클래스 정의와 동시에 테이블 메타데이터를 생성해 주는 기본 클래스이다. 클래스 변수로 컬럼의 타입과 제약조건을 정의하면, SQLAlchemy가 이를 데이터베이스 스키마로 변환한다.</li>
</ul>

<h3 id="3-주요-특징-및-장단점-trade-off">3. 주요 특징 및 장단점 (Trade-off)</h3>

<p><strong>장점:</strong></p>
<ul>
  <li><strong>데이터베이스 독립성 (DB Agnostic):</strong> 엔진의 URL만 변경하면 코드 수정 없이 PostgreSQL, MySQL, SQLite 등 다른 데이터베이스로 쉽게 마이그레이션이 가능하다.</li>
  <li><strong>보안 (SQL Injection 방지):</strong> 내부적으로 쿼리를 파라미터화하여 실행하므로 SQL 인젝션 공격으로부터 매우 안전하다.</li>
  <li><strong>비동기(Asyncio) 지원:</strong> <code class="language-plaintext highlighter-rouge">sqlalchemy.ext.asyncio</code> 모듈을 통해 파이썬의 비동기 I/O 패러다임을 완벽히 지원한다. FastAPI와 같은 비동기 웹 프레임워크와 결합 시 훌륭한 시너지를 낸다.</li>
</ul>

<p><strong>단점 (트레이드오프):</strong></p>
<ul>
  <li><strong>학습 곡선(Learning Curve):</strong> 기능이 방대하고 구조가 복잡하여(Core와 ORM 계층의 분리 등) 초기 진입 장벽이 다소 높은 편이다.</li>
  <li><strong>성능 오버헤드:</strong> 파이썬 객체를 SQL로 번역하고, 결과를 다시 객체로 변환하는 매핑 과정이 존재하므로 순수 SQL 드라이버(예: <code class="language-plaintext highlighter-rouge">asyncpg</code>)나 가벼운 쿼리 빌더를 사용할 때보다 미세하게 속도가 느리고 메모리 사용량이 많다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="FastAPI" /><summary type="html"><![CDATA[core/minio_client.py]]></summary></entry><entry><title type="html">NanoClaw review note - 01 - NanoClaw Init</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/14/01-nano-claw-reverse-review.html" rel="alternate" type="text/html" title="NanoClaw review note - 01 - NanoClaw Init" /><published>2026-02-14T00:00:00+00:00</published><updated>2026-02-14T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/14/01-nano-claw-reverse-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/14/01-nano-claw-reverse-review.html"><![CDATA[<h2 id="0-why-this-project">0. Why this Project?</h2>
<ul>
  <li>본 프로젝트는 AI 응용 어플리케이션 구축에서 필요한 내용, agentic AI 구축을 위하여 필요한 것들에 대한 이해도를 높이고, 현재 진행중인 Nexus 프로젝트 이후 AI 기반의 서비스 구축 능력을 갖추기 위한 첫 도전이다.</li>
  <li>당장 무언가를 만들기보단, 잘 만들어진 예시를 기반으로 RAG 이상의 기능 구현을 어떤 식으로 접근하면 좋을지 사전 학습 겸 하여 진행하게 되었다.</li>
  <li><a href="https://github.com/Paul2021-R/nanoclaw-for-study">코드 레포지터리</a></li>
</ul>

<hr />

<h2 id="1-루트-디렉토리-전체-구조">1. 루트 디렉토리 전체 구조</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nanoclaw/
├── src/                   # 핵심 소스 코드
├── container/             # 컨테이너 빌드 &amp; 에이전트 런너
├── docs/                  # 아키텍처 문서
├── groups/                # 그룹별 격리 메모리
├── config-examples/       # 설정 예시 파일
├── launchd/               # macOS 서비스 데몬 설정
├── assets/                # 로고, 아이콘 등 정적 자산
├── .github/               # GitHub Actions &amp; PR 템플릿
├── package.json           # 프로젝트 의존성 &amp; 스크립트
├── tsconfig.json          # TypeScript 컴파일 설정
├── vitest.config.ts       # 테스트 프레임워크 설정
├── CLAUDE.md              # Claude AI에게 주는 프로젝트 맥락
├── README.md / README_zh.md  # 프로젝트 문서 (영어/중국어)
├── CONTRIBUTING.md        # 기여 가이드
└── LICENSE                # 라이선스 (MIT)
</code></pre></div></div>

<h3 id="src--핵심-애플리케이션-코드"><code class="language-plaintext highlighter-rouge">src/</code> — 핵심 애플리케이션 코드</h3>

<p>프로젝트의 심장부이다. 모든 비즈니스 로직이 여기에 모여 있다.</p>

<table>
  <thead>
    <tr>
      <th>파일</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index.ts</code></td>
      <td>**오케스트레이터(Orchestrator)** — 상태 관리, 메시지 루프, 에이전트 호출을 총괄하는 진입점이다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">config.ts</code></td>
      <td>트리거 패턴, 경로, 인터벌, 타임아웃 등 **전역 설정값**을 관리한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">router.ts</code></td>
      <td>메시지 포맷팅 및 **아웃바운드 라우팅**을 담당한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">container-runner.ts</code></td>
      <td>Agent 컨테이너를 **스폰(Spawn)하고 마운트를 설정**하는 핵심 모듈이다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ipc.ts</code></td>
      <td>호스트↔컨테이너 간 **IPC(프로세스 간 통신)** 감시 및 태스크 처리를 담당한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">db.ts</code></td>
      <td>**SQLite** 기반의 데이터 관리 (대화 기록, 스케줄 등)를 수행한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">task-scheduler.ts</code></td>
      <td>**cron/interval/once** 기반의 예약 작업 관리를 담당한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">group-queue.ts</code></td>
      <td>그룹별 메시지 **큐(Queue)** 관리를 처리한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mount-security.ts</code></td>
      <td>컨테이너에 마운트할 경로의 **보안 검증** (allowlist/blocklist)을 수행한다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">types.ts</code></td>
      <td>프로젝트 전체에서 사용되는 **타입 정의** (Channel, Message, Task 등)를 담고 있다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">logger.ts</code></td>
      <td><code class="language-plaintext highlighter-rouge">pino</code> 기반의 **구조화된 로깅** 설정이다</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">whatsapp-auth.ts</code></td>
      <td>WhatsApp **QR 인증** 전용 스크립트이다</td>
    </tr>
  </tbody>
</table>

<h4 id="srcchannels--채널-추상화-계층"><code class="language-plaintext highlighter-rouge">src/channels/</code> — 채널 추상화 계층</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>channels/
├── whatsapp.ts        # WhatsApp 연결, 인증, 송/수신 구현체
└── whatsapp.test.ts   # WhatsApp 채널 테스트
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Channel</code> 인터페이스를 통해 메시징 플랫폼을 추상화한 구조이다. 현재는 WhatsApp만 구현되어 있지만, 이 패턴 덕분에 Telegram 등 다른 채널도 쉽게 추가할 수 있는 확장 가능한 설계이다.</p>

<h3 id="container--에이전트-컨테이너-환경"><code class="language-plaintext highlighter-rouge">container/</code> — 에이전트 컨테이너 환경</h3>

<p>Claude Agent가 실제로 <strong>실행되는 격리된 환경</strong>을 구성하는 폴더이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>container/
├── Dockerfile         # 에이전트 실행 환경 이미지 빌드 정의
├── build.sh           # 컨테이너 빌드 스크립트
├── agent-runner/      # 컨테이너 내부에서 실행되는 별도 Node.js 패키지
│   ├── package.json   # agent-runner 전용 의존성
│   ├── tsconfig.json
│   └── src/           # IPC MCP stdio 등 내부 통신 로직
└── skills/            # 에이전트에게 주입되는 스킬
    └── agent-browser/ # 브라우저 자동화 도구
</code></pre></div></div>

<p>핵심 포인트는 <strong>호스트 프로세스(src/)와 에이전트 런타임(container/agent-runner/)이 완전히 분리</strong>되어 있다는 것이다. 에이전트는 Apple Container(Linux VM) 안에서 돌아가기 때문에, 설령 AI가 위험한 명령을 실행하더라도 호스트 시스템에는 영향을 줄 수 없는 <strong>샌드박스(Sandbox)</strong> 구조이다. (AI의 자유와 시스템의 안전을 동시에 챙기는 아주 영리한 설계이다!)</p>

<h3 id="groups--그룹별-격리-메모리"><code class="language-plaintext highlighter-rouge">groups/</code> — 그룹별 격리 메모리</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>groups/
├── global/
│   └── CLAUDE.md      # 모든 그룹에 공통 적용되는 Claude 메모리
└── main/
    └── CLAUDE.md      # main 그룹 전용 Claude 메모리
</code></pre></div></div>

<p>각 WhatsApp 그룹(또는 개인 대화)은 고유한 폴더를 가지며, 해당 폴더의 <code class="language-plaintext highlighter-rouge">CLAUDE.md</code>가 <strong>그 그룹만의 개인화된 AI 메모리</strong> 역할을 한다. <code class="language-plaintext highlighter-rouge">global/</code>은 모든 그룹에 공통으로 적용되는 설정이고, <code class="language-plaintext highlighter-rouge">main/</code>은 메인(개인) 대화 전용이다. 그룹마다 파일시스템과 메모리가 <strong>완전히 격리</strong>되는 구조인 것이다.</p>

<h3 id="docs--프로젝트-문서"><code class="language-plaintext highlighter-rouge">docs/</code> — 프로젝트 문서</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docs/
├── SPEC.md                         # 전체 프로젝트 사양서 (가장 중요!)
├── REQUIREMENTS.md                 # 아키텍처 의사결정 기록
├── SDK_DEEP_DIVE.md                # Claude Agent SDK 심층 분석
├── SECURITY.md                     # 보안 모델 문서
├── DEBUG_CHECKLIST.md              # 디버깅 체크리스트
└── APPLE-CONTAINER-NETWORKING.md   # Apple Container 네트워킹 가이드
</code></pre></div></div>

<p>단순한 README를 넘어서 <strong>아키텍처 결정 근거(ADR)</strong>, <strong>보안 모델</strong>, <strong>SDK 분석</strong> 등이 체계적으로 정리되어 있다. 특히 <code class="language-plaintext highlighter-rouge">SPEC.md</code>와 <code class="language-plaintext highlighter-rouge">REQUIREMENTS.md</code>는 프로젝트를 이해하는 데 가장 중요한 문서이다.</p>

<h3 id="config-examples--설정-예시"><code class="language-plaintext highlighter-rouge">config-examples/</code> — 설정 예시</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>config-examples/
└── mount-allowlist.json   # 컨테이너 마운트 허용 경로 설정 예시
</code></pre></div></div>

<p>컨테이너에 어떤 호스트 디렉토리를 마운트할 수 있는지 제어하는 <strong>보안 설정의 예시 파일</strong>이다. 실제 설정은 <code class="language-plaintext highlighter-rouge">~/.config/nanoclaw/mount-allowlist.json</code>에 위치하며, 의도적으로 프로젝트 루트 <strong>바깥</strong>에 두어 에이전트가 임의로 수정할 수 없도록 설계했다. (파일 하나에 보안 철학이 담겨 있는 셈이다!)</p>

<h3 id="launchd--macos-서비스-데몬"><code class="language-plaintext highlighter-rouge">launchd/</code> — macOS 서비스 데몬</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>launchd/
└── com.nanoclaw.plist     # macOS LaunchAgent 설정
</code></pre></div></div>

<p>nanoclaw을 macOS의 <strong>백그라운드 서비스</strong>로 등록하기 위한 plist 파일이다. <code class="language-plaintext highlighter-rouge">launchctl load</code>/<code class="language-plaintext highlighter-rouge">unload</code> 명령으로 시스템 시작 시 자동 실행되도록 구성할 수 있다.</p>

<h3 id="루트-설정-파일들">루트 설정 파일들</h3>

<table>
  <thead>
    <tr>
      <th>파일</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">package.json</code></td>
      <td>프로젝트 의존성, 스크립트, 엔진 버전 정의</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tsconfig.json</code></td>
      <td>TypeScript 컴파일러 설정</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">vitest.config.ts</code></td>
      <td>Vitest 테스트 프레임워크 설정</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.prettierrc</code></td>
      <td>코드 포맷팅 규칙</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.gitignore</code></td>
      <td>Git 추적 제외 파일 목록</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.mcp.json</code></td>
      <td>MCP(Model Context Protocol) 설정</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CLAUDE.md</code></td>
      <td>Claude AI에게 프로젝트 구조와 명령을 알려주는 컨텍스트 파일</td>
    </tr>
  </tbody>
</table>

<hr />
<p>nanoclaw은 <strong>“메시징 인터페이스 → 메시지 라우팅 → 격리된 컨테이너에서 AI 실행 → 결과 반환”</strong> 이라는 깔끔한 파이프라인 구조를 가진 프로젝트이다. 호스트와 에이전트의 완전한 분리, 그룹별 메모리 격리, 마운트 보안까지 — AI 백엔드 아키텍처의 정석을 잘 보여주고 있다.</p>

<hr />

<h2 id="향후-학습-방향성">향후 학습 방향성</h2>

<h3 id="-1단계-전체-흐름-파악-big-picture">🥇 1단계: 전체 흐름 파악 (Big Picture)</h3>

<table>
  <thead>
    <tr>
      <th>순서</th>
      <th>파일</th>
      <th>이유</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>①</td>
      <td>SPEC.md</td>
      <td>코드를 보기 전에 전체 사양서를 먼저 읽으면, 각 모듈이 **왜** 그렇게 설계됐는지 맥락확인하기</td>
    </tr>
    <tr>
      <td>②</td>
      <td>types.ts</td>
      <td>Channel, NewMessage, ScheduledTask 등 핵심 타입들이 정의되어 있어서 전체 데이터 흐름의 파악하기</td>
    </tr>
    <tr>
      <td>③</td>
      <td>config.ts</td>
      <td>트리거 패턴, 타임아웃, 동시 컨테이너 수 등 시스템 동작을 결정하는 **설정값**들 역으로 분석하기</td>
    </tr>
  </tbody>
</table>

<h3 id="-2단계-핵심-파이프라인-메시지--ai-실행--응답">🥈 2단계: 핵심 파이프라인 (메시지 → AI 실행 → 응답)</h3>

<table>
  <thead>
    <tr>
      <th>순서</th>
      <th>파일</th>
      <th>이유</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>④</td>
      <td>index.ts</td>
      <td>**오케스트레이터** — 메시지가 들어오면 어떻게 처리되는지, AI 에이전트를 언제 호출하는지 전체 흐름의 중심</td>
    </tr>
    <tr>
      <td>⑤</td>
      <td>container-runner.ts</td>
      <td>**가장 중요한 파일** Claude Agent를 Apple Container 안에서 어떻게 스폰하고, 마운트를 설정하고, 결과를 받아오는지가 다 여기 있어요. AI 실행 아키텍처의 핵심. 파악해둘 것</td>
    </tr>
    <tr>
      <td>⑥</td>
      <td>ipc.ts</td>
      <td>호스트↔컨테이너 간의 **IPC 통신 메커니즘** — AI 에이전트가 결과를 어떻게 전달하는지 파악하기</td>
    </tr>
  </tbody>
</table>

<h3 id="-3단계-보조-시스템">🥉 3단계: 보조 시스템</h3>

<table>
  <thead>
    <tr>
      <th>순서</th>
      <th>파일</th>
      <th>이유</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⑦</td>
      <td>mount-security.ts</td>
      <td>AI에게 파일 접근을 주되, **어디까지 허용할 것인가**의 보안 로직. 실무에서 AI 서비스를 운영할 때 반드시 고려해야 할 부분.</td>
    </tr>
    <tr>
      <td>⑧</td>
      <td>task-scheduler.ts</td>
      <td>AI에게 **예약 작업**을 시킬 수 있는 스케줄러. cron/interval/once 패턴이 깔끔하게 구현되어 있으므로 알아둘 것</td>
    </tr>
    <tr>
      <td>⑨</td>
      <td>db.ts</td>
      <td>대화 기록, 태스크 로그 등을 SQLite로 어떻게 관리하는지 볼 수 있음</td>
    </tr>
  </tbody>
</table>

<h3 id="-4단계-컨테이너-내부-에이전트-시점">🔍 4단계: 컨테이너 내부 (에이전트 시점)</h3>

<table>
  <thead>
    <tr>
      <th>순서</th>
      <th>파일</th>
      <th>이유</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⑩</td>
      <td>container/agent-runner/</td>
      <td>컨테이너 **안에서** 돌아가는 에이전트의 런타임 코드. 호스트 코드와 어떻게 IPC로 대화하는지를 에이전트 시점에서 확인할 것</td>
    </tr>
    <tr>
      <td>⑪</td>
      <td>SDK_DEEP_DIVE.md</td>
      <td>Claude Agent SDK를 깊게 파헤친 문서. SDK 활용법을 체계적으로 이해할 수 있음.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="AI" /><category term="Study" /><category term="Review" /><category term="NanoClaw" /><summary type="html"><![CDATA[0. Why this Project? 본 프로젝트는 AI 응용 어플리케이션 구축에서 필요한 내용, agentic AI 구축을 위하여 필요한 것들에 대한 이해도를 높이고, 현재 진행중인 Nexus 프로젝트 이후 AI 기반의 서비스 구축 능력을 갖추기 위한 첫 도전이다. 당장 무언가를 만들기보단, 잘 만들어진 예시를 기반으로 RAG 이상의 기능 구현을 어떤 식으로 접근하면 좋을지 사전 학습 겸 하여 진행하게 되었다. 코드 레포지터리]]></summary></entry><entry><title type="html">Project Nexus - Docker를 넘어, 진짜 인프라로</title><link href="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2026/02/10/00-init-project-nexus.html" rel="alternate" type="text/html" title="Project Nexus - Docker를 넘어, 진짜 인프라로" /><published>2026-02-10T00:00:00+00:00</published><updated>2026-02-10T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2026/02/10/00-init-project-nexus</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/2026/02/10/00-init-project-nexus.html"><![CDATA[<h2 id="project-nexus-docker를-넘어-진짜-인프라로">Project Nexus: Docker를 넘어, 진짜 인프라로</h2>

<blockquote>
  <p>불완전 연소된 ProtoStar를 살리고 다음을 준비하기 위한 플레이그라운드의 필요성, 3년차 개발자 수준의 인프라 역량을 만드는 여정</p>
</blockquote>

<hr />

<h3 id="출발점-불완전연소된-protostar-그리고">출발점: 불완전연소된 ProtoStar 그리고…</h3>

<p>1년차 메인 서버 개발자로 역할을 수행했다. 그리고 이젠 3년차 개발자의 역량을 갖추어야 다음 도전이 가능하리라 생각하고 있었다. <strong>그런데 AI는 여기서 한 발 더 나아가, 개발자에게 요구되는 역량을 크게 변화시켰다.</strong></p>

<p>그 점을 고려하지 않는다면 생존에서 불가피할 것이라는 생각을 하였고, 결과적으로 AI 와 DevOps 의 역량을 갖추고, 백엔드 개발자로서 제대로된 인프라를 구축하는 역량을, <strong>소프트웨어 아키텍처이자, 오케스트레이터가 되어야 한다고 판단했다.</strong></p>

<p>그리하여 토스 러너스 하이 2기와 함께 시작한 Protostar 프로젝트는 나름 성공적이었다. Next.js 기반의 프론트엔드-챗봇을 구현하고, 백엔드는 Nest.js, FastAPI 를 이용하며 고가용성 체계를 구축하는 과정은 확실히 단순한 백엔드 설계를 넘어서는 여러 도전 요소들을 갖고 있고, 그 결과가 현재 블로그 상에 올라가 있는 챗봇이다.</p>

<p>자못 훌륭하며, 개인적으로 1달이란 시간에 이걸 했다는 사실은 자부심을 가지기에 충분하지 않을까? AI도 DevOps 도 백엔드 설계 역량도 보여줄 수 있는 것들이 있었으니,  자랑스럽게 자랑을 인터뷰 상에서 할 수 있다면 좋겠다 생각한다.</p>

<p><strong>하지만 한편으로 아쉬움은 있다.</strong></p>

<p>기획의 한계, 고려사항들이 있단 점에서 온전한 서비스로의 확장은 포기했다-는 점은 제외하더라도,
기술적 아쉬움, 특히 DevOps 경험에 대한 아쉬움이 크게 남았다.</p>

<p>k8s 방식을 정복할 시간이 부족해 포기했다. 또한 무엇보다 Docker 로 구현 시 안되는 건 없지만, 그렇다고 <strong>‘온전하게’ 유기적으로 동작하지 않는다고 느낀 부분들이 있었다.</strong> Docker Swarm, ReplicaSet 등을 기반으로 고가용성을 구현할 순 있다. 하지만 한계는 명백했다. <strong>k8s 를 선택했을 때 얻을 수 있는 이점에 대해 다시 한 번 떠오르게 되었다.</strong></p>

<p>뿐만 아니라 온프레미스 서버에 약 100여만원을 투자하여 나만의 홈랩을 꾸미게 되면서 깨달은게 있다.</p>

<p>실무 경험이 중요한 이유는, 실무 수준에서의 책임감, 안정성, 고려할 사항 등, 단순히 개인의 자그마한 데모 수준에서는 알 수 없는 ‘실무의 깊이’와 ‘실무의 너비’가 존재한다. 그런 점에서 인프라를 개인의 신분으로 지원 없이 AWS, GCP 등에 올린다면? 유료 사용에서 한계가 발생하고, 할 수 있는 수준의 제약이 발생했을 것이다.</p>

<p>그런데 홈랩으로 꾸미게 되면서, 그러한 한계가 상당 부분 사라졌다. 결국 ‘규모의 경제’는 곧 경험인 것이다.</p>

<p>덕분에 과감히 인프라 선택이 가능하고, 효과적으로 기술을 적용할 수 있었다. 그렇다면 할 일은 무엇인가? 그건 결국 ‘앞으로 가는 것’ 아니겠는가? 결국 인프라는 있으니 더 명료하게 IaC(Infrastructure as Code)를 구현하고, 내가 경험할 수 있는 최선의 인프라 위에서 또 다른 도전을 해야 그게 진짜가 되지 않을까?</p>

<p><strong>그런 점에서 나만의 플레이그라운드, 기반이 필요하다고 판단했다. 그것이 Nexus(기반), 완전한 k8s 기반의 GitOps 서버 클러스터 구축 프로젝트이다.</strong></p>

<hr />

<h3 id="깨달음-지향할-푯대는-어디로-향하는가">깨달음: 지향할 푯대는 어디로 향하는가?</h3>

<h4 id="docker만-쓰던-시절의-한계">Docker만 쓰던 시절의 한계</h4>

<p>Docker는 훌륭한 도구다. 메인 서버로 1년 간 살면서, Docker 로 옮긴 레거시 서버들은 덕분에 엄청난 포텐셜을 얻었고, 최적화, 관리 편의성을 얻었기에 지금의 내 경험, 이력을 만들 수 있었다고 해도 과언이 아니다. 그런 점에서 서비스를 바로 시작하기에 Docker 만한 컨테이닝은 없다고 생각한다.</p>

<p>하지만 막상 ‘고가용성’이란 목표를 지향했을 때 Docker 는 굉장히 아쉬움을 불러일으켰다.</p>

<ol>
  <li><strong>데몬에 종속된 구조</strong>: dockerd가 죽으면 모든 컨테이너가 영향을 받는다. 단일 장애점(SPOF)이 존재한다는 점은 고가용성을 생각할 때, 문제였다. 하나의 컨테이너가 과도한 사용량을 차지하게 되었을 때, 전체 시스템은 문제가 발생한다. AWS 에서 인스턴스를 여러개 분산하는 대안도 있다. 그러나 이는 또 다른 복잡도의 서막이며 대안이 되진 못했다. 어디까지나 보완책이었다.</li>
  <li><strong>보안 취약성</strong>: 기본적으로 root 권한이 필요하다는게 생각보다 큰 부담이었다. rootless 모드는 있지만 2차 시민 취급이었다. 또한 이러한 보안 이슈로 공식 이미지들 마다 다르게 권한이 설정되는 등으로 문제가 되었다.</li>
  <li><strong>k8s와의 괴리감</strong>: Docker Compose로 개발하고, k8s YAML로 배포한다? 로컬과 프로덕션 환경이 달라지고 이는 완벽하지 않은 환경 통제였다. ‘완벽함’이 필요한 백엔드 환경 구축에서 한 점의 오차는 ‘아마추어’란 사실을 증명하는 꼴이라고 생각이 들었다. 플랫폼이 다르면 증상도 달라지고, 특히 이전 후기에서도 다뤘듯, 각 개별 설계가 의존성이 없어도, 관계의 통합은 의존성을 만들고 새로운 증상을 유도한다.</li>
  <li><strong>스크립트 단위의 파편화된 관리 구조</strong>: Dockerfile, docker-compose.yml, Jenkinsfile, 쉘 스크립트 등, CI/CD 파이프라이닝을 구축해보고 얻은 결론은 명확했다. 각각 분리되어 각 역할을 보기엔 명료해보이고 유기적이게 보인다. 하지만 반대로 그렇기에 한 곳을 수정하면 예상하지 못한 곳의 문제가 발생할 수 있고, 이는 결국 ‘단독’으로 볼 때만 ‘희극’이며 ‘전체’를 볼 땐 ‘비극’이었다.</li>
  <li><strong>상태관리의 어려움</strong>: PostgreSQL 이나, Redis, 모니터링 등의 Stateful 서비스에 대한 백업/ 복구 전략에서 수동으로 해야 하는 영역이 존재하며, 고가용성 구성이 상당히 복잡했다.</li>
</ol>

<h4 id="엔터프라이즈-환경에서-요구하는-역량">엔터프라이즈 환경에서 요구하는 역량</h4>

<p>AI를 기반으로 약 100개 정도의 주요 기업들의 백엔드 엔지니어 직군의 공고문을 딥리서치 해보았다. 내가 3년차 수준을 인정 받길 원한다면 단순히 “Docker 써봤어요”로는 부족했다. 이를 압축해서 정리하면 다음과 같았다.</p>

<ul>
  <li><strong>컨테이너 오케스트레이션</strong>: Kubernetes를 실무에서 사용할 수 있고, 이를 기반으로 서비스의 생명주기 제어가 가능한가?</li>
  <li><strong>보안 의식</strong>: 특히 최근의 중요사항이자, 국내에서도 중요해지고 있는 영역으로 서버들 사이의 격리가 명료한가? rootless 컨테이너, 권한 분리, 이미지 스캐닝의 경험이 있는가?</li>
  <li><strong>자동화</strong>: CI/CD 파이프라인의 현대화, GitOps, 롤링 업데이트 등을 통해 서비스의 무결성이 확보되는가? 개발 생산성을 확보 하는가?</li>
  <li><strong>관찰성</strong>: 메트릭, 로그, 추적 시스템 구축하여 운영 문제를 소프트웨어 엔지니어링 방식으로 해결할 수 있는가? SRE(Site Reliability Engineering) 방식으로 대규모 시스템의 안정성, 확장성, 가용성을 극대화 가능한가?</li>
</ul>

<p>결국 안정성, 효율성, 운영 최적화된 역량이 필요했다. 이러한 영역에 대한 나만의 답이 필요했고, 결국 내가 생존하기 위하여 필요한 ‘전문성’이란 무엇인가를 명확하게 정리할 수 있었다.</p>

<hr />

<h3 id="전략-초-현실주의">전략: ‘초’ 현실주의</h3>

<h4 id="온프레미스-서버를-프로덕션-클러스터로">온프레미스 서버를 프로덕션 클러스터로</h4>

<p>보다 현실적이게 짜야 한다고 생각했다. 연습용의 minikube 정도가 아니라 프로덕션처럼 운영을 위한 구성과 실천이 되어야 한다고 판단했다. 오버 엔지니어링, 허세를 하고 싶단 말은 아니다. 현실적으로 과도하지 않으면서도 진짜 엔터프라이즈급을 지향해본다는 그 벨런스를 중요시했다. 향후 더 많은 기술의 플레이그라운드 만들기를 지향한다.</p>

<p>Protostar가 구동 중인 서버 어플리케이션들은 현재 두 대의 온프레미스 서버에서 동작하고 있다. 메인 서버는 서비스를, 서브 서버는 모니터링 / 빌드 및 배포 파이프라인을 담당하고 있다.</p>

<p>여기서 단순히 k8s 를 위한 플랫폼을 설치, k8s 용 스크립트 작성을 해도 되지만… 보다 현실적이고, 무엇보다 IaC 를 극대화하기 위해선, 온프레미스 서버들이 마치 하나처럼 동작하게 만드는 것이 반드시 필요하다고 생각했다.</p>

<p><strong>결론적으로 계획은 이렇다:</strong></p>
<ul>
  <li>개발용으로는 단일 개발 PC에서 작업하여 Podman 기반으로 Docker-free 를 달성.</li>
  <li>Production 은 두 개의 온프레미스 서버에 k3s 기반 Kubernetes 클러스터링을 한다. namespace 를 기반으로 역할을 설정한다. 즉, 한 대 같은 두 대를 만들고, 각 영역은 ‘목적’을 포함시킨다.</li>
  <li>현재 가동 중인 ProtoStar 서비스를 이 환경으로 완전히 마이그레이션한다.(서비스 + 모니터링 스택)</li>
  <li>위의 작업들의 종결 이후, 새로운 서비스들 역시 여기서 동작하며, 테스팅 되며, 배포 된다.</li>
</ul>

<h4 id="로컬에서-프로덕션까지-일관된-환경">로컬에서 프로덕션까지 일관된 환경</h4>

<p>가장 중요한 원칙: <strong>로컬 개발 환경과 프로덕션 환경을 최대한 비슷하게 만들어내는 것이다.</strong></p>

<p><strong>기존 방식:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>로컬 / 프로덕션: Docker Compose 기반, Jenkins 파이프라이닝 때문에 환경변수를 비롯 차이점 있음
→ 환경이 달라서 "내 컴퓨터에선 되는데요?" 발생, 결과적으로 이미지 차원의 변경 발생 시 2회 적용 되어야 함
</code></pre></div></div>

<p><strong>새로운 방식:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>로컬: Podman + k8s YAML
프로덕션: k3s + k8s YAML
→ 같은 YAML 파일을 로컬과 클러스터에서 모두 사용
</code></pre></div></div>

<p>Podman의 <code class="language-plaintext highlighter-rouge">podman play kube</code> 명령어를 쓰면 k8s YAML을 로컬에서도 그대로 실행할 수 있다. 이게 핵심이다.</p>

<h4 id="계획">계획</h4>

<p>무작정 달려들기보단, AI 를 기반으로 구현할 항목들을 정리했고, 목표를 지정하였다. 이직 일정과 겹쳐 딜레이가 발생할 순 있으나 최대한 현실적으로 설정해보았다.</p>

<p><strong>Phase 1 (1주): 도구 전환</strong></p>

<ul>
  <li>Docker → Podman 로컬 개발 환경 전환</li>
  <li>기존 Dockerfile이 Podman에서도 돌아가는지 검증</li>
  <li>rootless 환경의 포트 바인딩 제약 해결 (80 → 8080)</li>
</ul>

<p><strong>Phase 2 (0.5주): k8s 기초</strong></p>

<ul>
  <li>k3s 클러스터 구축</li>
  <li>Pod, Deployment, Service 개념 실습</li>
  <li>kubectl 명령어 익히기</li>
</ul>

<p><strong>Phase 3 (0.5주): Dev 환경에 Stateless 서비스 먼저</strong></p>

<ul>
  <li>React, NestJS 같은 무상태 서비스부터 배포</li>
  <li>실패해도 재배포하면 끝이라 학습 비용이 낮음</li>
  <li>서비스 간 통신 (k8s 내부 DNS) 이해</li>
</ul>

<p><strong>Phase 4 (0.5주): Dev 환경에 Stateful 서비스 마이그레이션 해보기</strong></p>

<ul>
  <li>PostgreSQL, Redis 같은 상태 저장 서비스</li>
  <li>StatefulSet, PersistentVolume 개념</li>
  <li>데이터 백업/복구 전략 수립</li>
</ul>

<p><strong>Phase 5 (1주): 자동화와 관찰성</strong></p>

<ul>
  <li>ArgoCD 기반 GitOps CI/CD 파이프라인 구축</li>
  <li>Prometheus + Grafana 모니터링 스택</li>
</ul>

<p><strong>Phase 6 (1주): Production 마이그레이션</strong></p>

<ul>
  <li>지금까지의 실습을 모두 클러스터링 된 온프레미스 서버로 일체 이전한다.</li>
</ul>

<hr />

<h3 id="도구-왜-이-스택인가">도구: 왜 이 스택인가</h3>

<h4 id="podman-보안과-확장성">Podman: 보안과 확장성</h4>

<p><strong>선택 이유 세 가지:</strong></p>

<ol>
  <li><strong>Rootless가 기본</strong>: 일반 사용자 권한으로 컨테이너 실행. 보안 침해 시 피해 범위가 제한된다.</li>
  <li><strong>Daemonless 아키텍처</strong>: 중앙 데몬 없이 각 컨테이너가 독립적으로 실행. dockerd가 죽어서 전체가 멈추는 일이 없다.</li>
  <li><strong>Pod 네이티브 지원</strong>: k8s Pod 개념을 로컬에서도 그대로 사용 가능. 같은 Pod 안의 컨테이너끼리 localhost로 통신한다.</li>
</ol>

<p><strong>리스크:</strong></p>
<ul>
  <li>커뮤니티가 Docker보다 작아서 문제 발생 시 레퍼런스가 적을 수 있음</li>
  <li>일부 Docker 전용 도구와 호환성 이슈 가능 (예: Docker Desktop 기능들)</li>
</ul>

<h4 id="kubernetes-k3s-업계-표준">Kubernetes (k3s): 업계 표준</h4>

<p><strong>선택 이유 세 가지:</strong></p>

<ol>
  <li><strong>업계 표준</strong>: 대부분의 엔터프라이즈 환경이 k8s를 사용. 실무 경험으로 직결된다.</li>
  <li><strong>선언적 구성</strong>: YAML로 원하는 상태를 선언하면 k8s가 알아서 그 상태를 유지한다.</li>
  <li><strong>확장성</strong>: 단일 노드에서 시작해도 나중에 멀티 클러스터로 확장이 자연스럽다.</li>
</ol>

<p><strong>k3s를 선택한 이유:</strong></p>
<ul>
  <li>표준 k8s보다 가볍고 빠름 (메모리 사용량 절반)</li>
  <li>온프레미스 환경에 최적화</li>
  <li>Traefik Ingress가 기본 내장</li>
</ul>

<p><strong>리스크:</strong></p>
<ul>
  <li>학습 곡선이 가파름. Pod, Deployment, Service, Ingress 등 개념이 많음</li>
  <li>초기 설정이 복잡할 수 있음</li>
</ul>

<h4 id="gitops-argocd-자동화와-추적성">GitOps (ArgoCD): 자동화와 추적성</h4>

<p><strong>선택 이유 세 가지:</strong></p>

<ol>
  <li><strong>Git이 진실의 원천</strong>: 모든 배포 상태가 Git 저장소에 기록됨. 언제든 이전 상태로 롤백 가능.</li>
  <li><strong>자동 동기화</strong>: Git에 푸시하면 자동으로 클러스터에 반영. 수동 배포 작업 제거.</li>
  <li><strong>가시성</strong>: 무엇이 언제 누구에 의해 배포되었는지 명확하게 추적 가능.</li>
</ol>

<p><strong>리스크:</strong></p>
<ul>
  <li>초기 설정이 복잡할 수 있음</li>
  <li>Git과 클러스터 상태가 어긋날 경우 디버깅이 어려울 수 있음</li>
</ul>

<hr />

<h3 id="마무리-왜-이-여정이-중요한가">마무리: 왜 이 여정이 중요한가</h3>

<p>이 프로젝트는 단순히 기술 스택을 바꾸는 것이 아니다. <strong>“할 줄 안다”에서 “제대로 한다”로의 전환을 생각하고 있다.</strong></p>

<p>Docker Compose로 띄우는 것과 k8s 클러스터를 운영하는 것은 완전히 다른 차원이다. 전자는 개발자의 편의를 위한 도구이고, 후자는 프로덕션 환경을 위한 플랫폼이다.</p>

<p>ProtoStar는 더 이상 불완전연소된 프로젝트가 아니라, 이제 <strong>내가 엔터프라이즈급 인프라를 구축할 수 있다는 것을 증명하는 살아있는 증거</strong>가 되도록 만들고 싶다. 또한 AI가 개인이 할 수 있는 영역을 극대화 시켜줄 것이니 Nexus 는 그 토대가 될 것이다. 내가 만들 다양한 어플리케이션들의 토대가 되어줄 것이다. 십년의 대장정의 모험이 있다고 하면, 그 기반 중에 기반이 되리라 생각한다.</p>

<p>경험이 현실이 되고, 현실이 직무가 된다. 단순히 개발자라고 불리고 싶진 않다. ‘전문가’가 되어 회사의 시스템들의 운용을 정말 ‘현실적으로’ 해내길 원한다. 그 초석을 만들고 싶다.</p>]]></content><author><name>Paul2021-R</name></author><category term="프로젝트" /><category term="Backend" /><category term="개발" /><category term="Nexus" /><category term="K8s" /><summary type="html"><![CDATA[Project Nexus: Docker를 넘어, 진짜 인프라로]]></summary></entry><entry><title type="html">Protostar review note - 00 - infrastructure</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/10/01-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 00 - infrastructure" /><published>2026-02-10T00:00:00+00:00</published><updated>2026-02-10T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/10/01-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/10/01-protostar-review.html"><![CDATA[<h2 id="핵심-특징-5가지">핵심 특징 5가지</h2>
<ol>
  <li>물리적 / 논리적 망 분리 : 서비스 존과 매니징 존을 분리하였고, 이를 통한 운영 안정성을 확보함.</li>
  <li>트래픽 제어를 위한 Nginx 레이어에서의 Traffic Dam :
    <ul>
      <li>토큰 버킷 알고리즘 기반의 트래픽 제어
        <ul>
          <li>Heavy Zone, Light Zone 으로 구분하여서 매크로성을 엄격히 막아야 하는 위치(Backend), 정적 리소스 로딩을 위한 일반 존(Frontend)로 구분하여 로딩속성과 백엔드 서비스 보호를 양립함.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>투명한 IP 보존(L4, L7 Proxy Protocol)
    <ul>
      <li>두대의 서버, 한대의 공유기의 네트워크 환경에서 클라이언트의 원본 IP 를 추적하기 위함, 동시에 각 서버의 HTTPS 접속을 구현함으로서 서비스 서버와 메인터넌스 서버에 접속하는 루트를 분리. 이를 통한 서비스 서버의 문제가 발생하더라도, 이를 모니터링하는 서버의 접속은 문제 없도록 만들어냄</li>
    </ul>
  </li>
  <li>중앙집중형 관제 시스템
    <ul>
      <li>Prometheus 의 Pull 방식과 함께 Promtail을 통해 Loki 기반의 서버 어플리케이션들의 로그를 수집하도록 했음</li>
      <li>통합 대시보드를 통해 서버들의 상태, 관리의 중앙 집중구조를 구현함.</li>
    </ul>
  </li>
  <li>AI 서비스를 위한 최적화 데이터베이스 구현
    <ul>
      <li>pgvector 확장을 위하여 init.spl에서 확장기능을 활성화 시켜 벡터 DB 기능을 사용하였다. 별도의 벡터 DB 가 아닌, RDBMS 인프라 내에서 임베딩 벡터를 저장, 검색함으로써 관리 복잡도를 줄여줌</li>
    </ul>
  </li>
</ol>

<h2 id="구체적인-구성요소-해석">구체적인 구성요소 해석</h2>
<h3 id="docker">Docker</h3>
<h4 id="include">include</h4>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># protostar-server-configs/docker-compose.yml</span>
<span class="na">include</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">./main-server/docker-compose.yml</span>
    <span class="na">env_file</span><span class="pi">:</span> <span class="s">./main-server/.env</span>
  <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">./sub-server/docker-compose.yml</span>
    <span class="na">env_file</span><span class="pi">:</span> <span class="s">./sub-server/.env</span>
</code></pre></div></div>

<pre><code class="language-plain">COMPOSE_PROFILES="main"
</code></pre>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># protostar-server-configs/main-server/docker-compose.yml</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx-main</span><span class="pi">:</span>
    <span class="na">profiles</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">main"</span><span class="pi">]</span> 
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">${DOMAIN:-main}-nginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:alpine</span>
    <span class="na">ulimits</span><span class="pi">:</span>
      <span class="na">nofile</span><span class="pi">:</span>
        <span class="na">soft</span><span class="pi">:</span> <span class="m">65535</span>
        <span class="na">hard</span><span class="pi">:</span> <span class="m">65535</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">443:443"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/nginx_target.conf:/etc/nginx/nginx.conf</span>
        <span class="s">.</span>
        <span class="s">.</span>
        <span class="s">.</span>
        <span class="s">(생략)</span>
</code></pre></div></div>
<ul>
  <li>기존의 모놀리식 설정 파일을 팀별/ 기능별  쪼개서 관리하기 위한 목적의 명령어</li>
  <li>기존에는 <code class="language-plaintext highlighter-rouge">-f docker-compose.yml</code>  이렇게 별도로 파일을 지정하여 설정을 실행함. 하지만 <code class="language-plaintext highlighter-rouge">include</code>는 파일 내부에 선언적으로 설정함. <code class="language-plaintext highlighter-rouge">.env</code> 등의 환경 설정을 통해, 키워드를 설정하고, 이를 통해  세부 docker-compose.yml 파일에서 <code class="language-plaintext highlighter-rouge">profiles</code> 키워드를 찾아서 그 내용을 실행하게 만듬.</li>
  <li>왜 <code class="language-plaintext highlighter-rouge">include</code> 는 강력한가?
    <ol>
      <li>상대 경로 독립성 보장 :
        <ul>
          <li>기존 <code class="language-plaintext highlighter-rouge">-f</code> 옵션 방식은 루트 디렉토리 기준 상대경로가 꼬일 수 있음.</li>
          <li>해당 명령을 통해선 프로필로 직접 해석하기 때문에, 루트 디렉토리 기준 꼬이지 않고 동작하며, <code class="language-plaintext highlighter-rouge">main-server</code> 라는 부분만 옯겨도 수정 없이 바로 사용이 가능하다.</li>
        </ul>
      </li>
      <li>환경 변수 스코프 분리 :
        <ul>
          <li>만약 모놀리식에 하나의 <code class="language-plaintext highlighter-rouge">.env</code> 형태라고 치자, 물리적으로 나뉜 설정이 혼재되고 관리하기 어려워진다.</li>
          <li>이에비하면 <code class="language-plaintext highlighter-rouge">main-server</code>, <code class="language-plaintext highlighter-rouge">sub-server</code>는 각각 <code class="language-plaintext highlighter-rouge">.env</code> 파일을 지정할수 있고, 관리 면에서 물리적인 분리로, 변수 이름 충돌 등의 문제가 발생하지 않게 됨.</li>
        </ul>
      </li>
      <li>단일 진입점
        <ul>
          <li>물리적으로 설정이 완벽하게 분리되지만, 동시에 하나의 진입점에서 명령어를 친다는 점은 관리가 매우 편리함.</li>
          <li>개발자는 메인 <code class="language-plaintext highlighter-rouge">.env</code>의 키워드만 바꿔줌으로써 전체 아키텍쳐 안에서 필요한 환경만 한번에 불러올 수 있음.
            <h4 id="restart-정책---always-vs-unless-stopped">restart 정책  : <code class="language-plaintext highlighter-rouge">always</code> vs <code class="language-plaintext highlighter-rouge">unless-stopped</code></h4>
            <h5 id="1-restart-always-좀비-모드">1. <code class="language-plaintext highlighter-rouge">restart: always</code> (좀비 모드)</h5>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li><strong>동작:</strong> 컨테이너가 멈추면 무조건 다시 살려냄.</li>
  <li><strong>수동 종료 시:</strong> <code class="language-plaintext highlighter-rouge">docker stop</code>으로 멈춰도, 도커 데몬이 재시작되거나(예: 서버 재부팅) 하면 <strong>다시 살아난다.</strong></li>
  <li><strong>특징:</strong> 개발자가 “이제 그만 죽어 있어”라고 명령해도, 컴퓨터를 껐다 켜면 “짜잔” 하고 다시 살아난다. 무조건 켜져 있어야 하는 핵심 데몬에 적합하다.</li>
</ul>

<h5 id="2-restart-unless-stopped-매너-모드">2. <code class="language-plaintext highlighter-rouge">restart: unless-stopped</code> (매너 모드)</h5>

<ul>
  <li><strong>동작:</strong> <code class="language-plaintext highlighter-rouge">always</code>와 똑같이 컨테이너가 죽으면 살려내지만, <strong>“명시적으로 멈춘 상태”는 존중</strong>.</li>
  <li><strong>수동 종료 시:</strong> <code class="language-plaintext highlighter-rouge">docker stop</code>으로 멈춘 상태에서 서버를 재부팅하면, <strong>계속 멈춰 있다.</strong> (되살아나지 않음)</li>
  <li><strong>특징:</strong> “내가 껐으면 끈 거야”라는 의도를 기억한다. 유지보수를 위해 잠시 꺼둔 DB나 서비스를 재부팅 후에도 꺼진 채로 유지하고 싶을 때 유용</li>
</ul>

<p>결론적으로, 이러한 특성 때문에 온프레미스 환경에서 운영중이고 유지보수나 점검을 해야할 때 멋데로 다시 켜지거나 하여 충돌, 데이터 오염을 최소화 하고자, 개발자의 의도를 최우선으로 삼았기 때문에 모든 아키텍쳐는 <code class="language-plaintext highlighter-rouge">unless-stopped</code> 로 설정 되어 있음</p>

<h4 id="deployresourceslimits-vs-deployresourcsreservations">deploy.resources.limits vs deploy.resourcs.reservations</h4>

<ol>
  <li>Limits : 컨테이너의 사용 가능한 자원의 최대치를 제한을 건다. 특정 컨테이너가 과도한 리소스 점유를 방지하는 역할</li>
  <li>Resrvations : 컨테이너 구동에 필요한 최소한의 자원을 예약하거나, 자원 부족 시 우선순위를 결정하는 기준이 됨.
    <ol>
      <li>메모리의 경우, 평소엔 limits 까지 쓰이지만, reservations 설정이 있으면, host 의 메모리 부족 시 <code class="language-plaintext highlighter-rouge">reservations</code>의 값을 기반으로 컨테이너의 메모리 먼저 회수, 종료 함으로써 최소 사양으로 돌아가고 살아 있지만, 그 외의 리소스는 최대한 외부의 서비스가 쓸 수 있도록 제공해주는 역할을 함.</li>
    </ol>
  </li>
</ol>

<h4 id="logging-설정">logging 설정</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">.</span>
<span class="s">.</span>
<span class="s">.</span>
<span class="na">logging</span><span class="pi">:</span>
  <span class="na">driver</span><span class="pi">:</span> <span class="s2">"</span><span class="s">json-file"</span>
  <span class="na">options</span><span class="pi">:</span>
    <span class="na">max-size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">10m"</span>
    <span class="na">max-file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>
    <span class="s">.</span>
    <span class="s">.</span>
    <span class="s">.</span>
</code></pre></div></div>

<ul>
  <li>Docker 컨테이너의 로그가 무한정 커질 수 있으니, 로그의 로테이션을 설정함으로써 로깅을 제한을 걸기 위해 쓸 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">driver: "json-file"</code> : 로깅하는 방식, 호스트 머신에 어떤 포맷으로 적용할지,</li>
  <li><code class="language-plaintext highlighter-rouge">max-size</code> : 최대치 설정</li>
  <li><code class="language-plaintext highlighter-rouge">max-file</code> : 최대 파일 개수, 설정 만큼 파일이 차고 용량 역시 정한 만큼 넘어가면, 가장 오래된 로그는 삭제한다.</li>
  <li><code class="language-plaintext highlighter-rouge">node-exporter</code> , <code class="language-plaintext highlighter-rouge">cadvisor</code> 같은 모니터링에 적용된다. 이유는 간단하다. 여기서의 수집되는 데이터들이 Grafana에 모이고 있기 때문에 물리적 파일 형태로 갖추는 건 긴급한 상황 보기 위한 수준만 있으면 되고, 그 이상은 이미 Grafna 대시보드에 수집됨.</li>
</ul>

<h4 id="network-external">network ‘external’</h4>
<ul>
  <li>네트워크를 해당 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 에서 만들 수도 있다. 하지만 여러 컨테이너가 연결되어 있을 수 잇다보니, 또한 여러 컨테이너를 추가로 붙이는 경우에도 이렇게 설정하면 외부에 이미 되어 있으니 생성하라고 하지 않을 수 있으며, 당연히 네트워크 그룹으로 묶이니 소통이 편리해진다.</li>
  <li><strong>네트워크의 수명과 컨테이너의 분리</strong>
    <ol>
      <li>실수로 인한 고립 방지 : 기본 설정만 할 경우 네트워크가 자동 생성, 삭제된다.</li>
      <li>다른 프로젝트와의 연결 : 공용도로로 연결되기 때문에, 향후 다른 서비스를 별도로 붙이더라도 손쉽게 붙이기가 가능함.</li>
    </ol>
  </li>
</ul>

<h3 id="shell-script">Shell Script</h3>

<ul>
  <li>SSL인증서 갱신을 위하여 구현하였던 쉘 스크립트.</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c">#!/bin/bash</span>

  <span class="c"># 1. 스크립트가 있는 '진짜' 폴더 위치 계산 (절대 경로)</span>
  <span class="nv">SCRIPT_DIR</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span> <span class="nb">cd</span> <span class="s2">"</span><span class="si">$(</span> <span class="nb">dirname</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BASH_SOURCE</span><span class="p">[0]</span><span class="k">}</span><span class="s2">"</span> <span class="si">)</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nb">pwd</span> <span class="si">)</span><span class="s2">"</span>

  <span class="c"># 2. Crontab용 PATH 설정</span>
  <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

  <span class="c"># 에러 발생 시 멈춤</span>
  <span class="nb">set</span> <span class="nt">-e</span>

  <span class="nb">echo</span> <span class="s2">"========================================"</span>
  <span class="nb">echo</span> <span class="s2">"🚀 SSL Renewal Started at </span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"   Target Dir: </span><span class="nv">$SCRIPT_DIR</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"========================================"</span>

  <span class="c"># --- [핵심] 환경 감지 로직 (COMPOSE_PROFILES 활용) ---</span>
  <span class="c"># .env 파일을 읽어서 COMPOSE_PROFILES 변수에 'main'이 포함되어 있는지 확인합니다.</span>

  <span class="nv">ENV_FILE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SCRIPT_DIR</span><span class="s2">/.env"</span>

  <span class="c"># .env 파일 로드 (변수 불러오기)</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$ENV_FILE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
      </span><span class="nb">source</span> <span class="s2">"</span><span class="nv">$ENV_FILE</span><span class="s2">"</span>
  <span class="k">fi</span>

  <span class="c"># COMPOSE_PROFILES 변수 확인 (메인 서버인지 판단)</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$COMPOSE_PROFILES</span><span class="s2">"</span> <span class="o">==</span> <span class="k">*</span><span class="s2">"main"</span><span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
      </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; Detected Environment: Main Server (A5) (Profile: </span><span class="nv">$COMPOSE_PROFILES</span><span class="s2">)"</span>
      <span class="nv">CERTBOT_SVC</span><span class="o">=</span><span class="s2">"certbot-main"</span>
      <span class="nv">NGINX_SVC</span><span class="o">=</span><span class="s2">"nginx-main"</span>
  <span class="k">else
      </span><span class="nb">echo</span> <span class="s2">"&gt;&gt; Detected Environment: Standard/Sub Server (Profile: </span><span class="k">${</span><span class="nv">COMPOSE_PROFILES</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">)"</span>
      <span class="nv">CERTBOT_SVC</span><span class="o">=</span><span class="s2">"certbot"</span>
      <span class="nv">NGINX_SVC</span><span class="o">=</span><span class="s2">"nginx"</span>
  <span class="k">fi

  </span><span class="nb">echo</span> <span class="s2">"   Target Services -&gt; Certbot: </span><span class="nv">$CERTBOT_SVC</span><span class="s2"> / Nginx: </span><span class="nv">$NGINX_SVC</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"========================================"</span>

  <span class="c"># 3. Docker Compose 실행 (공통 변수 사용)</span>
  <span class="nv">DC_CMD</span><span class="o">=</span><span class="s2">"docker compose --project-directory </span><span class="nv">$SCRIPT_DIR</span><span class="s2"> --env-file </span><span class="nv">$ENV_FILE</span><span class="s2">"</span>

  <span class="nb">echo</span> <span class="s2">"[Step 1] Certbot Renew..."</span>
  <span class="nv">$DC_CMD</span> run <span class="nt">--rm</span> <span class="s2">"</span><span class="nv">$CERTBOT_SVC</span><span class="s2">"</span> renew

  <span class="nb">echo</span> <span class="s2">"[Step 2] Nginx Reload..."</span>
  <span class="nv">$DC_CMD</span> <span class="nb">exec</span> <span class="s2">"</span><span class="nv">$NGINX_SVC</span><span class="s2">"</span> nginx <span class="nt">-s</span> reload

  <span class="nb">echo</span> <span class="s2">"========================================"</span>
  <span class="nb">echo</span> <span class="s2">"✅ SSL Renewal Completed!"</span>
  <span class="nb">echo</span> <span class="s2">"========================================"</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">crontab</code>으로 스케줄링을 걸면, 실행 위치가 엉뚱한 곳이 될 수 있음. <code class="language-plaintext highlighter-rouge">.env</code>와 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 를 정확히 찾기 위한 장치가 필요하여 스크립트 위치를 계산한다.</li>
  <li><code class="language-plaintext highlighter-rouge">cron</code> 환경은 일반 사용자 쉘과는 다름. 따라서 <code class="language-plaintext highlighter-rouge">PATH</code>가 최소 지정으로 <code class="language-plaintext highlighter-rouge">docker</code> 명령어를 못찾을 수 있어서 지정해주는게 안전한 실행을 발생 시킴</li>
  <li><code class="language-plaintext highlighter-rouge">if [조건]; then [실행할 명령]; fi</code> : 조건문</li>
  <li><code class="language-plaintext highlighter-rouge">[[ ... ]]</code> : 확장 테스트 명령, 일반 <code class="language-plaintext highlighter-rouge">[ ... ]</code> 에서 <code class="language-plaintext highlighter-rouge">==</code> 우측에 와일드카드를 써도 패턴 매칭안되고 단순 문자열 취급. ‘패턴매칭’ 이 동작하고, 키워드가 맞는지 검사하는게 된다.</li>
  <li>결과적으로 if 문을 통해 환경을 파악하고, 적용해야하는 컨테이너 이름들의 값을 확정지은다.</li>
  <li><code class="language-plaintext highlighter-rouge">DC_CMD="~"</code> 명령어도 변수로 담아 둘 수 있으며, 이를 통해 반복 입력을 최소화한다.</li>
  <li>결론
    <ol>
      <li>이 스크립트는 환경 인식을 통한 코드 중복을 제거하여, 스크립트를 여러개 만들지 않는 구조를 채택함</li>
      <li>Cron 환경을 고려하여 환경변수, 현재 위치 등을 파악하고, 먼저 안전하게 수행하도록 함.</li>
      <li><code class="language-plaintext highlighter-rouge">nginx -s reload</code> 등, 마지막 부분에서는 인증서 갱신이 되더라도 안정적이고, 트래픽이 끊기지 않게 만들고자 reload 를 사용함으로써 무중단 운영이 되도록 신경을 썼다.</li>
    </ol>
  </li>
</ol>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><summary type="html"><![CDATA[핵심 특징 5가지 물리적 / 논리적 망 분리 : 서비스 존과 매니징 존을 분리하였고, 이를 통한 운영 안정성을 확보함. 트래픽 제어를 위한 Nginx 레이어에서의 Traffic Dam : 토큰 버킷 알고리즘 기반의 트래픽 제어 Heavy Zone, Light Zone 으로 구분하여서 매크로성을 엄격히 막아야 하는 위치(Backend), 정적 리소스 로딩을 위한 일반 존(Frontend)로 구분하여 로딩속성과 백엔드 서비스 보호를 양립함. 투명한 IP 보존(L4, L7 Proxy Protocol) 두대의 서버, 한대의 공유기의 네트워크 환경에서 클라이언트의 원본 IP 를 추적하기 위함, 동시에 각 서버의 HTTPS 접속을 구현함으로서 서비스 서버와 메인터넌스 서버에 접속하는 루트를 분리. 이를 통한 서비스 서버의 문제가 발생하더라도, 이를 모니터링하는 서버의 접속은 문제 없도록 만들어냄 중앙집중형 관제 시스템 Prometheus 의 Pull 방식과 함께 Promtail을 통해 Loki 기반의 서버 어플리케이션들의 로그를 수집하도록 했음 통합 대시보드를 통해 서버들의 상태, 관리의 중앙 집중구조를 구현함. AI 서비스를 위한 최적화 데이터베이스 구현 pgvector 확장을 위하여 init.spl에서 확장기능을 활성화 시켜 벡터 DB 기능을 사용하였다. 별도의 벡터 DB 가 아닌, RDBMS 인프라 내에서 임베딩 벡터를 저장, 검색함으로써 관리 복잡도를 줄여줌]]></summary></entry><entry><title type="html">Protostar review note - 00 - FastAPI intro</title><link href="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/10/02-protostar-review.html" rel="alternate" type="text/html" title="Protostar review note - 00 - FastAPI intro" /><published>2026-02-10T00:00:00+00:00</published><updated>2026-02-10T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/10/02-protostar-review</id><content type="html" xml:base="http://0.0.0.0:4000/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/2026/02/10/02-protostar-review.html"><![CDATA[<h1 id="fastapi-개념-정리">FastAPI 개념 정리</h1>
<ul>
  <li>현대적, 성능이 뛰어난 웹 프레임워크 서버</li>
  <li>RESTFul API 를 구축하는데 최적화, 3.14의 멀티코어 병렬 처리와 uv 같은 고속 툴 체인을 결합하여 백엔드 개발의 표준 방식으로 자리 잡게됨.
    <h2 id="핵시-철학-및-특징">핵시 철학 및 특징</h2>
  </li>
  <li>고성능: 웹엔진(Starlette), 데이터 검증(Pydantic)</li>
  <li>빠른 개발 속도: 파이썬의 <code class="language-plaintext highlighter-rouge">Type Hints</code>를 활용해 코딩 시간을 획기적으로 줄임.</li>
  <li>자동 문서화: 별도 작업 없이 Swagger UI 와 ReDoc을 통해 대화형 API 문서를 생성함.</li>
  <li>데이터 검증 및 직렬화: JSON 데이터를 파이썬 객체로 자동 변환, 타입에러를 통한 안정성 확보</li>
</ul>

<h2 id="기술-근간">기술 근간</h2>
<p>|**구성 요소**|**역할**|
|—|—|
|**Starlette**|가볍고 빠른 ASGI 프레임워크로, 라우팅, 웹소켓, 미들웨어 등 핵심 웹 기능을 담당합니다.|
|**Pydantic**|파이썬 타입 힌트를 기반으로 데이터 검증(Validation)과 설정 관리(Serialization)를 수행합니다.|
|**Uvicorn / uv**|비동기 서버(ASGI)로, FastAPI 애플리케이션을 실행하는 엔진 역할을 합니다.|</p>
<ul>
  <li>ASGI(Asynchronous Server Gateway Interface): Python 비동기 웹 표준. WSGI(Sync)와 달리 async/await 지원으로 고성능 웹앱 가능
    <ul>
      <li>라우팅 / 미들웨어 / 요청, 응답 처리 / 라이프 사이클 관리 역할을 함</li>
    </ul>
  </li>
  <li>pydantic: 타입힌트를 기반 검증, 파싱 라이브러리
    <ul>
      <li>python dataclass 확장, Json -&gt; python 객체 자동 변환 + 검증 역할</li>
      <li>FastAPI 연계될 때는
        <ul>
          <li>Path/Query/Form 모델: 함수 인자로 사용, 자동 파싱 / 검증</li>
          <li>Response 모델: 출력 스키마를 정의 하며 자동 생성해줌</li>
          <li>Validator / Field 커스텀: 각종 데코레이터, Field 로 입력을 수신해줌.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="주요-개념-및-동작-로직">주요 개념 및 동작 로직</h2>
<ol>
  <li>비동기 처리(Async / Await)</li>
  <li>의존성 주입: 함수를 할당해두고 Annotated와 Depends 를 활용해, 이를 추적해서 사용하도록 함으로써 코드 재사용성을 극대화함.</li>
  <li>타입 힌트 기반 검증</li>
  <li>애플리케이션 구조: 2026년 현재 도메인 주도 설계 적용, 비즈니스 로직의 서비스 레이어와 Router 레이어(HTTP 통신 수신)을 분리하는 방식이 권장 됨.</li>
</ol>

<h2 id="프레임-워크">프레임 워크</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">**구분**</th>
      <th style="text-align: left">**Django**</th>
      <th style="text-align: left">**Flask**</th>
      <th style="text-align: left">**FastAPI**</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">**성격**</td>
      <td style="text-align: left">Batteries-included (모든 기능 포함)</td>
      <td style="text-align: left">Micro-framework (최소 기능)</td>
      <td style="text-align: left">Modern API-first (현대적 API 특화)</td>
    </tr>
    <tr>
      <td style="text-align: center">**성능**</td>
      <td style="text-align: left">상대적으로 무거움</td>
      <td style="text-align: left">보통 (동기 위주)</td>
      <td style="text-align: left">**매우 빠름 (비동기)**</td>
    </tr>
    <tr>
      <td style="text-align: center">**주요 용도**</td>
      <td style="text-align: left">대규모 웹 서비스, 관리자 페이지</td>
      <td style="text-align: left">소규모 프로토타입</td>
      <td style="text-align: left">**마이크로서비스, AI 모델 서빙**</td>
    </tr>
    <tr>
      <td style="text-align: center">**데이터 검증**</td>
      <td style="text-align: left">Forms / Serializers 사용</td>
      <td style="text-align: left">수동 설정 필요</td>
      <td style="text-align: left">**자동 (Pydantic)**</td>
    </tr>
  </tbody>
</table>

<hr />
<h1 id="의존성-주입-세부적으로-알아보기">의존성 주입 세부적으로 알아보기</h1>

<h3 id="함수-의존성-예시-코드">함수 의존성 예시 코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>
  <span class="kn">from</span> <span class="n">fastapi</span> <span class="kn">import</span> <span class="n">Depends</span><span class="p">,</span> <span class="n">FastAPI</span>

  <span class="n">app</span> <span class="o">=</span> <span class="nc">FastAPI</span><span class="p">()</span>

  <span class="c1"># 1. 의존성(Dependable) 함수 정의
</span>  <span class="c1"># 공통적으로 사용할 로직을 일반 함수(또는 async 함수)로 만듭니다.
</span>  <span class="k">async</span> <span class="k">def</span> <span class="nf">common_parameters</span><span class="p">(</span><span class="n">q</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">skip</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">q</span><span class="sh">"</span><span class="p">:</span> <span class="n">q</span><span class="p">,</span> <span class="sh">"</span><span class="s">skip</span><span class="sh">"</span><span class="p">:</span> <span class="n">skip</span><span class="p">,</span> <span class="sh">"</span><span class="s">limit</span><span class="sh">"</span><span class="p">:</span> <span class="n">limit</span><span class="p">}</span>

  <span class="c1"># 2. 경로 함수(Path Operation)에 주입
</span>  <span class="c1"># Annotated를 사용하여 반환 타입(dict)과 의존성 선언(Depends)을 결합합니다.
</span>  <span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/items/</span><span class="sh">"</span><span class="p">)</span>
  <span class="k">async</span> <span class="k">def</span> <span class="nf">read_items</span><span class="p">(</span><span class="n">commons</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nc">Depends</span><span class="p">(</span><span class="n">common_parameters</span><span class="p">)]):</span>
      <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">message</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">Items list</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">params</span><span class="sh">"</span><span class="p">:</span> <span class="n">commons</span><span class="p">}</span>

  <span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/users/</span><span class="sh">"</span><span class="p">)</span>
  <span class="k">async</span> <span class="k">def</span> <span class="nf">read_users</span><span class="p">(</span><span class="n">commons</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nc">Depends</span><span class="p">(</span><span class="n">common_parameters</span><span class="p">)]):</span>
      <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">message</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">Users list</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">params</span><span class="sh">"</span><span class="p">:</span> <span class="n">commons</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="리소스-관리를-위한-의존성-예시-코드">리소스 관리를 위한 의존성 예시 코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>
  <span class="kn">from</span> <span class="n">fastapi</span> <span class="kn">import</span> <span class="n">Depends</span><span class="p">,</span> <span class="n">FastAPI</span>

  <span class="n">app</span> <span class="o">=</span> <span class="nc">FastAPI</span><span class="p">()</span>

  <span class="c1"># 데이터베이스 세션을 시뮬레이션하는 의존성
</span>  <span class="k">async</span> <span class="k">def</span> <span class="nf">get_db_session</span><span class="p">():</span>
      <span class="n">db</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Database Connection Created</span><span class="sh">"</span>
      <span class="k">try</span><span class="p">:</span>
          <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">연결 생성</span><span class="sh">"</span><span class="p">)</span>
          <span class="k">yield</span> <span class="n">db</span>  <span class="c1"># 엔드포인트 함수에 db 객체 전달
</span>      <span class="k">finally</span><span class="p">:</span>
          <span class="c1"># 엔드포인트 작업이 끝나면(성공/실패 상관없이) 실행됩니다.
</span>          <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">연결 종료 및 정리 로직 실행</span><span class="sh">"</span><span class="p">)</span>

  <span class="nd">@app.get</span><span class="p">(</span><span class="sh">"</span><span class="s">/db-task</span><span class="sh">"</span><span class="p">)</span>
  <span class="k">async</span> <span class="k">def</span> <span class="nf">perform_db_task</span><span class="p">(</span><span class="n">db</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nc">Depends</span><span class="p">(</span><span class="n">get_db_session</span><span class="p">)]):</span>
      <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">status</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">success</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">data</span><span class="sh">"</span><span class="p">:</span> <span class="n">db</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="결론">결론</h3>
<ul>
  <li>FastAPI 의 의존성 부여는, NestJS나 Spring 에서 지향하듯 시스템에서 의존성을 관리해주는 형태는 아니다.</li>
  <li>오히려 특정 함수가 있고, 찾아서 쓰라는 식의 Raw 한 접근에 가깝다.</li>
  <li><strong>Request Lifecycle</strong>: 기본적으로 FastAPI는 <strong>하나의 HTTP 요청</strong> 안에서 같은 의존성이 여러 번 호출되면, 함수를 매번 실행하지 않고 <strong>처음 계산된 결과를 캐싱</strong>해서 돌려준다.(캐싱이 내장)
    <ul>
      <li><strong>재사용성</strong>: 예를 들어 <code class="language-plaintext highlighter-rouge">get_current_user</code>라는 의존성을 여러 함수가 참조해도, 실제 유저를 DB에서 찾는 로직은 한 요청당 딱 한 번만 실행된다.</li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="protostar-fastapi-ai-worker">Protostar FastAPI (AI Worker)</h1>

<p><img src="https://img.shields.io/badge/Python-3.13+-3776AB?style=for-the-badge&amp;logo=python&amp;logoColor=white" alt="Python" />
<img src="https://img.shields.io/badge/FastAPI-0.122+-009688?style=for-the-badge&amp;logo=fastapi&amp;logoColor=white" alt="FastAPI" />
<img src="https://img.shields.io/badge/Redis-Job_Queue-DC382D?style=for-the-badge&amp;logo=redis&amp;logoColor=white" alt="Redis" />
<img src="https://img.shields.io/badge/Docker-Ready-2496ED?style=for-the-badge&amp;logo=docker&amp;logoColor=white" alt="Docker" /></p>

<p><strong>Project Protostar</strong>의 두뇌 역할을 담당하는 AI Worker 서비스다. 
비동기 작업 큐(Redis Queue)를 기반으로 고성능 AI 추론, RAG(Retrieval-Augmented Generation) 파이프라인, 그리고 데이터 요약 작업을 병렬로 처리하도록 구조화 되어있다.</p>

<h2 id="-시스템-아키텍처-system-architecture">🏗 시스템 아키텍처 (System Architecture)</h2>

<p>본 프로젝트는 서비스의 안정성과 확장성을 위해 <strong>멀티 워커(Multi-Worker) 구조</strong>를 채택하고 있다.</p>

<p><img src="/assets/images/posts/2026-02/017.png" alt="" /></p>

<h3 id="-핵심-구성-요소-core-components">🛠 핵심 구성 요소 (Core Components)</h3>

<ol>
  <li><strong>채팅 워커 (Chat Worker)</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">chat:job:queue</code>를 구독(Consume)하여 실시간 대화를 처리한다.</li>
      <li>RAG를 통한 지식 검색 및 스트리밍 응답(Streaming Response)을 지원한다.</li>
      <li>해당 워커를 통해 사용자의 질문에 대한 답변을 생성하고, 이를 사용자에게 스트리밍으로 전달한다.</li>
    </ul>
  </li>
  <li><strong>지식 워커 (Knowledge Worker)</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ai:job:queue</code>를 구독하여 문서 벡터화 작업을 수행한다.</li>
      <li>MinIO에서 파일을 가져와 텍스트 추출 -&gt; 청킹(Chunking) -&gt; 임베딩 -&gt; DB 저장을 담당한다.</li>
      <li>해당 워커를 통해 문서의 내용을 벡터화하여 저장하고, 이를 통해 RAG를 구현한다.</li>
    </ul>
  </li>
  <li><strong>요약 워커 (Summary Worker)</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">chat:summary:queue</code>를 구독하여 대화 내용을 배경에서 요약한다.</li>
      <li>다음 대화 시 컨텍스트(Context)를 효율적으로 관리할 수 있도록 돕는다.</li>
      <li>해당 워커를 통해 세션 당 기억력을 확보하고, 장기기 기억 시의 토큰 소비량을 약 73% 까지 압축하는 결과를 만들었다.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="-프로젝트-구조-project-structure">📂 프로젝트 구조 (Project Structure)</h2>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  app/
  ├── core/               # 핵심 비즈니스 로직
  │   ├── ai.py           # LLM 인터페이스 및 스트리밍 처리
  │   ├── worker.py       # 메인 채팅 워커 (Chat Worker)
  │   ├── worker_knowledge.py # RAG 전처리 워커 (Knowledge Worker)
  │   ├── worker_summary.py   # 대화 요약 워커 (Summary Worker)
  │   ├── rag_service.py  # 벡터 검색 및 RAG 로직
  │   ├── minio_client.py # MinIO 연동 클라이언트
  │   └── database.py     # SQLAlchemy &amp; DB 설정
  ├── prompts/            # 시스템 프롬프트 관리
  ├── main.py             # FastAPI 진입점 및 인스턴스 관리
  └── pyproject.toml      # 의존성 및 패키지 관리 (uv)
</code></pre></div></div>]]></content><author><name>Paul2021-R</name></author><category term="문제해결" /><category term="Backend" /><category term="개발" /><category term="Protostar" /><category term="Project" /><category term="Review" /><category term="FastAPI" /><summary type="html"><![CDATA[FastAPI 개념 정리 현대적, 성능이 뛰어난 웹 프레임워크 서버 RESTFul API 를 구축하는데 최적화, 3.14의 멀티코어 병렬 처리와 uv 같은 고속 툴 체인을 결합하여 백엔드 개발의 표준 방식으로 자리 잡게됨. 핵시 철학 및 특징 고성능: 웹엔진(Starlette), 데이터 검증(Pydantic) 빠른 개발 속도: 파이썬의 Type Hints를 활용해 코딩 시간을 획기적으로 줄임. 자동 문서화: 별도 작업 없이 Swagger UI 와 ReDoc을 통해 대화형 API 문서를 생성함. 데이터 검증 및 직렬화: JSON 데이터를 파이썬 객체로 자동 변환, 타입에러를 통한 안정성 확보]]></summary></entry></feed>