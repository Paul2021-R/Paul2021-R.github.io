<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-10-29T15:11:29+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Paul’s Archives</title><subtitle>성장하는 개발자, 소통하는 개발자, 빠른 적용을 최 우선으로 삼는 개발자. 다음을 항상 생각하며, 개발 속에서 가치를 만들어내는 것을 목표로 합니다.</subtitle><author><name>Paul2021-R</name></author><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (1)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-frontend.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (1)" /><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-frontend</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/28/til-frontend.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h2 id="01-jenkins">01 Jenkins</h2>

<h3 id="개념">개념</h3>
<ul>
  <li>Jenkins는 소프트웨어 개발에서 지속적인 통합(Continuous Integration, CI)과 지속적인 배포(Continuous Deployment, CD)를 자동화하는 데 사용되는 오픈 소스 자동화 서버다.</li>
  <li>개발자가 코드를 변경하고 저장소에 커밋(commit)하면, Jenkins는 자동으로 코드를 빌드(build)하고, 테스트(test)하며, 배포하는 일련의 과정을 수행한다.</li>
  <li>개발 프로세스의 효율성을 높이고, 오류를 조기에 발견하며, 궁극적으로 안정적인 소프트웨어 릴리스(release)를 가능하게 하는 도구이다.
    <h3 id="왜--jenkins-와-같은-전문-툴이-필요한가--지속적인-통합continuous-integrateion-ci">왜  Jenkins 와 같은 전문 툴이 필요한가? : 지속적인 통합(Continuous Integrateion, CI)</h3>
  </li>
  <li><strong>오류 조기 발견</strong>: 코드가 자주 통합되고 테스트되므로, 통합 과정에서 발생하는 오류나 버그를 개발 초기에 발견하고 수정할 수 있다. 이는 문제 해결 비용을 크게 절감한다.</li>
  <li><strong>코드 품질 향상</strong>: 자동화된 테스트를 통해 코드의 일관성과 안정성을 유지하며, 개발자들은 더 높은 품질의 코드를 작성하는 데 집중할 수 있게 만든다.</li>
  <li><strong>개발 생산성 증대</strong>: 수동으로 빌드하고 테스트하는 시간을 줄여 개발자들이 새로운 기능 개발에 더 많은 시간을 할애할 수 있도록 한다.</li>
  <li><strong>팀 협업 강화</strong>: 개발자들이 서로의 코드 변경 사항을 빠르게 공유하고 통합함으로써 팀 전체의 협업 효율성을 높인다.</li>
</ul>

<h3 id="왜-jenkins-와-같은-전문-툴이-필요한가--지속적인-배포continuous-deployment-cd">왜 Jenkins 와 같은 전문 툴이 필요한가? : 지속적인 배포(Continuous Deployment, CD)</h3>
<ul>
  <li><strong>빠른 릴리스 주기</strong>: 새로운 기능이나 버그 수정 사항을 신속하게 사용자에게 제공하여 시장 변화에 빠르게 대응할 수 있다.</li>
  <li><strong>배포 프로세스 자동화</strong>: 수동 배포 과정에서 발생할 수 있는 인적 오류를 제거하고, 배포의 일관성과 신뢰성을 확보한다.</li>
  <li><strong>위험 감소</strong>: 작고 빈번한 배포를 통해 한 번의 배포로 인한 위험 부담을 줄이고, 문제가 발생하더라도 빠르게 롤백(rollback)하거나 수정할 수 있다.</li>
  <li><strong>피드백 루프 단축</strong>: 사용자 피드백을 빠르게 수집하고 다음 개발 주기에 반영함으로써 제품 개선 속도를 높인다.</li>
</ul>

<h3 id="jenkins-의-역할은">Jenkins 의 역할은</h3>
<ul>
  <li><strong>코드 변경 감지</strong>: Git, SVN 등 다양한 버전 관리 시스템(VCS)과 연동하여 코드 저장소의 변경 사항을 지속적으로 감지한다.</li>
  <li><strong>자동 빌드</strong>: 변경된 코드를 자동으로 가져와 컴파일(compile)하고, 필요한 의존성(dependency)을 설치하며, 실행 가능한 아티팩트(artifact)를 생성한다.</li>
  <li><strong>자동 테스트</strong>: 단위 테스트(unit test), 통합 테스트(integration test), 성능 테스트(performance test) 등 다양한 유형의 테스트를 자동으로 실행하여 코드의 품질과 안정성을 검증한다.</li>
  <li><strong>자동 배포</strong>: 테스트를 통과한 아티팩트를 개발, 스테이징(staging), 프로덕션 환경 등 지정된 서버에 자동으로 배포한다.</li>
  <li><strong>파이프라인 오케스트레이션(Orchestration)</strong>: 빌드, 테스트, 배포 등 CI/CD의 모든 단계를 하나의 파이프라인으로 정의하고, 각 단계의 실행 순서와 조건을 관리한다.</li>
  <li><strong>알림 및 보고</strong>: 빌드 및 배포 결과에 대한 성공/실패 알림을 이메일, Slack, Discord 등 다양한 채널로 전송하고, 상세한 보고서를 제공한다.</li>
</ul>

<h3 id="jenkins-의-장점">Jenkins 의 장점</h3>
<ul>
  <li><strong>오픈 소스 및 확장성</strong>: 무료로 사용할 수 있는 오픈 소스이며, 수많은 플러그인을 통해 거의 모든 종류의 빌드, 테스트, 배포 도구와 연동하여 기능을 확장할 수 있다.</li>
  <li><strong>다양한 환경 지원</strong>: Java, Python, Node.js, .NET 등 다양한 프로그래밍 언어와 프레임워크(framework)를 지원하며, Docker, Kubernetes와 같은 컨테이너(container) 기술과도 쉽게 통합된다.</li>
  <li>
    <p><strong>강력한 파이프라인 기능</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 통해 CI/CD 파이프라인을 코드로 정의하고 버전 관리할 수 있어, 파이프라인의 재현성(reproducibility)과 유지보수성(maintainability)을 높다. (예시: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>)
```Groovy
pipeline {
agent any</p>

    <p>environment {
    GHCR_CREDS_ID = ‘ghcr-creds’
    GITHUB_CREDS_ID = ‘github-creds’
    TARGET_SSH_CREDS_ID = ‘a5-localhost-jenkins’</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TARGET_DEPLOY_SERVER = 'GEEKOM-A5-Server'

DISCORD_CREDS_ID = 'discord-webhook-url'
</code></pre></div>    </div>
  </li>
</ul>

<p>// … 중략</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stages {
// code pull
    stage('Checkout') {
        steps {
            echo "1. Get the latest code from GitHub"
            git credentialsId: GITHUB_CREDS_ID, url: 'https://github.com/paul2021-r/project-mini-frontend.git', branch: 'main'
        }
    }
</code></pre></div></div>

<p>// … 중략</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>post {
    success {
        echo "Deployment succeeded. Now send a discord notification."
        script {
            withCredentials([string(credentialsId: DISCORD_CREDS_ID, variable: 'DISCORD_URL')]) {
                def message = "{\"content\": \"🚀 Build Process is successfully finished : **[${env.JOB_NAME}]** - **#${env.BUILD_NUMBER}**\"}"
</code></pre></div></div>

<p>// … 후략</p>

<p>}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
*   **활발한 커뮤니티 지원**: 전 세계적으로 많은 사용자와 개발자들이 활발하게 활동하며, 다양한 문제 해결과 기능 개선에 기여하고 있다. 이는 풍부한 자료와 지원을 받을 수 있다는 장점으로 이어진다.
*   **시각화 및 모니터링**: Blue Ocean과 같은 플러그인을 통해 파이프라인의 실행 과정을 시각적으로 확인하고, 빌드 상태를 실시간으로 모니터링할 수 있다.

### Jenkins 의 아키텍쳐 
- 단일 빌드도 가능하나, 여러 프로젝트를 동시에 처리하는 경우 분산 빌드(Distrivuted Builds) 아키텍처를 활용한다. 이러한 아키텍쳐는 컨트롤러와 노드로 구분되며 각기 역할을 분담하면 Jenkins 의 확장성, 효율성에 도움이 된다. 단, 어디까지나 시스템과 리소스의 상황에 따라 최적화 시키는것이 중요하다. 
#### Jenkins Master(컨트롤러)
   - **작업 스케줄링 및 관리**: 빌드 작업을 언제, 어떤 Agent에서 실행할지 결정하고, 전체 파이프라인의 흐름을 관리한다. 
*   **Agent 연결 관리**: 등록된 Agent들과의 연결을 유지하고, Agent의 상태를 모니터링한다.
*   **설정 및 플러그인 관리**: Jenkins의 전반적인 설정, 사용자 관리, 보안 설정, 그리고 설치된 플러그인들을 관리합니다. `project-mini-jenkins` 프로젝트의 `jenkins/casc.yaml` 파일은 Master의 설정을 코드로 관리하는 예시입니다.
*   **빌드 결과 저장**: 빌드 로그, 테스트 결과, 아티팩트 등 빌드 관련 데이터를 저장하고 관리한다.
*   **UI 제공**: 웹 인터페이스를 통해 사용자에게 Jenkins의 모든 기능과 빌드 현황을 제공합한다.

#### Jenkins Agent(노드/ 실행기)
*   **작업 실행**: Master로부터 전달받은 빌드 스크립트(예: `Jenkinsfile`에 정의된 `sh` 명령어)를 실행하여 코드 빌드, 테스트, 배포 등의 작업을 수행한다. 
*   **다양한 환경 지원**: Agent는 물리 서버, 가상 머신(VM), Docker 컨테이너 등 다양한 형태로 구성될 수 있다. 각 Agent는 특정 운영체제, 소프트웨어 버전, 라이브러리 등 특정 빌드 환경을 제공 일정하게 제공할 수 있다.
*   **확장성**: 필요한 경우 Agent를 추가하여 Jenkins 시스템의 처리 용량을 쉽게 확장할 수 있다. 이는 동시에 더 많은 빌드 작업을 처리하거나, 특정 환경이 필요한 작업을 분리하여 실행하는 데 유용하다.
*   **격리된 환경**: 각 Agent는 독립적인 환경에서 작업을 수행하므로, 한 Agent에서 실행되는 작업이 다른 Agent의 작업에 영향을 미치지 않는다. 이는 빌드 환경의 일관성과 안정성을 보장해줘, 서로의 충돌이나 호스트 OS에 영향을 주지 않을 수 있다.

#### 분산 빌드(Distributed Builds, Master-Slave)
- Jenkins 마스터와 하나 이상의 Agent를 준비하고, 빌드를 하여 여러 머신에 분산하여 처리하는 방법을 의미한다. 이 방식의 이점은 아래와 같다. 

*   **부하 분산 (Load Balancing)**: Master의 부하를 줄이고, 빌드 작업을 여러 Agent에 분산하여 동시에 더 많은 작업을 처리할 수 있다. 이는 빌드 큐(queue)를 줄이고 전체 CI/CD 파이프라인의 처리량을 증가시킨다.
*   **환경 격리 (Environment Isolation)**: 각 Agent가 독립적인 빌드 환경을 제공하므로, 서로 다른 프로젝트나 다른 버전의 소프트웨어가 필요한 빌드 작업을 충돌 없이 실행할 수 있다. 예를 들어, 한 Agent는 Java 8 환경에서 빌드하고, 다른 Agent는 Node.js 18 환경에서 빌드할 수 있다.
*   **확장성 (Scalability)**: 빌드 요구사항이 증가함에 따라 Agent를 쉽게 추가하거나 제거할 수 있어, Jenkins 시스템의 확장성을 유연하게 관리할 수 있다.
*   **안정성 (Reliability)**: 특정 Agent에 문제가 발생하더라도 다른 Agent에서 작업을 계속 수행할 수 있으므로, 전체 CI/CD 시스템의 안정성이 향상된다.

- `project-mini-frontend` 프로젝트는 jenkins 시스템을 활용하고, `Jenkinsfile`을 이용하여 Host 서버에서 Docker 컨테이너로 구성되어 있다. 또한 Jenkins 컨테이너는 DooD(Docker-out-of-Docker) 패턴을 통해 Jenkins Master 컨테이너 자체가 Agent 역할을 겸한다. 
- 그러나 여기에 다른 서버를 추가한다면, Master 와 Agent 를 분리할 수 있고, 특히 용도와 리소스에 맞게 분리한다면 서버의 역할에 따라 빌드하는 노드를 별도로 가져갈 수도 있고, 안정성을  더 강화할 수도 있다.

### Docker 를 이용한 Jenkins 설치 
- Jenkins를 Docker 컨테이너로 설치하는 것은 환경 설정의 일관성을 보장하고, 배포 및 관리를 용이하게 하는 현대적인 방법이다.
- 또한 컨테이너화 함을 통해, Jenkins 환경을 모듈화시킬 수 있어 다양한 리소스에 이식할 수 있고, 또 동일한 CICD 환경 구축을 가능케한다.
- 다양한 패턴이 있겠지만, 많지 않은 리소스 상황, 그리고 Host 의 자원을 완전하게 이용하기 위하여 Jenkins Master 컨테이너가 안에서 Host 의 도커를 조작할 수 있도록 하는 DooD 패턴을 이번 프로젝트에 활용했다. 이를 통해 환경 구축과 내용의 격리는 컨테이너 내에 이루었지만, 실제 빌드는 Host 에서 구성되는 형태를 취한다.

#### DooD 를 위한 docker-compose.yml

```yaml
# project-mini-jenkins/docker-compose.yml
services:
  jenkins:
    build:
      context: jenkins
    container_name: jenkins-server
    ports:
      - "12345:8080"
    volumes:
      - ./jenkins_home:/var/jenkins_home
      # Docker CLI 사용을 위해 호스트로 마운트
      - /var/run/docker.sock:/var/run/docker.sock
      - /usr/bin/docker:/usr/bin/docker
      - /usr/bin/docker-compose:/usr/bin/docker-compose
    environment:
      - CASC_JENKINS_CONFIG=/var/jenkins_home/casc.yaml
    entrypoint: &gt;
      bash -c "
        cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;
        /usr/bin/tini -- /usr/local/bin/jenkins.sh
      "
</code></pre></div></div>

<p>주요 내용은 다음과 같다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">build</code></strong>: <code class="language-plaintext highlighter-rouge">context: jenkins</code>는 <code class="language-plaintext highlighter-rouge">jenkins</code> 디렉토리 내의 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 사용하여 이미지를 빌드하도록 지시한다.</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">container_name</code></strong>: 컨테이너 이름을 <code class="language-plaintext highlighter-rouge">jenkins-server</code>로 지정하여 쉽게 식별할 수 있도록 했다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ports</code></strong>: 호스트의 <code class="language-plaintext highlighter-rouge">12345</code> 포트를 컨테이너의 <code class="language-plaintext highlighter-rouge">8080</code> 포트(Jenkins 기본 포트)에 매핑하여 외부에서 Jenkins에 접근할 수 있도록 하고, 자주 사용되는 포트 점유를 피한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">volumes</code></strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">./jenkins_home:/var/jenkins_home</code>: Jenkins의 데이터(설정, 빌드 기록, 플러그인 등)를 호스트의 <code class="language-plaintext highlighter-rouge">jenkins_home</code> 디렉토리에 영구적으로 저장하도록 마운트한다. 이는 컨테이너가 삭제되더라도 데이터가 보존되도록 하며, 명시적으로 해당 폴더에 남기에, 해당 데이터를 이동하면 다른 서버로 이식이 용이하다.</li>
      <li><code class="language-plaintext highlighter-rouge">/var/run/docker.sock:/var/run/docker.sock</code>: 호스트의 Docker 소켓을 컨테이너 내부에 마운트한다. 이 설정은 Jenkins 컨테이너가 호스트의 Docker 데몬과 통신하여 Docker 명령어를 실행할 수 있도록 하는 DooD 패턴의 핵심으로, 공유되지 않으면 내부에서 외부로의 조종이 불가능하다.</li>
      <li><code class="language-plaintext highlighter-rouge">/usr/bin/docker:/usr/bin/docker</code>, <code class="language-plaintext highlighter-rouge">/usr/bin/docker-compose:/usr/bin/docker-compose</code>: 호스트의 Docker 및 Docker Compose 바이너리를 컨테이너 내부에 마운트하여 Jenkins가 이들을 직접 사용할 수 있도록 했다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">environment</code></strong>: <code class="language-plaintext highlighter-rouge">CASC_JENKINS_CONFIG</code> 환경 변수를 설정하여 JCasC 설정 파일의 경로를 지정한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">entrypoint</code></strong>: Jenkins 컨테이너가 시작될 때 <code class="language-plaintext highlighter-rouge">casc.yaml</code> 파일을 <code class="language-plaintext highlighter-rouge">jenkins_home</code>으로 복사하고 Jenkins를 실행하는 스크립트를 정의하였다. 해당 entrypoint 설정은 Dockerfile의 기본 설정이 있더라도, 이를 무시하고 덮어씌워진다.</li>
</ul>

<h3 id="jenkins-초기-설정">Jenkins 초기 설정</h3>

<h4 id="초기-관리자-비밀번호-확인">초기 관리자 비밀번호 확인</h4>

<ol>
  <li><strong>Jenkins 컨테이너 실행</strong>: <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 명령으로 Jenkins 컨테이너를 실행한다.</li>
  <li><strong>로그 확인</strong>: 다음 명령어를 사용하여 Jenkins 컨테이너의 로그를 확인한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs jenkins-server
</code></pre></div>    </div>
    <p>로그 출력에서 <code class="language-plaintext highlighter-rouge">Please use the following password to proceed to installation:</code> 또는 유사한 메시지 뒤에 나오는 긴 문자열이 초기 관리자 비밀번호다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************
</code></pre></div>    </div>
    <p>(여기서 <code class="language-plaintext highlighter-rouge">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code> 부분이 실제 비밀번호다.)</p>
  </li>
</ol>

<h4 id="초기-설정-진행-절차">초기 설정 진행 절차</h4>

<ol>
  <li><strong>Jenkins 웹 인터페이스 접속</strong>: 웹 브라우저를 열고 <code class="language-plaintext highlighter-rouge">http://localhost:12345</code> (또는 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에 설정된 포트)로 접속.</li>
  <li><strong>관리자 비밀번호 입력</strong>: 위에서 확인한 초기 관리자 비밀번호를 입력하고 <code class="language-plaintext highlighter-rouge">Continue</code>를 클릭</li>
  <li><strong>플러그인 설치</strong>: <code class="language-plaintext highlighter-rouge">Install suggested plugins</code>를 선택하여 권장 플러그인을 설치하거나, <code class="language-plaintext highlighter-rouge">Select plugins to install</code>을 선택하여 필요한 플러그인만 설치할 수 있다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트의 <code class="language-plaintext highlighter-rouge">jenkins/plugins.txt</code>와 <code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code>을 사용한다면, 플러그인과 기본 설정은 자동으로 적용된다.</li>
  <li><strong>관리자 계정 생성</strong>: 초기 관리자 비밀번호를 사용한 후, 새로운 관리자 계정(사용자 이름, 비밀번호, 이름, 이메일)을 생성한다. 이 계정은 이후 Jenkins에 로그인할 때 사용된다.</li>
  <li><strong>Jenkins URL 설정</strong>: Jenkins 인스턴스의 URL을 설정합니다. 기본값으로 두거나 필요에 따라 변경할 수 있다.</li>
</ol>

<p>이 과정을 통해 Jenkins 서버의 초기 설정이 완료되며, CI/CD 파이프라인을 구축하고 관리할 준비가 된다. 단 여기서 중요한 지점으로,</p>

<p>1) 실제 프로젝트를 위한 플러그인을 설치할 것이 무엇이 있는지 판단 및 밑설치를 미리 해둬야 예상외의 발생 에러를 잡을 수 있다. 최초 설치시 아주 기본적인 내용만 있고, 빌드 자체를 위한 도구 정도만 설치됨. 이에 dockerfile 을 통해 컨테이너 내부에서 조작할 도구들과, jenkins 자체를 위한 플러그인(예, ssh agent)등을 정확하게 보고 미리 설치해놓아야 한다. 
2) 외부에서 신호를 수신하여 동작하는 등의 것이 있을 경우, HTTPS 를 통한 외부 접속 통로를 확보해둔 설계가 필요할 수 있다. GitHub 의 웹훅이나, 다양한 도구들의 연결 시 HTTPS 가 필수인 경우가 많다. 이를 고려하지 않은 설계가 되면 완전 자동화를 만들기 어려울 수 있다. (수동 호출 및 빌드는 HTTP 환경으로도 충분)</p>

<h3 id="jenkins-plugin">Jenkins Plugin</h3>

<h4 id="역할">역할</h4>
<ul>
  <li><strong>기능 확장</strong>: Jenkins 코어(core)에 없는 새로운 기능을 추가한다. 예를 들어, 특정 버전 관리 시스템(Git, SVN), 빌드 도구(Maven, Gradle), 클라우드 플랫폼(AWS, Azure), 알림 서비스(Slack, Discord) 등과의 연동 기능을 제공한다.</li>
  <li><strong>통합 용이성</strong>: 다양한 개발 및 운영 도구와의 통합을 간소화하여, 복잡한 CI/CD 파이프라인을 쉽게 구축할 수 있도록 돕는다.</li>
  <li><strong>사용자 정의</strong>: 특정 프로젝트나 조직의 요구사항에 맞춰 Jenkins 환경을 사용자 정의할 수 있는 유연성을 제공한다.</li>
  <li><strong>생산성 향상</strong>: 반복적이고 수동적인 작업을 자동화하고, 개발 프로세스의 병목 현상을 제거하여 개발 생산성을 향상시킨다.</li>
</ul>

<h4 id="핵심-플러그인-정리">핵심 플러그인 정리</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">configuration-as-code</code> (Jenkins Configuration as Code Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins의 시스템 설정, 플러그인 설정, 보안 설정 등을 YAML 파일(<code class="language-plaintext highlighter-rouge">casc.yaml</code>)로 정의하고 관리할 수 있도록 한다. 이를 통해 Jenkins 환경을 코드로서 버전 관리하고, 여러 Jenkins 인스턴스 간에 일관된 설정을 적용할 수 있다.</li>
      <li><strong>중요성</strong>: Jenkins 환경의 재현성(reproducibility)과 유지보수성(maintainability)을 크게 향상시켜 DevOps 원칙을 실현하는 데 필수.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">git</code> (Git Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Git 저장소와 Jenkins를 연동하여 소스 코드를 가져오고, Git 관련 작업을 수행할 수 있도록 한다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서 <code class="language-plaintext highlighter-rouge">git credentialsId: GITHUB_CREDS_ID, url: '...', branch: 'main'</code>와 같은 명령을 사용할 수 있게 한다.</li>
      <li><strong>중요성</strong>: 대부분의 현대 소프트웨어 개발에서 Git이 버전 관리 시스템으로 사용되므로, CI/CD 파이프라인의 시작점인 소스 코드 가져오기 기능을 제공하는 핵심 플러그인.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">workflow-aggregator</code> (Pipeline: Aggregator Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins Pipeline 기능을 제공하는 여러 플러그인들의 집합체다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 사용하여 파이프라인을 정의하고 실행할 수 있도록 하는 기반을 마련한다.</li>
      <li><strong>중요성</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 기반의 CI/CD 파이프라인을 구축하는 데 필수적인 플러그인으로, 복잡한 빌드, 테스트, 배포 워크플로우를 코드로 정의할 수 있게 한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">blueocean</code> (Blue Ocean Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins 파이프라인의 실행 과정을 시각적으로 보여주는 현대적이고 사용자 친화적인 UI 플러그인. 파이프라인의 각 단계와 상태를 한눈에 파악하고, 문제 발생 시 디버깅(debugging)을 용이하게 한다.</li>
      <li><strong>중요성</strong>: 파이프라인의 가시성을 높여 개발자와 운영자가 CI/CD 프로세스를 더 쉽게 이해하고 관리할 수 있도록 돕는다.</li>
    </ul>
  </li>
</ul>

<h3 id="jcasc">JCasC</h3>
<h4 id="개념-1">개념</h4>
<p>Jenkins Configuration as Code (JCasC)는 Jenkins의 설정을 YAML 파일과 같은 코드로 정의하고 관리하는 방법론이다. 전통적으로 Jenkins 설정은 웹 UI를 통해 수동으로 이루어졌으며, 이는 설정의 일관성을 유지하기 어렵고, 변경 이력을 추적하기 힘들며, 새로운 Jenkins 인스턴스를 구축할 때마다 동일한 작업을 반복해야 하는 비효율성을 초래했다. JCasC는 이러한 문제점을 해결하고, Jenkins 설정을 소프트웨어 개발의 다른 부분과 마찬가지로 코드로서 관리할 수 있도록 했다.</p>

<h4 id="jcasc의-이유와-장점">JCasC의 이유와 장점</h4>
<ul>
  <li><strong>재현성 (Reproducibility)</strong>: 모든 Jenkins 설정이 코드 파일에 명시되어 있으므로, 언제든지 동일한 Jenkins 환경을 정확하게 재구축할 수 있다. 이는 개발, 테스트, 프로덕션 환경 간의 일관성을 보장한다.</li>
  <li><strong>버전 관리 (Version Control)</strong>: 설정 파일이 Git과 같은 버전 관리 시스템에 저장되므로, 설정 변경 이력을 추적하고, 필요한 경우 이전 버전으로 쉽게 롤백할 수 있다. 이는 설정 변경으로 인한 문제를 해결하는 데 큰 도움이된다.</li>
  <li><strong>자동화 (Automation)</strong>: Jenkins 인스턴스를 프로비저닝(provisioning)하고 설정하는 과정을 자동화할 수 있다. 이는 특히 클라우드 환경에서 Jenkins를 동적으로 생성하고 관리할 때 매우 유용하다.</li>
  <li><strong>협업 강화 (Enhanced Collaboration)</strong>: 여러 개발자나 DevOps 엔지니어가 Jenkins 설정을 함께 검토하고 수정할 수 있으며, 코드 리뷰(code review)를 통해 설정 변경의 투명성과 품질을 높일 수 있다.</li>
  <li><strong>오류 감소 (Reduced Errors)</strong>: 수동 설정 과정에서 발생할 수 있는 인적 오류를 줄이고, 일관된 방식으로 설정을 적용할 수 있다.</li>
  <li><strong>문서화 (Documentation)</strong>: 설정 파일 자체가 Jenkins 환경에 대한 명확하고 최신 상태의 문서 역할을 한다.</li>
</ul>

<h4 id="jcasc-로-설정할-수-있는-주요-기능">JCasC 로 설정할 수 있는 주요 기능</h4>

<p>JCasC를 사용하면 Jenkins의 거의 모든 설정을 YAML 파일로 정의하고 적용할 수 있다.</p>

<ul>
  <li><strong>전역 설정 (Global Settings)</strong>:
    <ul>
      <li>시스템 메시지 (System Message)</li>
      <li>보안 설정 (Security Realm, Authorization Strategy)</li>
      <li>플러그인 관리 (Plugin Manager)</li>
      <li>UI 설정 (Theme, Appearance)</li>
    </ul>
  </li>
  <li><strong>도구 설정 (Tool Configurations)</strong>:
    <ul>
      <li>JDK, Maven, Git 등 빌드에 필요한 도구들의 설치 경로 및 설정</li>
    </ul>
  </li>
  <li><strong>노드 설정 (Node Configurations)</strong>:
    <ul>
      <li>Jenkins 에이전트 (Agent) 노드 추가, 레이블(Label) 설정, 연결 방식 등</li>
    </ul>
  </li>
  <li><strong>작업(Job) 관련 설정</strong>:
    <ul>
      <li>기본 작업 템플릿, 스케줄링 관련 설정 등 (개별 Job 설정은 주로 Jenkinsfile로 관리)</li>
    </ul>
  </li>
  <li><strong>연동 서비스 설정</strong>:
    <ul>
      <li>SCM (Source Code Management) 연동 설정</li>
      <li>알림 서비스 (Discord, Slack 등) 연동 설정</li>
    </ul>
  </li>
</ul>

<p><strong>JCasC 설정 예시 (YAML)</strong></p>

<p>아래는 JCasC를 사용하여 몇 가지 일반적인 설정을 구성하는 예시다. 실제 설정은 Jenkins 버전 및 설치된 플러그인에 따라 달라질 수 있다.</p>

<p><strong>예시 1: 시스템 메시지 및 기본 Executor 설정</strong></p>

<p>이 예시는 Jenkins의 시스템 메시지를 설정하고, 기본 빌드 실행기(Executor)의 수를 지정합니다. 이는 이전 분석 보고서에서 언급된 내용과 관련이 있습니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">systemMessage</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">Welcome to Jenkins! This instance is configured via Jenkins Configuration as Code.</span>
    <span class="s">For any issues, please contact the DevOps team.</span>
  <span class="na">numExecutors</span><span class="pi">:</span> <span class="m">5</span> <span class="c1"># 기본 Executor 수를 5개로 설정</span>
</code></pre></div></div>

<p><strong>예시 2: Git 도구 설정</strong></p>

<p>Jenkins에서 사용할 Git 실행 파일의 경로를 지정하는 예시입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">tool</span><span class="pi">:</span>
  <span class="na">git</span><span class="pi">:</span>
    <span class="na">installations</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Default</span><span class="nv"> </span><span class="s">Git"</span>
        <span class="na">home</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/usr/bin/git"</span> <span class="c1"># 시스템에 설치된 Git 경로</span>
</code></pre></div></div>

<p><strong>예시 3: Jenkins 에이전트 노드 설정</strong></p>

<p>새로운 빌드 에이전트 노드를 추가하고 레이블을 지정하는 예시입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">slaves</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">my-agent-node"</span>
      <span class="na">remoteFS</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/home/jenkins/agent"</span>
      <span class="na">labels</span><span class="pi">:</span> <span class="s2">"</span><span class="s">docker</span><span class="nv"> </span><span class="s">linux"</span>
      <span class="na">mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">NORMAL"</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hudson.slaves.DumbSlave"</span>
      <span class="na">launcher</span><span class="pi">:</span>
        <span class="na">ssh</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s2">"</span><span class="s">your-agent-host.example.com"</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s2">"</span><span class="s">jenkins"</span>
          <span class="na">privateKey</span><span class="pi">:</span>
            <span class="na">credentialsId</span><span class="pi">:</span> <span class="s2">"</span><span class="s">jenkins-ssh-key"</span> <span class="c1"># Jenkins Credentials에 등록된 SSH 키 ID</span>
</code></pre></div></div>

<p><strong>예시 4: 보안 설정 (익명 접근 비활성화)</strong></p>

<p>익명 사용자의 Jenkins 접근을 비활성화하는 설정입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">securityRealm</span><span class="pi">:</span>
    <span class="c1"># Active Directory, LDAP 등 다른 보안 설정을 사용할 수도 있습니다.</span>
    <span class="c1"># 여기서는 Jenkins 자체 사용자 관리 (Jenkins's own user database)를 가정합니다.</span>
    <span class="na">jenkinsUsers</span><span class="pi">:</span> <span class="pi">[]</span> <span class="c1"># 사용자 DB를 사용하되, 초기에는 비어있음</span>
  <span class="na">authorizationStrategy</span><span class="pi">:</span>
    <span class="na">globalMatrix</span><span class="pi">:</span>
      <span class="c1"># 모든 권한을 가진 Admin 사용자에게만 접근 허용</span>
      <span class="na">permissions</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">Overall/Administer:anonymous"</span> <span class="c1"># 익명 사용자에게 관리자 권한 부여 방지</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">Overall/Administer:authenticated"</span> <span class="c1"># 인증된 사용자에게 관리자 권한 부여 방지 (필요에 따라 조정)</span>
</code></pre></div></div>

<p>이러한 YAML 설정 파일들을 <code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code>과 같은 경로에 저장하고 Jenkins에 적용하면, 해당 설정들이 자동으로 반영된다.</p>

<h4 id="jcasc-문법-및-구조">JCasC 문법 및 구조</h4>

<p>JCasC 설정 파일은 Jenkins의 내부 객체 모델을 YAML 형식으로 매핑한다. 기본적인 YAML 문법 규칙은 다음과 같다.</p>

<ul>
  <li><strong>키-값 쌍 (Key-Value Pairs)</strong>: <code class="language-plaintext highlighter-rouge">키: 값</code> 형태로 데이터를 표현한다. 콜론(<code class="language-plaintext highlighter-rouge">:</code>) 뒤에는 공백이 하나 이상 있어야 한다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">key</span><span class="pi">:</span> <span class="s">value</span>
</code></pre></div>    </div>
  </li>
  <li><strong>들여쓰기 (Indentation)</strong>: 들여쓰기를 사용하여 계층 구조를 나타낸다. 공백만 사용하며, 탭(tab)은 사용할 수 없다. 동일한 레벨의 항목은 동일한 들여쓰기를 가져야 한다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">parent</span><span class="pi">:</span>
  <span class="na">child_key</span><span class="pi">:</span> <span class="s">child_value</span>
</code></pre></div>    </div>
  </li>
  <li><strong>목록 (Lists)</strong>: 하이픈(<code class="language-plaintext highlighter-rouge">-</code>)으로 시작하는 항목들을 사용하여 목록을 표현합니다.
```yaml
fruits:
    <ul>
      <li>Apple</li>
      <li>Banana</li>
      <li>Orange
```</li>
    </ul>
  </li>
  <li><strong>주석 (Comments)</strong>: <code class="language-plaintext highlighter-rouge">#</code>으로 시작하는 줄은 주석으로 처리됩니다.</li>
</ul>

<p>JCasC 설정 파일의 복잡성은 Jenkins 환경 복잡성에 비례해서 증대되고, 그만큼 다 이해하고 작업하는 것은 난이도가 수직 상승하게 된다. 그러나 기본적인 문법과 설정 항목들이 어떻게 매핑되는지를 이해하면 효율적인 관리가 가능하다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (1)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/1-til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (1)" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/1-til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/1-til-jenkins.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h2 id="01-jenkins">01 Jenkins</h2>

<h3 id="개념">개념</h3>
<ul>
  <li>Jenkins는 소프트웨어 개발에서 지속적인 통합(Continuous Integration, CI)과 지속적인 배포(Continuous Deployment, CD)를 자동화하는 데 사용되는 오픈 소스 자동화 서버다.</li>
  <li>개발자가 코드를 변경하고 저장소에 커밋(commit)하면, Jenkins는 자동으로 코드를 빌드(build)하고, 테스트(test)하며, 배포하는 일련의 과정을 수행한다.</li>
  <li>개발 프로세스의 효율성을 높이고, 오류를 조기에 발견하며, 궁극적으로 안정적인 소프트웨어 릴리스(release)를 가능하게 하는 도구이다.
    <h3 id="왜--jenkins-와-같은-전문-툴이-필요한가--지속적인-통합continuous-integrateion-ci">왜  Jenkins 와 같은 전문 툴이 필요한가? : 지속적인 통합(Continuous Integrateion, CI)</h3>
  </li>
  <li><strong>오류 조기 발견</strong>: 코드가 자주 통합되고 테스트되므로, 통합 과정에서 발생하는 오류나 버그를 개발 초기에 발견하고 수정할 수 있다. 이는 문제 해결 비용을 크게 절감한다.</li>
  <li><strong>코드 품질 향상</strong>: 자동화된 테스트를 통해 코드의 일관성과 안정성을 유지하며, 개발자들은 더 높은 품질의 코드를 작성하는 데 집중할 수 있게 만든다.</li>
  <li><strong>개발 생산성 증대</strong>: 수동으로 빌드하고 테스트하는 시간을 줄여 개발자들이 새로운 기능 개발에 더 많은 시간을 할애할 수 있도록 한다.</li>
  <li><strong>팀 협업 강화</strong>: 개발자들이 서로의 코드 변경 사항을 빠르게 공유하고 통합함으로써 팀 전체의 협업 효율성을 높인다.</li>
</ul>

<h3 id="왜-jenkins-와-같은-전문-툴이-필요한가--지속적인-배포continuous-deployment-cd">왜 Jenkins 와 같은 전문 툴이 필요한가? : 지속적인 배포(Continuous Deployment, CD)</h3>
<ul>
  <li><strong>빠른 릴리스 주기</strong>: 새로운 기능이나 버그 수정 사항을 신속하게 사용자에게 제공하여 시장 변화에 빠르게 대응할 수 있다.</li>
  <li><strong>배포 프로세스 자동화</strong>: 수동 배포 과정에서 발생할 수 있는 인적 오류를 제거하고, 배포의 일관성과 신뢰성을 확보한다.</li>
  <li><strong>위험 감소</strong>: 작고 빈번한 배포를 통해 한 번의 배포로 인한 위험 부담을 줄이고, 문제가 발생하더라도 빠르게 롤백(rollback)하거나 수정할 수 있다.</li>
  <li><strong>피드백 루프 단축</strong>: 사용자 피드백을 빠르게 수집하고 다음 개발 주기에 반영함으로써 제품 개선 속도를 높인다.</li>
</ul>

<h3 id="jenkins-의-역할은">Jenkins 의 역할은</h3>
<ul>
  <li><strong>코드 변경 감지</strong>: Git, SVN 등 다양한 버전 관리 시스템(VCS)과 연동하여 코드 저장소의 변경 사항을 지속적으로 감지한다.</li>
  <li><strong>자동 빌드</strong>: 변경된 코드를 자동으로 가져와 컴파일(compile)하고, 필요한 의존성(dependency)을 설치하며, 실행 가능한 아티팩트(artifact)를 생성한다.</li>
  <li><strong>자동 테스트</strong>: 단위 테스트(unit test), 통합 테스트(integration test), 성능 테스트(performance test) 등 다양한 유형의 테스트를 자동으로 실행하여 코드의 품질과 안정성을 검증한다.</li>
  <li><strong>자동 배포</strong>: 테스트를 통과한 아티팩트를 개발, 스테이징(staging), 프로덕션 환경 등 지정된 서버에 자동으로 배포한다.</li>
  <li><strong>파이프라인 오케스트레이션(Orchestration)</strong>: 빌드, 테스트, 배포 등 CI/CD의 모든 단계를 하나의 파이프라인으로 정의하고, 각 단계의 실행 순서와 조건을 관리한다.</li>
  <li><strong>알림 및 보고</strong>: 빌드 및 배포 결과에 대한 성공/실패 알림을 이메일, Slack, Discord 등 다양한 채널로 전송하고, 상세한 보고서를 제공한다.</li>
</ul>

<h3 id="jenkins-의-장점">Jenkins 의 장점</h3>
<ul>
  <li><strong>오픈 소스 및 확장성</strong>: 무료로 사용할 수 있는 오픈 소스이며, 수많은 플러그인을 통해 거의 모든 종류의 빌드, 테스트, 배포 도구와 연동하여 기능을 확장할 수 있다.</li>
  <li><strong>다양한 환경 지원</strong>: Java, Python, Node.js, .NET 등 다양한 프로그래밍 언어와 프레임워크(framework)를 지원하며, Docker, Kubernetes와 같은 컨테이너(container) 기술과도 쉽게 통합된다.</li>
  <li>
    <p><strong>강력한 파이프라인 기능</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 통해 CI/CD 파이프라인을 코드로 정의하고 버전 관리할 수 있어, 파이프라인의 재현성(reproducibility)과 유지보수성(maintainability)을 높다. (예시: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>)
```Groovy
pipeline {
agent any</p>

    <p>environment {
    GHCR_CREDS_ID = ‘ghcr-creds’
    GITHUB_CREDS_ID = ‘github-creds’
    TARGET_SSH_CREDS_ID = ‘a5-localhost-jenkins’</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TARGET_DEPLOY_SERVER = 'GEEKOM-A5-Server'

DISCORD_CREDS_ID = 'discord-webhook-url'
</code></pre></div>    </div>
  </li>
</ul>

<p>// … 중략</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stages {
// code pull
    stage('Checkout') {
        steps {
            echo "1. Get the latest code from GitHub"
            git credentialsId: GITHUB_CREDS_ID, url: 'https://github.com/paul2021-r/project-mini-frontend.git', branch: 'main'
        }
    }
</code></pre></div></div>

<p>// … 중략</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>post {
    success {
        echo "Deployment succeeded. Now send a discord notification."
        script {
            withCredentials([string(credentialsId: DISCORD_CREDS_ID, variable: 'DISCORD_URL')]) {
                def message = "{\"content\": \"🚀 Build Process is successfully finished : **[${env.JOB_NAME}]** - **#${env.BUILD_NUMBER}**\"}"
</code></pre></div></div>

<p>// … 후략</p>

<p>}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
*   **활발한 커뮤니티 지원**: 전 세계적으로 많은 사용자와 개발자들이 활발하게 활동하며, 다양한 문제 해결과 기능 개선에 기여하고 있다. 이는 풍부한 자료와 지원을 받을 수 있다는 장점으로 이어진다.
*   **시각화 및 모니터링**: Blue Ocean과 같은 플러그인을 통해 파이프라인의 실행 과정을 시각적으로 확인하고, 빌드 상태를 실시간으로 모니터링할 수 있다.

### Jenkins 의 아키텍쳐 
- 단일 빌드도 가능하나, 여러 프로젝트를 동시에 처리하는 경우 분산 빌드(Distrivuted Builds) 아키텍처를 활용한다. 이러한 아키텍쳐는 컨트롤러와 노드로 구분되며 각기 역할을 분담하면 Jenkins 의 확장성, 효율성에 도움이 된다. 단, 어디까지나 시스템과 리소스의 상황에 따라 최적화 시키는것이 중요하다. 
#### Jenkins Master(컨트롤러)
   - **작업 스케줄링 및 관리**: 빌드 작업을 언제, 어떤 Agent에서 실행할지 결정하고, 전체 파이프라인의 흐름을 관리한다. 
*   **Agent 연결 관리**: 등록된 Agent들과의 연결을 유지하고, Agent의 상태를 모니터링한다.
*   **설정 및 플러그인 관리**: Jenkins의 전반적인 설정, 사용자 관리, 보안 설정, 그리고 설치된 플러그인들을 관리합니다. `project-mini-jenkins` 프로젝트의 `jenkins/casc.yaml` 파일은 Master의 설정을 코드로 관리하는 예시입니다.
*   **빌드 결과 저장**: 빌드 로그, 테스트 결과, 아티팩트 등 빌드 관련 데이터를 저장하고 관리한다.
*   **UI 제공**: 웹 인터페이스를 통해 사용자에게 Jenkins의 모든 기능과 빌드 현황을 제공합한다.

#### Jenkins Agent(노드/ 실행기)
*   **작업 실행**: Master로부터 전달받은 빌드 스크립트(예: `Jenkinsfile`에 정의된 `sh` 명령어)를 실행하여 코드 빌드, 테스트, 배포 등의 작업을 수행한다. 
*   **다양한 환경 지원**: Agent는 물리 서버, 가상 머신(VM), Docker 컨테이너 등 다양한 형태로 구성될 수 있다. 각 Agent는 특정 운영체제, 소프트웨어 버전, 라이브러리 등 특정 빌드 환경을 제공 일정하게 제공할 수 있다.
*   **확장성**: 필요한 경우 Agent를 추가하여 Jenkins 시스템의 처리 용량을 쉽게 확장할 수 있다. 이는 동시에 더 많은 빌드 작업을 처리하거나, 특정 환경이 필요한 작업을 분리하여 실행하는 데 유용하다.
*   **격리된 환경**: 각 Agent는 독립적인 환경에서 작업을 수행하므로, 한 Agent에서 실행되는 작업이 다른 Agent의 작업에 영향을 미치지 않는다. 이는 빌드 환경의 일관성과 안정성을 보장해줘, 서로의 충돌이나 호스트 OS에 영향을 주지 않을 수 있다.

#### 분산 빌드(Distributed Builds, Master-Slave)
- Jenkins 마스터와 하나 이상의 Agent를 준비하고, 빌드를 하여 여러 머신에 분산하여 처리하는 방법을 의미한다. 이 방식의 이점은 아래와 같다. 

*   **부하 분산 (Load Balancing)**: Master의 부하를 줄이고, 빌드 작업을 여러 Agent에 분산하여 동시에 더 많은 작업을 처리할 수 있다. 이는 빌드 큐(queue)를 줄이고 전체 CI/CD 파이프라인의 처리량을 증가시킨다.
*   **환경 격리 (Environment Isolation)**: 각 Agent가 독립적인 빌드 환경을 제공하므로, 서로 다른 프로젝트나 다른 버전의 소프트웨어가 필요한 빌드 작업을 충돌 없이 실행할 수 있다. 예를 들어, 한 Agent는 Java 8 환경에서 빌드하고, 다른 Agent는 Node.js 18 환경에서 빌드할 수 있다.
*   **확장성 (Scalability)**: 빌드 요구사항이 증가함에 따라 Agent를 쉽게 추가하거나 제거할 수 있어, Jenkins 시스템의 확장성을 유연하게 관리할 수 있다.
*   **안정성 (Reliability)**: 특정 Agent에 문제가 발생하더라도 다른 Agent에서 작업을 계속 수행할 수 있으므로, 전체 CI/CD 시스템의 안정성이 향상된다.

- `project-mini-frontend` 프로젝트는 jenkins 시스템을 활용하고, `Jenkinsfile`을 이용하여 Host 서버에서 Docker 컨테이너로 구성되어 있다. 또한 Jenkins 컨테이너는 DooD(Docker-out-of-Docker) 패턴을 통해 Jenkins Master 컨테이너 자체가 Agent 역할을 겸한다. 
- 그러나 여기에 다른 서버를 추가한다면, Master 와 Agent 를 분리할 수 있고, 특히 용도와 리소스에 맞게 분리한다면 서버의 역할에 따라 빌드하는 노드를 별도로 가져갈 수도 있고, 안정성을  더 강화할 수도 있다.

### Docker 를 이용한 Jenkins 설치 
- Jenkins를 Docker 컨테이너로 설치하는 것은 환경 설정의 일관성을 보장하고, 배포 및 관리를 용이하게 하는 현대적인 방법이다.
- 또한 컨테이너화 함을 통해, Jenkins 환경을 모듈화시킬 수 있어 다양한 리소스에 이식할 수 있고, 또 동일한 CICD 환경 구축을 가능케한다.
- 다양한 패턴이 있겠지만, 많지 않은 리소스 상황, 그리고 Host 의 자원을 완전하게 이용하기 위하여 Jenkins Master 컨테이너가 안에서 Host 의 도커를 조작할 수 있도록 하는 DooD 패턴을 이번 프로젝트에 활용했다. 이를 통해 환경 구축과 내용의 격리는 컨테이너 내에 이루었지만, 실제 빌드는 Host 에서 구성되는 형태를 취한다.

#### DooD 를 위한 docker-compose.yml

```yaml
# project-mini-jenkins/docker-compose.yml
services:
  jenkins:
    build:
      context: jenkins
    container_name: jenkins-server
    ports:
      - "12345:8080"
    volumes:
      - ./jenkins_home:/var/jenkins_home
      # Docker CLI 사용을 위해 호스트로 마운트
      - /var/run/docker.sock:/var/run/docker.sock
      - /usr/bin/docker:/usr/bin/docker
      - /usr/bin/docker-compose:/usr/bin/docker-compose
    environment:
      - CASC_JENKINS_CONFIG=/var/jenkins_home/casc.yaml
    entrypoint: &gt;
      bash -c "
        cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;
        /usr/bin/tini -- /usr/local/bin/jenkins.sh
      "
</code></pre></div></div>

<p>주요 내용은 다음과 같다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">build</code></strong>: <code class="language-plaintext highlighter-rouge">context: jenkins</code>는 <code class="language-plaintext highlighter-rouge">jenkins</code> 디렉토리 내의 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 사용하여 이미지를 빌드하도록 지시한다.</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">container_name</code></strong>: 컨테이너 이름을 <code class="language-plaintext highlighter-rouge">jenkins-server</code>로 지정하여 쉽게 식별할 수 있도록 했다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ports</code></strong>: 호스트의 <code class="language-plaintext highlighter-rouge">12345</code> 포트를 컨테이너의 <code class="language-plaintext highlighter-rouge">8080</code> 포트(Jenkins 기본 포트)에 매핑하여 외부에서 Jenkins에 접근할 수 있도록 하고, 자주 사용되는 포트 점유를 피한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">volumes</code></strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">./jenkins_home:/var/jenkins_home</code>: Jenkins의 데이터(설정, 빌드 기록, 플러그인 등)를 호스트의 <code class="language-plaintext highlighter-rouge">jenkins_home</code> 디렉토리에 영구적으로 저장하도록 마운트한다. 이는 컨테이너가 삭제되더라도 데이터가 보존되도록 하며, 명시적으로 해당 폴더에 남기에, 해당 데이터를 이동하면 다른 서버로 이식이 용이하다.</li>
      <li><code class="language-plaintext highlighter-rouge">/var/run/docker.sock:/var/run/docker.sock</code>: 호스트의 Docker 소켓을 컨테이너 내부에 마운트한다. 이 설정은 Jenkins 컨테이너가 호스트의 Docker 데몬과 통신하여 Docker 명령어를 실행할 수 있도록 하는 DooD 패턴의 핵심으로, 공유되지 않으면 내부에서 외부로의 조종이 불가능하다.</li>
      <li><code class="language-plaintext highlighter-rouge">/usr/bin/docker:/usr/bin/docker</code>, <code class="language-plaintext highlighter-rouge">/usr/bin/docker-compose:/usr/bin/docker-compose</code>: 호스트의 Docker 및 Docker Compose 바이너리를 컨테이너 내부에 마운트하여 Jenkins가 이들을 직접 사용할 수 있도록 했다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">environment</code></strong>: <code class="language-plaintext highlighter-rouge">CASC_JENKINS_CONFIG</code> 환경 변수를 설정하여 JCasC 설정 파일의 경로를 지정한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">entrypoint</code></strong>: Jenkins 컨테이너가 시작될 때 <code class="language-plaintext highlighter-rouge">casc.yaml</code> 파일을 <code class="language-plaintext highlighter-rouge">jenkins_home</code>으로 복사하고 Jenkins를 실행하는 스크립트를 정의하였다. 해당 entrypoint 설정은 Dockerfile의 기본 설정이 있더라도, 이를 무시하고 덮어씌워진다.</li>
</ul>

<h3 id="jenkins-초기-설정">Jenkins 초기 설정</h3>

<h4 id="초기-관리자-비밀번호-확인">초기 관리자 비밀번호 확인</h4>

<ol>
  <li><strong>Jenkins 컨테이너 실행</strong>: <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 명령으로 Jenkins 컨테이너를 실행한다.</li>
  <li><strong>로그 확인</strong>: 다음 명령어를 사용하여 Jenkins 컨테이너의 로그를 확인한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs jenkins-server
</code></pre></div>    </div>
    <p>로그 출력에서 <code class="language-plaintext highlighter-rouge">Please use the following password to proceed to installation:</code> 또는 유사한 메시지 뒤에 나오는 긴 문자열이 초기 관리자 비밀번호다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************
</code></pre></div>    </div>
    <p>(여기서 <code class="language-plaintext highlighter-rouge">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code> 부분이 실제 비밀번호다.)</p>
  </li>
</ol>

<h4 id="초기-설정-진행-절차">초기 설정 진행 절차</h4>

<ol>
  <li><strong>Jenkins 웹 인터페이스 접속</strong>: 웹 브라우저를 열고 <code class="language-plaintext highlighter-rouge">http://localhost:12345</code> (또는 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에 설정된 포트)로 접속.</li>
  <li><strong>관리자 비밀번호 입력</strong>: 위에서 확인한 초기 관리자 비밀번호를 입력하고 <code class="language-plaintext highlighter-rouge">Continue</code>를 클릭</li>
  <li><strong>플러그인 설치</strong>: <code class="language-plaintext highlighter-rouge">Install suggested plugins</code>를 선택하여 권장 플러그인을 설치하거나, <code class="language-plaintext highlighter-rouge">Select plugins to install</code>을 선택하여 필요한 플러그인만 설치할 수 있다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트의 <code class="language-plaintext highlighter-rouge">jenkins/plugins.txt</code>와 <code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code>을 사용한다면, 플러그인과 기본 설정은 자동으로 적용된다.</li>
  <li><strong>관리자 계정 생성</strong>: 초기 관리자 비밀번호를 사용한 후, 새로운 관리자 계정(사용자 이름, 비밀번호, 이름, 이메일)을 생성한다. 이 계정은 이후 Jenkins에 로그인할 때 사용된다.</li>
  <li><strong>Jenkins URL 설정</strong>: Jenkins 인스턴스의 URL을 설정합니다. 기본값으로 두거나 필요에 따라 변경할 수 있다.</li>
</ol>

<p>이 과정을 통해 Jenkins 서버의 초기 설정이 완료되며, CI/CD 파이프라인을 구축하고 관리할 준비가 된다. 단 여기서 중요한 지점으로,</p>

<p>1) 실제 프로젝트를 위한 플러그인을 설치할 것이 무엇이 있는지 판단 및 밑설치를 미리 해둬야 예상외의 발생 에러를 잡을 수 있다. 최초 설치시 아주 기본적인 내용만 있고, 빌드 자체를 위한 도구 정도만 설치됨. 이에 dockerfile 을 통해 컨테이너 내부에서 조작할 도구들과, jenkins 자체를 위한 플러그인(예, ssh agent)등을 정확하게 보고 미리 설치해놓아야 한다. 
2) 외부에서 신호를 수신하여 동작하는 등의 것이 있을 경우, HTTPS 를 통한 외부 접속 통로를 확보해둔 설계가 필요할 수 있다. GitHub 의 웹훅이나, 다양한 도구들의 연결 시 HTTPS 가 필수인 경우가 많다. 이를 고려하지 않은 설계가 되면 완전 자동화를 만들기 어려울 수 있다. (수동 호출 및 빌드는 HTTP 환경으로도 충분)</p>

<h3 id="jenkins-plugin">Jenkins Plugin</h3>

<h4 id="역할">역할</h4>
<ul>
  <li><strong>기능 확장</strong>: Jenkins 코어(core)에 없는 새로운 기능을 추가한다. 예를 들어, 특정 버전 관리 시스템(Git, SVN), 빌드 도구(Maven, Gradle), 클라우드 플랫폼(AWS, Azure), 알림 서비스(Slack, Discord) 등과의 연동 기능을 제공한다.</li>
  <li><strong>통합 용이성</strong>: 다양한 개발 및 운영 도구와의 통합을 간소화하여, 복잡한 CI/CD 파이프라인을 쉽게 구축할 수 있도록 돕는다.</li>
  <li><strong>사용자 정의</strong>: 특정 프로젝트나 조직의 요구사항에 맞춰 Jenkins 환경을 사용자 정의할 수 있는 유연성을 제공한다.</li>
  <li><strong>생산성 향상</strong>: 반복적이고 수동적인 작업을 자동화하고, 개발 프로세스의 병목 현상을 제거하여 개발 생산성을 향상시킨다.</li>
</ul>

<h4 id="핵심-플러그인-정리">핵심 플러그인 정리</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">configuration-as-code</code> (Jenkins Configuration as Code Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins의 시스템 설정, 플러그인 설정, 보안 설정 등을 YAML 파일(<code class="language-plaintext highlighter-rouge">casc.yaml</code>)로 정의하고 관리할 수 있도록 한다. 이를 통해 Jenkins 환경을 코드로서 버전 관리하고, 여러 Jenkins 인스턴스 간에 일관된 설정을 적용할 수 있다.</li>
      <li><strong>중요성</strong>: Jenkins 환경의 재현성(reproducibility)과 유지보수성(maintainability)을 크게 향상시켜 DevOps 원칙을 실현하는 데 필수.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">git</code> (Git Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Git 저장소와 Jenkins를 연동하여 소스 코드를 가져오고, Git 관련 작업을 수행할 수 있도록 한다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서 <code class="language-plaintext highlighter-rouge">git credentialsId: GITHUB_CREDS_ID, url: '...', branch: 'main'</code>와 같은 명령을 사용할 수 있게 한다.</li>
      <li><strong>중요성</strong>: 대부분의 현대 소프트웨어 개발에서 Git이 버전 관리 시스템으로 사용되므로, CI/CD 파이프라인의 시작점인 소스 코드 가져오기 기능을 제공하는 핵심 플러그인.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">workflow-aggregator</code> (Pipeline: Aggregator Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins Pipeline 기능을 제공하는 여러 플러그인들의 집합체다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 사용하여 파이프라인을 정의하고 실행할 수 있도록 하는 기반을 마련한다.</li>
      <li><strong>중요성</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 기반의 CI/CD 파이프라인을 구축하는 데 필수적인 플러그인으로, 복잡한 빌드, 테스트, 배포 워크플로우를 코드로 정의할 수 있게 한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">blueocean</code> (Blue Ocean Plugin)</strong>:
    <ul>
      <li><strong>기능</strong>: Jenkins 파이프라인의 실행 과정을 시각적으로 보여주는 현대적이고 사용자 친화적인 UI 플러그인. 파이프라인의 각 단계와 상태를 한눈에 파악하고, 문제 발생 시 디버깅(debugging)을 용이하게 한다.</li>
      <li><strong>중요성</strong>: 파이프라인의 가시성을 높여 개발자와 운영자가 CI/CD 프로세스를 더 쉽게 이해하고 관리할 수 있도록 돕는다.</li>
    </ul>
  </li>
</ul>

<h3 id="jcasc">JCasC</h3>
<h4 id="개념-1">개념</h4>
<p>Jenkins Configuration as Code (JCasC)는 Jenkins의 설정을 YAML 파일과 같은 코드로 정의하고 관리하는 방법론이다. 전통적으로 Jenkins 설정은 웹 UI를 통해 수동으로 이루어졌으며, 이는 설정의 일관성을 유지하기 어렵고, 변경 이력을 추적하기 힘들며, 새로운 Jenkins 인스턴스를 구축할 때마다 동일한 작업을 반복해야 하는 비효율성을 초래했다. JCasC는 이러한 문제점을 해결하고, Jenkins 설정을 소프트웨어 개발의 다른 부분과 마찬가지로 코드로서 관리할 수 있도록 했다.</p>

<h4 id="jcasc의-이유와-장점">JCasC의 이유와 장점</h4>
<ul>
  <li><strong>재현성 (Reproducibility)</strong>: 모든 Jenkins 설정이 코드 파일에 명시되어 있으므로, 언제든지 동일한 Jenkins 환경을 정확하게 재구축할 수 있다. 이는 개발, 테스트, 프로덕션 환경 간의 일관성을 보장한다.</li>
  <li><strong>버전 관리 (Version Control)</strong>: 설정 파일이 Git과 같은 버전 관리 시스템에 저장되므로, 설정 변경 이력을 추적하고, 필요한 경우 이전 버전으로 쉽게 롤백할 수 있다. 이는 설정 변경으로 인한 문제를 해결하는 데 큰 도움이된다.</li>
  <li><strong>자동화 (Automation)</strong>: Jenkins 인스턴스를 프로비저닝(provisioning)하고 설정하는 과정을 자동화할 수 있다. 이는 특히 클라우드 환경에서 Jenkins를 동적으로 생성하고 관리할 때 매우 유용하다.</li>
  <li><strong>협업 강화 (Enhanced Collaboration)</strong>: 여러 개발자나 DevOps 엔지니어가 Jenkins 설정을 함께 검토하고 수정할 수 있으며, 코드 리뷰(code review)를 통해 설정 변경의 투명성과 품질을 높일 수 있다.</li>
  <li><strong>오류 감소 (Reduced Errors)</strong>: 수동 설정 과정에서 발생할 수 있는 인적 오류를 줄이고, 일관된 방식으로 설정을 적용할 수 있다.</li>
  <li><strong>문서화 (Documentation)</strong>: 설정 파일 자체가 Jenkins 환경에 대한 명확하고 최신 상태의 문서 역할을 한다.</li>
</ul>

<h4 id="jcasc-로-설정할-수-있는-주요-기능">JCasC 로 설정할 수 있는 주요 기능</h4>

<p>JCasC를 사용하면 Jenkins의 거의 모든 설정을 YAML 파일로 정의하고 적용할 수 있다.</p>

<ul>
  <li><strong>전역 설정 (Global Settings)</strong>:
    <ul>
      <li>시스템 메시지 (System Message)</li>
      <li>보안 설정 (Security Realm, Authorization Strategy)</li>
      <li>플러그인 관리 (Plugin Manager)</li>
      <li>UI 설정 (Theme, Appearance)</li>
    </ul>
  </li>
  <li><strong>도구 설정 (Tool Configurations)</strong>:
    <ul>
      <li>JDK, Maven, Git 등 빌드에 필요한 도구들의 설치 경로 및 설정</li>
    </ul>
  </li>
  <li><strong>노드 설정 (Node Configurations)</strong>:
    <ul>
      <li>Jenkins 에이전트 (Agent) 노드 추가, 레이블(Label) 설정, 연결 방식 등</li>
    </ul>
  </li>
  <li><strong>작업(Job) 관련 설정</strong>:
    <ul>
      <li>기본 작업 템플릿, 스케줄링 관련 설정 등 (개별 Job 설정은 주로 Jenkinsfile로 관리)</li>
    </ul>
  </li>
  <li><strong>연동 서비스 설정</strong>:
    <ul>
      <li>SCM (Source Code Management) 연동 설정</li>
      <li>알림 서비스 (Discord, Slack 등) 연동 설정</li>
    </ul>
  </li>
</ul>

<p><strong>JCasC 설정 예시 (YAML)</strong></p>

<p>아래는 JCasC를 사용하여 몇 가지 일반적인 설정을 구성하는 예시다. 실제 설정은 Jenkins 버전 및 설치된 플러그인에 따라 달라질 수 있다.</p>

<p><strong>예시 1: 시스템 메시지 및 기본 Executor 설정</strong></p>

<p>이 예시는 Jenkins의 시스템 메시지를 설정하고, 기본 빌드 실행기(Executor)의 수를 지정합니다. 이는 이전 분석 보고서에서 언급된 내용과 관련이 있습니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">systemMessage</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">Welcome to Jenkins! This instance is configured via Jenkins Configuration as Code.</span>
    <span class="s">For any issues, please contact the DevOps team.</span>
  <span class="na">numExecutors</span><span class="pi">:</span> <span class="m">5</span> <span class="c1"># 기본 Executor 수를 5개로 설정</span>
</code></pre></div></div>

<p><strong>예시 2: Git 도구 설정</strong></p>

<p>Jenkins에서 사용할 Git 실행 파일의 경로를 지정하는 예시입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">tool</span><span class="pi">:</span>
  <span class="na">git</span><span class="pi">:</span>
    <span class="na">installations</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Default</span><span class="nv"> </span><span class="s">Git"</span>
        <span class="na">home</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/usr/bin/git"</span> <span class="c1"># 시스템에 설치된 Git 경로</span>
</code></pre></div></div>

<p><strong>예시 3: Jenkins 에이전트 노드 설정</strong></p>

<p>새로운 빌드 에이전트 노드를 추가하고 레이블을 지정하는 예시입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">slaves</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">my-agent-node"</span>
      <span class="na">remoteFS</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/home/jenkins/agent"</span>
      <span class="na">labels</span><span class="pi">:</span> <span class="s2">"</span><span class="s">docker</span><span class="nv"> </span><span class="s">linux"</span>
      <span class="na">mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">NORMAL"</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hudson.slaves.DumbSlave"</span>
      <span class="na">launcher</span><span class="pi">:</span>
        <span class="na">ssh</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s2">"</span><span class="s">your-agent-host.example.com"</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s2">"</span><span class="s">jenkins"</span>
          <span class="na">privateKey</span><span class="pi">:</span>
            <span class="na">credentialsId</span><span class="pi">:</span> <span class="s2">"</span><span class="s">jenkins-ssh-key"</span> <span class="c1"># Jenkins Credentials에 등록된 SSH 키 ID</span>
</code></pre></div></div>

<p><strong>예시 4: 보안 설정 (익명 접근 비활성화)</strong></p>

<p>익명 사용자의 Jenkins 접근을 비활성화하는 설정입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">securityRealm</span><span class="pi">:</span>
    <span class="c1"># Active Directory, LDAP 등 다른 보안 설정을 사용할 수도 있습니다.</span>
    <span class="c1"># 여기서는 Jenkins 자체 사용자 관리 (Jenkins's own user database)를 가정합니다.</span>
    <span class="na">jenkinsUsers</span><span class="pi">:</span> <span class="pi">[]</span> <span class="c1"># 사용자 DB를 사용하되, 초기에는 비어있음</span>
  <span class="na">authorizationStrategy</span><span class="pi">:</span>
    <span class="na">globalMatrix</span><span class="pi">:</span>
      <span class="c1"># 모든 권한을 가진 Admin 사용자에게만 접근 허용</span>
      <span class="na">permissions</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">Overall/Administer:anonymous"</span> <span class="c1"># 익명 사용자에게 관리자 권한 부여 방지</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">Overall/Administer:authenticated"</span> <span class="c1"># 인증된 사용자에게 관리자 권한 부여 방지 (필요에 따라 조정)</span>
</code></pre></div></div>

<p>이러한 YAML 설정 파일들을 <code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code>과 같은 경로에 저장하고 Jenkins에 적용하면, 해당 설정들이 자동으로 반영된다.</p>

<h4 id="jcasc-문법-및-구조">JCasC 문법 및 구조</h4>

<p>JCasC 설정 파일은 Jenkins의 내부 객체 모델을 YAML 형식으로 매핑한다. 기본적인 YAML 문법 규칙은 다음과 같다.</p>

<ul>
  <li><strong>키-값 쌍 (Key-Value Pairs)</strong>: <code class="language-plaintext highlighter-rouge">키: 값</code> 형태로 데이터를 표현한다. 콜론(<code class="language-plaintext highlighter-rouge">:</code>) 뒤에는 공백이 하나 이상 있어야 한다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">key</span><span class="pi">:</span> <span class="s">value</span>
</code></pre></div>    </div>
  </li>
  <li><strong>들여쓰기 (Indentation)</strong>: 들여쓰기를 사용하여 계층 구조를 나타낸다. 공백만 사용하며, 탭(tab)은 사용할 수 없다. 동일한 레벨의 항목은 동일한 들여쓰기를 가져야 한다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">parent</span><span class="pi">:</span>
  <span class="na">child_key</span><span class="pi">:</span> <span class="s">child_value</span>
</code></pre></div>    </div>
  </li>
  <li><strong>목록 (Lists)</strong>: 하이픈(<code class="language-plaintext highlighter-rouge">-</code>)으로 시작하는 항목들을 사용하여 목록을 표현합니다.
```yaml
fruits:
    <ul>
      <li>Apple</li>
      <li>Banana</li>
      <li>Orange
```</li>
    </ul>
  </li>
  <li><strong>주석 (Comments)</strong>: <code class="language-plaintext highlighter-rouge">#</code>으로 시작하는 줄은 주석으로 처리됩니다.</li>
</ul>

<p>JCasC 설정 파일의 복잡성은 Jenkins 환경 복잡성에 비례해서 증대되고, 그만큼 다 이해하고 작업하는 것은 난이도가 수직 상승하게 된다. 그러나 기본적인 문법과 설정 항목들이 어떻게 매핑되는지를 이해하면 효율적인 관리가 가능하다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (2)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/2-til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (2)" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/2-til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/2-til-jenkins.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h3 id="jenkins-파이프라인">Jenkins 파이프라인</h3>
<h4 id="개념">개념</h4>
<ul>
  <li>파이프라인은 소프트웨어의 빌드, 테스트, 배포 과정을 자동화하는 일련의 단계를 코드로 정의한 것이다.</li>
  <li>Jenkins Pipeline은 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>이라는 텍스트 파일에 정의되며, 이 파일은 프로젝트의 소스 코드 저장소에 함께 저장된다. 이를 통해 파이프라인 자체도 코드로서 관리(Pipeline as Code)되어, 소프트웨어 개발의 다른 부분과 마찬가지로 버전 관리, 코드 리뷰, 변경 이력 추적 등의 이점을 얻을 수 있다.</li>
</ul>

<h4 id="declarative-pipeline-vs-scripted-pipeline">Declarative Pipeline vs Scripted Pipeline</h4>
<ul>
  <li><strong>Declarative Pipeline (선언형 파이프라인)</strong>:
    <ul>
      <li><strong>특징</strong>: 구조화된 블록(<code class="language-plaintext highlighter-rouge">pipeline</code>, <code class="language-plaintext highlighter-rouge">agent</code>, <code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">stage</code>, <code class="language-plaintext highlighter-rouge">steps</code> 등)을 사용하여 파이프라인을 정의한다. 미리 정의된 구조와 키워드를 사용하여 파이프라인의 흐름을 명확하고 간결하게 선언하는 방식이다. Groovy 스크립팅에 대한 깊은 지식 없이도 쉽게 작성하고 이해할 수 있는 편이다.</li>
      <li><strong>장점</strong>: 가독성이 높고, 배우기 쉬우며, Jenkins UI에서 시각적으로 파이프라인을 쉽게 이해할 수 있다. 복잡한 로직보다는 표준화된 CI/CD 흐름에 적합하다.</li>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 Declarative Pipeline의 대표적인 예시다.</li>
    </ul>

    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Declarative Pipeline 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span> <span class="c1">// 에이전트를 지정</span>
    <span class="n">environment</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// 전역 환경을 설정 역할을 한다</span>
    <span class="n">stages</span> <span class="o">{</span> <span class="c1">// 각 단계를 지정한다</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// checkout</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// 이미지 빌드</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    <span class="n">post</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span> <span class="c1">// 모든 절차가 종료 후 작업</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Scripted Pipeline (스크립트형 파이프라인)</strong>:
    <ul>
      <li><strong>특징</strong>: Groovy 스크립트 언어를 사용하여 파이프라인의 모든 로직을 직접 작성한다. <code class="language-plaintext highlighter-rouge">node</code> 블록 내에서 자유로운 Groovy 문법과 Jenkins DSL(Domain Specific Language)을 활용하여 복잡하고 동적인 파이프라인을 구현할 수 있다.</li>
      <li><strong>장점</strong>: 매우 유연하고 강력하며, 복잡한 조건부 로직, 루프, 예외 처리 등 고급 프로그래밍 기능을 활용할 수 있다. 특정 요구사항에 맞춰 파이프라인을 세밀하게 제어해야 할 때 유용하다.(실질 빌드 작업을 프로그래밍 하듯이 다 만드는 구조니깐)</li>
      <li><strong>단점</strong>: Groovy 언어에 대한 이해가 필요하며, 가독성이 Declarative Pipeline보다 낮을 수 있다.</li>
    </ul>
  </li>
</ul>

<p>현대 Jenkins Pipeline 개발에서는 Declarative Pipeline이 더 권장한다. 대부분의 CI/CD 요구사항을 충족하며, 유지보수가 용이하고 팀원 간의 협업에 더 적합하기 때문이다. Scripted Pipeline은 Declarative Pipeline으로 구현하기 어려운 특정 고급 시나리오에서 보조적으로 사용될 수 있다. (빌드 절차 과정에서 유동성이 필요한 작업이 포함된다면 특히나 스크립트형으로 작성이 실질 더 편할 수 있으니까)</p>

<h4 id="jenkinsfile-의-역할과-중요성">Jenkinsfile 의 역할과 중요성</h4>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>은 Jenkins Pipeline의 핵심이며, CI/CD 파이프라인의 모든 단계를 코드로 정의한 파일이다. 이 파일은 프로젝트의 소스 코드 저장소의 루트 디렉토리(또는 지정된 경로)에 위치하며, Jenkins는 이 파일을 읽고 파이프라인을 실행한다.</p>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 역할과 중요성은 다음과 같다.</p>

<ul>
  <li><strong>Pipeline as Code (코드형 파이프라인)</strong>: 파이프라인 정의가 코드화되어 Git과 같은 버전 관리 시스템에 저장하는게 낫다. 이는 파이프라인의 변경 이력을 추적하고, 코드 리뷰를 통해 품질을 관리하며, 필요한 경우 이전 버전으로 롤백할 수 있도록 한다.</li>
  <li><strong>재현 가능한 CI/CD 환경</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 하나만 있으면 어떤 Jenkins 인스턴스에서도 동일한 CI/CD 파이프라인을 구축하고 실행할 수 있다. 이는 환경 간의 일관성을 보장하고, 새로운 프로젝트 온보딩(onboarding)을 간소화한다.</li>
  <li><strong>개발자와 운영자의 협업</strong>: 개발자는 코드와 함께 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 관리하며, 운영자는 이 파일을 통해 배포 프로세스를 이해하고 개선할 수 있다. 이는 개발(Dev)과 운영(Ops) 간의 경계를 허물고 협업을 강화한다.</li>
  <li><strong>유연성과 확장성</strong>: <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>은 Groovy 언어의 강력한 기능을 활용하여 복잡한 로직과 다양한 도구 통합을 지원한다. 이를 통해 프로젝트의 특정 요구사항에 맞춰 파이프라인을 유연하게 확장하고 커스터마이징(customizing)할 수 있다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 실제 프로젝트에서 코드 체크아웃, Docker 이미지 빌드, GHCR(GitHub Container Registry) 푸시, 그리고 Blue/Green 배포 전략을 포함한 서버 배포 단계를 명확하게 정의하고 있고, 이를 통해 수동 빌드와 배포의 과정을 읽고 모사한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (일부 발췌)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span>
    
    <span class="n">environment</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

    <span class="n">stages</span> <span class="o">{</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Deploy to Server'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
    <span class="o">}</span>
   
    <span class="n">post</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>은 CI/CD 파이프라인의 ‘설계도’이자 ‘실행 스크립트’로서, 현대 소프트웨어 개발에서 자동화된 배포 프로세스를 구축하는 데 필수적인 역할을 수행한다.</p>

<h3 id="pipeline-문법-및-구조-간단-정리">Pipeline 문법 및 구조 간단 정리</h3>

<p>Jenkins Declarative Pipeline은 구조화된 블록과 지시어(Directive)를 사용하여 CI/CD 파이프라인을 정의한다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>을 예시로 각 주요 블록과 지시어의 역할에 대해 설명한다.</p>

<h4 id="pipeline-블록"><code class="language-plaintext highlighter-rouge">pipeline</code> 블록</h4>

<p><code class="language-plaintext highlighter-rouge">pipeline</code> 블록은 Declarative Pipeline의 최상위 요소이며, 모든 파이프라인 정의를 감싸는 컨테이너다. 이 블록 내부에 <code class="language-plaintext highlighter-rouge">agent</code>, <code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">post</code> 등 파이프라인의 모든 구성 요소가 포함된다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 시작과 끝을 정의하며, 전체 파이프라인의 구조를 명시한다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 시작 부분은 <code class="language-plaintext highlighter-rouge">pipeline { ... }</code>으로 구성된다.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile</span>
<span class="n">pipeline</span> <span class="o">{</span> <span class="c1">// 문서 시작을 알리는 부분</span>
    <span class="n">agent</span> <span class="n">any</span>
    
    <span class="n">environment</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

    <span class="n">stages</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
   
    <span class="n">post</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="agent-지시어-directive"><code class="language-plaintext highlighter-rouge">agent</code> 지시어 (Directive)</h4>

<p><code class="language-plaintext highlighter-rouge">agent</code> 지시어는 파이프라인 또는 특정 <code class="language-plaintext highlighter-rouge">stage</code>가 실행될 Jenkins Agent(노드)를 지정한다. 이는 빌드 작업을 수행할 환경을 정의하는 데 사용된다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 각 단계가 실행될 물리적 또는 가상 환경을 선언한다.</li>
  <li><strong>유형</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">any</code>: 사용 가능한 모든 Agent에서 파이프라인을 실행한다.</li>
      <li><code class="language-plaintext highlighter-rouge">none</code>: 파이프라인 레벨에서는 Agent를 지정하지 않고, 각 <code class="language-plaintext highlighter-rouge">stage</code>에서 개별적으로 <code class="language-plaintext highlighter-rouge">agent</code>를 지정한다.</li>
      <li><code class="language-plaintext highlighter-rouge">label 'your-label'</code>: 특정 라벨이 지정된 Agent에서 실행 (예: <code class="language-plaintext highlighter-rouge">agent { label 'docker-node-with-host-docker' }</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">docker { image '...' }</code>: Docker 이미지를 사용하여 임시 컨테이너에서 <code class="language-plaintext highlighter-rouge">stage</code>를 실행</li>
    </ul>
  </li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">agent any</code>를 사용하여 파이프라인의 모든 단계가 사용 가능한 Agent에서 실행되도록 했다</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (agent 지시어 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span> <span class="c1">// 파이프라인의 모든 단계가 사용 가능한 Agent에서 실행됩니다.</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="environment-블록-환경-변수-관리"><code class="language-plaintext highlighter-rouge">environment</code> 블록 (환경 변수 관리)</h4>

<p><code class="language-plaintext highlighter-rouge">environment</code> 블록은 파이프라인 전체 또는 특정 <code class="language-plaintext highlighter-rouge">stage</code>에서 사용할 환경 변수를 정의한다. 이는 빌드 스크립트 내에서 재사용 가능한 값이나 민감한 정보를 안전하게 관리하는 데 유용한 역할을 한다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인 실행 중에 접근할 수 있는 환경 변수를 선언</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 GHCR 자격 증명 ID, GitHub 자격 증명 ID, SSH 자격 증명 ID, 배포 서버 정보, Discord 웹훅 URL, 이미지 이름, SSH 호스트 및 포트, 프로젝트 경로 등 다양한 환경 변수를 정의</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (environment 블록 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="n">agent</span> <span class="n">any</span>
    
    <span class="n">environment</span> <span class="o">{</span>
        <span class="n">GHCR_CREDS_ID</span> <span class="o">=</span> <span class="s1">'ghcr-creds'</span>
        <span class="n">GITHUB_CREDS_ID</span> <span class="o">=</span> <span class="s1">'github-creds'</span>
        <span class="n">TARGET_SSH_CREDS_ID</span> <span class="o">=</span> <span class="s1">'a5-localhost-jenkins'</span>

        <span class="n">TARGET_DEPLOY_SERVER</span> <span class="o">=</span> <span class="s1">'GEEKOM-A5-Server'</span>

        <span class="n">DISCORD_CREDS_ID</span> <span class="o">=</span> <span class="s1">'discord-webhook-url'</span>

        <span class="n">IMAGE_NAME</span> <span class="o">=</span> <span class="s1">'ghcr.io/paul2021-r/project-mini-frontend'</span>

        <span class="n">TARGET_HOST</span> <span class="o">=</span> <span class="n">credentials</span><span class="o">(</span><span class="s1">'ssh-host-creds'</span><span class="o">)</span> <span class="c1">// Jenkins Credentials에서 가져옴 =&gt; 보안을 위함</span>
        <span class="n">TARGET_PORT</span> <span class="o">=</span> <span class="n">credentials</span><span class="o">(</span><span class="s1">'ssh-port-creds'</span><span class="o">)</span> <span class="c1">// Jenkins Credentials에서 가져옴</span>
        <span class="n">TARGET_PROJECT_PATH</span> <span class="o">=</span> <span class="s1">'/home/hansol/workspace/project-mini-frontend'</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">credentials()</code> 함수는 Jenkins Credentials 플러그인을 통해 Jenkins에 저장된 자격 증명(예: 비밀번호, SSH 키)을 안전하게 가져와 환경 변수로 사용할 수 있도록 한다. 이렇게 한 이유는 스크립트로 노출 되어도 문제가 없는 영역과, 그렇지 않은 영역을 구분하기 위함이다.</p>

<h4 id="stages-및-stage-블록-파이프라인-단계-정의"><code class="language-plaintext highlighter-rouge">stages</code> 및 <code class="language-plaintext highlighter-rouge">stage</code> 블록 (파이프라인 단계 정의)</h4>

<p><code class="language-plaintext highlighter-rouge">stages</code> 블록은 파이프라인의 모든 <code class="language-plaintext highlighter-rouge">stage</code> 블록을 포함하는 컨테이너다. 각 <code class="language-plaintext highlighter-rouge">stage</code> 블록은 파이프라인의 논리적인 단계를 정의하며, 일반적으로 빌드, 테스트, 배포와 같은 주요 작업을 나타내고 또한 격리한다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 전체 흐름을 구성하는 개별적인 작업 단위를 정의</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 <code class="language-plaintext highlighter-rouge">Checkout</code>, <code class="language-plaintext highlighter-rouge">Build Image</code>, <code class="language-plaintext highlighter-rouge">Push to GHCR</code>, <code class="language-plaintext highlighter-rouge">Deploy to Server</code>와 같은 여러 <code class="language-plaintext highlighter-rouge">stage</code>를 정의하여 CI/CD 파이프라인의 각 단계를 명확히 구분</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (stages 및 stage 블록 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="n">stages</span> <span class="o">{</span>
    <span class="c1">// code pull</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"1. Get the latest code from GitHub"</span>
                <span class="n">git</span> <span class="nl">credentialsId:</span> <span class="n">GITHUB_CREDS_ID</span><span class="o">,</span> <span class="nl">url:</span> <span class="s1">'https://github.com/paul2021-r/project-mini-frontend.git'</span><span class="o">,</span> <span class="nl">branch:</span> <span class="s1">'main'</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// build image</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

        <span class="c1">// push image</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>

        <span class="c1">// deploy to server</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Deploy to Server'</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="steps-블록-단계별-실행-명령어"><code class="language-plaintext highlighter-rouge">steps</code> 블록 (단계별 실행 명령어)</h4>

<p>각 <code class="language-plaintext highlighter-rouge">stage</code> 블록 내에는 <code class="language-plaintext highlighter-rouge">steps</code> 블록이 포함되며, 이 블록은 해당 <code class="language-plaintext highlighter-rouge">stage</code>에서 실제로 실행될 하나 이상의 명령어를 정의한다. <code class="language-plaintext highlighter-rouge">steps</code> 블록 내에서는 쉘(shell) 명령어(<code class="language-plaintext highlighter-rouge">sh</code>), Groovy 스크립트(<code class="language-plaintext highlighter-rouge">script { ... }</code>), Jenkins 플러그인이 제공하는 DSL(Domain Specific Language) 등을 사용할 수 있다.</p>

<ul>
  <li><strong>역할</strong>: <code class="language-plaintext highlighter-rouge">stage</code> 내에서 수행될 구체적인 작업들을 순차적으로 실행한다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">Checkout</code> 단계에서는 <code class="language-plaintext highlighter-rouge">echo</code> 명령어로 메시지를 출력하고, <code class="language-plaintext highlighter-rouge">git</code> 명령어로 소스 코드를 가져온다.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (steps 블록 예시)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"1. Get the latest code from GitHub"</span>
                <span class="n">git</span> <span class="nl">credentialsId:</span> <span class="n">GITHUB_CREDS_ID</span><span class="o">,</span> <span class="nl">url:</span> <span class="s1">'https://github.com/paul2021-r/project-mini-frontend.git'</span><span class="o">,</span> <span class="nl">branch:</span> <span class="s1">'main'</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<h4 id="post-블록-빌드-후-처리"><code class="language-plaintext highlighter-rouge">post</code> 블록 (빌드 후 처리)</h4>

<p><code class="language-plaintext highlighter-rouge">post</code> 블록은 파이프라인 실행이 완료된 후(성공, 실패, 항상 등 조건에 따라) 특정 작업을 수행하도록 정의한다. 주로 알림 전송, 리소스 정리, 로그아웃 등의 후처리 작업에 사용된다.</p>

<ul>
  <li><strong>역할</strong>: 파이프라인의 최종 상태에 따라 실행될 작업을 정의</li>
  <li><strong>조건</strong>: <code class="language-plaintext highlighter-rouge">always</code>, <code class="language-plaintext highlighter-rouge">success</code>, <code class="language-plaintext highlighter-rouge">failure</code>, <code class="language-plaintext highlighter-rouge">unstable</code>, <code class="language-plaintext highlighter-rouge">changed</code> 등 다양한 조건에 따라 <code class="language-plaintext highlighter-rouge">post</code> 액션을 실행할 수 있다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 빌드 성공 시와 실패 시 Discord 알림을 보내고, 항상 GHCR에서 로그아웃하도록 <code class="language-plaintext highlighter-rouge">post</code> 블록을 사용.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (post 블록 예시)</span>
    <span class="n">post</span> <span class="o">{</span>
        <span class="n">success</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Deployment succeeded. Now send a discord notification."</span>
            <span class="n">script</span> <span class="o">{</span> <span class="cm">/* ... Discord 성공 알림 ... */</span> <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">failure</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Deployment failed! Now send a discord notification."</span>
            <span class="n">script</span> <span class="o">{</span> <span class="cm">/* ... Discord 실패 알림 ... */</span> <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">always</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Logout from GHCR"</span>
            <span class="n">sh</span> <span class="s2">"docker logout ghcr.io"</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="groovy-언어의-기본-문법-basic-groovy-syntax">Groovy 언어의 기본 문법 (Basic Groovy Syntax)</h3>

<p>Jenkins Pipeline은 Groovy 언어를 기반으로 한다. Groovy는 Java 플랫폼에서 실행되는 동적 언어로, Java와 유사한 문법을 가지면서도 스크립팅에 더 적합한 유연성을 제공한다. 이전에 정리를 한 적이 있으나, 까먹은 관계로(…) 무식하게 복습한 번 하고 간다. Jenkins Pipeline에서 Groovy의 기본 문법을 이해하는 것은 파이프라인을 효과적으로 작성하고 디버깅하는 데 필수적인 역할을 수행한다.</p>

<h4 id="변수-선언-및-사용-variable-declaration--usage">변수 선언 및 사용 (Variable Declaration &amp; Usage)</h4>

<p>Groovy에서 변수는 <code class="language-plaintext highlighter-rouge">def</code> 키워드를 사용하여 선언할 수 있으며, 타입을 명시하지 않아도 됩니다. 변수는 문자열, 숫자, 리스트, 맵 등 다양한 데이터 타입을 저장할 수 있습니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">def</code> 키워드</strong>: 변수를 선언할 때 사용합니다. 타입을 명시하지 않으면 Groovy가 자동으로 타입을 추론합니다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">myString</span> <span class="o">=</span> <span class="s2">"Hello, Jenkins!"</span>
<span class="kt">def</span> <span class="n">myNumber</span> <span class="o">=</span> <span class="mi">123</span>
<span class="kt">def</span> <span class="n">myList</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"apple"</span><span class="o">,</span> <span class="s2">"banana"</span><span class="o">]</span>
</code></pre></div>    </div>
  </li>
  <li><strong>타입 명시</strong>: 필요에 따라 타입을 명시할 수도 있습니다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">anotherString</span> <span class="o">=</span> <span class="s2">"Hello, Groovy!"</span>
<span class="kt">int</span> <span class="n">anotherNumber</span> <span class="o">=</span> <span class="mi">456</span>
</code></pre></div>    </div>
  </li>
  <li><strong>변수 사용</strong>: 선언된 변수는 스크립트 내에서 직접 참조하여 사용할 수 있습니다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span> <span class="s2">"${myString} The number is ${myNumber}"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">environment</code> 블록 내에서 환경 변수를 정의하거나, <code class="language-plaintext highlighter-rouge">script</code> 블록 내에서 <code class="language-plaintext highlighter-rouge">def</code> 키워드를 사용하여 로컬 변수를 선언하고 활용하는 것을 볼 수 있다. 당연히 스크립트 작성 시 전역용과, 지역용에 맞춰서 스코프가 있는 만큼 그에 맞춰 동작하도록 만드는게 중요.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (변수 선언 및 사용 예시)</span>
<span class="n">pipeline</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="n">environment</span> <span class="o">{</span>
        <span class="n">IMAGE_NAME</span> <span class="o">=</span> <span class="s1">'ghcr.io/paul2021-r/project-mini-frontend'</span> <span class="c1">// 환경 변수</span>
    <span class="o">}</span>
    <span class="n">stages</span> <span class="o">{</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">script</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> <span class="c1">// def를 사용한 로컬 변수 선언</span>
                    <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="조건문-conditional-statements">조건문 (Conditional Statements)</h4>

<p>Groovy는 <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else</code>와 같은 표준 조건문을 지원한다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">if-else</code> 구조</strong>: 조건이 참(true)일 때 특정 코드 블록을 실행하고, 거짓(false)일 때 다른 코드 블록을 실행.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">status</span> <span class="o">=</span> <span class="s2">"success"</span>
<span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">==</span> <span class="s2">"success"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">echo</span> <span class="s2">"Operation succeeded."</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">echo</span> <span class="s2">"Operation failed."</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>삼항 연산자</strong>: 간단한 조건에 따라 값을 할당할 때 유용
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">def</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"Pass"</span> <span class="o">:</span> <span class="s2">"Fail"</span>
<span class="n">echo</span> <span class="s2">"Result: ${result}"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>의 홀짝 여부를 판단하여 배포할 서비스를 결정하는 데 조건문을 활용한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (조건문 예시)</span>
<span class="n">stage</span><span class="o">(</span><span class="s1">'Deploy to Server'</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">steps</span> <span class="o">{</span>
        <span class="n">script</span> <span class="o">{</span>
            <span class="c1">// 어떤 컨테이너를 업데이트 및 업스트림 대상을 지정</span>
            <span class="kt">def</span> <span class="n">deployService</span> <span class="o">=</span> <span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="na">BUILD_NUMBER</span><span class="o">.</span><span class="na">toInteger</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-green"</span> <span class="o">:</span> <span class="s2">"app-blue"</span> 
            <span class="kt">def</span> <span class="n">upstreamService</span> <span class="o">=</span> <span class="o">(</span><span class="n">deployService</span> <span class="o">==</span> <span class="s2">"app-green"</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-blue"</span> <span class="o">:</span> <span class="s2">"app-green"</span>
            <span class="c1">// ...</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">env.BUILD_NUMBER.toInteger() % 2 == 0</code>은 현재 빌드 번호가 짝수인지 홀수인지 확인하는 조건이다. 짝수이면 <code class="language-plaintext highlighter-rouge">app-green</code>을 <code class="language-plaintext highlighter-rouge">deployService</code>로, 홀수이면 <code class="language-plaintext highlighter-rouge">app-blue</code>를 <code class="language-plaintext highlighter-rouge">deployService</code>로 할당하게 했다. 이는 Blue/Green 배포 전략에서 트래픽을 전환할 대상을 동적으로 결정하는 핵심 로직으로, 더 복잡한 방식을 써볼까 했지만, 결과적으로 심플함, 예측 가능성 등을 고려하여 일단 프론트엔드서버는 간단한 방식을 차용하였다.</p>

<h3 id="jenkins-pipeline에서-groovy-활용-eg-script----블록">Jenkins Pipeline에서 Groovy 활용 (e.g., <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록)</h3>

<p>Declarative Pipeline은 구조화된 형태를 가지지만, 복잡한 로직이나 동적인 처리가 필요할 때는 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록을 사용하여 Groovy 스크립트를 직접 실행할 수 있다. 이 블록은 Declarative Pipeline 내에서 Scripted Pipeline의 유연성을 제공하는 ‘탈출구’ 역할을 한다.</p>

<h4 id="script----블록의-역할"><code class="language-plaintext highlighter-rouge">script { ... }</code> 블록의 역할</h4>

<ul>
  <li><strong>복잡한 로직 구현</strong>: Declarative Pipeline의 제한된 표현력으로는 어려운 복잡한 조건부 로직, 반복문, 예외 처리 등을 Groovy 스크립트로 직접 구현할 수 있다.</li>
  <li><strong>동적 처리</strong>: 빌드 번호, 환경 변수, 외부 API 호출 결과 등 동적인 값에 따라 파이프라인의 동작을 변경해야 할 때 유용.</li>
  <li><strong>Jenkins DSL 확장</strong>: Jenkins Pipeline이 제공하는 내장 DSL(Domain Specific Language) 외에, Groovy의 강력한 기능을 활용하여 사용자 정의 함수나 라이브러리를 호출할 수 있다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Build Image</code>, <code class="language-plaintext highlighter-rouge">Push to GHCR</code>, <code class="language-plaintext highlighter-rouge">Deploy to Server</code>, <code class="language-plaintext highlighter-rouge">post</code> 블록 내에서 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록이 광범위하게 사용했다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (script 블록 활용 예시)</span>
<span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">steps</span> <span class="o">{</span>
        <span class="n">echo</span> <span class="s2">"2. Build New Docker Image"</span>
        <span class="n">script</span> <span class="o">{</span>
            <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> <span class="c1">// 빌드할 이미지 명을 가변적으로 지정하도록 사용함.</span>
            <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span> 
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">steps</span> <span class="o">{</span>
        <span class="n">echo</span> <span class="s2">"3. Push the Docker Image to GHCR"</span>
        <span class="n">script</span> <span class="o">{</span>
            <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span>
            <span class="n">withCredentials</span><span class="o">([</span><span class="n">usernamePassword</span><span class="o">(</span><span class="nl">credentialsId:</span> <span class="n">GHCR_CREDS_ID</span><span class="o">,</span> <span class="nl">usernameVariable:</span> <span class="s1">'USER'</span><span class="o">,</span> <span class="nl">passwordVariable:</span> <span class="s1">'TOKEN'</span><span class="o">)])</span> <span class="o">{</span>
                <span class="n">sh</span> <span class="s2">"echo ${TOKEN} | docker login ghcr.io -u ${USER} --password-stdin"</span>
                <span class="n">sh</span> <span class="s2">"docker push ${imageTag}"</span>
            <span class="o">}</span> <span class="c1">// withCredentials 로 주요내용을 함께 가져가서 명령어에 적용시킨다. </span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록은 <code class="language-plaintext highlighter-rouge">imageTag</code> 변수를 선언하고, <code class="language-plaintext highlighter-rouge">sh</code> 명령어를 사용하여 Docker 빌드 및 푸시 작업을 수행하는 Groovy 코드를 포함한다. 특히 <code class="language-plaintext highlighter-rouge">withCredentials</code>와 같은 Jenkins DSL은 <code class="language-plaintext highlighter-rouge">script</code> 블록 내에서 더욱 유연하게 활용될 수 있다.</p>

<p>Jenkins Pipeline 스크립트 언어인 Groovy를 이해하고 활용하는 것은 복잡한 CI/CD 파이프라인을 구축하고 유지보수하는 데 필수적인 역량이다. Groovy의 기본 문법과 <code class="language-plaintext highlighter-rouge">script { ... }</code> 블록의 활용법을 숙지함으로써, Jenkins 파이프라인의 잠재력을 최대한 발휘할 수 있다.</p>

<h3 id="소스-코드-관리-source-code-management---scm">소스 코드 관리 (Source Code Management - SCM)</h3>

<p>CI/CD 파이프라인의 첫 번째이자 가장 기본적인 단계는 소스 코드를 관리하고 변경 사항을 감지하는 것이다. 소스 코드 관리(SCM) 시스템은 개발자들이 작성한 코드를 저장하고, 변경 이력을 추적하며, 여러 개발자 간의 협업을 지원하는 도구다. Jenkins는 다양한 SCM 시스템과 연동하여 코드 변경을 감지하고 파이프라인을 트리거(trigger)해준다. 이 프로젝트에서는 Git을 SCM을 기반으로 만들었다.</p>

<h4 id="git-연동-git-credentialsid-github_creds_id-url--branch-main">Git 연동 (<code class="language-plaintext highlighter-rouge">git credentialsId: GITHUB_CREDS_ID, url: '...', branch: 'main'</code>)</h4>

<p>Jenkins는 Git 플러그인을 통해 Git 저장소와 쉽게 연동할 수 있게 되어있다. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 내에서 <code class="language-plaintext highlighter-rouge">git</code> 스텝(step)을 사용하여 특정 Git 저장소에서 소스 코드를 체크아웃(checkout)할 수 있고 특별히 요청하는 단계 없이 자연스럽게 해당 저장소에서 파일을 가져와준다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">git</code> 스텝</strong>: Jenkins Pipeline에서 Git 저장소에서 코드를 가져오는 데 사용되는 내장 스텝이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">credentialsId</code></strong>: Jenkins에 미리 등록된 자격 증명(Credentials)의 ID를 지정한다. 이 자격 증명은 비공개(private) 저장소에 접근하거나, 특정 작업을 수행할 권한이 필요할 때 사용된다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">GITHUB_CREDS_ID</code>를 사용하여 GitHub 저장소에 접근하도록 세팅했다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">url</code></strong>: 소스 코드를 가져올 Git 저장소의 URL을 지정한다. HTTPS 또는 SSH URL을 사용할 수 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">branch</code></strong>: 체크아웃할 브랜치(branch)를 지정한다. 일반적으로 <code class="language-plaintext highlighter-rouge">main</code> 또는 <code class="language-plaintext highlighter-rouge">master</code> 브랜치를 지정하여 최신 코드를 가져오도록 설정했다.</li>
</ul>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Checkout stage)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Checkout'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"1. Get the latest code from GitHub"</span>
                <span class="n">git</span> <span class="nl">credentialsId:</span> <span class="n">GITHUB_CREDS_ID</span><span class="o">,</span> <span class="nl">url:</span> <span class="s1">'https://github.com/paul2021-r/project-mini-frontend.git'</span><span class="o">,</span> <span class="nl">branch:</span> <span class="s1">'main'</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p>이 스텝은 <code class="language-plaintext highlighter-rouge">GITHUB_CREDS_ID</code>에 해당하는 자격 증명을 사용하여 <code class="language-plaintext highlighter-rouge">https://github.com/paul2021-r/project-mini-frontend.git</code> 저장소의 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에서 최신 코드를 Jenkins 작업 공간(workspace)으로 가져온다. <code class="language-plaintext highlighter-rouge">credentialsId</code>를 사용하는 것은 민감한 정보(예: GitHub Personal Access Token)를 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에 직접 노출하지 않고 안전하게 관리하는 구조다.</p>

<h4 id="git-pull-origin-main-git-checkout-main-명령의-이해"><code class="language-plaintext highlighter-rouge">git pull origin main</code>, <code class="language-plaintext highlighter-rouge">git checkout main</code> 명령의 이해</h4>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 단계 내에서 SSH를 통해 원격 서버에 접속한 후 <code class="language-plaintext highlighter-rouge">git pull origin main</code> 및 <code class="language-plaintext highlighter-rouge">git checkout main</code> 명령어를 실행한다. 이는 배포 서버 자체의 프로젝트 디렉토리에서 최신 코드를 유지하기 위한 목적으로 제공된다. 즉, 기존 젠킨스 빌드 서버는 workspace 에서 자동으로 최신화되지만, 시크릿을 제외한 환경 파일이나 설정 등, 깃을 통해 공유되는 영역을 위해, SSH 접속 후에도 최신화를 시키는 세심한 단계를 추가했다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">ssh</span> <span class="o">-</span><span class="n">o</span> <span class="n">StrictHostKeyChecking</span><span class="o">=</span><span class="n">no</span> <span class="o">-</span><span class="n">p</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PORT</span><span class="o">}</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_HOST</span><span class="o">}</span> <span class="err">'</span>
                                <span class="n">set</span> <span class="o">-</span><span class="n">ex</span>
                                
                                <span class="c1">// ...</span>

                                <span class="n">echo</span> <span class="s2">"--- Refresh main repository ---"</span>
                                <span class="n">cd</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PROJECT_PATH</span><span class="o">}</span>
                                <span class="n">git</span> <span class="n">pull</span> <span class="n">origin</span> <span class="n">main</span>
                                <span class="n">git</span> <span class="n">checkout</span> <span class="n">main</span>
                                
                                <span class="c1">// ...</span>
                                <span class="err">'</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">cd ${TARGET_PROJECT_PATH}</code></strong>: 먼저 배포 서버의 프로젝트 루트 디렉토리로 이동.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">git pull origin main</code></strong>: 원격 저장소(<code class="language-plaintext highlighter-rouge">origin</code>)의 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에서 최신 변경 사항을 가져와 현재 로컬 브랜치에 병합(merge)한다. 이는 배포 서버에 항상 최신 버전의 코드가 존재하도록 보장</li>
  <li><strong><code class="language-plaintext highlighter-rouge">git checkout main</code></strong>: 현재 작업 중인 브랜치를 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 전환한다. 이는 혹시 다른 브랜치에 머물러 있을 경우를 대비하여 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에서 작업을 수행하도록 명확히 하는 역할을 한다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - Jenkins 프로젝트 전체 내용 정리 (3)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/3-til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 프로젝트 전체 내용 정리 (3)" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/3-til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/27/3-til-jenkins.html"><![CDATA[<h2 id="25-10-24--25-10-27">25-10-24 ~ 25-10-27</h2>

<ul>
  <li>본 내용은 프로젝트에 적용한 CICD 배포 과정에서 있었던 내용 중 개념적으로 추가가 필요한 내용들을 정리한 글이다.</li>
  <li>사실 KTX 를 탔는데 할 일이 없다… 공부나 하자라는 감성을 했던 내용을 복습한다.</li>
</ul>

<h2 id="jenkins">Jenkins</h2>
<h3 id="docker-이미지-빌드-및-관리-docker-image-build--management">Docker 이미지 빌드 및 관리 (Docker Image Build &amp; Management)</h3>

<p>CI/CD 파이프라인에서 애플리케이션을 컨테이너화하는 것은 환경 일관성을 보장하고 배포를 간소화하는 핵심적인 단계다. Jenkins는 Docker CLI와 연동하여 Docker 이미지를 빌드하고, 컨테이너 레지스트리(Registry)에 푸시(push)하며, 배포 서버에서 이미지를 풀(pull)하는 일련의 과정을 자동화한다. 이 섹션에서는 <code class="language-plaintext highlighter-rouge">project-mini-frontend</code>의 <code class="language-plaintext highlighter-rouge">app/Dockerfile</code>과 <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>을 기반으로 Docker 이미지 빌드 및 관리의 주요 개념을 정리하였다.</p>

<h4 id="docker-build-명령어-및---build-arg-활용"><code class="language-plaintext highlighter-rouge">docker build</code> 명령어 및 <code class="language-plaintext highlighter-rouge">--build-arg</code> 활용</h4>

<p><code class="language-plaintext highlighter-rouge">docker build</code> 명령어는 <code class="language-plaintext highlighter-rouge">Dockerfile</code>에 정의된 지침에 따라 Docker 이미지를 생성한다. 이 과정에서 <code class="language-plaintext highlighter-rouge">--build-arg</code> 옵션을 사용하여 빌드 시점에 환경 변수를 주입할 수 있다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker build -t &lt;image_name&gt;:&lt;tag&gt; &lt;path_to_dockerfile_context&gt;</code></strong>: 이미지를 빌드하는 기본 명령어.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-t &lt;image_name&gt;:&lt;tag&gt;</code>: 빌드된 이미지에 이름과 태그를 부여한다. 태그는 이미지의 버전을 식별하는 데 사용된다.</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;path_to_dockerfile_context&gt;</code>: <code class="language-plaintext highlighter-rouge">Dockerfile</code>이 위치한 디렉토리의 경로를 지정합한다. Docker 빌드 컨텍스트(context)가 된다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">--build-arg &lt;VAR_NAME&gt;=&lt;value&gt;</code></strong>: <code class="language-plaintext highlighter-rouge">Dockerfile</code> 내에서 <code class="language-plaintext highlighter-rouge">ARG</code> 지시어로 선언된 변수에 값을 전달한다. 이는 빌드 시점에 동적으로 환경을 구성할 때 유용하다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Build Image</code> 단계에서는 <code class="language-plaintext highlighter-rouge">docker build</code> 명령어를 사용하여 Next.js 애플리케이션 이미지를 빌드한다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Build Image stage)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Build Image'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"2. Build New Docker Image"</span>
                <span class="n">script</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> 
                    <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span> 
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">sh "docker build -t ${imageTag} ./app"</code> 명령은 <code class="language-plaintext highlighter-rouge">project-mini-frontend/app</code> 디렉토리를 빌드 컨텍스트로 사용하여 이미지를 빌드하고, <code class="language-plaintext highlighter-rouge">IMAGE_NAME</code>과 Jenkins의 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>를 조합한 태그를 부여한다. 만약 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 내에서 <code class="language-plaintext highlighter-rouge">ARG</code>를 통해 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_API_URL</code>과 같은 환경 변수를 받도록 설정되어 있다면, <code class="language-plaintext highlighter-rouge">sh "docker build -t ${imageTag} --build-arg NEXT_PUBLIC_API_URL=${env.API_URL} ./app"</code>와 같이 <code class="language-plaintext highlighter-rouge">--build-arg</code>를 추가하여 빌드 시점에 값을 주입해서 다이나믹한 대응이 가능하다.</p>

<h4 id="docker-이미지-태깅-전략-eg-latest-build_number">Docker 이미지 태깅 전략 (e.g., <code class="language-plaintext highlighter-rouge">latest</code>, <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>)</h4>

<p>Docker 이미지 태깅은 이미지의 버전을 관리하고 식별하는 데 매우 중요하다. 일관된 태깅 전략은 CI/CD 파이프라인의 안정성과 효율성을 높이기에 구조를 이해할 필요가 있다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">latest</code> 태그</strong>: 일반적으로 가장 최신 버전의 안정적인 이미지에 부여된다. 하지만 <code class="language-plaintext highlighter-rouge">latest</code> 태그는 항상 최신을 의미하므로, 특정 버전을 명확히 식별하기 어렵다는 단점이 있다. 프로덕션 환경에서는 <code class="language-plaintext highlighter-rouge">latest</code> 태그만 사용하는 것을 지양하고, 특정 버전 태그와 함께 사용하는 것이 권장된다.(아니면 편의성, 이식성을 위해 이미지를 두개로 tag를 나눠, latest 인 경우, 빌드넘버 두가지를 함께 병용하는 것도 괜찮다.)</li>
  <li><strong><code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code> 태그</strong>: Jenkins의 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>와 같이 CI/CD 시스템에서 생성되는 고유한 빌드 번호를 태그로 사용하는 것은 매우 효과적인 전략이다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>를 활용한 태깅 전략을 사용했다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (이미지 태깅 예시)</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span> 
                    <span class="n">sh</span> <span class="s2">"docker build -t ${imageTag} ./app"</span> 
                    <span class="c1">// ...</span>
                    <span class="n">sh</span> <span class="s2">"docker push ${imageTag}"</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">ghcr.io/paul2021-r/project-mini-frontend:123</code>과 같이 빌드 번호가 포함된 태그를 사용함으로써, 어떤 빌드에서 생성된 이미지인지 명확하게 식별할 수 있다.</p>

<h4 id="github-container-registry-ghcr-사용법">GitHub Container Registry (GHCR) 사용법</h4>

<p>GitHub Container Registry (GHCR)는 GitHub에서 제공하는 Docker 이미지 저장소 서비스다. Docker Hub와 유사하게 Docker 이미지를 저장하고 공유할 수 있으며, GitHub 저장소와 긴밀하게 통합된다.</p>

<ul>
  <li><strong>장점</strong>: GitHub 저장소와 연동되어 접근 제어 및 권한 관리가 용이하며, GitHub Actions와 같은 CI/CD 도구와 함께 사용하기 편리하다.</li>
  <li><strong>사용 이유</strong>: 다른 서비스들은 무료로 제공해주긴 해도 제한사항이 있고, default 값이 아니라는 점만 제외하면 모든 기능이 동일하다. EKS 와 같은 AWS 의 상용 서비스도 고려는 했지만, 굳이 비용을 들일 필요가 없기 때문에, 가장 널널하게 쓰기좋은 GHCR 을 적용했다.</li>
  <li><strong>사용법</strong>: <code class="language-plaintext highlighter-rouge">docker login</code>, <code class="language-plaintext highlighter-rouge">docker push</code>, <code class="language-plaintext highlighter-rouge">docker pull</code> 명령어를 사용하여 GHCR에 이미지를 푸시하고 풀할 수 있다. 인증은 GitHub Personal Access Token(PAT)을 통해 이루어진다. 단, PAT 발급 시 package 에 대한 write 권한을 제공해야 한다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Push to GHCR</code> 단계는 GHCR 사용법을 보여준다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Push to GHCR stage)</span>
        <span class="n">stage</span><span class="o">(</span><span class="s1">'Push to GHCR'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">steps</span> <span class="o">{</span>
                <span class="n">echo</span> <span class="s2">"3. Push the Docker Image to GHCR"</span>
                <span class="n">script</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">imageTag</span> <span class="o">=</span> <span class="s2">"${IMAGE_NAME}:${env.BUILD_NUMBER}"</span>
                    <span class="n">withCredentials</span><span class="o">([</span><span class="n">usernamePassword</span><span class="o">(</span><span class="nl">credentialsId:</span> <span class="n">GHCR_CREDS_ID</span><span class="o">,</span> <span class="nl">usernameVariable:</span> <span class="s1">'USER'</span><span class="o">,</span> <span class="nl">passwordVariable:</span> <span class="s1">'TOKEN'</span><span class="o">)])</span> <span class="o">{</span>
                        <span class="n">sh</span> <span class="s2">"echo ${TOKEN} | docker login ghcr.io -u ${USER} --password-stdin"</span>
                        <span class="n">sh</span> <span class="s2">"docker push ${imageTag}"</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">withCredentials</code> 블록을 사용하여 Jenkins에 저장된 <code class="language-plaintext highlighter-rouge">GHCR_CREDS_ID</code> 자격 증명(GitHub 사용자 이름과 PAT)을 <code class="language-plaintext highlighter-rouge">USER</code>와 <code class="language-plaintext highlighter-rouge">TOKEN</code> 환경 변수로 주입한다. 이 정보를 사용하여 <code class="language-plaintext highlighter-rouge">docker login ghcr.io</code> 명령으로 GHCR에 로그인한 후, <code class="language-plaintext highlighter-rouge">docker push ${imageTag}</code> 명령으로 빌드된 이미지를 GHCR에 푸시한다.</p>

<h4 id="docker-login-docker-push-docker-pull-docker-logout-명령어"><code class="language-plaintext highlighter-rouge">docker login</code>, <code class="language-plaintext highlighter-rouge">docker push</code>, <code class="language-plaintext highlighter-rouge">docker pull</code>, <code class="language-plaintext highlighter-rouge">docker logout</code> 명령어</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker login &lt;registry_url&gt;</code></strong>: Docker 레지스트리에 로그인한다. 사용자 이름과 비밀번호(또는 PAT)를 입력하며, url을 기준으로 사용하는 서비스 주체 플랫폼을 결정할 수 있다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">echo ${TOKEN} | docker login ghcr.io -u ${USER} --password-stdin</code>와 같이 표준 입력을 통해 비밀번호를 전달하여 자동화된 로그인 과정을 구현한다.(보안이 약하다고 하여, 대안이 되는 다른 방법도 있다지만, 아직 구현에 성공하진 못했다.)</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker push &lt;image_name&gt;:&lt;tag&gt;</code></strong>: 로컬에 빌드된 Docker 이미지를 원격 레지스트리에 업로드(푸시)한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker pull &lt;image_name&gt;:&lt;tag&gt;</code></strong>: 원격 레지스트리에서 Docker 이미지를 로컬로 다운로드(풀)한다. <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 단계에서 배포 서버가 GHCR로부터 이미지를 풀하는 데 사용된다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                            <span class="n">echo</span> <span class="s2">"--- (1/4) Pull the new image : ${imageTag} ---"</span>
                            <span class="n">docker</span> <span class="n">pull</span> <span class="n">$</span><span class="o">{</span><span class="n">imageTag</span><span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker logout &lt;registry_url&gt;</code></strong>: Docker 레지스트리에서 로그아웃합니다. 보안을 위해 파이프라인의 <code class="language-plaintext highlighter-rouge">post</code> 블록에서 항상 로그아웃하는 것이 권장되고, 그렇게 적용해두었다. 이로써 빌드 하나의 사이클에서 모든 내용이 종결되고 빌드 프로세스는 격리된다.
    <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (post block)</span>
    <span class="n">always</span> <span class="o">{</span>
        <span class="n">echo</span> <span class="s2">"Logout from GHCR"</span>
        <span class="n">sh</span> <span class="s2">"docker logout ghcr.io"</span>
    <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="docker-out-of-docker-dood-패턴-docker-out-of-docker-pattern">Docker-out-of-Docker (DooD) 패턴 (Docker-out-of-Docker Pattern)</h3>

<p>Docker-out-of-Docker (DooD) 패턴은 Docker 컨테이너 내부에서 Docker 명령어를 실행하여 호스트(Host)의 Docker 데몬(Daemon)과 상호작용하는 전략이다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트는 Jenkins 컨테이너 내부에서 호스트의 Docker 데몬을 제어하기 위해 DooD 패턴을 활용하고 있다.</p>

<h4 id="jenkins-컨테이너에서-호스트-docker-데몬-제어-원리">Jenkins 컨테이너에서 호스트 Docker 데몬 제어 원리</h4>

<p>일반적으로 Docker 컨테이너는 호스트 시스템과 격리된 환경에서 실행된다. 하지만 DooD 패턴을 사용하면 컨테이너 내부에서 호스트의 Docker 데몬에 접근하여 Docker 명령어를 실행할 수 있다.</p>

<ol>
  <li><strong>Docker 소켓 마운트</strong>: 호스트의 Docker 데몬은 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code>이라는 유닉스 소켓(Unix socket)을 통해 외부와 통신한다. DooD 패턴은 Jenkins 컨테이너를 실행할 때 이 호스트의 <code class="language-plaintext highlighter-rouge">docker.sock</code> 파일을 컨테이너 내부로 마운트한다.
    <ul>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-jenkins/docker-compose.yml</code>의 <code class="language-plaintext highlighter-rouge">volumes</code> 설정
```yaml
        <h1 id="project-mini-jenkinsdocker-composeyml-일부">project-mini-jenkins/docker-compose.yml (일부)</h1>
        <p>services:
  jenkins:</p>
        <h1>…</h1>
        <p>volumes:</p>
        <ul>
          <li>./jenkins_home:/var/jenkins_home</li>
          <li>/var/run/docker.sock:/var/run/docker.sock # 이 부분이 핵심</li>
          <li>/usr/bin/docker:/usr/bin/docker</li>
          <li>/usr/bin/docker-compose:/usr/bin/docker-compose
            <h1 id="-1">…</h1>
            <p>```
위 설정은 호스트의 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code>을 Jenkins 컨테이너의 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> 경로로 마운트한다. 이로써 Jenkins 컨테이너 내부의 Docker CLI는 호스트의 Docker 데몬과 통신할 수 있게 된 것이다.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Docker CLI 설치</strong>: Jenkins 컨테이너 내부에 Docker CLI가 설치되어 있어야 한다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>은 <code class="language-plaintext highlighter-rouge">apt-get install -y docker-ce-cli</code> 명령을 통해 Docker CLI를 설치하여 제어 도구들을 컨테이너 내부에 소지하게 되는 것이다.
    <ul>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>의 Docker CLI 설치 부분
        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># project-mini-jenkins/jenkins/Dockerfile (일부)</span>
<span class="c"># ...</span>
<span class="c"># 4. 패키지 목록 다시 업데이트 및 Docker CLI 설치 (서버 데몬 제외)</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> docker-ce-cli
<span class="c"># ...</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>권한 설정</strong>: Jenkins 컨테이너 내부에서 Docker 명령어를 실행하는 사용자(일반적으로 <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자)가 호스트의 <code class="language-plaintext highlighter-rouge">docker.sock</code>에 접근할 수 있는 권한을 가져야 한다. 이는 해당 사용자를 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 추가함으로써 해결된다. <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>은 <code class="language-plaintext highlighter-rouge">usermod -aG docker jenkins</code> 명령을 통해 이 권한을 부여한다.
    <ul>
      <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>의 권한 설정 부분
        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># project-mini-jenkins/jenkins/Dockerfile (일부)</span>
<span class="c"># ...</span>
<span class="c"># DooD 구조를 위함. Docker 그룹에 jenkins 유저 추가</span>
<span class="k">ARG</span><span class="s"> DOCKER_GID=1001</span>
<span class="k">RUN </span>groupadd <span class="nt">-g</span> <span class="k">${</span><span class="nv">DOCKER_GID</span><span class="k">}</span> docker
<span class="k">RUN </span>usermod <span class="nt">-aG</span> docker jenkins
<span class="c"># ...</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h4 id="jenkins-사용자를-docker-그룹에-추가하는-이유"><code class="language-plaintext highlighter-rouge">jenkins</code> 사용자를 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 추가하는 이유</h4>

<p>리눅스(Linux) 시스템에서 <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> 파일은 일반적으로 <code class="language-plaintext highlighter-rouge">root</code> 사용자 또는 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 속한 사용자만 접근할 수 있도록 권한이 설정되어 있ㅊ다. Jenkins 컨테이너 내부에서 <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자가 Docker 명령어를 실행하려면 이 소켓 파일에 대한 접근 권한이 필요하다.</p>

<p><code class="language-plaintext highlighter-rouge">project-mini-jenkins/jenkins/Dockerfile</code>에서 <code class="language-plaintext highlighter-rouge">usermod -aG docker jenkins</code> 명령을 통해 <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자를 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 추가하는 것은 바로 이 접근 권한을 부여하기 위함이다. <code class="language-plaintext highlighter-rouge">jenkins</code> 사용자가 <code class="language-plaintext highlighter-rouge">docker</code> 그룹에 속하게 되면, <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> 파일에 대한 읽기/쓰기 권한을 얻게 되어 호스트의 Docker 데몬과 통신할 수 있게 된다.</p>

<h3 id="bluegreen-배포-개념-concept-of-bluegreen-deployment">Blue/Green 배포 개념 (Concept of Blue/Green Deployment)</h3>

<p>Blue/Green 배포는 무중단 배포(Zero-Downtime Deployment)를 실현하기 위한 효과적인 전략 중 하나다. 이 방식은 프로덕션 환경에 두 개의 동일한 환경을 구축하고, 한 번에 하나의 환경만 활성화하여 사용자 트래픽을 처리한다. 일반적으로 ‘Blue’ 환경과 ‘Green’ 환경으로 명명되며, 한 환경이 현재 운영 중인(Active) 상태일 때 다른 환경은 새로운 버전의 애플리케이션을 배포하고 테스트하는 데 사용된다.</p>

<h4 id="무중단-배포-zero-downtime-deployment의-중요성">무중단 배포 (Zero-Downtime Deployment)의 중요성</h4>

<p>무중단 배포는 서비스 중단 없이 새로운 버전의 애플리케이션을 배포하는 것을 의미한다. 이는 현대 비즈니스 환경에서 다음과 같은 이유로 매우 중요합니다.</p>

<ul>
  <li><strong>사용자 경험 유지</strong>: 서비스 중단은 사용자에게 부정적인 경험을 제공하고, 이는 고객 이탈로 이어질 수 있다. 무중단 배포는 사용자가 서비스 중단을 인지하지 못하도록 하여 긍정적인 사용자 경험을 유지한다.</li>
  <li><strong>비즈니스 연속성 보장</strong>: 24시간 365일 운영되어야 하는 서비스의 경우, 배포로 인한 짧은 중단조차도 큰 비즈니스 손실로 이어질 수 있다. 무중단 배포는 이러한 비즈니스 연속성을 보장한다.</li>
  <li><strong>경쟁력 확보</strong>: 빠르게 변화하는 시장에서 새로운 기능을 신속하게 배포하고 사용자 피드백을 반영하는 능력은 기업의 경쟁력을 좌우한다. 무중단 배포는 이러한 빠른 릴리스 주기를 가능하게 한다.</li>
  <li><strong>안정성 향상</strong>: 배포 과정에서 발생할 수 있는 위험을 최소화하고, 문제가 발생하더라도 신속하게 이전 버전으로 롤백할 수 있는 안전망을 제공하여 서비스의 전반적인 안정성을 향상시킨다.</li>
</ul>

<h4 id="bluegreen-환경-구성-원리">Blue/Green 환경 구성 원리</h4>

<p>Blue/Green 배포는 다음과 같은 원리로 구성된다.</p>

<ol>
  <li><strong>두 개의 동일한 환경</strong>: ‘Blue’와 ‘Green’이라는 두 개의 완전히 동일한 프로덕션 환경을 준비한다. 이 두 환경은 하드웨어, 소프트웨어, 네트워크 구성 등 모든 면에서 동일해야한다. 이번 프로젝트의 경우, 가능한 실무를 모사하고, 목표로하는 AI서비스를 위해 프론트드는 다소 작게 준비하였기에, 한 호스트 서버에 작게 분할하여 집어넣는 것을 모색했다.</li>
  <li><strong>트래픽 라우팅 (Traffic Routing)</strong>: 사용자 트래픽은 로드 밸런서(Load Balancer) 또는 리버스 프록시(Reverse Proxy)를 통해 현재 활성화된 환경으로 라우팅된다. <code class="language-plaintext highlighter-rouge">project-mini-frontend</code> 프로젝트에서는 Nginx가 이 역할을 수행하게된다.</li>
  <li><strong>새로운 버전 배포</strong>: 현재 비활성화된 환경(예: Green)에 새로운 버전의 애플리케이션을 배포하고, 필요한 테스트를 수행할 수 있게 한다. 단, 지금은 로컬 개발환경이 존재하여, 그러한 접근을 만들진 않았음. 그러나 Ngnix 의 가상 서버 기능을 도입하여, 접근 가능한 도메인 URL 단위로 접근하도록 할 것이다.</li>
  <li><strong>트래픽 전환</strong>: 새로운 버전의 애플리케이션이 안정적으로 동작하는 것이 확인되면, 로드 밸런서/리버스 프록시의 설정을 변경하여 사용자 트래픽을 Blue 환경에서 Green 환경으로 전환한다. 이 전환은 매우 빠르게 이루어지므로 사용자 입장에서는 서비스 중단을 느끼지 못하며, stateless 서버이므로 트래픽의 전환이 아무 문제가 없다.</li>
  <li><strong>이전 환경 유지 또는 폐기</strong>: 트래픽 전환 후, 이전 버전이 실행되던 환경(예: Blue)은 잠시 동안 유지하여 문제가 발생할 경우 즉시 롤백할 수 있도록 한다. 안정성이 확인되면 이전 환경은 폐기하거나 다음 배포를 위한 대기 환경으로 재활용될 수 있다. 이 부분에 대해도 현재는 롤백을 위한 백업처럼 되어있고, 테스트를 위해선 수동 최신화가 필요하다. 하만, 향후 서비스의 문제 없을 시 이용 가능한 예비 서버의 업데이트 배포 방식도 작업으로추가할 예정이다.</li>
</ol>

<h3 id="jenkinsfile-내-bluegreen-로직-분석-project-mini-frontendjenkinsfile-참고"><code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 내 Blue/Green 로직 분석 (<code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code> 참고)</h3>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 Blue/Green 배포 전략을 Jenkins 파이프라인 내에서 직접 구현해보았다. 특히 <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 단계에서 이 로직이 핵심적으로 동작한다.</p>

<h4 id="build_number를-이용한-배포-서비스-결정-deployservice-upstreamservice"><code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>를 이용한 배포 서비스 결정 (<code class="language-plaintext highlighter-rouge">deployService</code>, <code class="language-plaintext highlighter-rouge">upstreamService</code>)</h4>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                    <span class="c1">// 어떤 컨테이너를 업데이트 및 업스트림 대상을 지정</span>
                    <span class="kt">def</span> <span class="n">deployService</span> <span class="o">=</span> <span class="o">(</span><span class="n">env</span><span class="o">.</span><span class="na">BUILD_NUMBER</span><span class="o">.</span><span class="na">toInteger</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-green"</span> <span class="o">:</span> <span class="s2">"app-blue"</span> 
                    <span class="kt">def</span> <span class="n">upstreamService</span> <span class="o">=</span> <span class="o">(</span><span class="n">deployService</span> <span class="o">==</span> <span class="s2">"app-green"</span><span class="o">)</span> <span class="o">?</span> <span class="s2">"app-blue"</span> <span class="o">:</span> <span class="s2">"app-green"</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">deployService</code>: 현재 빌드된 새로운 버전의 애플리케이션이 배포될 대상 서비스(컨테이너)의 이름을 결정한다. <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code>가 짝수이면 <code class="language-plaintext highlighter-rouge">app-green</code>, 홀수이면 <code class="language-plaintext highlighter-rouge">app-blue</code>로 결정된다.</li>
  <li><code class="language-plaintext highlighter-rouge">upstreamService</code>: 현재 사용자 트래픽을 처리하고 있는 이전 버전의 애플리케이션 서비스 이름이다. <code class="language-plaintext highlighter-rouge">deployService</code>와 반대되는 서비스로 설정된다.</li>
</ul>

<h4 id="docker-compose-up--d---no-deps---force-recreate-명령의-역할"><code class="language-plaintext highlighter-rouge">docker compose up -d --no-deps --force-recreate</code> 명령의 역할</h4>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">cd</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PROJECT_PATH</span><span class="o">}</span>
                                <span class="c1">// ...</span>
                                <span class="n">docker</span> <span class="n">compose</span> <span class="o">--</span><span class="n">env</span><span class="o">-</span><span class="n">file</span> <span class="n">init</span><span class="o">.</span><span class="na">env</span> <span class="n">up</span> <span class="o">-</span><span class="n">d</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">deps</span> <span class="o">--</span><span class="n">force</span><span class="o">-</span><span class="n">recreate</span> <span class="n">$</span><span class="o">{</span><span class="n">deployService</span><span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker compose up -d</code></strong>: Docker Compose 파일에 정의된 서비스를 백그라운드(<code class="language-plaintext highlighter-rouge">-d</code>)에서 실행 및 업데이트 역할</li>
  <li><strong><code class="language-plaintext highlighter-rouge">--env-file init.env</code></strong>: <code class="language-plaintext highlighter-rouge">init.env</code> 파일에 정의된 환경 변수(예: <code class="language-plaintext highlighter-rouge">APP_BLUE_IMAGE</code>, <code class="language-plaintext highlighter-rouge">APP_GREEN_IMAGE</code>)를 Docker Compose 명령에 적용한다. 이 변수들은 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 이미지 이름을 동적으로 설정하는 데 사용된다.
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># project-mini-frontend/docker-compose.yml (일부)</span>
<span class="na">app-blue</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">${APP_BLUE_IMAGE}</span>
  <span class="c1"># ...</span>
<span class="na">app-green</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">${APP_GREEN_IMAGE}</span>
  <span class="c1"># ...</span>
</code></pre></div>    </div>
    <p>Jenkins 파이프라인은 <code class="language-plaintext highlighter-rouge">init.env</code> 파일을 업데이트하여 <code class="language-plaintext highlighter-rouge">APP_BLUE_IMAGE</code> 또는 <code class="language-plaintext highlighter-rouge">APP_GREEN_IMAGE</code> 변수가 새로 빌드된 이미지 태그를 가리키도록 할 수 있다. (현재 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">init.env</code>를 직접 수정하는 로직은 없지만, 이러한 방식으로 연동될 수 있다.)</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">--no-deps</code></strong>: 지정된 서비스(<code class="language-plaintext highlighter-rouge">deployService</code>)만 업데이트하고, 해당 서비스가 의존하는 다른 서비스(예: Nginx)는 다시 시작하지 않도록 하는 설정. 불필요한 서비스 중단을 방지하여 무중단 배포에 기여한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">--force-recreate</code></strong>: 서비스 컨테이너를 강제로 다시 생성합니다. 이는 새로운 이미지로 컨테이너를 업데이트할 때 필수적이다. 레이어가 중복되는 걸로 인식하여, 실제 변경 사항이 제대로 바뀌지 않는 것을 막기 위함이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">${deployService}</code></strong>: <code class="language-plaintext highlighter-rouge">app-blue</code> 또는 <code class="language-plaintext highlighter-rouge">app-green</code> 중 현재 배포 대상이 되는 서비스 이름이다.</li>
</ul>

<h4 id="sed-명령어를-이용한-nginx-설정-동적-변경-nginxnginxconf-업데이트"><code class="language-plaintext highlighter-rouge">sed</code> 명령어를 이용한 Nginx 설정 동적 변경 (<code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code> 업데이트)</h4>

<p>새로운 버전의 애플리케이션이 성공적으로 배포되면, Nginx 리버스 프록시의 설정을 변경하여 사용자 트래픽을 새로운 환경으로 전환해야 하고 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에서는 <code class="language-plaintext highlighter-rouge">sed</code> 명령어를 사용하여 <code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code> 파일을 동적으로 수정하고 있다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">echo</span> <span class="s2">"--- (3/4) Switch Nginx Configuration to change traffic ---"</span>
                                <span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="s2">"s|server ${upstreamService}:3000;|server ${deployService}:3000;|"</span> <span class="n">$</span><span class="o">{</span><span class="n">TARGET_PROJECT_PATH</span><span class="o">}</span><span class="s">/nginx/</span><span class="n">nginx</span><span class="o">.</span><span class="na">conf</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">sed -i</code></strong>: <code class="language-plaintext highlighter-rouge">sed</code> 명령어는 텍스트 스트림 편집기(Stream Editor)로, 파일의 내용을 변경하는 데 사용된다. <code class="language-plaintext highlighter-rouge">-i</code> 옵션은 변경 사항을 원본 파일에 직접 적용(in-place)하도록 하는 옵션이다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">"s|server ${upstreamService}:3000;|server ${deployService}:3000;|"</code></strong>: <code class="language-plaintext highlighter-rouge">s</code>는 ‘substitute’를 의미하며, 특정 패턴을 찾아 다른 문자열로 대체한다. 여기서는 <code class="language-plaintext highlighter-rouge">server ${upstreamService}:3000;</code> 패턴을 찾아 <code class="language-plaintext highlighter-rouge">server ${deployService}:3000;</code>으로 변경한다. 즉, Nginx가 현재 트래픽을 보내고 있는 이전 서비스(<code class="language-plaintext highlighter-rouge">upstreamService</code>)를 새로운 서비스(<code class="language-plaintext highlighter-rouge">deployService</code>)로 변경하도록 설정 파일의 해당 URL 구문만 수정하는 역할을 한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">${TARGET_PROJECT_PATH}/nginx/nginx.conf</code></strong>: 수정할 Nginx 설정 파일의 경로</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code> 예시</strong>:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># project-mini-frontend/nginx/nginx.conf (일부)</span>
<span class="k">upstream</span> <span class="s">nextjs_app</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="nf">app-blue</span><span class="p">:</span><span class="mi">3000</span><span class="p">;</span> <span class="c1"># 이 부분이 동적으로 변경됩니다.</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="c1"># ...</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://nextjs_app</span><span class="p">;</span>
        <span class="c1"># ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="docker-compose-exec-nginx-nginx--s-reload를-통한-nginx-재로드"><code class="language-plaintext highlighter-rouge">docker compose exec nginx nginx -s reload</code>를 통한 Nginx 재로드</h4>

<p><code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일이 수정된 후, Nginx가 변경된 설정을 적용하도록 재로드해야 한다. 이때 Nginx 서비스를 중단하지 않고 설정을 재로드하는 것이 무중단 배포의 핵심이 된다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (Deploy to Server stage 일부)</span>
                                <span class="n">echo</span> <span class="s2">"--- (4/4) Reload Nginx Configuration ---"</span>
                                <span class="n">docker</span> <span class="n">compose</span> <span class="o">--</span><span class="n">env</span><span class="o">-</span><span class="n">file</span> <span class="n">init</span><span class="o">.</span><span class="na">env</span> <span class="o">-</span><span class="n">f</span> <span class="n">docker</span><span class="o">-</span><span class="n">compose</span><span class="o">.</span><span class="na">yml</span> <span class="n">exec</span> <span class="o">-</span><span class="n">T</span> <span class="n">nginx</span> <span class="n">nginx</span> <span class="o">-</span><span class="n">s</span> <span class="n">reload</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker compose exec nginx</code></strong>: <code class="language-plaintext highlighter-rouge">nginx</code> 서비스 컨테이너 내부에서 명령어를 실행한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">nginx -s reload</code></strong>: Nginx에게 현재 실행 중인 서비스를 중단하지 않고 설정 파일을 다시 읽어들이도록 지시한다. 이는 새로운 연결은 변경된 설정으로 처리하고, 기존 연결은 현재 설정으로 계속 처리하도록 하여 서비스 중단 없이 설정을 적용할 수 있게 만든다.</li>
</ul>

<p>이 과정을 통해 사용자 트래픽은 새로운 버전의 애플리케이션이 실행되는 환경으로 즉시 전환되며, 이전 버전의 애플리케이션은 여전히 실행 중인 상태로 유지된다. 이는 문제가 발생할 경우 빠른 롤백을 가능하게 하는 안전망 역할을 한다.</p>

<h3 id="롤백-전략-rollback-strategy">롤백 전략 (Rollback Strategy)</h3>

<p>Blue/Green 배포는 롤백이 매우 용이하다는 강력한 장점을 가지기에 무중단 배포의 여러 전략 중 이번 프로젝트의 CICD 의 핵심이라고 할 수 있다. 새로운 버전 배포 후 심각한 문제가 발견될 경우, 즉시 이전 버전으로 트래픽을 되돌릴 수 있다.</p>

<h4 id="bluegreen-배포에서의-롤백-용이성">Blue/Green 배포에서의 롤백 용이성</h4>

<ul>
  <li><strong>즉각적인 전환</strong>: 새로운 환경(Green)으로 트래픽을 전환한 후 문제가 발생하면, Nginx 설정을 다시 변경하여 이전 환경(Blue)으로 트래픽을 즉시 되돌릴 수 있다. 이 과정은 <code class="language-plaintext highlighter-rouge">sed</code> 명령어를 반대로 실행하거나, conf 를 직접 수정 후 Nginx를 재로드하는 것만으로 가능해진다.</li>
  <li><strong>이전 환경 유지</strong>: 이전 버전의 애플리케이션이 실행되던 환경은 트래픽 전환 후에도 현재는 유지되도록 해두었다. 이는 롤백 시 별도의 배포 과정 없이 즉시 서비스를 복구할 수 있도록 한다.</li>
</ul>

<h4 id="명시적인-롤백-단계-또는-스크립트의-필요성">명시적인 롤백 단계 또는 스크립트의 필요성</h4>

<p><code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은, 현재는 명시적인 롤백 단계를 포함하고 있지 않다. 프로젝트의 진행, 기존 Jenkins 의 작업을 그대로 활용해서 만들면 되기 때문이다. 향후에 적용이 될 예정이다.</p>

<ul>
  <li><strong>자동 롤백</strong>: <code class="language-plaintext highlighter-rouge">post { failure { ... } }</code> 블록 내에서 배포 실패 시 자동으로 Nginx 설정을 이전 상태로 되돌리고 Nginx를 재로드하는 스크립트를 추가할 수 있다.</li>
  <li><strong>수동 롤백 스크립트</strong>: Jenkins Job으로 별도의 롤백 스크립트를 생성하여, 특정 빌드 번호로 Nginx 트래픽을 전환할 수 있도록 할 수 있다. 이는 긴급 상황 발생 시 운영자가 빠르게 대응할 수 있도록 한다.</li>
</ul>

<h3 id="discord-알림-discord-notification">Discord 알림 (Discord Notification)</h3>

<p>CI/CD 파이프라인에서 빌드 및 배포 과정의 성공 또는 실패 여부를 실시간으로 파악하는 것은 매우 중요하기에 현재는 아주 기본적인 로깅 체계를 구축했다. Jenkins는 다양한 알림 채널을 지원하지만, 현재 개발 중에 가장 많이 사용하는 Discord 를 활용한 실시간 알림 체계를 구축했고, <code class="language-plaintext highlighter-rouge">project-mini-frontend/jenkinsfile</code>은 빌드 결과에 따라 Discord 채널에 알림을 보내는 기능이 동작한다.</p>

<h4 id="curl--x-post--h-content-type-applicationjson---data-message-discord_url-명령어-분석"><code class="language-plaintext highlighter-rouge">curl -X POST -H 'Content-Type: application/json' --data '${message}' ${DISCORD_URL}</code> 명령어 분석</h4>

<p><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">post</code> 블록 내에서 <code class="language-plaintext highlighter-rouge">curl</code> 명령어를 사용하여 Discord 웹훅(Webhook)으로 알림 메시지를 전송한다. 이 명령어는 HTTP POST 요청을 통해 JSON 형식의 데이터를 Discord 웹훅 URL로 보낸다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// project-mini-frontend/jenkinsfile (post success 블록 일부)</span>
        <span class="n">success</span> <span class="o">{</span>
            <span class="n">echo</span> <span class="s2">"Deployment succeeded. Now send a discord notification."</span>
            <span class="n">script</span> <span class="o">{</span>
                <span class="n">withCredentials</span><span class="o">([</span><span class="n">string</span><span class="o">(</span><span class="nl">credentialsId:</span> <span class="n">DISCORD_CREDS_ID</span><span class="o">,</span> <span class="nl">variable:</span> <span class="s1">'DISCORD_URL'</span><span class="o">)])</span> <span class="o">{</span>
                    <span class="kt">def</span> <span class="n">message</span> <span class="o">=</span> <span class="s2">"{\"content\": \"🚀 Build Process is successfully finished : **[${env.JOB_NAME}]** - **#${env.BUILD_NUMBER}**\"}"</span>

                    <span class="n">sh</span> <span class="s2">"curl -X POST -H 'Content-Type: application/json' --data '${message}' ${DISCORD_URL}"</span>
                <span class="o">}</span>

            <span class="o">}</span>

        <span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">curl -X POST</code></strong>: HTTP POST 메서드를 사용하여 요청을 보낸다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">-H 'Content-Type: application/json'</code></strong>: 요청 헤더(Header)에 <code class="language-plaintext highlighter-rouge">Content-Type</code>을 <code class="language-plaintext highlighter-rouge">application/json</code>으로 지정하여, 보내는 데이터가 JSON 형식임을 명시.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">--data '${message}'</code></strong>: 요청 본문(Body)에 전송할 데이터를 지정한다. 여기서는 <code class="language-plaintext highlighter-rouge">message</code> 변수에 저장된 JSON 문자열을 보낸다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">${DISCORD_URL}</code></strong>: Discord 웹훅 URL입니다. 이 URL은 Jenkins Credentials에 <code class="language-plaintext highlighter-rouge">Secret text</code> 타입으로 저장된 <code class="language-plaintext highlighter-rouge">DISCORD_CREDS_ID</code> 자격 증명을 <code class="language-plaintext highlighter-rouge">withCredentials</code> 블록을 통해 <code class="language-plaintext highlighter-rouge">DISCORD_URL</code> 환경 변수로 주입받아 사용한다. 이는 웹훅 URL과 같은 민감한 정보가 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>에 직접 노출되는 것을 방지하여 보안을 강화하는 역할이다.</li>
</ul>

<h4 id="향후-목표">향후 목표</h4>

<p>Jenkins 의 빌드 과정에 대한 report 를 포함, 빌드 과정에서 문제가 발생하지 않고, 하더라도 빠른 대응이 되기 위해 메시지를 단순히 discord로 보내는 것만으로는 한계가 있다. 이에 전문적인 로깅 툴을 연결, 그 툴에 메시지를 보내는 기능을 단계별로 넣어서, 수행하는 작업이나, 향후 들어갈 테스트 등의 항목의 결과들을 공유하도록 수정해볼 생각이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-24 ~ 25-10-27]]></summary></entry><entry><title type="html">TIL - NextJS 무중단 배포 적용</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/23/til-jenkins.html" rel="alternate" type="text/html" title="TIL - NextJS 무중단 배포 적용" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/23/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/23/til-jenkins.html"><![CDATA[<h2 id="25-10-23-jenkins-무중단-배포-적용">25-10-23 Jenkins 무중단 배포 적용</h2>

<h3 id="1-오늘의-목표">1. 오늘의 목표</h3>

<p>기존에 수동으로 배포되던 Next.js 애플리케이션(<code class="language-plaintext highlighter-rouge">project-mini-frontend</code>)을 위해, 독립적으로 운영되는 Jenkins 서버를 활용하여 GitHub <code class="language-plaintext highlighter-rouge">main</code> 브랜치 변경 시 자동으로 빌드, GHCR 푸시, 타겟 서버 SSH 접속 및 Blue/Green 무중단 배포를 수행하는 CI/CD 파이프라인을 완성하는 것이 목표였다.</p>

<hr />
<h3 id="jenkins-무중단-배포-파이프라인-구축-절차">Jenkins 무중단 배포 파이프라인 구축 절차</h3>
<p><strong>1단계: 젠킨스 환경 최종 준비 (도구 챙기기)</strong></p>
<ul>
  <li><strong>목표:</strong> 젠킨스 컨테이너가 배포에 필요한 ‘도구’(<code class="language-plaintext highlighter-rouge">ssh</code>, <code class="language-plaintext highlighter-rouge">git</code>, <code class="language-plaintext highlighter-rouge">docker</code>)를 모두 갖추고, ‘비밀번호’(<code class="language-plaintext highlighter-rouge">Credentials</code>)를 발급받도록 합니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">jenkins/Dockerfile</code>에 <code class="language-plaintext highlighter-rouge">openssh-client</code> 설치 코드 추가 및 젠킨스 재시작
        <ul>
          <li>설치: <code class="language-plaintext highlighter-rouge">RUN apt-get update &amp;&amp; apt-get install -y openssh-client</code></li>
          <li>빌드 및 실행(터미널에서) : <code class="language-plaintext highlighter-rouge">docker exec jenkins-server ssh</code> &gt; 입력 시 ssh 정상 설치 되면 매뉴얼이 뜸</li>
        </ul>
      </li>
      <li>젠킨스 Credential 등록 (GitHub PAT, GHCR PAT)
        <ul>
          <li><strong>1. GitHub 리포지토리 접근용 (Git Checkout)</strong>
            <ul>
              <li><strong>Kind:</strong> <code class="language-plaintext highlighter-rouge">Username with password</code></li>
              <li><strong>Username:</strong> (본인의 GitHub ID)</li>
              <li><strong>Password:</strong> (GitHub PAT - <code class="language-plaintext highlighter-rouge">repo</code> 스코프 권한 필요)</li>
              <li><strong>ID:</strong> <code class="language-plaintext highlighter-rouge">github-creds</code> (또는 식별 가능한 이름)</li>
            </ul>
          </li>
          <li><strong>2. GHCR 이미지 푸시용 (Docker Push)</strong>
            <ul>
              <li><strong>Kind:</strong> <code class="language-plaintext highlighter-rouge">Username with password</code></li>
              <li><strong>Username:</strong> (본인의 GitHub ID)</li>
              <li><strong>Password:</strong> (GitHub PAT - <code class="language-plaintext highlighter-rouge">write:packages</code> 스코프 권한 필요)</li>
              <li><strong>ID:</strong> <code class="language-plaintext highlighter-rouge">ghcr-creds</code> (또는 식별 가능한 이름)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>호스트 서버 <code class="language-plaintext highlighter-rouge">sshd</code> 서비스 실행 상태 최종 확인</li>
    </ol>
  </li>
</ul>

<p><strong>2단계: <code class="language-plaintext highlighter-rouge">project-mini-frontend</code> 리포지토리 설정 (명령서 작성)</strong></p>
<ul>
  <li><strong>목표:</strong> Next.js 리포지토리에 젠킨스가 수행할 모든 작업을 정의한 ‘명령서’(<code class="language-plaintext highlighter-rouge">Jenkinsfile</code>)를 추가하고, GitHub가 젠킨스를 호출할 ‘연락망’(Webhook)을 설정합니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Jenkinsfile</code> (파이프라인 스크립트) 신규 작성</li>
      <li>GitHub 리포지토리 Webhook 설정 (젠킨스 URL 연동)</li>
    </ol>
  </li>
  <li><strong>작업하면서 궁금했던 사항 정리</strong>
    <ul>
      <li>env 변수에 쓸수  있는 유용한 내장 환경 변수들
        <ul>
          <li><code class="language-plaintext highlighter-rouge">env.BUILD_NUMBER</code>: 현재 빌드의 순차 번호 (예: “57”)</li>
          <li><code class="language-plaintext highlighter-rouge">env.JOB_NAME</code>: 현재 실행 중인 젠킨스 잡(Job)의 이름</li>
          <li><code class="language-plaintext highlighter-rouge">env.BUILD_URL</code>: 현재 빌드 로그를 볼 수 있는 젠킨스의 URL (실패 알림에 필수)</li>
          <li><code class="language-plaintext highlighter-rouge">env.BRANCH_NAME</code>: 빌드를 트리거한 브랜치 이름 (예: “main”)</li>
          <li><code class="language-plaintext highlighter-rouge">env.GIT_COMMIT</code>: 빌드에 사용된 Git 커밋 해시(ID)</li>
          <li><code class="language-plaintext highlighter-rouge">env.WORKSPACE</code>: 젠킨스 에이전트가 코드를 Checkout 받은 경로</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ssh -o StrictHostKeyChecking=no</code> 란?
        <ul>
          <li>SSH 접속시 일반적으로 설정하는 것 질문 절차가 있는데, 젠킨스는 여기서 yes 라고 입력 안됨. 파이프라인 멈춤게 됨. 이에 그 질문을 강제로 무시하고, 무조건 신뢰하여 자동화 시키는 역할을 함.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>3단계: 젠킨스 파이프라인(Job) 생성 (프로젝트 연결)</strong></p>
<ul>
  <li><strong>목표:</strong> 젠킨스 UI에서 “이 GitHub 리포지토리의 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 읽어서 실행해”라고 설정하는 새 작업을 만듭니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li>젠킨스 대시보드에서 “New Item” &gt; “Pipeline” 생성</li>
      <li>“Pipeline script from SCM” 옵션으로 GitHub 리포지토리 및 <code class="language-plaintext highlighter-rouge">Jenkinsfile</code> 경로 연결</li>
    </ol>
  </li>
  <li>Jenkins Credential 등록 (GitHub PAT <code class="language-plaintext highlighter-rouge">github-creds</code>, GHCR PAT <code class="language-plaintext highlighter-rouge">ghcr-creds</code>, SSH Private Key <code class="language-plaintext highlighter-rouge">a5-localhost-jenkins</code>).</li>
  <li><strong>Blue/Green 전환 로직 (<code class="language-plaintext highlighter-rouge">Deploy to Server</code> SSH 스크립트):</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">set -ex</code>: 명령어 추적 및 오류 시 즉시 종료 설정.</li>
      <li><code class="language-plaintext highlighter-rouge">docker login ghcr.io ...</code>: 타겟 서버에서 GHCR 로그인.</li>
      <li><code class="language-plaintext highlighter-rouge">docker pull [imageTag]</code>: 새 이미지 다운로드.</li>
      <li><code class="language-plaintext highlighter-rouge">cd [TARGET_PROJECT_PATH]</code>: 프로젝트 폴더 이동.</li>
      <li><code class="language-plaintext highlighter-rouge">docker compose --env-file .env.[deployService] up -d --no-deps --force-recreate [deployService]</code>: 임시 <code class="language-plaintext highlighter-rouge">.env</code> 파일을 사용하여 대기조 컨테이너 강제 재생성.</li>
      <li><code class="language-plaintext highlighter-rouge">sed -i "s|...|..." [nginx.conf 경로]</code>: Nginx 설정 파일의 <code class="language-plaintext highlighter-rouge">upstream</code> 변경.</li>
      <li><code class="language-plaintext highlighter-rouge">docker compose --env-file init.env exec -T nginx nginx -s reload</code>: Nginx 리로드 (기본 <code class="language-plaintext highlighter-rouge">init.env</code> 참조).</li>
      <li><code class="language-plaintext highlighter-rouge">docker logout ghcr.io</code>: 타겟 서버 로그아웃.</li>
    </ol>
  </li>
</ul>

<p><strong>4단계: 최초 빌드 실행 및 트러블슈팅</strong></p>
<ul>
  <li><strong>목표:</strong> <code class="language-plaintext highlighter-rouge">main</code> 브랜치에 코드를 푸시(Push)하여 1~3단계의 모든 설정이 올바르게 작동하는지 확인하고, 첫 배포를 성공시킵니다.</li>
  <li><strong>주요 작업:</strong>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Jenkinsfile</code>을 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에 푸시하여 Webhook 트리거 실행 (또는 “Build Now” 수동 클릭)</li>
      <li>젠킨스 “Blue Ocean” UI에서 빌드 과정 실시간 모니터링</li>
      <li>오류 발생 시(예: 권한 문제, 경로 오류) 로그 확인 및 수정</li>
    </ol>
  </li>
</ul>

<hr />

<h3 id="진행-시-메모">진행 시 메모</h3>

<h4 id="jenkins-서버-쪽-작업">Jenkins 서버 쪽 작업</h4>
<ul>
  <li>jenkins 서버 내에서가 아닌 host 서버에서 build 해야 함
    <ul>
      <li>Jenkins 의 Dockerfile에 이를 위한 패키지를 추가했다.</li>
      <li>컨트롤을 할 클라이언트, Docker 를 호스트에서 수행하도록 만들어야 했다. : DooD 가 필요했고, 이를 위한 내용을 Jenkins 의 Dockerfile 에 기록했다.
        <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">services</span><span class="pi">:</span>
<span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">context</span><span class="pi">:</span> <span class="s">jenkins</span>
  <span class="na">container_name</span><span class="pi">:</span> <span class="s">jenkins-server</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">12345:8080"</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./jenkins_home:/var/jenkins_home</span>
    <span class="c1"># Docker CLI 사용을 위해 호스트로 마운트</span>
    <span class="pi">-</span> <span class="s">/var/run/docker.sock:/var/run/docker.sock</span>
    <span class="pi">-</span> <span class="s">/usr/bin/docker:/usr/bin/docker</span>
    <span class="pi">-</span> <span class="s">/usr/bin/docker-compose:/usr/bin/docker-compose</span>
  <span class="c1"># user: root</span>
  <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">CASC_JENKINS_CONFIG=/var/jenkins_home/casc.yaml</span>
  <span class="na">entrypoint</span><span class="pi">:</span> <span class="pi">&gt;</span>
    <span class="s">bash -c "</span>
      <span class="s">cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;</span>
      <span class="s">/usr/bin/tini -- /usr/local/bin/jenkins.sh</span>
    <span class="s">"</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>이때 가장 편한 방법은 <code class="language-plaintext highlighter-rouge">DooD</code> 시 Jenkins 컨테이너 내부 User를 <code class="language-plaintext highlighter-rouge">Root</code> 로 설정해야 바로 젠킨스 서버 컨테이너가, Host 서버의 Docker 를 수정할 수 있음
    <ul>
      <li>이는 보안의 위협이 됨. 이에 UID 와 GID 를 수정해줌으로써 권한 문제 없이 호스트를 제어 하도록 만들어 주었다.
        <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># 전략</span>
  <span class="c"># DooD 구조를 위함. Docker 그룹에 jenkins 유저 추가</span>
  ARG DOCKER_GID=1001
  RUN groupadd -g ${DOCKER_GID} docker
  RUN usermod -aG docker jenkins
  <span class="c"># 후략</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="nextjs-서버">NextJS 서버</h4>
<ul>
  <li>NextJS 이미지를 app-blue, app-green 으로 스위칭 되며 동작하게 만드는게 핵심이었고, docker-compose.yml 이를 위한 변수를 읽기 위해 <code class="language-plaintext highlighter-rouge">init.env</code> 파일을 설정하였다.</li>
  <li>Jenkinsfile 의 경우 <code class="language-plaintext highlighter-rouge">environment</code>, <code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">post</code> 로 간단한 구조다. 이때 핵심은 환경은 변수와 전역으로 필요한 것들만 지정해주었다.
    <ul>
      <li>stages 에는 각 스테이지들이 설정되고 스테이지들에서 유의사항은 다음과 같다.
        <ul>
          <li>Jenkins 는 workspace 라는 공간에서 설정에 따라 github을 설정하면 자동으로 바라보는 브랜치의 최신 상태를 다운로드 받는다.</li>
          <li>그리고 그 상단을 기준으로 하면, 이미 파일은 올라가있기 때문에 <code class="language-plaintext highlighter-rouge">Build Image</code> 스테이지에서는 빌드를 빠르게 가능하다.</li>
          <li>Stages는 아래와 같은 단계를 소유한다
            <ul>
              <li>Checkout</li>
              <li>Build Image</li>
              <li>Push to GHCR</li>
              <li>Deploy to GHCR</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>post 는 사후 단계로 향후에는 여러 로깅이나, 이런 것들이 가능하나, 현재는 웹 훅을 통한 알림을 추가했다. 
<img src="/assets/images/posts/2025-10/2025-10-23-052.png" alt="" />
        <blockquote>
          <p>알림은 아주 잘 온다. 향후엔 디테일하게 붙이는 방법이나, 모듈화를 고민해보자..</p>
        </blockquote>
      </li>
      <li>참고로 logging은 깔끔하게 보기 위하여 <code class="language-plaintext highlighter-rouge">블루오션</code> 플러그인을 활용했다
<img src="/assets/images/posts/2025-10/2025-10-23-053.png" alt="" />
        <blockquote>
          <p>처음엔 어떻게 쓰는지 몰라서 한참 기본 로그만 봤다…</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="주요-트러블슈팅-및-해결-과정-파이프라인-실행-중">주요 트러블슈팅 및 해결 과정 (파이프라인 실행 중)</h3>

<ol>
  <li><strong>Jenkinsfile 문법 오류 (<code class="language-plaintext highlighter-rouge">MultipleCompilationErrorsException</code>):</strong>
    <ul>
      <li><strong>원인:</strong> <code class="language-plaintext highlighter-rouge">stages</code> 블록 누락, <code class="language-plaintext highlighter-rouge">post</code> 블록 내 <code class="language-plaintext highlighter-rouge">script</code> 누락.</li>
      <li><strong>해결:</strong> 파이프라인 구조 수정.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sshagent</code> DSL 찾기 실패 (<code class="language-plaintext highlighter-rouge">NoSuchMethodError</code>):</strong>
    <ul>
      <li><strong>원인:</strong> “SSH Agent” 플러그인 미설치.</li>
      <li><strong>해결:</strong> 젠킨스 플러그인 관리자에서 설치.</li>
    </ul>
  </li>
  <li><strong>GHCR 푸시 실패 (<code class="language-plaintext highlighter-rouge">denied</code>, <code class="language-plaintext highlighter-rouge">insufficient_scope</code>):</strong>
    <ul>
      <li><strong>원인:</strong> 젠킨스 Credential의 PAT 정보 오류 또는 스코프 부족(<code class="language-plaintext highlighter-rouge">repo</code> 누락), <code class="language-plaintext highlighter-rouge">docker build</code> 시 이미지 태그 주소 누락 등 복합적 요인.</li>
      <li><strong>해결:</strong> Credential 재확인 했으나 문제 없었음. 핵심은 보안에 취약하다며 AI 가 추천한 방식으로 수정했을 때 문제 발생. <code class="language-plaintext highlighter-rouge">Jenkinsfile</code>의 <code class="language-plaintext highlighter-rouge">docker login</code> 방식 수정 (<code class="language-plaintext highlighter-rouge">echo | docker login --password-stdin</code>) 원래 형태로 수정하여 파이프를 통해 credential 전달로 해결 완료.</li>
    </ul>
  </li>
  <li><strong>타겟 서버 <code class="language-plaintext highlighter-rouge">docker pull</code> 실패 (<code class="language-plaintext highlighter-rouge">unauthorized</code>):</strong>
    <ul>
      <li><strong>원인:</strong> SSH로 접속한 타겟 서버(<code class="language-plaintext highlighter-rouge">hansol</code> 유저)가 GHCR에 로그인되어 있지 않음.</li>
      <li><strong>해결:</strong> <code class="language-plaintext highlighter-rouge">Deploy to Server</code> 스테이지 SSH 스크립트 내부에 <code class="language-plaintext highlighter-rouge">docker login ghcr.io ...</code> 명령어 추가. 너무 기본적인 거였는데… 호스트에선 보안, 그리고 클리어한 상태 유지를 위해 로직 내부에 login / logout 을 넣어줬어야 했다.</li>
    </ul>
  </li>
  <li><strong>Blue/Green 컨테이너 미교체 (<code class="language-plaintext highlighter-rouge">up-to-date</code>):</strong>
    <ul>
      <li><strong>원인:</strong> <code class="language-plaintext highlighter-rouge">docker compose up</code> 실행 시 <code class="language-plaintext highlighter-rouge">--env-file</code>로 전달된 새 이미지 태그를 인식하지 못하는 건지, 아니면 레이어가 바뀌지 않는 건지 동작하지 않았다.</li>
      <li><strong>해결:</strong> <code class="language-plaintext highlighter-rouge">docker compose up</code> 명령어에 <code class="language-plaintext highlighter-rouge">--force-recreate</code> 플래그 추가하여 무조건 교체가 되도록 하였음. 그리고 정확한 타게팅을 위해, 환경 변수가 필요했고 이에 <code class="language-plaintext highlighter-rouge">docker compose exec</code> 명령어에 <code class="language-plaintext highlighter-rouge">--env-file init.env</code> 옵션 추가로 환경변수를 명시해줌으로써 완전히 해결되었다.</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="배운-점-key-learnings">배운 점 (Key Learnings)</h3>

<ul>
  <li>젠킨스 파이프라인 문법 및 구조 (<code class="language-plaintext highlighter-rouge">stages</code>, <code class="language-plaintext highlighter-rouge">environment</code>, <code class="language-plaintext highlighter-rouge">Credentials</code>, <code class="language-plaintext highlighter-rouge">post</code>)를 제대로 공부했다. 아직 외운게 아니고 AI 를 통해 맡겨서 하면서, 뭔지 파악한 거라 향후엔 제대로 문서를 보든 해야 할 것 같다.</li>
  <li>SSH 기반 원격 서버 자동화 시 <code class="language-plaintext highlighter-rouge">sshagent</code>와 <code class="language-plaintext highlighter-rouge">StrictHostKeyChecking=no</code> 옵션, 명령어 실패 처리(<code class="language-plaintext highlighter-rouge">set -ex</code>)의 중요성.. 이라고 하지만 실상 필요한거면 당연히 안 들어있다고 생각했어야 한다. 🤣</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose</code> 명령어 실행 시 환경 변수 처리 방식 (<code class="language-plaintext highlighter-rouge">--env-file</code>, 기본 <code class="language-plaintext highlighter-rouge">.env</code>) 및 <code class="language-plaintext highlighter-rouge">--force-recreate</code> 플래그의 유용성.. 이라고 AI 가 정리해줬지만, 실질 이제는 –force-recreate 가 필요 없을지도..?</li>
  <li>Blue/Green 배포 시 <code class="language-plaintext highlighter-rouge">sed</code>를 이용한 Nginx <code class="language-plaintext highlighter-rouge">upstream</code> 동적 변경 및 <code class="language-plaintext highlighter-rouge">nginx -s reload</code>를 통한 무중단 트래픽 전환 방법은 되고 나니 너무 훌륭하고 짜릿하다…😍</li>
  <li>GHCR 인증 및 이미지 태그 지정 방식의 정확성 필요.</li>
  <li>CI/CD 파이프라인 구축 시 단계별 로그 확인(<code class="language-plaintext highlighter-rouge">docker logs</code>, <code class="language-plaintext highlighter-rouge">ssh -v</code>, Jenkins Console Output)을 통한 체계적인 트러블슈팅 방법. 아직 완벽하지도 않고, 보니 단계별로 명확한 로그가 남지 않는 다는 건 아쉽다. SSH 기반과 로그를 더 많이 기록하게 하는 방법이나 블루오션 플러그인 활용법 정리가 필요해 보인다.</li>
  <li>GitHub Webhook 연동을 위해서는 Jenkins 서버의 HTTPS 노출이 필요하며, 이는 <strong>향후 과제</strong>로 남겨두었다. 우선 프론트엔드 작업들 하면서 감 익히고 난 후엔 수행해볼 예정</li>
</ul>

<p><img src="/assets/images/posts/2025-10/2025-10-23-054.png" alt="" /></p>
<blockquote>
  <p>캬 … 먼저 배포부터 만들어버렸다… AI 덕이긴 한데 많이 늘었구나 나도…</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[25-10-23 Jenkins 무중단 배포 적용]]></summary></entry><entry><title type="html">TIL - Jenkins 서버 배포 및 무중단 배포 준비 프로세스</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/21/til-jenkins.html" rel="alternate" type="text/html" title="TIL - Jenkins 서버 배포 및 무중단 배포 준비 프로세스" /><published>2025-10-21T00:00:00+00:00</published><updated>2025-10-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/21/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/21/til-jenkins.html"><![CDATA[<h2 id="2025년-10월-21일-젠킨스jenkins-서버-구축-및-무중단-배포-아키텍처-설계">2025년 10월 21일: 젠킨스(Jenkins) 서버 구축 및 무중단 배포 아키텍처 설계</h2>

<h3 id="1-오늘의-목표">1. 오늘의 목표</h3>

<p>‘실무형 CI/CD 파이프라인’ 구축의 첫 단계로, JCasC(Jenkins Configuration as Code)를 활용해 젠킨스 서버를 독립적으로 설치하고, SSH 기반의 Blue/Green 무중단 배포 아키텍처를 설계 및 확정했다.</p>

<h3 id="2-핵심-아키텍처-설계">2. 핵심 아키텍처 설계</h3>

<p>젠킨스 서버의 독립성과 이식성을 최우선으로 하며, 실제 상용 서비스의 빌드/배포 환경을 정확히 모사하는 것을 목표로 한다.</p>

<h4 id="1-핵심-원칙">1. 핵심 원칙</h4>

<ul>
  <li><strong>젠킨스 독립성 (이식성):</strong> <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code>라는 별도 리포지토리에서 <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">casc.yaml</code> 등으로 젠킨스 서버 자체를 코드화(Codefied)하여 관리한다. 이는 백업 및 재설정을 매우 용이하게 한다.</li>
  <li><strong>실무 환경 모사 (역할 분리):</strong>
    <ul>
      <li><strong>빌드 서버 (Jenkins):</strong> 젠킨스 컨테이너가 이 역할을 맡는다.</li>
      <li><strong>타겟 서버 (Host):</strong> 젠킨스가 설치된 호스트 머신(<code class="language-plaintext highlighter-rouge">localhost</code>)이 이 역할을 맡는다.</li>
    </ul>
  </li>
  <li><strong>배포 방식 (SSH):</strong> 빌드 서버는 <strong>DooD 방식을 사용하지 않고</strong>, 오직 <strong>SSH</strong>를 통해서만 타겟 서버에 접속하여 배포 명령(<code class="language-plaintext highlighter-rouge">docker pull</code>, <code class="language-plaintext highlighter-rouge">docker compose up</code>, <code class="language-plaintext highlighter-rouge">nginx reload</code> 등)을 전달한다.</li>
</ul>

<h4 id="2-자동화-프로세스">2. 자동화 프로세스</h4>

<ol>
  <li><strong>Trigger:</strong> GitHub <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 PR이 병합되면 Webhook을 통해 젠킨스가 이를 감지한다.</li>
  <li><strong>Build:</strong> 젠킨스가 <code class="language-plaintext highlighter-rouge">project-mini-frontend</code>의 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 사용해 새 이미지를 클린 빌드한다.</li>
  <li><strong>Push:</strong> 젠킨스가 빌드된 이미지를 **GHCR(GitHub Container Registry)**로 푸시한다.</li>
  <li><strong>Deploy (via SSH):</strong> 젠킨스가 Credential에 등록된 SSH 키를 사용해 타겟 서버(<code class="language-plaintext highlighter-rouge">localhost</code>)에 접속한다.</li>
  <li><strong>Target Server Actions:</strong> SSH 세션 내에서 다음의 셸 스크립트가 순차적으로 실행된다:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (예시) 젠킨스가 SSH를 통해 실행할 명령어들</span>
docker pull ghcr.io/hansol/project-mini-frontend:build-123
docker compose up <span class="nt">-d</span> <span class="nt">--no-deps</span> app-green
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/server app-blue:3000;/server app-green:3000;/'</span> /path/to/nginx.conf
docker compose <span class="nb">exec </span>nginx nginx <span class="nt">-s</span> reload
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="3-이미지-및-롤백-전략">3. 이미지 및 롤백 전략</h4>

<ul>
  <li><strong>이미지 명명:</strong> 젠킨스가 <code class="language-plaintext highlighter-rouge">BUILD_NUMBER</code> (빌드 번호), <code class="language-plaintext highlighter-rouge">GIT_COMMIT</code> (커밋 해시) 등 강력한 메타데이터를 이미 관리하므로, 이미지 태그는 <code class="language-plaintext highlighter-rouge">ghcr.io/hansol/repo:${env.BUILD_NUMBER}</code>처럼 젠킨스의 <strong>빌드 번호</strong>를 사용하는 것이 가장 효율적이다.</li>
  <li><strong>롤백 전략:</strong> <code class="language-plaintext highlighter-rouge">docker image</code>를 이용한 롤백이 아닌, Git에서 <code class="language-plaintext highlighter-rouge">revert</code> 커밋을 푸시하여 새로운 파이프라인을 트리거하는 <strong>‘Roll-Forward’</strong> 방식을 채택한다. 이는 배포의 유일한 진입점을 CI/CD 파이프라인으로 통일시켜 안정성을 높인다.</li>
</ul>

<hr />

<h3 id="3-젠킨스-서버-설치-과정">3. 젠킨스 서버 설치 과정</h3>

<p>독립된 <code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 프로젝트를 통해 젠킨스 서버를 컨테이너로 실행했다.</p>

<h4 id="1-jcasc-템플릿-구성">1. JCasC 템플릿 구성</h4>

<p><code class="language-plaintext highlighter-rouge">project-mini-jenkins</code> 폴더를 다음과 같이 구성하여 젠킨스 서버 자체를 코드로 관리했다.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">docker-compose.yml</code> (서비스 정의)</strong></p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">jenkins</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">jenkins</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">jenkins-server</span>
    <span class="na">ports</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">12345:8080"</span><span class="pi">]</span> <span class="c1"># 8080 대신 12345 포트 사용</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./jenkins_home:/var/jenkins_home</span> <span class="c1"># Bind Mount</span>
    <span class="na">entrypoint</span><span class="pi">:</span> <span class="pi">&gt;</span> <span class="c1"># casc.yaml을 jenkins_home으로 복사</span>
      <span class="s">bash -c "</span>
        <span class="s">cp /usr/share/jenkins/ref/casc.yaml /var/jenkins_home/casc.yaml &amp;&amp;</span>
        <span class="s">/usr/bin/tini -- /usr/local/bin/jenkins.sh</span>
      <span class="s">"</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">jenkins_home</span><span class="pi">:</span> <span class="pi">{}</span> <span class="c1"># Bind Mount를 사용하기로 했으므로 이 부분은 삭제됨</span>
</code></pre></div>    </div>

    <p><em>최종적으로 <code class="language-plaintext highlighter-rouge">volumes: [jenkins_home: {}]</code>는 삭제하고, <code class="language-plaintext highlighter-rouge">volumes: [./jenkins_home:/var/jenkins_home]</code>로 수정하여 Bind Mount를 사용하기로 결정했다.</em></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">jenkins/Dockerfile</code> (커스텀 이미지)</strong></p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> jenkins/jenkins:lts-jdk21</span>
<span class="k">USER</span><span class="s"> root</span>
<span class="k">COPY</span><span class="s"> plugins.txt /usr/share/jenkins/ref/plugins.txt</span>
<span class="k">RUN </span>jenkins-plugin-cli <span class="nt">--plugin-file</span> /usr/share/jenkins/ref/plugins.txt
<span class="k">COPY</span><span class="s"> casc.yaml /usr/share/jenkins/ref/casc.yaml</span>
<span class="k">USER</span><span class="s"> jenkins</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">jenkins/plugins.txt</code> (플러그인 목록)</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>configuration-as-code
git
workflow-aggregator
blueocean
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">jenkins/casc.yaml</code> (젠킨스 설정)</strong></p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jenkins</span><span class="pi">:</span>
  <span class="na">systemMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Welcome</span><span class="nv"> </span><span class="s">to</span><span class="nv"> </span><span class="s">My</span><span class="nv"> </span><span class="s">Jenkins</span><span class="nv"> </span><span class="s">Server!</span><span class="nv"> </span><span class="s">This</span><span class="nv"> </span><span class="s">instance</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">managed</span><span class="nv"> </span><span class="s">by</span><span class="nv"> </span><span class="s">Code.</span><span class="nv"> </span><span class="s">🚀"</span>
  <span class="na">numExecutors</span><span class="pi">:</span> <span class="m">2</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-bind-mount와-uid-1000-권한-분석">2. Bind Mount와 UID 1000 권한 분석</h4>

<p><code class="language-plaintext highlighter-rouge">Dockerfile</code>로 빌드된 젠킨스 컨테이너는 보안을 위해 <code class="language-plaintext highlighter-rouge">root</code>가 아닌 UID <code class="language-plaintext highlighter-rouge">1000</code>번(<code class="language-plaintext highlighter-rouge">jenkins</code> 유저)으로 실행된다. <code class="language-plaintext highlighter-rouge">volumes: [./jenkins_home:/var/jenkins_home]</code> (Bind Mount) 사용 시, 호스트 폴더의 소유자 UID와 컨테이너 유저의 UID가 다르면 ‘Permission denied’ 오류가 발생한다.</p>

<ul>
  <li><strong>일반적인 해결책:</strong> 호스트에서 <code class="language-plaintext highlighter-rouge">sudo chown -R 1000:1000 jenkins_home</code> 명령어로 소유권을 강제로 맞춰야 한다.</li>
  <li><strong>나의 상황 (오늘의 발견):</strong> 내 호스트 서버(Ubuntu 22.04)의 <code class="language-plaintext highlighter-rouge">hansol</code> 계정 ID를 확인해보니, 젠킨스 컨테이너와 동일한 <code class="language-plaintext highlighter-rouge">1000</code>번이었다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">id </span>hansol
<span class="c"># uid=1000(hansol) gid=1000(hansol) groups=1000(hansol)...</span>
</code></pre></div>    </div>
  </li>
  <li><strong>결론:</strong> 나의 <code class="language-plaintext highlighter-rouge">hansol</code> 계정은 우분투 설치 시 생성된 첫 번째 표준 계정 ID(<code class="language-plaintext highlighter-rouge">1000</code>)를 사용하고 있어, 젠킨스 컨테이너의 UID(<code class="language-plaintext highlighter-rouge">1000</code>)와 완벽하게 일치한다. 이로 인해 나는 ‘Permission denied’ 문제가 원천적으로 발생하지 않는 이상적인 상태이며, 별도의 <code class="language-plaintext highlighter-rouge">chown</code> 명령어가 필요 없음을 확인했다.</li>
</ul>

<h4 id="3-젠킨스-실행-및-설정-마법사">3. 젠킨스 실행 및 설정 마법사</h4>

<ol>
  <li>프로젝트 폴더에 <code class="language-plaintext highlighter-rouge">jenkins_home</code> 디렉터리를 생성했다. (나의 경우 <code class="language-plaintext highlighter-rouge">chown</code>은 불필요했다.)
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>jenkins_home
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker compose up --build -d</code> 명령어로 젠킨스 빌드 및 실행.</li>
  <li><code class="language-plaintext highlighter-rouge">docker logs jenkins-server</code>로 초기 관리자 비밀번호 확인.</li>
  <li><code class="language-plaintext highlighter-rouge">http://paulryu9309.ddns.net:12345</code> (서버 IP와 변경된 포트)로 접속하여 설정 마법사(플러그인 설치, 관리자 계정 생성)를 완료했다.</li>
  <li>젠킨스 대시보드에서 <code class="language-plaintext highlighter-rouge">casc.yaml</code>에 정의한 “Welcome to My Jenkins Server!…” 환영 메시지를 확인하며 JCasC 적용을 최종 검증했다.</li>
</ol>

<h4 id="4-ssh-credential-등록-핵심-준비">4. SSH Credential 등록 (핵심 준비)</h4>

<p>젠킨스가 타겟 서버(<code class="language-plaintext highlighter-rouge">localhost</code>)에 접속할 수 있도록 <code class="language-plaintext highlighter-rouge">ssh-keygen</code>을 통해 젠킨스 전용 키 페어(<code class="language-plaintext highlighter-rouge">jenkins_key</code>, <code class="language-plaintext highlighter-rouge">jenkins_key.pub</code>)를 생성했다.</p>

<ol>
  <li><strong>서버(호스트)에 ‘자물쇠’ 설치:</strong> 생성한 공개키(<code class="language-plaintext highlighter-rouge">jenkins_key.pub</code>)의 내용을 <code class="language-plaintext highlighter-rouge">cat</code>을 이용해 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 파일에 추가했다.</li>
  <li><strong>젠킨스에 ‘열쇠’ 등록:</strong> 젠킨스 UI의 [Manage Jenkins] &gt; [Credentials]에서 <code class="language-plaintext highlighter-rouge">Kind</code>를 <code class="language-plaintext highlighter-rouge">SSH Username with Private Key</code>로 선택하고, <code class="language-plaintext highlighter-rouge">Username</code>에 <code class="language-plaintext highlighter-rouge">hansol</code>, <code class="language-plaintext highlighter-rouge">Private Key</code>에 개인키(<code class="language-plaintext highlighter-rouge">jenkins_key</code>)의 내용을 복사하여 글로벌 Credential을 성공적으로 등록했다.</li>
</ol>

<p><img src="/assets/images/posts/2025-10/2025-10-21-051.png" alt="" /></p>
<blockquote>
  <p>WSL 만 아니었으면 무중단까지 간건데… 아쉽다…</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 21일: 젠킨스(Jenkins) 서버 구축 및 무중단 배포 아키텍처 설계]]></summary></entry><entry><title type="html">TIL - HTTPS 적용 및 갱신 구조 적용하기(Nginx, NextJS)</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/20/til-devops.html" rel="alternate" type="text/html" title="TIL - HTTPS 적용 및 갱신 구조 적용하기(Nginx, NextJS)" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-10-20T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/20/til-devops</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/20/til-devops.html"><![CDATA[<h2 id="2025년-10월-20일-docker-compose와-nginx-환경에-lets-encrypt-certbot로-https-적용-및-자동-갱신-설정">2025년 10월 20일: Docker Compose와 Nginx 환경에 Let’s Encrypt (Certbot)로 HTTPS 적용 및 자동 갱신 설정</h2>

<h3 id="요약">요약</h3>

<p>기존에 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>로 관리하던 Nginx 리버스 프록시와 Next.js (Blue/Green) 환경에, Let’s Encrypt의 Certbot을 도입하여 HTTPS를 적용했다. 이 과정에서 포트포워딩, Nginx 설정 충돌, 도메인 CAA 정책 등 다양한 문제를 마주쳤으며, 이를 해결한 뒤 최종적으로 호스트 서버의 <code class="language-plaintext highlighter-rouge">Crontab</code>을 이용해 인증서 자동 갱신 스크립트까지 설정하여 전체 배포 아키텍처를 완성했다.</p>

<hr />

<h3 id="1-최종-목표">1. 최종 목표</h3>

<p>Nginx 리버스 프록시에 SSL을 적용하여 <code class="language-plaintext highlighter-rouge">http://</code> 요청을 <code class="language-plaintext highlighter-rouge">https://</code>로 강제 리디렉션하고, 443 포트를 통해 암호화된 트래픽을 처리한다. 인증서는 무료 발급 기관인 Let’s Encrypt를 사용하며, 발급 및 갱신은 Certbot을 통해 자동화한다.</p>

<p><strong>사용한 핵심 기술:</strong></p>
<ul>
  <li>Docker Compose</li>
  <li>Nginx (Reverse Proxy)</li>
  <li>Certbot (Let’s Encrypt Client)</li>
  <li><code class="language-plaintext highlighter-rouge">webroot</code> (HTTP-01) 인증 방식</li>
</ul>

<hr />

<h3 id="2-https-적용-절차">2. HTTPS 적용 절차</h3>

<p>HTTPS 적용은 ‘최초 발급’과 ‘최종 적용’의 두 단계로 나누어 진행했다.</p>

<h4 id="1단계-certbot-서비스-및-볼륨-정의">1단계: Certbot 서비스 및 볼륨 정의</h4>

<p><code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일에 <code class="language-plaintext highlighter-rouge">certbot</code> 서비스를 추가하고, Nginx와 Certbot이 인증서 및 인증용 파일을 공유할 수 있도록 2개의 볼륨을 마운트했다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">./nginx/certs:/etc/letsencrypt</code>: 발급된 인증서가 저장될 경로</li>
  <li><code class="language-plaintext highlighter-rouge">./nginx/www:/var/www/certbot</code>: Certbot이 <code class="language-plaintext highlighter-rouge">webroot</code> 인증을 위해 임시 파일을 생성할 경로</li>
</ul>

<p>또한 Nginx 서비스의 <code class="language-plaintext highlighter-rouge">ports</code>에 <code class="language-plaintext highlighter-rouge">"443:443"</code>을 추가했다.</p>

<h4 id="2단계-nginx-임시-설정-인증서-발급용">2단계: Nginx 임시 설정 (인증서 발급용)</h4>

<p><code class="language-plaintext highlighter-rouge">webroot</code> 방식은 80번 포트의 특정 경로(<code class="language-plaintext highlighter-rouge">/.well-known/acme-challenge/</code>)로 HTTP 요청이 들어왔을 때, Certbot이 생성한 파일을 Nginx가 서빙할 수 있어야 한다.
이를 위해 <code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>를 80번 포트만 리스닝하고, 해당 경로의 요청만 처리하는 임시 파일로 수정했다.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nginx.conf (임시 인증용)</span>
<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">paulryu9309.ddns.net</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>
        <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">return</span> <span class="mi">404</span><span class="p">;</span> <span class="c1"># 나머지 요청은 404 처리</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3단계-certbot-최초-발급-실행">3단계: Certbot 최초 발급 실행</h4>

<p>Nginx를 임시 설정으로 실행한 뒤(<code class="language-plaintext highlighter-rouge">docker compose up -d nginx</code>), <code class="language-plaintext highlighter-rouge">docker compose run</code> 명령어로 Certbot 컨테이너를 일회성 실행했다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose run <span class="nt">--rm</span> certbot certonly <span class="nt">--webroot</span> <span class="nt">-w</span> /var/www/certbot <span class="nt">-d</span> paulryu9309.ddns.net <span class="nt">--email</span> <span class="o">[</span>이메일] <span class="nt">--agree-tos</span> <span class="nt">--no-eff-email</span>
</code></pre></div></div>

<h4 id="4단계-nginx-최종-설정-https-적용">4단계: Nginx 최종 설정 (HTTPS 적용)</h4>

<p>인증서 발급이 성공한 후, <code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>를 <code class="language-plaintext highlighter-rouge">upstream</code>을 포함한 최종 버전으로 다시 수정했다.</p>

<p><strong>핵심 내용:</strong></p>
<ol>
  <li><strong>HTTP (80) 서버</strong>: <code class="language-plaintext highlighter-rouge">/.well-known/</code> 경로는 갱신을 위해 남겨두고, 나머지 모든 요청(<code class="language-plaintext highlighter-rouge">location /</code>)은 <code class="language-plaintext highlighter-rouge">https://</code> (443 포트)로 301 리디렉션.</li>
  <li><strong>HTTPS (443) 서버</strong>: <code class="language-plaintext highlighter-rouge">listen 443 ssl;</code>을 활성화하고, <code class="language-plaintext highlighter-rouge">ssl_certificate</code>와 <code class="language-plaintext highlighter-rouge">ssl_certificate_key</code> 경로에 1단계에서 공유한 볼륨의 인증서 경로(<code class="language-plaintext highlighter-rouge">.../live/paulryu9309.ddns.net/...</code>)를 지정. <code class="language-plaintext highlighter-rouge">location /</code>에는 <code class="language-plaintext highlighter-rouge">proxy_pass http://nextjs_app;</code>을 설정.</li>
</ol>

<h4 id="5단계-전체-시스템-재시작">5단계: 전체 시스템 재시작</h4>
<p>최종 설정이 적용된 <code class="language-plaintext highlighter-rouge">docker compose up -d</code> 명령으로 전체 시스템을 실행하여 <code class="language-plaintext highlighter-rouge">https://paulryu9309.ddns.net</code> 접속 및 자물쇠(🔒) 아이콘을 확인했다.</p>

<hr />

<h3 id="3-문제-해결-과정-troubleshooting-battle">3. 문제 해결 과정 (Troubleshooting “Battle”)</h3>
<p>HTTPS를 적용하는 과정은 순탄하지 않았으며, 여러 에러를 단계적으로 해결해야 했다.</p>

<h4 id="문제-1-connection-refused-연결-거부">문제 1: <code class="language-plaintext highlighter-rouge">Connection refused</code> (연결 거부)</h4>
<ul>
  <li><strong>증상</strong>: Certbot이 80번 포트로 접속을 시도했으나 연결이 거부됨.</li>
  <li><strong>원인</strong>: 로컬 환경에서 테스트 하는 것으로 가능하다고 생각했음. 원격 서버에 수동 배포 및 공유기의 <strong>포트포워딩</strong> 설정이 누락되어 있었다.</li>
  <li><strong>해결</strong>: 수동 배포하여 초기 구동 및 80포트 접속 가능 여부 확인함. iptime 관리자 페이지에서 외부 80 포트를 Docker가 실행 중인 서버의 내부 IP 80 포트로 포트포워딩 설정하여 해결.</li>
</ul>

<h4 id="문제-2-404-not-found-파일-없음">문제 2: <code class="language-plaintext highlighter-rouge">404 Not Found</code> (파일 없음)</h4>
<ul>
  <li><strong>증상</strong>: <code class="language-plaintext highlighter-rouge">Connection refused</code> 해결 후, Certbot이 인증 파일을 찾을 수 없다고 응답.</li>
  <li><strong>원인</strong>: <code class="language-plaintext highlighter-rouge">docker compose restart nginx</code>를 했음에도, Nginx가 임시 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 설정을 제대로 불러오지 못함. <code class="language-plaintext highlighter-rouge">/.well-known/</code> location이 아닌 <code class="language-plaintext highlighter-rouge">location / { return 404; }</code>가 모든 요청을 처리함. 확인 결과 nginx.conf 파일의 주소 경로 오타 + 이미 설정 된 레이어가 에러를 일으킴.</li>
  <li><strong>해결</strong>: 오타 수정 후 <code class="language-plaintext highlighter-rouge">docker compose down --rmi all</code> 후 <code class="language-plaintext highlighter-rouge">up -d nginx</code>로 컨테이너를 완전히 다시 생성하여 임시 설정을 강제로 적용.</li>
</ul>

<h4 id="문제-3-nginx-컨테이너-무한-재시작">문제 3: Nginx 컨테이너 무한 재시작</h4>

<ul>
  <li><strong>증상</strong>: Nginx 컨테이너가 <code class="language-plaintext highlighter-rouge">restarting</code> 상태를 반복.</li>
  <li><strong>원인</strong>: <code class="language-plaintext highlighter-rouge">docker logs project-mini-nginx</code>로 로그 확인 결과, <code class="language-plaintext highlighter-rouge">nginx.conf</code>의 문법 오류(<code class="language-plaintext highlighter-rouge">[emerg]</code>). 임시 설정 파일임에도 불구하고 <code class="language-plaintext highlighter-rouge">upstream nextjs_app { ... }</code> 블록을 삭제하지 않아 발생한 오류였다.</li>
  <li><strong>해결</strong>: 임시 <code class="language-plaintext highlighter-rouge">nginx.conf</code>에서 <code class="language-plaintext highlighter-rouge">upstream</code> 블록을 제거하여 문법 오류 해결.</li>
</ul>

<h4 id="문제-4-type-caa-caa-레코드-문제">문제 4: <code class="language-plaintext highlighter-rouge">Type: caa</code> (CAA 레코드 문제)</h4>

<ul>
  <li><strong>증상</strong>: 모든 설정이 완벽했음에도 <code class="language-plaintext highlighter-rouge">CAA record for iptime.org prevents issuance</code> 에러 발생.</li>
  <li><strong>원인</strong>: 사용 중이던 <code class="language-plaintext highlighter-rouge">iptime.org</code> DDNS의 상위 도메인 정책(CAA 레코드)이 Let’s Encrypt 기관의 인증서 발급을 허용하지 않음.</li>
  <li><strong>해결</strong>: <code class="language-plaintext highlighter-rouge">iptime.org</code> DDNS 사용을 포기하고, CAA 레코드 제한이 없는 <strong>No-IP</strong> DDNS (<code class="language-plaintext highlighter-rouge">paulryu9309.ddns.net</code>)로 교체하여 즉시 해결.</li>
</ul>

<h4 id="문제-5-duplicate-upstream-nextjs_app-upstream-중복">문제 5: <code class="language-plaintext highlighter-rouge">duplicate upstream "nextjs_app"</code> (Upstream 중복)</h4>

<ul>
  <li><strong>증상</strong>: 최종 HTTPS 설정 적용 후 Nginx가 다시 무한 재시작.</li>
  <li><strong>원인</strong>: <code class="language-plaintext highlighter-rouge">docker logs</code> 확인 결과, <code class="language-plaintext highlighter-rouge">upstream</code> 정의가 중복되었다고 나옴.
    <ol>
      <li><code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>: <code class="language-plaintext highlighter-rouge">COPY nginx.conf ...</code>로 이미지 빌드 시점에 설정 파일이 복사되어 컨테이너 내부로 들어감.</li>
      <li>docker-compose.yml: volumes: - ./nginx.conf:…로 컨테이너 실행 시점에 설정 파일이 또 마운트됨.</li>
      <li>결론 적으로 Nginx가 설정 폴더 내의 두 파일을 모두 읽어 충돌 발생</li>
    </ol>
  </li>
  <li><strong>해결</strong>: <code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>의 <code class="language-plaintext highlighter-rouge">COPY</code> 라인을 삭제하고, <code class="language-plaintext highlighter-rouge">docker compose</code>의 <strong>볼륨 마운트 방식만 사용</strong>하여 설정 파일을 관리하도록 통일. <code class="language-plaintext highlighter-rouge">docker compose build --no-cache nginx</code>로 이미지를 재생성하여 해결.</li>
</ul>

<hr />

<h3 id="4-인증서-자동-갱신-설정">4. 인증서 자동 갱신 설정</h3>

<p>Let’s Encrypt 인증서는 90일마다 만료되므로, 호스트 서버의 <code class="language-plaintext highlighter-rouge">Crontab</code>을 이용해 자동 갱신을 설정했다.</p>
<ol>
  <li>갱신 스크립트 (renew-ssl.sh) 생성:
 프로젝트 루트 폴더로 cd 한 뒤, docker compose run으로 Certbot 갱신을 시도하고, docker compose exec로 Nginx를 리로드하는 쉘 스크립트를 작성했다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/sh</span>
 <span class="nb">cd</span> /home/hansol/workspace/project-mini-frontend/ <span class="c"># 실제 경로</span>
 docker compose run <span class="nt">--rm</span> certbot renew
 docker compose <span class="nb">exec </span>nginx nginx <span class="nt">-s</span> reload
</code></pre></div>    </div>
  </li>
  <li>
    <p>실행 권한 부여:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">chmod</span> +x /home/hansol/workspace/project-mini-frontend/renew-ssl.sh
</code></pre></div>    </div>
  </li>
  <li>
    <p>Crontab 등록:</p>

    <p>crontab -e 명령어로 편집기를 열고, 매일 새벽 3시 30분에 스크립트를 실행하도록 등록했다.</p>

    <div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="m">30</span> <span class="m">3</span> * * * <span class="sr">/home/</span>hansol<span class="sr">/workspace/</span>project<span class="p">-</span>mini<span class="p">-</span>frontend/renew<span class="p">-</span><span class="nb">ssl</span><span class="p">.</span><span class="k">sh</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="5-배운-점">5. 배운 점</h3>

<ul>
  <li>Dockerfile의 <code class="language-plaintext highlighter-rouge">COPY</code>는 빌드 시점(Build-time)에, Docker Compose의 <code class="language-plaintext highlighter-rouge">volumes</code>는 실행 시점(Run-time)에 작동한다. 설정 파일처럼 자주 바뀌는 것은 <code class="language-plaintext highlighter-rouge">volumes</code>로 마운트하는 것이 이미지 재빌드 없이 유연하게 대처할 수 있다.</li>
  <li>에러 로그를 읽는 것이 문제 해결의 90%이다. <code class="language-plaintext highlighter-rouge">docker logs [컨테이너]</code>는 항상 가장 먼저 확인해야 할 정보다.</li>
  <li>Let’s Encrypt의 <code class="language-plaintext highlighter-rouge">webroot</code> 방식은 80번 포트가 외부 인터넷에 반드시 열려있어야 한다. 공유기 환경에서는 포트포워딩이 필수이다.</li>
  <li>도메인의 CAA 레코드는 내가 제어할 수 없는 상위 정책일 수 있다. DDNS 사용 시 서비스 제공자의 정책을 확인해야 한다.</li>
  <li>Nginx 설정 문법이 틀리면 Nginx는 아예 시작조차 하지 않는다. <code class="language-plaintext highlighter-rouge">docker compose run --rm nginx nginx -t</code> 명령어로 문법을 미리 테스트해볼 수 있다.</li>
</ul>

<hr />

<h3 id="6-코드레빗-지적-사항-학습-및-개선">6. 코드레빗 지적 사항 학습 및 개선</h3>

<p>PR 을 통해 머지 전, 발생한 Major 이슈로 문제가 되는 부분이 뭔지, 그리고 그 부분의 문제 개선 내용을 요약해두었다.</p>

<h4 id="certbot-네트워크-설정-없음docker-composeyml">Certbot 네트워크 설정 없음(Docker-Compose.yml)</h4>
<p><img src="/assets/images/posts/2025-10/2025-10-20-046.png" alt="" /></p>
<ul>
  <li>개요 : 기본적으로 현재 방식은 공유 볼룸을 기반으로 <code class="language-plaintext highlighter-rouge">weebroot</code> 방식은 공유 되는 파일을 주고 받아, 컨테이너들 사이의 네트워크, 특히나 도커 네트워크 기반으로 설정할 필요가 없음. 그러나 AI 의 지적은 몇가지 타당성이 있기 때문에 문제시 될 수 있다.
    <ol>
      <li>구성의 일관성 및 명확성</li>
      <li>docker compose run 동작 시 연결되는 네트워크 : 현재 프로젝트의 <code class="language-plaintext highlighter-rouge">project-mini-network</code>에 접속하여 연결되는 구조가 성립되어 있으나, 이러한 설정이 없으면 아무래도 기본 네트워크에 연결이 되며, 이 점은 비일관적이고 오작동을 유발 할 수도 있다.</li>
      <li>향후 확장성 : 현재는 심플한 webroot 방식이지만 nginx의 플러그인을 활용한다면, certbot 이 nginx 컨테이너에 직접 연결될수도 있음. 그렇다면 누락시켜서 문제시 되는 거 보다 일단 네트워크는 사용하지 않더라도 연결해두는게 낫다.</li>
    </ol>
  </li>
  <li>결정 : 일관성과 향후를 위해 간단하게 네트워크 통일</li>
</ul>

<h4 id="ssltls-보안-설정-부족">SSL/TLS 보안 설정 부족</h4>
<ul>
  <li>기본 설정 만으론 보안 표준 충족 안됨 TLS 프로토콜에 대한 버전 제안, 암호화 스위트, 기타 보안 헤더 설정이 필요
    <ol>
      <li><strong><code class="language-plaintext highlighter-rouge">ssl_protocols TLSv1.2 TLSv1.3;</code></strong></li>
    </ol>
    <ul>
      <li><strong>설명:</strong> Nginx 서버가 허용할 TLS 프로토콜 버전을 명시적으로 지정한다.</li>
      <li><strong>이유:</strong> <code class="language-plaintext highlighter-rouge">TLSv1.0</code>과 <code class="language-plaintext highlighter-rouge">TLSv1.1</code> 버전은 POODLE, BEAST와 같은 심각한 보안 취약점이 발견되어 사용이 권장되지 않음. 이 설정을 통해 <strong>안전하다고 검증된 <code class="language-plaintext highlighter-rouge">TLSv1.2</code>와 최신 버전인 <code class="language-plaintext highlighter-rouge">TLSv1.3</code>만</strong> 허용하여 하위 버전의 취약점을 원천적으로 차단하는 역할을 함.</li>
    </ul>
  </li>
</ul>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_prefer_server_ciphers on;</code></strong>
    <ul>
      <li><strong>설명:</strong> SSL/TLS 연결 협상 시, 클라이언트(브라우저)가 제안하는 암호화 스위트 목록과 서버가 제안하는 목록 중 <strong>서버(Nginx)의 목록을 우선</strong>하도록 설정한다.</li>
      <li><strong>이유:</strong> 서버는 관리자가 의도한 강력한 암호화 방식(아래 <code class="language-plaintext highlighter-rouge">ssl_ciphers</code>에서 설정)을 사용하도록 구성되어 있음. 만약 클라이언트가 약한 암호화 방식을 우선적으로 제안하더라도, 이 옵션을 켜두면 서버가 선택한 가장 강력한 방식을 강제할 수 있다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_ciphers '...';</code></strong>
    <ul>
      <li><strong>설명:</strong> 서버가 허용할 <strong>암호화 스위트(Cipher Suites)의 목록</strong>을 강력한 순서대로 지정한다. 제안된 목록(<code class="language-plaintext highlighter-rouge">ECDHE-ECDSA-AES128-GCM-SHA256</code> 등)은 모두 강력한 보안을 제공하는 최신 알고리즘으로 설정하는 역할을 함.</li>
      <li><strong>이유:</strong> 이 목록은 특히 <strong>PFS(Perfect Forward Secrecy)</strong> 를 지원하는 <code class="language-plaintext highlighter-rouge">ECDHE</code> 계열의 암호화를 우선한다. PFS는 만약 서버의 개인 키가 미래에 유출되더라도, 과거에 이 키로 암호화되어 저장된 트래픽(통신 내용)을 해독할 수 없도록 보장하는 매우 중요한 보안 기능이다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_session_cache shared:SSL:10m;</code></strong>
    <ul>
      <li><strong>설명:</strong> SSL 세션 정보를 서버 메모리에 캐시할 공간을 설정한다. <code class="language-plaintext highlighter-rouge">shared:SSL:10m</code>은 모든 Nginx 워커 프로세스가 공유하는 <code class="language-plaintext highlighter-rouge">SSL</code>이라는 이름의 10MB 캐시 공간을 의미한다.</li>
      <li><strong>이유 (성능 향상):</strong> HTTPS는 연결 시마다 암호화 키를 교환하는 복잡한 과정(Handshake)을 거치는데, 이 과정은 CPU 자원을 소모함. 이 설정을 통해 한 번 연결했던 클라이언트가 다시 접속할 때(예: 페이지 내의 여러 이미지 로드) Handshake 과정을 생략하고 캐시된 세션 정보를 재사용하여 <strong>HTTPS 연결 속도를 크게 향상</strong>시키는 역할을 함. 기본적으로 설정을 안할 경우 <code class="language-plaintext highlighter-rouge">none</code> 으로 설정되므로 세션 캐시를 만들지 않음.</li>
      <li>1MB 는 약 4천개의 세션을 저장하는데(하나의 세션이 256 바이트 정도된다), 따라서 10MB 설정은 약 40,000개의 동시 세션을 저장하는 공간이다. 따라서 기본적으로 중소 규모 웹 사이트의 트래픽을 감당할 수준이라고 보면 된다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ssl_session_timeout 10m;</code></strong>
    <ul>
      <li><strong>설명:</strong> 위에서 만든 세션 캐시가 <strong>10분</strong> 동안 유효하도록 설정한다.</li>
      <li><strong>이유 (성능 향상):</strong> <code class="language-plaintext highlighter-rouge">ssl_session_cache</code>와 함께 작동하여, 10분 이내에 재접속하는 사용자는 빠른 세션 재개를 통해 성능 이점을 누릴 수 있다. 비 설정 시 기본값은 5분이지만, 새션 캐시가 존재하지 않으면 의미가 없기 때문에 세트로 옵션이 설정되어야 한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;</code></strong>
    <ul>
      <li><strong>설명:</strong> <strong>HSTS(HTTP Strict Transport Security)</strong> 헤더를 브라우저에 전송한다.</li>
      <li><strong>이유 (보안 강화):</strong> 이 헤더를 한 번이라도 받은 브라우저는 <code class="language-plaintext highlighter-rouge">max-age</code>에 설정된 시간(31536000초 = 1년) 동안 해당 도메인(및 <code class="language-plaintext highlighter-rouge">includeSubDomains</code> 설정 시 하위 도메인까지)에 <strong>절대로 HTTP로 접속하지 않고, 무조건 HTTPS로만 접속</strong>하게 된다. 이는 사용자가 실수로 <code class="language-plaintext highlighter-rouge">http://</code>로 접속 시도하는 것을 방지하고, 중간자 공격(MITM)의 일종인 <strong>SSL 스트리핑(SSL Stripping)</strong> 공격을 완벽하게 방어하는 역할을 수행한다.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>모르는 내용 정리
    <ul>
      <li>암호화 스위트 : 클라이언트와 서버 사이의 HTTPS 통신 전, 통신 암호화 규칙을 설정하는 묶음 세트. 명시적으로 설정함으로써 통신의 규약을 확정 짓는 방법
        <ul>
          <li>구성요소 :
            <ul>
              <li>키 교환 알고리즘</li>
              <li>인증 알고리즘</li>
              <li>대칭키 알고리즘</li>
              <li>메시지 인증/ 무결성 알고리즘</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>OCSP 스테이플링 적용 :
        <ul>
          <li>개념 :
            <ul>
              <li>OCSP 스테이플링은 SSL/TLS 인증서의 유효성(폐기 여부)을 확인하는 책임을 클라이언트(브라우저)가 아닌 <strong>서버(Nginx)가 대신 수행</strong>하는 기능이다.</li>
              <li>기본적으로 브라우저는 HTTPS 사이트 접속 시, 해당 인증서가 폐기되지 않았는지 확인하기 위해 인증 기관(CA) 서버에 OCSP(Online Certificate Status Protocol) 요청을 별도로 전송한다. 이 방식은 연결 속도를 저하(지연 발생)시키고, 사용자의 접속 기록이 CA에 노출되는 프라이버시 문제를 야기한다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>적용 예시
        <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nginx.conf 내 http { ... } 또는 server { ... } 블록</span>
  <span class="c1"># OCSP 스테이플링 활성화</span>
  <span class="k">ssl_stapling</span> <span class="no">on</span><span class="p">;</span>
  <span class="k">ssl_stapling_verify</span> <span class="no">on</span><span class="p">;</span>
		
  <span class="c1"># 스테이플링 검증을 위한 신뢰할 수 있는 인증서 체인 지정</span>
  <span class="c1"># Let's Encrypt의 fullchain.pem은 서버 인증서와 체인 인증서를 모두 포함하고 있음</span>
  <span class="k">ssl_trusted_certificate</span> <span class="n">/etc/letsencrypt/live/paulryu9309.ddns.net/fullchain.pem</span><span class="p">;</span>
		
  <span class="c1"># (선택 사항) OCSP 응답 확인을 위한 리졸버 (예: Google DNS)</span>
  <span class="c1"># resolver 8.8.8.8;</span>
</code></pre></div>        </div>
      </li>
      <li>작동 원리
        <ol>
          <li><strong>서버의 사전 확인:</strong> Nginx 서버가 주기적으로 CA 서버에 “내 인증서는 유효한가?”라고 질의한다.</li>
          <li><strong>응답 캐싱:</strong> Nginx는 CA로부터 타임스탬프가 찍힌 “유효함” 응답(OCSP 응답)을 받아 캐시한다.</li>
          <li><strong>응답 첨부 (Stapling):</strong> 클라이언트가 최초 연결(SSL Handshake)을 시도할 때, Nginx는 SSL 인증서와 함께 이 캐시된 “유효함” 응답을 <strong>“찝어서(Stapling)”</strong> 함께 전송한다.</li>
          <li><strong>브라우저 확인 생략:</strong> 클라이언트는 서버가 제공한 OCSP 응답을 신뢰하므로, CA 서버에 직접 질의하는 단계를 생략한다.</li>
        </ol>
      </li>
      <li>적용 이점
        <ul>
          <li><strong>성능 향상 (속도):</strong> 브라우저가 CA 서버에 추가 질의하는 과정을 생략함으로써, HTTPS 초기 연결(Handshake) 속도가 빨라진다.</li>
          <li><strong>프라이버시 보호:</strong> 사용자의 접속 정보(IP, 방문 사이트)가 CA 서버에 노출되지 않아 개인정보 보호 수준이 향상된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="critical-인증서-경로-초기-설정-추가-필요-내역">Critical 인증서 경로 초기 설정 추가 필요 내역</h4>
<p><img src="/assets/images/posts/2025-10/2025-10-20-047.png" alt="" /></p>
<ul>
  <li>핵심 문제 : docker 를 통해 nginx 서비스가 실행 -&gt; 이때 nginx.conf 를 참조하는데, 이때 인증서 존재여부를 보게 되니, 최초에 현재 conf(SSL 설정이 된) 로는 에러가 발생한다는 것이 문제.</li>
  <li>개선 방안은 다음과 같다.
    <ol>
      <li><strong>init-letsencrypt.sh</strong> 와 같은 초기화 스크립트를 활용할 것</li>
      <li><strong>가짜 인증서</strong>를 만드는 전략을 활용해 구동을 하고 certbot으로 진짜 인증서를 받고, 유효한 심볼링 링크를 생성하는 방식 -&gt; 초기화 스크립트는 복잡하고, 여러 수정 작업등이 존재하므로, 차라리 가짜 인증서를 certbot으로 진짜 인증서 발급 이후 새롭게 접근하는 방식. (향후 적용 예정)</li>
    </ol>
  </li>
</ul>

<h4 id="갱신-스크립트의-하드코딩-경로-문제">갱신 스크립트의 하드코딩 경로 문제</h4>
<p><img src="/assets/images/posts/2025-10/2025-10-20-048.png" alt="" /></p>
<ul>
  <li>개요 : 하드 코딩 &amp; 에러처리의 간단한 구조이다보니 문제 있음</li>
  <li>개선 : AI 지적한데로 개선된 형태를 그대로 차용하여 적용</li>
</ul>

<h4 id="certbot-갱신-실패-에러-핸들링-추가">Certbot 갱신 실패 에러 핸들링 추가</h4>

<p><img src="/assets/images/posts/2025-10/2025-10-20-049.png" alt="" /></p>
<ul>
  <li>개요 : 갱신 절차에 대해 실행 결과를 확인하지 않고 해야할 일만 바로 수행하도록 되어 있음</li>
  <li>개선 : 지적한 대로 스크립트 수정</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 20일: Docker Compose와 Nginx 환경에 Let’s Encrypt (Certbot)로 HTTPS 적용 및 자동 갱신 설정]]></summary></entry><entry><title type="html">도쿄게임쇼 2025 - AI 미완의 서곡</title><link href="http://0.0.0.0:4000/ai/2025/10/19/tgs2025-with-ai.html" rel="alternate" type="text/html" title="도쿄게임쇼 2025 - AI 미완의 서곡" /><published>2025-10-19T00:00:00+00:00</published><updated>2025-10-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/ai/2025/10/19/tgs2025-with-ai</id><content type="html" xml:base="http://0.0.0.0:4000/ai/2025/10/19/tgs2025-with-ai.html"><![CDATA[<h1 id="도쿄-게임쇼-2025--ai-미완의-서곡">도쿄 게임쇼 2025 : AI 미완의 서곡</h1>
<h2 id="요약">요약</h2>

<blockquote>
  <p>“도쿄 게임쇼 2025 참관 후 작성된 이 글은 AI와 게임 산업의 현재 접점을 분석하며, 인디 개발사들의 AI 활용 실험과 대형 게임사들의 콘텐츠 중심 전략 간의 대조를 보여줍니다. AI의 게임 산업 적용 가능성은 높으나, 높은 비용과 불확실한 비즈니스 모델이라는 현실적인 과제가 남아있음을 지적합니다. 특히 AI가 게임 개발의 ‘도구’로서 가치를 발휘하며, 이에 따라 개발자의 역할이 ‘코더’에서 ‘AI 조작자(tuner)’로 변화하고 비용 최적화 및 도메인 전문성의 중요성이 더욱 커질 것이라는 전망을 제시하며, AI 시대의 기회와 도전을 탐색합니다.” by OrionAI</p>
</blockquote>

<hr />

<h2 id="도쿄-게임쇼-ai-와-함께-하나">도쿄 게임쇼, AI 와 함께 하나…?</h2>
<p><img src="/assets/images/posts/2025-10/2025-10-20-028.png" alt="" /></p>

<p><big><em>AI 와 게임은 괜찮은 궁합이라고 생각하시나요?</em></big></p>

<p>‘게임’이란 산업은 ‘찰떡의 조합’으로 AI와 함께 해야 하는 시장이라고 생각합니다. 여러분의 생각은 어떤가요? AI, LLM 과 게임의 조합이 어떻다고 생각하시나요?</p>

<p>AI를 통해 지능형 NPC 가 나와서, 저와 함께 싸워준다면 …?</p>

<p>기계적으로 지정된 분기가 아니라, 게임 행적을 기반으로 만약 게임의 엔딩이 바뀌고, 그 엔딩이 내가 꿈꿔온 결말이라면…?</p>

<p>던전이 매 순간 변화하고, 그에 따라 나오는 몬스터가 변하고, 그런 모습 속에서 더 처절한 용사가 되어 모험을 해나간다면…?</p>

<p>매 순간 설레는 모험. 질리지 않는 다양한 사건들로, 우리의 게임의 플레이 환경이 획일적인 상황을 넘어서는 무언가가 된다면?</p>

<p>이유는 많이 있습니다. AI의 특성 때문이기도하며, 동시에 게임의 특성과, 문화 산업의 힘을 생각하면 AI의 존재가 게임 산업 전반에 침투 했을 때 일어날 시너지는 분명 엄청날 것입니다. 그리고 그런 상상은 꾸준히 미디어를 통해 시사되었고, LLM 의 등장은 그런 ‘로망’을 이루기에 충분하다는 사람들의 평가를 받고 있지요.</p>

<p>뿐만 아니라 기업 적으로 봐도 그렇습니다. 게임 개발의 프로세스의 혁신은, 매 순간 기다려야 하는 발매일을 앞 당길 수 있을지 모릅니다. 뿐만 아니라 만드는 과정에서 드는 비용의 절감은, 분명 더 많은 콘텐츠가 더 합리적인 가격으로 제시 될 수 있는 기회를 줄지도 모릅니다.</p>

<p>영화 같은 모험을, 내가 생각하고, 내가 뛰어들어 그 세계를 탐험하는 모험이 가능하며 그 세상을 실제로 누려볼 수 있다는 점은 어쩌면 게임이 단순한 유희를 넘어서는 새로운 지평선이 되어 줄지 모를것입니다.</p>

<p>이런 생각 와중에, 개인 프로젝트 내용을 채워 나가고 있던 9월. 알고 지내던 지인, 게임사 대표가 말했습니다.</p>

<p>‘도쿄 게임쇼 가실래요?’</p>

<p>오잉, 심지어 비즈니스 데이 참석 가능한 티켓. 프리패스로 참석이 가능하다고?</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-029.png" alt="" /></p>
<blockquote>
  <p>가즈아…!!!!</p>
</blockquote>

<p>AI와 게임, 미디어 산업, 어느 쪽도 절대 놓치면 안된다는 생각이 든 저는, 빠르게 결단을 내렸습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-030.png" alt="" /></p>
<blockquote>
  <p>두둥</p>
</blockquote>

<p>9월 25일부터 4일 간 진행되며, 비즈니스 데이에는 각종 게임과 관련된 기업들의 컨퍼런스(혹은 홍보 행사)까지… 안 가는게 바보겠구나 싶어서 당장 진행시켰습니다…! 본 글은 그런 저의 도쿄 게임쇼 2025 생존 후기라고 보시면 되겠습니다.</p>

<h2 id="1--인디-게임-ai-실험의-최전선">1.  인디 게임, AI, 실험의 최전선</h2>

<h3 id="게임과-ai">게임과 AI</h3>

<p><img src="/assets/images/posts/2025-10/2025-10-20-027.png" alt="" /></p>

<p>게임이라는 컨텐츠는 부정적으로 보는 사람도 많지만, 실질적으로 매우 큰 시장이자, 산업입니다. 특히나 게임은 온갖 컨텐츠들이 종합되어 있으며, 사람의 감정을 근본적으로 동요하게 만듬으로 써 감동도, 성취감도, 동시에 메시지도 줄 수 있지요. 그렇기에 이 시장이 큰 것이며, 요즘은 더욱이 남녀노소를 안가리고 있단 점에서 차세대 컨텐츠로 가장 미래지향적이며, 여전히 할 일이 많이 남아있는 콘텐츠라고 생각합니다.</p>

<p>그렇기에 필연적으로 게임은 대단히 노동 집약적인 산업입니다. 기획과 의도, 메시지를 담아내고, 그걸 위한 온갖 역할군의 사람들이 협업하여 만들어낸 작품. 그렇기에 명작은 사람들에게 충격을 주기도하고, 애정이란 감정을 일으키기에 사람의 인생에 매우 큰 영향을 주기도 한다는 점은, 결코 거짓이 아닐 것입니다.</p>

<p>그러나 이러한 특성으로 게임은 현재 여러 비판들에도 직면하게 됩니다. 우선 IP 의 강력함은 있지만, 동시에 개발 프로세스에서 들어가는 비용에 대한 천문학적 액수는, 개발자와 경영자, 그리고 소비자 사이에서 가장 큰 갈등의 요소가 됩니다.</p>

<p>그런 와중에 AI 는 무엇입니까? 자연어로 지시를 하면, ‘확률’에 의거하여 사람이 하던 행동을 대신 해줍니다. 과거에는 그 수준이 미비하고, 부족했지만, 하드웨어를 믿고 거대한 모델로 학습하기 시작하자, 그 능력치는 폭발하게 되었습니다. 이제는 사람이 하던 일들에 대하여 아주 손쉽게 대응하는게 가능해졌습니다. 프로세스 요소 요소마다의 비용적 절감을 가져오고 이것이 전 영역(코딩, 음원, 이미지 기타 등등)에서 가능하단 점은, 고부가 가치의 산업인 게임이 현재 직면한 상당한 문제들을 개선해주는 훌륭한 구원투수가 될 것이라는게 전문가들의 일반적인 평가이지요.</p>

<p>뿐 만 아니라 게임 내부를 보아도 마찬가지입니다. 게임 속 기획들은 사람의 동기를 부여하고, 성취감, 재미를 주는데, 문제는 기존의 방식든 어떤 수를 써도 한계가 있기 때문에 콘텐츠의 생산면에서 한정된 리소스, 한정된 만큼의 경우의 수를 만들어줄 수 밖에 없습니다. 하지만 적절한 프롬프트, 적절한 연산 장치만 갖춘다면, 그 내용들 전체를 기반으로 다시 새롭게 없던 무언가를, 사람이 할법한 내용으로 구축해낼 수 있습니다.</p>

<p>수치적으로 봐도 이러한 흐름은 증명된 것일 겁니다. 게임 산업은 2024년 1827억 달러 규모로 성장되었고, AI 적용 시장은 2024년 32.8억 달러 수준이고, 2033년까지 512.6억 달러로 도달할 것이란 예측 수치가 나왔습니다. Unity Gaming Report 2024에선 62% 개발자가 AI를 쓰고 있고, GDC의 조사에선 2024년 31%의 스튜디오와 부서가 생성형 AI를 활용하고 있다고 이야기 하고 있습니다. 특히나 스타트업의 펀딩 영역에서 AI 를 기반으로 하여, 도구들은 2024년 이미 1천억 달러 이상 펀딩을 받았는데, 이는 2023년 556억에서 두배, 80% 증가했다고 보여주었습니다. AI 와 게임의 조합은 이미 시작부터 끝까지, 그리고 앞으로 이미 확정적인 성장세라고 보는게 타당할 것 입니다.</p>

<p>그리고 이러한 저의 생각은 당연히 저보다 먼저 앞서 게임을 만드는 열의를 가진 분들을 통해 나타나고 있었습니다. 도쿄 게임쇼 2025는 게이머들의 축제이지만, 동시에 그 시발점에 게임사들이 드디어 적용되어 가고 있음을 보여주었습니다.</p>

<h3 id="ai와-인디의-시너지">AI와 인디의 시너지</h3>

<p>저를 초대해준 업체가 있는 9 ~ 11관 쪽에서 가장 먼저 눈길이 갔고, 가장 크게 준비되어 있던 부스가 ‘인디 85선’이라는 부스였습니다. 자체적으로 선정한 85가지 게임의 소개 부스는 각자 자신들의 매력을 어필하려고 정말 노력하고 있다는 말이 부족할 정도로 뜨거운 열기를 보여주고 있었지요. 그 와중에 AI 가 관련되어 있던 부스 일부를 소개해보고자 합니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-031.png" alt="" /></p>
<blockquote>
  <p>실제 플레이 시 서라운드 사운드로, 마치 커맨더가 된 것처럼 캐릭터에게 지시를 내릴 수 있었다.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Final Link</code>(제작사 RunGround Works)라는 작품은 일본인 개발자와 두명 정도의 추가 인원이 개발한 SF 비주얼 노벨 게임입니다. 음성 입력을 활용하고, 실시간 대화를 통해 게임의 캐릭터가 움직이는 방식으로, ChatGPT 를 활용했습니다. 3D 노벨 게임이기에 분기를 갖고 있었는데, 이를 단순히 수치화하는게 아닌, 자연어의 선택으로 가게 만든다는 발상은, 약간의 플레이 만으로도 상당한 몰입감. 특히 내가 바라는대로 움직인다는 점을 생각한다면 상당한 흡입력을 보여주는 작품이었습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-032.png" alt="" /></p>
<blockquote>
  <p>시간 관계상 플레이까진 못해보았다</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">AI GRANDPRIX</code>(제작사 MIRACLE PLAY)는 AI 를 활용한 학습 방식으로 레이서를 육성하는 게임입니다. AI 가 대신 플레이를 해주는데, 이때 플레이 기록을 취사하여 자신만의 플레이스타일이 되도록 학습을 시키고, 그런 대상을 NFT 로 구축하여, 독자적인, 하나밖에 없는 AI 레이서를 만드는 것을 목표로 하는 육성 장르의 게임이었습니다. 해당 게임은 데모 정도의 구축이 되어 있었고, 아직 릴리즈할 수준은 아니라고 보였습니다. 그러나 단순히 AI 가 ‘대신 행동한다’가 아닌, 학습 자체의 과정을 마치 인격을 가진 존재 처럼, AI가 ‘학습을 한다’는 점을 이용한 새로운 접근 방식, <code class="language-plaintext highlighter-rouge">우마무스메</code>, <code class="language-plaintext highlighter-rouge">FM 매니저</code>와 같은 육성 시리즈로 한 획을 그었던 육성 장르적 특성의 연결은 육성 장르의 매력, 몰입감을 AI를 통해 더 극대화 하려는 듯 보였습니다.</p>

<p>그 외에도 여러 몇가지 AI를 활용한 게임들이 있었고, 게임에 AI를 녹여내진 않았으나, 물어봤을 때 AI를 적극 활용하고 있는 게임사 직원들의 이야기들은, 이미 생산성 향상과 게임이란 리소스 집약형 산업에 AI 가 적극적으로 침투되고 있는지를 보여주는 부분이었습니다.</p>

<h3 id="하지만">하지만…</h3>

<p>하지만 하나, 논의를 하면 개발자라면 동일하게 걱정하는 부분이 있었습니다. 바로 ‘비즈니스 모델’에 대한 영역입니다. 저 또한 LLM 기반의 프로젝트를 구성하면서, 조심해야겠구나 생각했던 것은 바로 어떤 LLM 을 쓰더라도 AI의 사용 비용은 명확하게 냉정하다는 지점입니다.</p>

<p>로컬에서 돌리는 MoE 방식의 작은 모델들이 물론 많지만, 실질 서비스 퀄리티를 위한 AI 를 활용하기 위해선 거대 모델의 사용은 실상 필수 입니다. 문제는 도구로 사용하는 경우엔 훨씬 낫지만, 인게임이에 들어 간다면? 사용자의 인터렉션에 맞춰 실시간으로 AI 로 대응하는 것은 게임이란 콘텐츠의 기본적인 패키지 식의 결제와는 어울리지 않는 지점을 보여줍니다.</p>

<p><strong>주요 AI 모델별 토큰 가격 비교 (2025년 10월 기준)</strong></p>

<p>| 공급사 | 모델 | 입력 비용 (1백만 토큰당) | 출력 비용 (1백만 토큰당) | 비고 |
| — | — | — | — | — |
| **OpenAI** | GPT-5 | $1.25 | $10.00 | 코딩 및 에이전트 작업에 최적화된 플래그십 모델 |
| | GPT-5 mini | $0.25 | $2.00 | 더 빠르고 저렴한 버전 |
| | GPT-5 nano | $0.05 | $0.40 | 요약 및 분류 작업에 적합한 가장 빠르고 저렴한 버전 |
| **Anthropic** | Claude 4.1 Opus | $15.00 | $75.00 | 현재 가장 성능이 뛰어난 Claude 모델 |
| | Claude 4.5 Sonnet | $3.00 | $15.00 | 성능과 비용의 균형을 맞춘 모델 |
| | Claude 3.5 Haiku | $0.80 | $4.00 | 가장 빠르고 비용 효율적인 모델 |
| **Google** | Gemini 2.5 Pro | $1.25 (≤ 20만 토큰) | $10.00 (≤ 20만 토큰) | 입력 토큰 양에 따라 가격 변동 |
| | | $2.50 (&gt; 20만 토큰) | $15.00 (&gt; 20만 토큰) | |
| | Gemini 2.5 Flash | $0.30 | $2.50 | 속도에 최적화된 경량 모델 |</p>
<blockquote>
  <p>최신 버전들은 이러한 지점 때문에, 의도적으로 저가형 모델들을 만들었다.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Final Link</code> 개발자 분과 이야기를 해봤을 때는 이러한 지점 때문에 결제 방식에 고심하고 있었습니다. 3일 정도의 플레이를 무제한으로 할 수 있는 이용권 방식을 고려하고 있다고도 이야기 했습니다. 이 부분에 대해 개발자님과 논의를 깊게 할 수는 없었지만, 기본적으로 구매를 하여 사용하던 게임, 즉 ‘소유’의 개념에 가까웠던 게임에서 구독, 그것도 3일이라는 제한된 시간을 이용가능하다는 점은, 과연 소비자가 납득할 것인가? 이 부분에 대해선 저나, 해당 개발자 역시 확신이 없었습니다. 이렇듯, AI 의 비용 계산이 토큰단위이고, 그런 상황에서 기존의 서비스들이 제공하던 방식이나 절차를 생각한다면 소비자에게 외면 받을 수도 있다는 점에서 대단히 조심스러울 수 밖에 없었습니다.</p>

<p>그렇다면 로컬로 돌리면 어떻지? 라고 생각 하실수 도 있습니다. 게임 내 AI 를 통합하고, VRAM 을 활용 하는  것 입니다. 기술적으로 불가능하지도 않고, 무엇보다 요즘 게임 유저들의 상향 평준화된 PC 스펙이라면 충분히 노려 볼 만한 구석도 있습니다. 하지만 알다시피 대형 모델이 아닌 이상 모델의 성능, 그리고 AI 자체의 반응속도, 인게임에서도 필요한 리소스, 그리고 본질적으로 소형 모델이 보여주는 환각과 관련된 문제 등… 여러 면을 고려한다면 이 핵심적인 문제는 해결되진 못합니다. 그렇기에 대형 LLM 을 활용하는 것은, 불가피한 선택입니다. 그리고 거기서 적립된 확실한 비즈니스 모델이 없다는 지점은 이 시장을 관통하는, 핵심 질문이라고 볼 수 있을 것 입니다.</p>

<h2 id="2-대형-게임사들과-ai-이에-대응-하려는-플랫폼들과-툴-경쟁">2. 대형 게임사들과 AI, 이에 대응 하려는 플랫폼들과 툴 경쟁</h2>

<p>첫 날, 그렇게 들렀던 인디게임 사들과, 다양한 중소 개발사들을 돌아 보고 나니 게임 제작하는 많은 이들의 열기도 느껴지고, 특히 국내 게임 제작사들의 처절함, 열심히 하고 있는 모습도 느낄 수 있었기에 매우 흥미 진진 &amp; 나 역시 무언가 하고 싶다는 느낌을 전염 받을 때 즈음, 드디어 슬슬 대기업 부스들을 돌아보게 되었습니다.</p>

<p>여기선 어떤 AI 기능들이 있을까? 얼마나 게임 속에 녹여 내었을까? 등등 … 게임도 설레였지만, 핵심은 AI 였고, AI 에 대한 내용들을 제대로 보고 싶어 주변을 전체적으로 둘러봤습니다…만 결과적으로 트리플 A 급 게임의 제조사들의 모습은 ‘사뭇’ 달랐습니다.</p>

<h3 id="콘텐츠에-집중하는-대형-부스들">콘텐츠에 집중하는 대형 부스들</h3>

<p>다소 실망스럽지만, 참가 게임 회사들의 내용들을 정리한 내용은 아래와 같았습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 스퀘어 에닉스 - FF 시리즈, FF 스핀오프 작품들과 JRPG 장르의 신규 IP 들
- 코에이 테크모 - 젤다무쌍 봉인전기
- 캡콤 - 최신 발매한 게임, 레지던트 이블 시리즈 신작 
- 세가 - 용과같이, 소닉 IP 레이싱 신작
- 코나미 - 사일런트 힐 f 
- 넥슨 - First Decent 
- 넷마블 - 7대 죄악 IP 를 활용한 모바일 게임
- 스마일게이트 - 신규 IP 미래시, 미소녀 수집 게임 장르
- 펄어비스 - 붉은 사막
- NC - SaaS 방식으로 아주 작은 부스로, 생성형 AI 를 활용한 에셋 제작 서비스
</code></pre></div></div>

<p>제가 다 기억하지 못하거나할 수  있으나, 방문 가능했던 부스들입니다. 보이시나요? 맞습니다. 아쉽게도 AI 와 관련된 것들 보단 ‘콘텐츠’에 집중하고 있었습니다. 물론 그렇지 않은 케이스도 있지만 말이죠.</p>

<p>우선, 일본의 게임 기업들, 내놓아라 하는 회사들의 특징은 강력한 IP 기반으로, 기존 팬덤을 위한, 그리고 신규 팬들을 만들기 위한 노력이 명확히 보였습니다. AI의 사용이 강조되기 보단, 기존 IP를 확장하여 팔고 캐시 카우를 끌어 올리되, 성공적인 시스템, 성공적인 배경이나 게임성을 기반으로 신규 팬덤이 생길 수 있는 새로운 시리즈들의 안정적인 출발을 고려하는 느낌이 물씬 들었습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-033.png" alt="" /></p>
<blockquote>
  <p>가장 눈길을 끌었던 단일 테마 부스는 단연 ‘젤다 무쌍’. 젤다 프렌차이즈를 해본 사람이라면 스토리 맛집으로 유명하다. 실제로도 단일 부스 기준 상당한 줄이 서있었다</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-034.png" alt="" /></p>
<blockquote>
  <p>신작들, 그리고 스위치 등에 재 이식되는 리메이크 혹은 리마스터작들이 주를 이루었다</p>
</blockquote>

<p>국내 기업들의 경우, 각 개발사의 상황에 따른 전략, 작품 홍보 쪽에 가깝다는 점들이 보였습니다. 넥슨은 해외 쪽 전략으로 퍼스트 디센트를, 넷마블은 계속 성공적인 일본 IP 기반의 모바일 게임을, 스마일 게이트는 수집형 미소녀 전략 게임인 ‘미래시’, 펄 어비스는 드디어 나오기로 확정된 붉은 사막… 등, 해당 업체들에서 현재 어느정도 반응이 있거나, 아니면 전략적으로 밀어주는 게임을 선보이는 모습이었습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-035.png" alt="" /></p>
<blockquote>
  <p>전엔 괜찮나? 했었지만 어느새 신작이 나오는 7대죄악 IP 기반의 모바일 게임. 부스 크기가 상당했다.</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-036.png" alt="" /></p>
<blockquote>
  <p>전형적인 미소녀 서브컬쳐 기반의 신작. 게임 성은 훌륭했다.</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-045.jpg" alt="" /></p>
<blockquote>
  <p>기대치를 미치지 못한 플레이를 보여주었던 붉은 사막. 다소 아쉬움은 남아있지만, 아직 출시 전이니…</p>
</blockquote>

<p>생각보다 아쉽긴 했습니다. 대기업들의 부스는 콘텐츠 중심이거나, 지속적으로 인정받은 캐시카우 장르들에 대한 쇼케이스가 주였다는것은 다소 아이러니 했습니다. 그러나 이러한 지점은 이 역시도 인사이트는 있다고 봅니다.</p>

<p>AI가 그들 내부에선 어떻게든 돌아가고, R&amp;D 를 할지 모르겠지만, 아직 콘텐츠로 녹여낼 수 있는 수준으로 시연될 만한 수준이 아니라는 점. 즉 결론적으로 AI 를 아직 엔드유저를 위한 콘텐츠로는 낼수 없다는 평가가 있다는게 결과론으로 증명 된게 아닐까? 하는 생각을 했습니다. 제가 고민하던 것, 인디 게임사들이 고민하던 것. 그런 모든 것들을 더욱 치열하게 고민했을 것이기에, 그 가능성에 투자한다는 기사는 종종 있었지만, 결국 <code class="language-plaintext highlighter-rouge">결과</code>가 나오지 않았다는 것은 그걸 보여주기엔 아직 이르다- 는게 제 결론이었습니다. 그들에게는 오히려 수집형 모바일 게임이거나, 자신들의 트리플 A급 상품들을 전시하는 것이 여전히 중요하며, 전세계적인 불황 속에서도 각 태도들이 보여주는 선두와 팔로워 기업들 사이의 치열함이 있음을 새삼 느낄 수 있었습니다.</p>

<h3 id="도구적-가치에-집중하는-회사들-nc-알리바바와-텐센트-그리고">도구적 가치에 집중하는 회사들, NC, 알리바바와 텐센트, 그리고…</h3>

<p>그런데 위에서 적은 것도 보셨으니 아실 것입니다. NC 쪽에 뭔가 특이한 내용이 있던 것을 기억하십니까? 놀랍게도 이런 상황에서 AI 의 결과물을 스리슬쩍 발표한 곳이 있었으니.. 그것은 바로 NC 였습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-038.png" alt="" /></p>
<blockquote>
  <p>NC 사의 AI 솔루션 ‘NC AI(현, VARCO Game-AI)’의 팜플렛</p>
</blockquote>

<p>NC 부스를 찍은 사진이 보이질 않아(…) 대단히 아쉽지만, 3D 생성 및 프롬프팅 편집을 하게 되면 3D 에셋의 프로토타입이 나오며, 심지어는 여기에 보이스, SFX 까지 생성이 가능하고, 애니메이션 역시 표현 가능하다는 팜플렛과 그 시연 내용은 대단히 인상적이었습니다.</p>

<p>우선, 오로지 NC 내부의 자료를 활용하여 학습을 시켰음으로 퀄리티가 상당하면서도 저작권 문제를 해결하였습니다. 또한 SaaS로 도전을 하며, 현재로선 우선 개인을 위한 솔루션으로만 내놓았다는 언급은 NC 라는 기업의 규모를 고려할 때 기업에서 게임을 만드는 것 이외에도 개발의 선도자, 도구의 플랫폼으로 도전해고 있다는 사실을 엿볼 수 있었습니다.</p>

<p>특히나 실제 시연 내용을 보았을 때는 그 수준과 성능이 상당하며, 특히나 개발 과정에서 단축해야할 부분이 어떤 것인지, 그 A to Z 를 잘 캐치하고 있다는 점에서 “써봄직하지 않나?” 라는 생각을 했습니다. NC가 혁신을 보여주던 그 시절, 기술적인 면에서나 자본 면에서나 엄청난 회사였고(물론 지금도 엄청난 편이지만) 그런 노하우들은 여전히 유효하고, 그걸 다시 많은 개발 환경에 적용 가능하다? 이 점은 도구로서 AI 의 본질에서 충분히 구현 가능한 상품이었습니다.</p>

<p>뿐만 아니라, 다른 회사들도 몇몇 보였는데 인상적인 기업들은 다음과 같았습니다. 어도비의 FireFly 라는 툴은, AI 기반이자 저작권 프리로 학습된 모델을 활용해 캐릭터의 의상이나 디자인을 프롬프트로 수정하는 서비스로 시연을 이어 갔습니다. 중국의 클라우드 플랫폼 알리바바와 텐센트는 게임을 위한 컴퓨팅 서비스들을 내걸고 있었습니다. 그 와중에도 AI 구동이 가능한 서버를 제공해주는 등의 홍보 내용들은, 게임에 집중하는 회사들을 위한 회사이자, 위에서도 언급했던 개발 코스트의 제약, 노동 집약을 해소하는 효과적이고 효율적인 도구로서의 AI를 지향하고 있다는 점을 볼 수 있었습니다. 일본 내의 AI 솔루션 제공 기업, 서버 기업 등도 있었는데, 그 수준과 비용은 차처하더라도 도구로서, AI 의 장점을 극대화하고 기존의 제작의 난이도를 더 낮추고, 1인 기업이 정말 가능할 것 같다는 듯 SaaS 의 저변을 넓히려는 시도가 명확해 보였습니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-039.png" alt="" /></p>
<blockquote>
  <p>점유율 세계 3위, AWS, Azure 다음인 알리바바의 클라우드 서비스, AI 를 비롯한 당연하게도 게임을 위한 서비스들이 너무나 많고, 무엇보다 싸면서도 대응이 빠르다. 대기업 플랫폼의 한계를 넘어서는 장점은 분명히 있다.</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-040.png" alt="" /></p>
<blockquote>
  <p>흥미롭게본 AIgoGames, 게임의 프로토타이핑 뿐 아니라, 제작 과정이나 검수, 로컬라이징 등 전체 프로세스를 AI 활용가능하다고 소개하고있는 업체였다</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-041.png" alt="" /></p>
<blockquote>
  <p>일본에서 여러 서비스를 유통하는 채널에서 만든 팜플렛, 어도비 Firefly 는 인상적이긴 했으나, 시연 퀄리티가 아쉬웠다</p>
</blockquote>

<p><img src="/assets/images/posts/2025-10/2025-10-20-042.png" alt="" />
<img src="/assets/images/posts/2025-10/2025-10-20-043.png" alt="" /></p>
<blockquote>
  <p>일본 내 기업이자 AI 서비스를 한다고 이야기 한 업체들의 팜플렛, 하나는 라마와 LLM 을 혼합하여 만든 가상 아바타 시스템으로 솔루션으로서 보여주었고, ubitus 라는 업체도 유사한 서비스를 보여주었다. 일본 자생 업체들의 비즈니스는 다소 성숙한 완성형이란 느낌은 아니었으며 실험적이란 느낌이었다.</p>
</blockquote>

<h2 id="결론--미완의-서곡-그러나-가능성과-기회">결론 : 미완의 서곡, 그러나 가능성과 기회</h2>

<p>TGS 2025에 3일 참가를 마치고, 지친 몸을 이끌고 귀국을 하면서 TGS 를 통해 얻게된 인사이트는 물론 업계의 차이는 있겠지만, 어느정도 일맥상통하지 않을까 합니다.</p>

<ul>
  <li>AI 응용 어플리케이션은 가능성의 영역에 존재한다.</li>
  <li>비용, 비즈니스 모델의 절대적 성공 모델은 아직 없다.</li>
  <li>그러나 그 능력만큼은 확실하기 때문에, 이에 대한 도전과 움직임은 끝나지 않을 것이다</li>
  <li>특히나 현재의 실험적 상황에서 핵심은 ‘Tool’로서의 접근일 것이며, 거기서부터 점차 엔드유저까지 퍼져 갈 것이다.</li>
</ul>

<p>AI 를 툴로 접근하고 플랫폼이 되려는 시도나, 각종 창조를 위한 툴로서 등장한 AI. 이 모든 것들은 분명 엄청난 파급력, 특히 사람이 할 수 있는 일을 대체하거나, 맥락을 이해하고 작업을 할 수 있는 등, 여러 면을 보더라도 분명 엄청난 가치를 가진게 분명하다고, 저는 생각합니다.</p>

<p>아직 아쉬움이 있고, 오히려 자본력을 투자했으면 하는 대형 업체들의 결과물이 나오지 않은 것은 사실이지만, 이는 자본주의 시장의 특징이라고 생각하면 충분히 납득이 갈만 합니다. 그럼에도 도전하는 많은 이들을 통해 ‘이 불완전한 상황’을 어떻게 극복해 내는가를 누가 얼마나 빨리, 많이 습득하냐에 따라 분명 그 기회는 명확하게 오리란 생각이 듭니다.</p>

<p>특히나 이러한 지점에 개발자적인 생각을 추가해본다면? AI 를 대하는 개발자의 상황은, 비록 녹녹하지 않다는 말이 많지만… 그럼에도 분명한 <code class="language-plaintext highlighter-rouge">Pain Points</code>를 이해해 하면 충분히 될 것이란 생각입니다.</p>

<p>AI 의 불완전한 지점, 특히 ‘결과물이 일정하지 않다’는 차원은 앞으로도 지속적으로 개발을 통해 개선될 것 = 아직 개발할 일이 남아 있음을 의미합니다. 대체 가능한 <code class="language-plaintext highlighter-rouge">코더(Coder)</code>는 사라질 것이지만, 그걸 뛰어넘는 AI에 대한 노하우를 가진 개발자의 <code class="language-plaintext highlighter-rouge">조작(tune)</code>은 이어갈 것이고, 이 영역은 결코 비 개발자 지식, 경험만으론 불가능할 것이고, 개발적 토대가 없으면 안되기 때문입니다.</p>

<p>또한 결정적인 영역은 바로 ‘최적화’라고 생각됩니다. 일본의 AI 아바타 솔루션을 제작한 업체의 설명에서도 나왔지만, 자연어의 이해나 대응 방향에 대해선 LLM으로 Gemini 를 사용하지만, 음성 합성과 실제 멘트의 대응은 라마 오픈 소스모델을 돌린다고 하였습니다. 여기엔 분명 <code class="language-plaintext highlighter-rouge">튜닝</code>, <code class="language-plaintext highlighter-rouge">반응속도</code>, 그리고 <code class="language-plaintext highlighter-rouge">가격</code>이라는 문제가 있기 때문이었습니다.</p>

<p>이렇듯, 서비스로 사용될 AI의 가장 문제는 역시나 리소스와 AI의 사용량에 달려 있습니다. 만들고, 붙이는 건 쉽고, 이를 통해 MVP 를 만드는 건 이젠 바이브 코딩으로도 충분합니다. AI의 깡 성능으로 충분히 해결 가능한 수준이 되었습니다. 하지만 그것이 서비스가 된다면? 현행 API 발행을 통한 사용 방식의 AI 를 래핑한 서비스라면, AI 는 종량제가 아니면 안되며, 결과적으로 플랫폼으로 거대 모델을 제공해주는 업체 정도가 아니라면 <code class="language-plaintext highlighter-rouge">어떤 비즈니스 모델로 소비자를 납득시킬 수있을 것인가?</code> 이 차원의 문제가 지속적으로 발생할 것입니다.</p>

<p>결국 전통적인 개발의 필요성, 개발의 깊이가 여전히 통용 됨을 증명한 꼴이 됩니다. AI를 위한 ‘비용 최적화’, AI 분야에 대한 대용량 처리의 문제로 직결될 것이라는 점은 자명해 보입니다. 결국 기존의 개발의 전문성, 왜 전문적인 영역으로 남아있는가? 에 대한 답변이 그대로 적용되는 것입니다.</p>

<p>AI는 설익은 과일입니다. 하지만 맛있을 것은 명확하며, 어딘가의 교수님 말씀처럼, 생산성의 혁명, AI 를 구동하는 자원이 곧 권력이 될 수도 있습니다. 심지어 기업이 한 나라를 먹여 살릴 수 있을 만큼 그 영향력을 가질지도 모른다고 이야기 하고 있죠. 그렇기에 AI에 대한 이해도와 접근, 그리고 원리에 대한 이해는 핵심이며, 이를 기반으로 어떤 서비스를 만들고 사용자를 모아보는 일. 어쩌면 개발을 배워야 하는 이유는 과거엔 단순히 ‘서비스를 만들기 위해’였지만, 이제는 ‘1인 기업이 되기 위해’ 일 지도 모르겠습니다. 이번 일주일의 과정은 그런 실질적인 상황을 보고 듣고, 체감할 수 있었습니다. 또한 내 안의 불확실함으로 갖고 있던 인사이트들도 명확해 지는 것으로 다시 한 번, 개발의 전문성, AI를 함께 하지만 결국 도메인의 전문성이 곧 개발자로의 생존(…)과 직결된다는 점에서 비장한(?) 각오와 함께, 오늘도 AI 와 뒹굴기를 시전해보려고 합니다.</p>

<p><img src="/assets/images/posts/2025-10/2025-10-20-044.png" alt="" /></p>
<blockquote>
  <p>트릭컬, 국내 게임사의 수집형 모바일 게임의 팬 행사….. 시선 처리까지 완벽하다….</p>
</blockquote>]]></content><author><name>Paul2021-R</name></author><category term="AI" /><category term="AI" /><category term="TGS2025" /><category term="Game" /><category term="생각정리" /><summary type="html"><![CDATA[도쿄 게임쇼 2025 : AI 미완의 서곡 요약]]></summary></entry><entry><title type="html">TIL - jenkins 로 무중단 nextjs 배포 구축하기</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins.html" rel="alternate" type="text/html" title="TIL - jenkins 로 무중단 nextjs 배포 구축하기" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/17/til-jenkins.html"><![CDATA[<h2 id="2025년-10월-17일-개발-내용-요약-및-학습-정리">2025년 10월 17일 개발 내용 요약 및 학습 정리</h2>
<h2 id="-jenkins-무중단-배포-구축을-위한-추가-밑작업">📝 Jenkins 무중단 배포 구축을 위한 추가 밑작업</h2>
<h3 id="-목적-purpose">✨ 목적 (Purpose)</h3>

<p>Jenkins 를 활용한 무중단 배포를 구축하기 위해, 단순히 Dodcker 컨테이너화로 끝나는게 아닌, 배포 용이, 무중단성을 확보하기 위한 구조 개선이 필요하다고 느꼈다. 이에 아래의 목표를 기반으로 NextJS 의 프로젝트에 추가적인 작업 목표를 설정해보았다.</p>

<ul>
  <li><strong>CI/CD 파이프라인 통합 용이성</strong>: Jenkins와 같은 CI/CD 도구를 통해 자동화된 빌드 및 배포를 더욱 용이하게 합니다.</li>
  <li><strong>개발 및 운영 환경 일관성 유지</strong>: Docker를 통해 개발 및 운영 환경 간의 차이를 최소화하고 일관성을 유지합니다.</li>
  <li><strong>무중단 배포(Zero-downtime Deployment) 지원</strong>: Nginx와 블루/그린 배포 전략을 통해 서비스 중단 없이 애플리케이션을 업데이트할 수 있는 기반을 마련합니다.</li>
  <li><strong>프로젝트 가독성 및 유지보수성 향상</strong>: 명확한 디렉토리 구조와 상세한 문서화를 통해 프로젝트의 가독성과 유지보수성을 높입니다.</li>
</ul>

<h3 id="️-주요-변경-사항">🛠️ 주요 변경 사항</h3>

<h4 id="1-프로젝트-구조-재편">1. 프로젝트 구조 재편</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">app/</code> 디렉토리로 파일 이동</strong>: 기존 루트 디렉토리에 있던 Next.js 관련 파일들 (<code class="language-plaintext highlighter-rouge">.dockerignore</code>, <code class="language-plaintext highlighter-rouge">.gitignore</code>, <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">eslint.config.mjs</code>, <code class="language-plaintext highlighter-rouge">next.config.ts</code>, <code class="language-plaintext highlighter-rouge">package.json</code>, <code class="language-plaintext highlighter-rouge">pnpm-lock.yaml</code>, <code class="language-plaintext highlighter-rouge">postcss.config.mjs</code>, <code class="language-plaintext highlighter-rouge">public/</code>, <code class="language-plaintext highlighter-rouge">src/</code>, <code class="language-plaintext highlighter-rouge">tsconfig.json</code>)이 모두 <code class="language-plaintext highlighter-rouge">app/</code> 디렉토리 내부로 이동시켰다. 이는 Next.js 애플리케이션의 모듈성을 높이고, 프로젝트의 각 구성 요소(Next.js 앱, Nginx)를 명확하게 분리하기 위함이다.</li>
</ul>

<h4 id="2-docker-환경-구성-개선">2. Docker 환경 구성 개선</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">app/Dockerfile</code> 다단계 빌드(Multi-stage Build) 개선</strong>: <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 스테이지 구성이 더욱 세분화 시켰다. <code class="language-plaintext highlighter-rouge">base</code>, <code class="language-plaintext highlighter-rouge">dev_runner</code>, <code class="language-plaintext highlighter-rouge">prod_modules_setter</code> 스테이지가 추가되어 개발 및 운영 환경에 맞는 의존성 설치 및 빌드 과정을 명확하게 분리했다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">dev_runner</code>: 개발용 의존성을 설치하여 빠른 개발 환경을 독립적으로 제공 목적으로 만듬.</li>
      <li><code class="language-plaintext highlighter-rouge">prod_modules_setter</code>: 운영용 의존성만 설치하여 최종 이미지 크기를 최적화하고 보안을 강화한다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">app/docker-compose.yml</code> 추가</strong>: <code class="language-plaintext highlighter-rouge">app/</code> 디렉토리 내부에 Next.js 앱만을 위한 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, 이 파일은 <code class="language-plaintext highlighter-rouge">dev</code>와 <code class="language-plaintext highlighter-rouge">prod</code> 서비스를 정의하여 Next.js 앱의 개발 및 운영 환경을 독립적으로 관리하도록 만들었다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">루트 최상단의 docker-compose.yml</code></strong> : 기존 <code class="language-plaintext highlighter-rouge">dev</code> 및 <code class="language-plaintext highlighter-rouge">prod</code> 서비스 정의가 삭제되고, <code class="language-plaintext highlighter-rouge">nginx</code>, <code class="language-plaintext highlighter-rouge">app-blue</code>, <code class="language-plaintext highlighter-rouge">app-green</code> 서비스가 새로 정의되어있다. 이는 블루/그린 배포 전략을 위한 핵심적인 내용만을 담고 있어서, 빌드 시 production으로 완전히 빌드되어주는 것만을 바라본다.</li>
</ul>

<h4 id="3-nginx-리버스-프록시reverse-proxy-및-블루그린-배포-설정">3. Nginx 리버스 프록시(Reverse Proxy) 및 블루/그린 배포 설정</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리 생성 및 설정 파일 추가</strong>: <code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리가 새로 생성되었고, 그 안에 <code class="language-plaintext highlighter-rouge">Dockerfile</code>과 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 를 만들었다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nginx/Dockerfile</code>: Nginx 이미지를 빌드한다. 기존 설정을 배제하는 것 까지만 포함된다.</li>
      <li><code class="language-plaintext highlighter-rouge">nginx/nginx.conf</code>: <code class="language-plaintext highlighter-rouge">nextjs_app</code> 업스트림을 통해 Next.js 앱(<code class="language-plaintext highlighter-rouge">app-blue:3000</code>으로 초기 설정)으로 트래픽을 전달하도록 설정시키는 용이다. 이는 Jenkins와 같은 CI/CD 도구를 통한 동적 배포를 염두에 둔 구성.</li>
    </ul>
  </li>
  <li><strong>블루/그린 배포 전략 도입</strong>: 루트 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 <code class="language-plaintext highlighter-rouge">nginx</code> 서비스가 <code class="language-plaintext highlighter-rouge">app-blue</code>와 <code class="language-plaintext highlighter-rouge">app-green</code> 서비스에 의존하도록 설정하여, 무중단 배포를 위한 블루/그린 배포 전략의 기반을 마련하였다.</li>
</ul>

<hr />

<h2 id="배운-것들-정리">배운 것들 정리</h2>
<h3 id="멀티-스테이지-빌드multi-stage-build">멀티 스테이지 빌드(Multi-stage build)</h3>
<ul>
  <li>멀티스테이지 빌드는 최종 이미지를 <strong>최대한 가볍고 안전하게</strong> 만들기 위해, 하나의 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 안에 여러 개의 독립적인 빌드 환경(스테이지)을 정의하는 기술이다.</li>
</ul>

<h4 id="필요한-이유는">필요한 이유는?</h4>
<p>만약 스테이지 개념 없이 <code class="language-plaintext highlighter-rouge">Dockerfile</code>을 작성하면, 다음과 같은 문제가 발생할 수 있다.</p>
<ol>
  <li><strong>이미지 비대화 (Bloated Image)</strong>: 코드를 빌드하기 위해 설치했던 <code class="language-plaintext highlighter-rouge">typescript</code>, <code class="language-plaintext highlighter-rouge">eslint</code> 같은 모든 개발용 도구(<code class="language-plaintext highlighter-rouge">devDependencies</code>)가 최종 실행 이미지에 불필요하게 포함된다.</li>
  <li><strong>보안 취약점 (Security Risk)</strong>: 사용하지 않는 도구나 라이브러리가 많을수록, 해커가 악용할 수 있는 공격 지점(Attack Surface)이 늘어난다.</li>
</ol>

<hr />
<h4 id="작동-원리-from--as-와-copy---from">작동 원리: <code class="language-plaintext highlighter-rouge">FROM ... AS</code> 와 <code class="language-plaintext highlighter-rouge">COPY --from</code></h4>

<p>멀티스테이지 빌드는 이 두 가지 명령어로 동작한다.</p>
<h5 id="1-from--as-스테이지_이름">1. <code class="language-plaintext highlighter-rouge">FROM ... AS &lt;스테이지_이름&gt;</code></h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Dockerfile</code>에서 <code class="language-plaintext highlighter-rouge">FROM</code> 명령어가 나올 때마다 새로운 스테이지가 시작됩니다. 이는 <strong>이전 스테이지와는 완전히 격리된, 새로운 환경</strong>에서 시작한다는 뜻이다.</li>
  <li><code class="language-plaintext highlighter-rouge">AS &lt;스테이지_이름&gt;</code> (예: <code class="language-plaintext highlighter-rouge">AS builder</code>) 구문을 사용해, 해당 스테이지에 우리가 알아볼 수 있는 <strong>이름표</strong>를 붙여주는 역할을 한다.</li>
</ul>

<h5 id="2-copy---from스테이지_이름">2. <code class="language-plaintext highlighter-rouge">COPY --from=&lt;스테이지_이름&gt;</code></h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">COPY</code> 명령어에 <code class="language-plaintext highlighter-rouge">--from</code> 플래그를 사용하면, 다른 스테이지에 붙여둔 이름표를 호출하여 <strong>해당 스테이지의 결과물만</strong> 현재 스테이지로 가져올 수 있다.</li>
</ul>

<h4 id="실-예제로-보면">실 예제로 보면?</h4>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ======= 1. BASE 스테이지 =======</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:22-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">base</span>
<span class="c"># 작업 위치 설정 - 해당 컨테이너 위치 </span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># pnpm 설치 </span>
<span class="k">RUN </span>npm <span class="nb">install</span> <span class="nt">-g</span> pnpm

<span class="c"># package.json, pnpm-lock.yaml 등 의존성 관련 파일만 복사</span>
<span class="k">COPY</span><span class="s"> package.json pnpm-lock.yaml ./</span>

<span class="c"># ======= 2. dev용 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">base</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">dev_runner</span>
<span class="c"># 의존성 설치 - dev 용</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span>

<span class="c"># ======= 3. 빌드 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">dev_runner</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>

<span class="c"># 나머지 소스 코드 전체 복사 </span>
<span class="k">COPY</span><span class="s"> . .</span>

<span class="c"># 애플리케이션 빌드</span>
<span class="k">RUN </span>pnpm run build

<span class="c"># ======= 4. 의존성 증류 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">base</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">prod_modules_setter</span>

<span class="c"># 의존성 중 production용만 받아오기</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span> <span class="nt">--prod</span>

<span class="c"># ======= 5. prod 실행 스테이지 ========</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:22-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">runner</span>

<span class="c"># 작업 디렉토리 설정 </span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># 빌드 스테이지의 운영에 필요한 파일들만 복사 </span>
<span class="c"># 1. 빌드 결과물 </span>
<span class="k">COPY</span><span class="s"> --from=builder /app/.next ./.next</span>

<span class="c"># 2. 정적 파일</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/public ./public</span>

<span class="c"># 3. 운영용 의존성</span>
<span class="k">COPY</span><span class="s"> --from=prod_modules_setter /app/node_modules ./node_modules</span>

<span class="c"># 4. package.json 파일</span>
<span class="k">COPY</span><span class="s"> --from=prod_modules_setter /app/package.json ./package.json</span>

<span class="c"># 애플리케이션이 사용할 포트 노출 </span>
<span class="k">EXPOSE</span><span class="s"> 3000</span>

<span class="c"># 컨테이너 시작 시 명령어</span>
<span class="k">CMD</span><span class="s"> ["node", "./node_modules/next/dist/bin/next", "start"]</span>
</code></pre></div></div>

<ul>
  <li>BASE 스테이지는 공통된 영역까지를 전제로 작성되어 레이어를 구성한다.</li>
  <li>dev 개발 환경은 모든 의존성을 설치 및 HR(핫리로딩)으로 동작하므로 <code class="language-plaintext highlighter-rouge">dev_runner</code> 스테이지에서 모든 의존성을 받아서, 설정을 종료 하게 된다.(docker-compose.yml 을 통해)</li>
  <li>prod 의 경우 <code class="language-plaintext highlighter-rouge">builder</code> 를 통해 빌드가 이루어지는데, 이때 빌드 하면서 개발환경의 노드 모듈들을 포함해야 하는데, 그렇기에 실제 프로덕션 환경에서 필요한 노드 모듈만 받아오지 못하게 되어 있다.</li>
  <li>그렇기에 <code class="language-plaintext highlighter-rouge">prod_modules_setter</code>는 다시 <code class="language-plaintext highlighter-rouge">base</code> 기반에서 –prod 옵션을 통해 프로덕션에서 필요한 것들만을 받아 놓는 역할만을 수행한다.</li>
  <li>최종적으로 <code class="language-plaintext highlighter-rouge">runner</code>는 빌드된 파일, 순수한 production 기반의 모듈들만을 받아서, 깔끔하게 실행된다.</li>
</ul>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="DevOps" /><category term="Jenkins" /><category term="Docker" /><summary type="html"><![CDATA[2025년 10월 17일 개발 내용 요약 및 학습 정리 📝 Jenkins 무중단 배포 구축을 위한 추가 밑작업 ✨ 목적 (Purpose)]]></summary></entry><entry><title type="html">TIL - Next.js</title><link href="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs.html" rel="alternate" type="text/html" title="TIL - Next.js" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs</id><content type="html" xml:base="http://0.0.0.0:4000/%ED%95%99%EC%8A%B5/2025/10/14/til-nextjs.html"><![CDATA[<h2 id="2025년-10월-14일-개발-내용-요약-및-학습-정리">2025년 10월 14일 개발 내용 요약 및 학습 정리</h2>

<h3 id="1-개발-내용-요약">1. 개발 내용 요약</h3>

<p>2025년 10월 14일, Next.js 프로젝트의 개발 환경 설정을 Docker 기반으로 고도화하는 작업이 완료되었다. 주요 내용은 다음과 같다.</p>

<ul>
  <li><strong>Next.js 프로젝트 설정:</strong> <code class="language-plaintext highlighter-rouge">create-next.js-app</code>을 사용하여 TypeScript 기반의 Next.js 프로젝트를 생성하고, <code class="language-plaintext highlighter-rouge">pnpm</code>을 최신 버전으로 업데이트하며 Next.js 15 버전으로 시작했다. Turbopack 사용 여부에 대한 검토 후, 현재 안정화된 webpack 기반으로 진행했다.</li>
  <li><strong>Docker 환경 구축:</strong>
    <ul>
      <li><strong>프로덕션(운영) Dockerfile 작성:</strong> 멀티 스테이지 빌드(Multi-stage builds)를 활용하여 <code class="language-plaintext highlighter-rouge">builder</code> 스테이지와 <code class="language-plaintext highlighter-rouge">runner</code> 스테이지로 나누어 효율적인 Docker 이미지를 생성했다. <code class="language-plaintext highlighter-rouge">builder</code> 스테이지에서는 의존성 설치 및 빌드를 수행하고, <code class="language-plaintext highlighter-rouge">runner</code> 스테이지에서는 빌드된 결과물만을 복사하여 가볍고 최적화된 운영 이미지를 구성했다. <code class="language-plaintext highlighter-rouge">.dockerignore</code> 파일을 통해 불필요한 파일이 이미지에 포함되지 않도록 설정했다.</li>
      <li><strong>Docker Compose를 활용한 개발 환경 구축:</strong> <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일을 작성하여 개발 환경(<code class="language-plaintext highlighter-rouge">dev</code> 서비스)을 설정했다. <code class="language-plaintext highlighter-rouge">Dockerfile</code>의 <code class="language-plaintext highlighter-rouge">builder</code> 스테이지를 사용하고, <code class="language-plaintext highlighter-rouge">npm run dev</code> 명령어를 오버라이드하여 HMR(Hot Module Replacement)을 지원하며, 로컬 소스코드와 컨테이너를 볼륨으로 마운트하여 실시간 코드 변경이 반영되도록 했다.</li>
      <li><strong>Docker Compose를 활용한 프로덕션 환경 추가 및 분리:</strong> 동일한 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일 내에 프로덕션 환경(<code class="language-plaintext highlighter-rouge">prod</code> 서비스)을 추가했다. <code class="language-plaintext highlighter-rouge">prod</code> 서비스는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 전체를 빌드하되, 볼륨 마운트 없이 빌드된 이미지를 그대로 사용하고 <code class="language-plaintext highlighter-rouge">npm start</code> 명령어로 운영 서버를 실행하도록 설정했다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">package.json</code> 스크립트 연동:</strong> 개발 편의성을 극대화하기 위해 <code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">pnpm start:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm start:prod</code>, <code class="language-plaintext highlighter-rouge">pnpm set:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm set:prod</code>, <code class="language-plaintext highlighter-rouge">pnpm unset:dev</code>, <code class="language-plaintext highlighter-rouge">pnpm unset:prod</code> 등의 Docker Compose 관련 스크립트를 추가하여 개발 경험(DX)을 효율화했다.</li>
</ul>

<h3 id="2-학습-내용-정리">2. 학습 내용 정리</h3>

<p>이번 개발 환경 설정을 통해 다음과 같은 내용을 학습하고 정리했다.</p>

<ul>
  <li><strong>Next.js 프로젝트 생성 및 기본 설정:</strong> <code class="language-plaintext highlighter-rouge">create-next-app</code> 사용법, TypeScript 및 <code class="language-plaintext highlighter-rouge">pnpm</code> 활용, Turbopack과 webpack의 차이점 및 선택 기준을 이해했다.</li>
  <li><strong>Docker Multi-stage Builds:</strong> 빌드 환경과 실행 환경을 분리하여 최종 이미지 크기를 최적화하고 보안을 강화하는 방법을 익혔다. 특히 <code class="language-plaintext highlighter-rouge">builder</code>와 <code class="language-plaintext highlighter-rouge">runner</code> 스테이지의 역할 분담을 명확히 이해했다.</li>
  <li><strong>Dockerfile 명령어 심층 이해:</strong> <code class="language-plaintext highlighter-rouge">RUN</code> vs <code class="language-plaintext highlighter-rouge">CMD</code>의 차이점, <code class="language-plaintext highlighter-rouge">COPY</code> 명령어의 역할과 캐싱 메커니즘, <code class="language-plaintext highlighter-rouge">alpine</code> 리눅스 이미지를 사용하는 이유(작은 크기, 보안) 등을 구체적으로 파악했다.</li>
  <li><strong>Docker Compose 활용:</strong> <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>을 통해 개발(<code class="language-plaintext highlighter-rouge">dev</code>) 및 운영(<code class="language-plaintext highlighter-rouge">prod</code>) 환경을 분리하고 관리하는 방법을 배웠다. 특히 개발 환경에서의 볼륨 마운트를 통한 HMR 구현과 프로덕션 환경에서의 최적화된 이미지 사용 방식을 이해했다.</li>
  <li><strong>개발 경험(DX) 최적화:</strong> <code class="language-plaintext highlighter-rouge">package.json</code> 스크립트를 활용하여 복잡한 Docker Compose 명령어를 단순화하고, 개발 워크플로우를 간소화하는 방법을 적용했다.</li>
</ul>

<h3 id="3-다음-단계-레포지토리-및-ai-리뷰-기능-연동">3. 다음 단계: 레포지토리 및 AI 리뷰 기능 연동</h3>

<p>이번 Docker 기반 개발 환경 설정을 성공적으로 마무리함에 따라, 다음 단계로는 이 환경을 기반으로 코드의 버전 관리 및 AI 기반 코드 리뷰 기능을 연동하는 작업을 진행할 예정이다.</p>]]></content><author><name>Paul2021-R</name></author><category term="학습" /><category term="학습" /><category term="NextJS" /><category term="Front-End" /><summary type="html"><![CDATA[2025년 10월 14일 개발 내용 요약 및 학습 정리]]></summary></entry></feed>